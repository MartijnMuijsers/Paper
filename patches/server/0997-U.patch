From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Tue, 28 Jun 2022 20:00:42 +0200
Subject: [PATCH] U


diff --git a/src/main/java/net/minecraft/world/level/block/Block.java b/src/main/java/net/minecraft/world/level/block/Block.java
index dbd8c8c6de36475b62e3b65e32156a86bbd2a7c3..6cc6ae1059f2ca410ba5bbe2cd766dac932a65f6 100644
--- a/src/main/java/net/minecraft/world/level/block/Block.java
+++ b/src/main/java/net/minecraft/world/level/block/Block.java
@@ -71,7 +71,11 @@ public class Block extends BlockBehaviour implements ItemLike {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Holder.Reference<Block> builtInRegistryHolder;
     public static final IdMapper<BlockState> BLOCK_STATE_REGISTRY = new IdMapper<>();
-    public static final IdMapper<BlockState> BLOCK_STATE_REGISTRY_VANILLA = new IdMapper<>(); // Martijn - custom blocks and items
+    // Martijn start - custom blocks and items
+    public static final IdMapper<BlockState> BLOCK_STATE_REGISTRY_VANILLA = new IdMapper<>();
+    public static int[] stateIdReplacementArrayWithResourcePack;
+    public static int[] stateIdReplacementArrayWithoutResourcePack;
+    // Martijn end - custom blocks and items
     private static final LoadingCache<VoxelShape, Boolean> SHAPE_FULL_BLOCK_CACHE = CacheBuilder.newBuilder().maximumSize(512L).weakKeys().build(new CacheLoader<VoxelShape, Boolean>() {
         public Boolean load(VoxelShape voxelshape) {
             return !Shapes.joinIsNotEmpty(Shapes.block(), voxelshape, BooleanOp.NOT_SAME);
diff --git a/src/main/java/net/minecraft/world/level/block/Blocks.java b/src/main/java/net/minecraft/world/level/block/Blocks.java
index 7af397733d917fa5529a9c5536f814d71ceacd1c..80c812ed5ae6e7099000457625af916245e5b221 100644
--- a/src/main/java/net/minecraft/world/level/block/Blocks.java
+++ b/src/main/java/net/minecraft/world/level/block/Blocks.java
@@ -1196,11 +1196,26 @@ public class Blocks {
                 if (block.isVanilla) {
                     Block.BLOCK_STATE_REGISTRY_VANILLA.add(blockState);
                 }
-                // Martijn end - custom blocks
+                // Martijn end - custom blocks and items
             }
 
             block.getLootTable();
         }
-
+        // Martijn start - custom blocks and items
+        // Initialize the global state replacement arrays so we can populate them
+        Block.stateIdReplacementArrayWithResourcePack = new int[Block.BLOCK_STATE_REGISTRY.size()];
+        Block.stateIdReplacementArrayWithoutResourcePack = new int[Block.BLOCK_STATE_REGISTRY.size()];
+        // Initialize the global state replacement arrays with identities (aka no replacement is done)
+        for (int id = 0; id < Block.BLOCK_STATE_REGISTRY.size(); id++) {
+            Block.stateIdReplacementArrayWithResourcePack[id] = id;
+            Block.stateIdReplacementArrayWithoutResourcePack[id] = id;
+        }
+        // Then overwrite them where necessary with all the needed replacements
+        for (Block block : Registry.BLOCK) {
+            if (block.replacementRule != null) {
+                block.replacementRule.writeToStateIdReplacementArrays();
+            }
+        }
+        // Martijn end - custom blocks and items
     }
 }
diff --git a/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerCustom.java b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerCustom.java
index 2b548e6c0b68591213a38037c017012f07586dbf..5fceb9573c706977e2357e0cc8e39bd36befd7bb 100644
--- a/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerCustom.java
+++ b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerCustom.java
@@ -51,22 +51,8 @@ public final class ChunkPacketBlockControllerCustom extends ChunkPacketBlockCont
         replaceCustom(chunkPacketInfoAntiXray);
     }
 
-    // Temporary only
-    static int replacementFor(int stateRegistryId, boolean doesPlayerHaveResourcePack) {
-        BlockState state = Block.BLOCK_STATE_REGISTRY.byId(stateRegistryId);
-        if (state.is(Blocks.STONE)) {
-            return Block.BLOCK_STATE_REGISTRY.getId(Blocks.DIRT.defaultBlockState());
-        } else if (state.is(Blocks.DIRT)) {
-            return Block.BLOCK_STATE_REGISTRY.getId(Blocks.OAK_LOG.defaultBlockState());
-        } else if (state.is(Blocks.ACACIA_LEAVES)) {
-            return Block.BLOCK_STATE_REGISTRY.getId(Blocks.RED_WOOL.defaultBlockState());
-        } else if (state.is(SuCraftBlocks.SNOWY_STONE_BRICKS)) {
-            return Block.BLOCK_STATE_REGISTRY.getId(Blocks.STONE_BRICKS.defaultBlockState());
-        }
-        return stateRegistryId;
-    }
-
     public static void replaceCustom(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+
         // bitStorageReader, bitStorageWriter and nearbyChunkSections could also be reused (with ThreadLocal if necessary) but it's not worth it
         BitStorageReader bitStorageReader = new BitStorageReader();
         BitStorageWriter bitStorageWriter = new BitStorageWriter();
@@ -80,13 +66,13 @@ public final class ChunkPacketBlockControllerCustom extends ChunkPacketBlockCont
         for (int chunkSectionIndex = 0; chunkSectionIndex < sectionsCount; chunkSectionIndex++) {
             if (chunkPacketInfoAntiXray.isWritten(chunkSectionIndex)) {
 
-                MinecraftServer.LOGGER.info(chunk.locX + " , " + chunk.locZ + " : " + chunkSectionIndex); // TEMP
-                String conversionString = null; // TEMP
-
                 // Get the current (potentially to be replaced) palette
                 var oldPalette = chunkPacketInfoAntiXray.getPalette(chunkSectionIndex);
                 int oldPaletteSize = oldPalette.getSize();
 
+                // Get the appropriate global replacements
+                int[] globalBlockStateReplacementsForResourcePackStatus = chunkPacketInfoAntiXray.doesPlayerHaveResourcePack ? Block.stateIdReplacementArrayWithResourcePack : Block.stateIdReplacementArrayWithoutResourcePack;
+
                 // First we store the old and new global ids, and flag if there will be any replacements
                 int[] oldStateRegistryIdsByOldPaletteId = new int[oldPaletteSize];
                 int[] newStateRegistryIdsByOldPaletteId = new int[oldPaletteSize];
@@ -95,7 +81,7 @@ public final class ChunkPacketBlockControllerCustom extends ChunkPacketBlockCont
                     BlockState oldValue = oldPalette.valueFor(oldPaletteId);
                     int oldStateRegistryId = Block.BLOCK_STATE_REGISTRY.getId(oldValue);
                     oldStateRegistryIdsByOldPaletteId[oldPaletteId] = oldStateRegistryId;
-                    int newStateRegistryId = replacementFor(oldStateRegistryId, chunkPacketInfoAntiXray.doesPlayerHaveResourcePack);
+                    int newStateRegistryId = globalBlockStateReplacementsForResourcePackStatus[oldStateRegistryId];
                     newStateRegistryIdsByOldPaletteId[oldPaletteId] = newStateRegistryId;
                     anyReplacements |= oldStateRegistryId != newStateRegistryId;
                 }
@@ -106,24 +92,19 @@ public final class ChunkPacketBlockControllerCustom extends ChunkPacketBlockCont
                 }
 
                 // Prepare for potential block replacements later
-                int[] blockReplacements = null;
+                int[] blockStateReplacements = null;
 
                 // Special case for the global palette, where we don't have to find a new list of which global ids are needed in the new palette: we can just use the palette containing all vanilla blocks
                 // But the palette isn't written at all to the packet in this case (the client simply expects the vanilla global palette), so we simply need to compute the needed block replacements
                 if (oldPalette instanceof GlobalPalette<BlockState>) {
 
-                    // TODO this is completely unnecessary, just for testing with replacementFor(), but normally we can just have this pre-computed since we need it anyway instead of replacementFor()
-                    blockReplacements = new int[oldPaletteSize];
-                    for (int i = 0; i < oldPaletteSize; i++) {
-                        blockReplacements[i] = replacementFor(i, chunkPacketInfoAntiXray.doesPlayerHaveResourcePack);
-                    }
+                    // We can just straight up use the appropriate precomputed array over all block states
+                    blockStateReplacements = globalBlockStateReplacementsForResourcePackStatus;
 
                 } else {
                     // If not a global palette, we must figure out what will go into the new palette
 
                     // We create sets of the old and new global ids so that we can for example check for old global ids whether they will be still present
-                    //                IntSet oldStateRegistryIds = (oldPaletteSize <= 16) ? new IntArraySet(oldPaletteSize) : new IntOpenHashSet(oldPaletteSize * 2);
-                    //                Arrays.stream(oldStateRegistryIdsByOldPaletteId).forEach(oldPaletteStateRegistryIds::add);
                     IntSet newStateRegistryIds = (oldPaletteSize <= 16) ? new IntArraySet(oldPaletteSize) : new IntOpenHashSet(oldPaletteSize * 2);
                     Arrays.stream(newStateRegistryIdsByOldPaletteId).forEach(newStateRegistryIds::add);
                     int newPaletteSize = newStateRegistryIds.size();
@@ -159,7 +140,6 @@ public final class ChunkPacketBlockControllerCustom extends ChunkPacketBlockCont
                     }
 
                     // Create the necessary entries for the new palette
-//                    int newPaletteBits = Mth.ceillog2(oldPalette.getSize());//Mth.ceillog2(newPaletteSize);
                     List<BlockState> newPaletteBlockStateList = new ArrayList<>(Arrays.stream(newStateRegistryIdsByNewPaletteId).mapToObj(stateRegistryId -> Block.BLOCK_STATE_REGISTRY.byId(stateRegistryId)).toList());
 
                     // Make sure we fit into the protocol by keeping the exact same number of bits and such, so we add some unused block states to the palette to get the same size as before
@@ -172,25 +152,6 @@ public final class ChunkPacketBlockControllerCustom extends ChunkPacketBlockCont
                         }
                     }
 
-                    // TODO temp test remove this (testing if the setPalette method below actually has any effect)
-                    // EDIT: Result: nope it has no effect, we need to find another way to set the palette for this chunk section
-                    if (newPaletteBlockStateList.size() > 0 && !newPaletteBlockStateList.get(0).isAir())
-                        newPaletteBlockStateList.set(0, Blocks.COAL_ORE.defaultBlockState());
-                    if (newPaletteBlockStateList.size() > 1 && !newPaletteBlockStateList.get(1).isAir())
-                        newPaletteBlockStateList.set(1, Blocks.IRON_ORE.defaultBlockState());
-                    if (newPaletteBlockStateList.size() > 2 && !newPaletteBlockStateList.get(2).isAir())
-                        newPaletteBlockStateList.set(2, Blocks.DIAMOND_ORE.defaultBlockState());
-                    if (newPaletteBlockStateList.size() > 3 && !newPaletteBlockStateList.get(3).isAir())
-                        newPaletteBlockStateList.set(3, Blocks.EMERALD_ORE.defaultBlockState());
-                    if (newPaletteBlockStateList.size() > 4 && !newPaletteBlockStateList.get(4).isAir())
-                        newPaletteBlockStateList.set(4, Blocks.REDSTONE_ORE.defaultBlockState());
-                    if (newPaletteBlockStateList.size() > 5 && !newPaletteBlockStateList.get(5).isAir())
-                        newPaletteBlockStateList.set(5, Blocks.NETHERITE_BLOCK.defaultBlockState());
-                    if (newPaletteBlockStateList.size() > 6 && !newPaletteBlockStateList.get(6).isAir())
-                        newPaletteBlockStateList.set(6, Blocks.EMERALD_BLOCK.defaultBlockState());
-                    if (newPaletteBlockStateList.size() > 7 && !newPaletteBlockStateList.get(7).isAir())
-                        newPaletteBlockStateList.set(7, Blocks.DIAMOND_BLOCK.defaultBlockState());
-
                     // We clone the palette with the new entries, so that we can then write it to the buffer
                     Palette<BlockState> newPalette = null; // Will be initialized in one of the cases below for sure
                     if (oldPalette instanceof SingleValuePalette<BlockState> oldSingleValuePalette) {
@@ -208,16 +169,7 @@ public final class ChunkPacketBlockControllerCustom extends ChunkPacketBlockCont
                         byteBuf.writerIndex(chunkPacketInfoAntiXray.getPaletteIndex(chunkSectionIndex));
                         paletteWriter = new FriendlyByteBuf(byteBuf);
                     }
-                    newPalette.write(paletteWriter); // TEMP DISABLED BUT THIS *SHOULD* WORK
-
-//                chunkPacketInfoAntiXray.setPalette(chunkSectionIndex, PalettedContainer.Strategy.SECTION_STATES.getConfiguration(Block.BLOCK_STATE_REGISTRY, newPaletteBits).factory().create(newPaletteBits, Block.BLOCK_STATE_REGISTRY, null, newPaletteBlockStateList));
-//                PalettedContainer<BlockState> palettedContainer = (PalettedContainer<BlockState>) oldPalette.listener; // ACtually should just be provided to this method
-//                PalettedContainer.Data<T> data2 = palettedContainer.createOrReuseData(palettedContainer.data, newBits);
-//                data2.copyFrom(palettedContainer.data.palette, palettedContainer.data.storage);
-//                palettedContainer.data = data2;
-                    // ^ This should have effect
-                    // EDIT: actually, it seems this already does the block replacements written below for us, so we may have to skip the code below if this works out
-
+                    newPalette.write(paletteWriter);
 
                     // For any palette id where the global id at that index in the new palette is not the replacement for the global id at that index in the old palette, we must replace the palette id of all block occurrences to the palette id where the replacement is in fact stored in the new palette
                     for (int oldPaletteId = 0; oldPaletteId < oldPaletteSize; oldPaletteId++) {
@@ -225,23 +177,19 @@ public final class ChunkPacketBlockControllerCustom extends ChunkPacketBlockCont
                         int newStateRegistryId = newStateRegistryIdsByOldPaletteId[oldPaletteId];
                         int newPaletteIdOfNewStateRegistryId = newPaletteIdByNewStateRegistryId.get(newStateRegistryId);
                         if (newPaletteIdOfNewStateRegistryId != oldPaletteId) {
-                            if (blockReplacements == null) {
-                                blockReplacements = new int[oldPaletteSize];
+                            if (blockStateReplacements == null) {
+                                blockStateReplacements = new int[oldPaletteSize];
                                 for (int i = 0; i < oldPaletteSize; i++) {
-                                    blockReplacements[i] = i;
+                                    blockStateReplacements[i] = i;
                                 }
                             }
-                            blockReplacements[oldPaletteId] = newPaletteIdOfNewStateRegistryId;
+                            blockStateReplacements[oldPaletteId] = newPaletteIdOfNewStateRegistryId;
                         }
                     }
 
-                    conversionString = "\t\tnewStateRegistryIdsByNewPaletteId: " + Arrays.toString(newStateRegistryIdsByNewPaletteId) + "\n\t\tnewPaletteBlockStateList: " + newPaletteBlockStateList + "\n\t\tnewPalette: " + newPalette + " of type " + newPalette.getClass().getName() + " of size " + newPalette.getSize() + " with bits " + (
-                        newPalette instanceof LinearPalette<BlockState> newLinearPalette ? newLinearPalette.bits : oldPalette instanceof HashMapPalette<BlockState> newHashMapPalette ? newHashMapPalette.bits : "<undefined>"
-                        ) + "\n\t\tblock replacements: " + Arrays.toString(blockReplacements);
-
                 }
 
-                if (blockReplacements != null) {
+                if (blockStateReplacements != null) {
                     bitStorageReader.setBits(chunkPacketInfoAntiXray.getBits(chunkSectionIndex));
                     bitStorageReader.setIndex(chunkPacketInfoAntiXray.getIndex(chunkSectionIndex));
                     bitStorageWriter.setBits(chunkPacketInfoAntiXray.getBits(chunkSectionIndex));
@@ -250,20 +198,13 @@ public final class ChunkPacketBlockControllerCustom extends ChunkPacketBlockCont
                     // Modify all layers of the current chunk section
                     for (int xyz = 0; xyz < 4096/* = 16*16*16 */; xyz++) {
                         int bits = bitStorageReader.read();
-                        try {
-                            bitStorageWriter.write(blockReplacements[bits]);
-                        } catch (Exception e) {
-                            MinecraftServer.LOGGER.warn("section bits: " + chunkPacketInfoAntiXray.getBits(chunkSectionIndex) + "\noldPalette: " + oldPalette + " of type " + oldPalette.getClass().getName() + " of size " + oldPaletteSize + " with bits " + (
-                                oldPalette instanceof LinearPalette<BlockState> oldLinearPalette ? oldLinearPalette.bits : oldPalette instanceof HashMapPalette<BlockState> oldHashMapPalette ? oldHashMapPalette.bits : "<undefined>"
-                                ) + ":\n\toldStateRegistryIdsByOldPaletteId: " + Arrays.toString(oldStateRegistryIdsByOldPaletteId) + "\n\tnewStateRegistryIdsByOldPaletteId: " + Arrays.toString(newStateRegistryIdsByOldPaletteId) + "\n\n" + conversionString);
-                            throw e;
-                        }
+                        bitStorageWriter.write(blockStateReplacements[bits]);
                     }
                     bitStorageWriter.flush();
                 }
             }
         }
-        MinecraftServer.LOGGER.info(chunk.locX + " , " + chunk.locZ + " : done");
+
     }
 
 }
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/BlockReplacementRule.java b/src/main/java/nl/martijnmuijsers/paper/block/BlockReplacementRule.java
index e2cbe13e8e18fed745f9d4b38205ffd8f628e05f..0dd5bb5c8565c1f3c0fbc46770ad6eb05eabe06f 100644
--- a/src/main/java/nl/martijnmuijsers/paper/block/BlockReplacementRule.java
+++ b/src/main/java/nl/martijnmuijsers/paper/block/BlockReplacementRule.java
@@ -30,6 +30,8 @@ public interface BlockReplacementRule {
 
     @Nullable Item getFallbackItem();
 
+    void writeToStateIdReplacementArrays();
+
     default void updateMinDestroyTimes() {
         updateMinDestroyTimeOfReal(); // Some will see it as the host, others as the fallback
         updateMinDestroyTimeOfHost(); // Some may see it as the host replacement
@@ -192,6 +194,17 @@ public interface BlockReplacementRule {
             );
         }
 
+        @Override
+        public void writeToStateIdReplacementArrays() {
+            int realId = Block.BLOCK_STATE_REGISTRY.getId(this.real.defaultBlockState());
+            int hostId = Block.BLOCK_STATE_REGISTRY.getId(this.host);
+            int hostReplacementId = Block.BLOCK_STATE_REGISTRY.getId(this.hostReplacement);
+            int fallbackId = Block.BLOCK_STATE_REGISTRY.getId(this.fallback);
+            Block.stateIdReplacementArrayWithResourcePack[realId] = hostId;
+            Block.stateIdReplacementArrayWithResourcePack[hostId] = hostReplacementId;
+            Block.stateIdReplacementArrayWithoutResourcePack[realId] = fallbackId;
+        }
+
     }
 
     // Blocks with item form
