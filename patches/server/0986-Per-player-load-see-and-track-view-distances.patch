From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Fri, 10 Jun 2022 00:26:10 +0200
Subject: [PATCH] Per-player load, see and track view distances


diff --git a/src/main/java/co/aikar/timings/TimingsExport.java b/src/main/java/co/aikar/timings/TimingsExport.java
index 2cc44fbf8e5bd436b6d4e19f6c06b351e750cb31..f5399e4ce53015d567327fab415d5361f41ff53b 100644
--- a/src/main/java/co/aikar/timings/TimingsExport.java
+++ b/src/main/java/co/aikar/timings/TimingsExport.java
@@ -164,8 +164,11 @@ public class TimingsExport extends Thread {
                 })),
                 // Paper start - replace chunk loader system
                 pair("ticking-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance()),
-                pair("no-ticking-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetNoTickViewDistance()),
-                pair("sending-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance())
+                // Martijn start - per-player track and see view distance
+                pair("max-track-distance", world.paperConfig().viewDistances.track.getMax()),
+                pair("max-see-distance", world.paperConfig().viewDistances.see.getMax()),
+                pair("max-load-distance", world.paperConfig().viewDistances.load.getMax())
+                // Martijn end - per-player track and see view distance
                 // Paper end - replace chunk loader system
             ));
         }));
diff --git a/src/main/java/co/aikar/timings/WorldTimingsHandler.java b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
index fe79c0add4f7cb18d487c5bb9415c40c5b551ea2..dc4f52c99466302345f2818c12d0760733f5fe9b 100644
--- a/src/main/java/co/aikar/timings/WorldTimingsHandler.java
+++ b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
@@ -44,6 +44,24 @@ public class WorldTimingsHandler {
     public final Timing broadcastChunkUpdates;
     public final Timing countNaturalMobs;
 
+    // Martijn start - per-player view distance
+//    public final Timing getPlayersNearChunkForSending;
+    public final Timing chunkMapPlayerMove;
+//    public final Timing chunkMapPlayerMoveUpdatePos;
+//    public final Timing chunkMapPlayerMoveUpdateDistanceManager;
+//    public final Timing chunkMapPlayerMoveUpdatePlayerMap;
+//    public final Timing chunkMapUpdatePlayerMaps;
+    public final Timing playerChunkLoaderUpdate;
+//    public final Timing chunkMapPlayerMoveUpdateChunkTrackingOrSeeing;
+//    public final Timing chunkMapPlayerMoveSortChunksForTrackAndSee;
+    public final Timing computeTrackViewDistance;
+    public final Timing computeSeeViewDistance;
+    public final Timing computeLoadViewDistance;
+    public final Timing trackViewDistanceMayHaveChanged;
+    public final Timing seeViewDistanceMayHaveChanged;
+    public final Timing loadViewDistanceMayHaveChanged;
+    // Martijn end - per-player view distance
+
     public final Timing chunkLoad;
     public final Timing chunkLoadPopulate;
     public final Timing syncChunkLoad;
@@ -119,6 +137,23 @@ public class WorldTimingsHandler {
         broadcastChunkUpdates = Timings.ofSafe(name + "Broadcast chunk updates");
         countNaturalMobs = Timings.ofSafe(name + "Count natural mobs");
 
+        // Martijn start - per-player view distance
+//        getPlayersNearChunkForSending = Timings.ofSafe("Get players near chunk for sending");
+        chunkMapPlayerMove = Timings.ofSafe("Chunk map player move");
+//        chunkMapPlayerMoveUpdatePos = Timings.ofSafe("Chunk map player move - update pos");
+//        chunkMapPlayerMoveUpdateDistanceManager = Timings.ofSafe("Chunk map player move - update distance manager");
+//        chunkMapPlayerMoveUpdatePlayerMap = Timings.ofSafe("Chunk map player move - update player map");
+//        chunkMapUpdatePlayerMaps = Timings.ofSafe("Chunk map update player maps");
+        playerChunkLoaderUpdate = Timings.ofSafe("Player chunk loader update");
+//        chunkMapPlayerMoveUpdateChunkTrackingOrSeeing = Timings.ofSafe("Chunk map player move - update chunk tracking or seeing");
+//        chunkMapPlayerMoveSortChunksForTrackAndSee = Timings.ofSafe("Chunk map player move - sort chunks for track and see");
+        computeTrackViewDistance = Timings.ofSafe("Compute track view distance");
+        computeSeeViewDistance = Timings.ofSafe("Compute see view distance");
+        computeLoadViewDistance = Timings.ofSafe("Compute load view distance");
+        trackViewDistanceMayHaveChanged = Timings.ofSafe("Track view distance may have changed");
+        seeViewDistanceMayHaveChanged = Timings.ofSafe("See view distance may have changed");
+        loadViewDistanceMayHaveChanged = Timings.ofSafe("Load view distance may have changed");
+        // Martijn end - per-player view distance
 
         miscMobSpawning = Timings.ofSafe(name + "Mob spawning - Misc");
 
diff --git a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
index b53402903eb6845df361daf6b05a668608ad7b63..fad91a47e97aecd5baf1ff0d8cc7161c4e1f5c2d 100644
--- a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
@@ -24,6 +24,7 @@ import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.entity.Player;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
 import java.util.TreeSet;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -49,31 +50,33 @@ public final class PlayerChunkLoader {
         return data.getTargetTickViewDistance();
     }
 
-    public static int getLoadViewDistance(final Player player) {
-        return getLoadViewDistance(((CraftPlayer)player).getHandle());
-    }
-
-    public static int getLoadViewDistance(final ServerPlayer player) {
-        final ServerLevel level = (ServerLevel)player.level;
-        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
-        if (data == null) {
-            return level.chunkSource.chunkMap.playerChunkManager.getLoadDistance();
-        }
-        return data.getLoadDistance();
-    }
-
-    public static int getSendViewDistance(final Player player) {
-        return getSendViewDistance(((CraftPlayer)player).getHandle());
-    }
-
-    public static int getSendViewDistance(final ServerPlayer player) {
-        final ServerLevel level = (ServerLevel)player.level;
-        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
-        if (data == null) {
-            return level.chunkSource.chunkMap.playerChunkManager.getTargetSendDistance();
-        }
-        return data.getTargetSendViewDistance();
-    }
+    // Martijn start - per-player view distance
+//    public static int getLoadViewDistance(final Player player) {
+//        return getLoadViewDistance(((CraftPlayer)player).getHandle());
+//    }
+//
+//    public static int getLoadViewDistance(final ServerPlayer player) {
+//        final ServerLevel level = (ServerLevel)player.level;
+//        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
+//        if (data == null) {
+//            return level.chunkSource.chunkMap.playerChunkManager.getLoadDistance();
+//        }
+//        return data.getLoadDistance();
+//    }
+
+//    public static int getSendViewDistance(final Player player) {
+//        return getSendViewDistance(((CraftPlayer)player).getHandle());
+//    }
+//
+//    public static int getSendViewDistance(final ServerPlayer player) {
+//        final ServerLevel level = (ServerLevel)player.level;
+//        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
+//        if (data == null) {
+//            return level.chunkSource.chunkMap.playerChunkManager.getTargetSendDistance();
+//        }
+//        return data.getTargetSendViewDistance();
+//    }
+    // Martijn end - per-player view distance
 
     protected final ChunkMap chunkMap;
     protected final Reference2ObjectLinkedOpenHashMap<ServerPlayer, PlayerLoaderData> playerMap = new Reference2ObjectLinkedOpenHashMap<>(512, 0.7f);
@@ -135,7 +138,15 @@ public final class PlayerChunkLoader {
     /**
      * The chunks to be sent to players, provided they're send-ready. Send-ready means the chunk and its 1 radius neighbours are loaded.
      */
-    public final PlayerAreaMap broadcastMap;
+    // Martijn start - per-player track and see view distance
+    public final PlayerAreaMap broadcastMapForTracking;
+    public final PlayerAreaMap broadcastMapForSeeing;
+
+    public PlayerAreaMap getBroadcastMap(final boolean concernsTracking) {
+        return concernsTracking ? this.broadcastMapForTracking : this.broadcastMapForSeeing;
+    }
+
+    // Martijn end - per-player track and see view distance
 
     /**
      * The chunks to be brought up to send-ready status. Send-ready means the chunk and its 1 radius neighbours are loaded.
@@ -153,15 +164,17 @@ public final class PlayerChunkLoader {
      */
     public final PlayerAreaMap tickMap;
 
-    /**
-     * -1 if defaulting to [load distance], else always in [2, load distance]
-     */
-    protected int rawSendDistance = -1;
-
-    /**
-     * -1 if defaulting to [tick view distance + 1], else always in [tick view distance + 1, 32 + 1]
-     */
-    protected int rawLoadDistance = -1;
+    // Martijn start - per-player view distance
+//    /**
+//     * -1 if defaulting to [load distance], else always in [2, load distance]
+//     */
+//    protected int rawSendDistance = -1;
+//
+//    /**
+//     * -1 if defaulting to [tick view distance + 1], else always in [tick view distance + 1, 32 + 1]
+//     */
+//    protected int rawLoadDistance = -1;
+    // Martijn end - per-player view distance
 
     /**
      * Never -1, always in [2, 32]
@@ -178,47 +191,49 @@ public final class PlayerChunkLoader {
         this.setTickDistance(distance);
     }
 
-    public int getTargetNoTickViewDistance() {
-        return this.getLoadDistance() - 1;
-    }
-
-    public void setTargetNoTickViewDistance(final int distance) {
-        this.setLoadDistance(distance == -1 ? -1 : distance + 1);
-    }
-
-    public int getTargetSendDistance() {
-        return this.rawSendDistance == -1 ? this.getLoadDistance() : this.rawSendDistance;
-    }
-
-    public void setTargetSendDistance(final int distance) {
-        this.setSendDistance(distance);
-    }
-
-    // internal methods
-
-    public int getSendDistance() {
-        final int loadDistance = this.getLoadDistance();
-        return this.rawSendDistance == -1 ? loadDistance : Math.min(this.rawSendDistance, loadDistance);
-    }
-
-    public void setSendDistance(final int distance) {
-        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
-            throw new IllegalArgumentException("Send distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + ", or -1, got: " + distance);
-        }
-        this.rawSendDistance = distance;
-    }
-
-    public int getLoadDistance() {
-        final int tickDistance = this.getTickDistance();
-        return this.rawLoadDistance == -1 ? tickDistance + 1 : Math.max(tickDistance + 1, this.rawLoadDistance);
-    }
-
-    public void setLoadDistance(final int distance) {
-        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
-            throw new IllegalArgumentException("Load distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + ", or -1, got: " + distance);
-        }
-        this.rawLoadDistance = distance;
-    }
+    // Martijn start - per-player view distance
+//    public int getTargetNoTickViewDistance() {
+//        return this.getLoadDistance() - 1;
+//    }
+//
+//    public void setTargetNoTickViewDistance(final int distance) {
+//        this.setLoadDistance(distance == -1 ? -1 : distance + 1);
+//    }
+//
+//    public int getTargetSendDistance() {
+//        return this.rawSendDistance == -1 ? this.getLoadDistance() : this.rawSendDistance;
+//    }
+//
+//    public void setTargetSendDistance(final int distance) {
+//        this.setSendDistance(distance);
+//    }
+//
+//    // internal methods
+//
+//    public int getSendDistance() {
+//        final int loadDistance = this.getLoadDistance();
+//        return this.rawSendDistance == -1 ? loadDistance : Math.min(this.rawSendDistance, loadDistance);
+//    }
+//
+//    public void setSendDistance(final int distance) {
+//        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
+//            throw new IllegalArgumentException("Send distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + ", or -1, got: " + distance);
+//        }
+//        this.rawSendDistance = distance;
+//    }
+//
+//    public int getLoadDistance() {
+//        final int tickDistance = this.getTickDistance();
+//        return this.rawLoadDistance == -1 ? tickDistance + 1 : Math.max(tickDistance + 1, this.rawLoadDistance);
+//    }
+//
+//    public void setLoadDistance(final int distance) {
+//        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
+//            throw new IllegalArgumentException("Load distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + ", or -1, got: " + distance);
+//        }
+//        this.rawLoadDistance = distance;
+//    }
+    // Martijn end - per-player view distance
 
     public int getTickDistance() {
         return this.rawTickDistance;
@@ -256,12 +271,20 @@ public final class PlayerChunkLoader {
 
     public PlayerChunkLoader(final ChunkMap chunkMap, final PooledLinkedHashSets<ServerPlayer> pooledHashSets) {
         this.chunkMap = chunkMap;
-        this.broadcastMap = new PlayerAreaMap(pooledHashSets,
+        // Martijn start - player track and see view distance
+        this.broadcastMapForTracking = new PlayerAreaMap(pooledHashSets,
+                null,
+                (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                    PlayerChunkLoader.this.onChunkLeave(player, rangeX, rangeZ, true);
+                });
+        this.broadcastMapForSeeing = new PlayerAreaMap(pooledHashSets,
                 null,
                 (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
                  com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
-                    PlayerChunkLoader.this.onChunkLeave(player, rangeX, rangeZ);
+                    PlayerChunkLoader.this.onChunkLeave(player, rangeX, rangeZ, false);
                 });
+        // Martijn end - player track and see view distance
         this.loadMap = new PlayerAreaMap(pooledHashSets,
                 null,
                 (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
@@ -311,12 +334,16 @@ public final class PlayerChunkLoader {
     protected final LongOpenHashSet isTargetedForPlayerLoad = new LongOpenHashSet();
     protected final LongOpenHashSet chunkTicketTracker = new LongOpenHashSet();
 
-    public boolean isChunkNearPlayers(final int chunkX, final int chunkZ) {
-        final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.broadcastMap.getObjectsInRange(chunkX, chunkZ);
+    // Martijn start - per-player track and see view distance
+
+    public boolean isChunkNearPlayers(final int chunkX, final int chunkZ, boolean concernsTracking) {
+        final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.getBroadcastMap(concernsTracking).getObjectsInRange(chunkX, chunkZ);
 
         return playersInSendRange != null;
     }
 
+    // Martijn end - per-player track and see view distance
+
     public void onChunkPostProcessing(final int chunkX, final int chunkZ) {
         this.onChunkSendReady(chunkX, chunkZ);
     }
@@ -348,34 +375,38 @@ public final class PlayerChunkLoader {
         return levelChunk != null && levelChunk.isPostProcessingDone && this.isTargetedForPlayerLoad.contains(key);
     }
 
-    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean borderOnly) {
-        return borderOnly ? this.isChunkSentBorderOnly(player, chunkX, chunkZ) : this.isChunkSent(player, chunkX, chunkZ);
+    // Martijn start - per-player track and see view distance
+
+    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean borderOnly, final boolean concernsTracking) {
+        return borderOnly ? this.isChunkSentBorderOnly(player, chunkX, chunkZ, concernsTracking) : this.isChunkSent(player, chunkX, chunkZ, concernsTracking);
     }
 
-    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) {
         final PlayerLoaderData data = this.playerMap.get(player);
         if (data == null) {
             return false;
         }
 
-        return data.hasSentChunk(chunkX, chunkZ);
+        return data.hasSentChunk(chunkX, chunkZ, concernsTracking);
     }
 
-    public boolean isChunkSentBorderOnly(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public boolean isChunkSentBorderOnly(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) {
         final PlayerLoaderData data = this.playerMap.get(player);
         if (data == null) {
             return false;
         }
 
-        final boolean center = data.hasSentChunk(chunkX, chunkZ);
+        final boolean center = data.hasSentChunk(chunkX, chunkZ, concernsTracking);
         if (!center) {
             return false;
         }
 
-        return !(data.hasSentChunk(chunkX - 1, chunkZ) && data.hasSentChunk(chunkX + 1, chunkZ) &&
-            data.hasSentChunk(chunkX, chunkZ - 1) && data.hasSentChunk(chunkX, chunkZ + 1));
+        return !(data.hasSentChunk(chunkX - 1, chunkZ, concernsTracking) && data.hasSentChunk(chunkX + 1, chunkZ, concernsTracking) &&
+            data.hasSentChunk(chunkX, chunkZ - 1, concernsTracking) && data.hasSentChunk(chunkX, chunkZ + 1, concernsTracking));
     }
 
+    // Martijn end - per-player track and see view distance
+
     protected int getMaxConcurrentChunkSends() {
         return GlobalConfiguration.get().chunkLoading.maxConcurrentSends;
     }
@@ -400,47 +431,55 @@ public final class PlayerChunkLoader {
     }
 
     public void onChunkSendReady(final int chunkX, final int chunkZ) {
-        final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.broadcastMap.getObjectsInRange(chunkX, chunkZ);
 
-        if (playersInSendRange == null) {
-            return;
-        }
+        // Martijn start - per-player track and see view distance
 
-        final Object[] rawData = playersInSendRange.getBackingSet();
-        for (int i = 0, len = rawData.length; i < len; ++i) {
-            final Object raw = rawData[i];
+        for (boolean concernsTracking : new boolean[] {false, true}) {
+            final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.getBroadcastMap(concernsTracking).getObjectsInRange(chunkX, chunkZ);
 
-            if (!(raw instanceof ServerPlayer)) {
-                continue;
+            if (playersInSendRange == null) {
+                return;
+            }
+
+            final Object[] rawData = playersInSendRange.getBackingSet();
+            for (int i = 0, len = rawData.length; i < len; ++i) {
+                final Object raw = rawData[i];
+
+                if (!(raw instanceof ServerPlayer)) {
+                    continue;
+                }
+                this.onChunkSendReady((ServerPlayer) raw, chunkX, chunkZ, concernsTracking);
             }
-            this.onChunkSendReady((ServerPlayer)raw, chunkX, chunkZ);
         }
+
+        // Martijn end - per-player track and see view distance
+
     }
 
-    public void onChunkSendReady(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public void onChunkSendReady(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) { // Martijn - per-player track and see view distance
         final PlayerLoaderData data = this.playerMap.get(player);
 
         if (data == null) {
             return;
         }
 
-        if (data.hasSentChunk(chunkX, chunkZ) || !this.isChunkPlayerLoaded(chunkX, chunkZ)) {
+        if (data.hasSentChunk(chunkX, chunkZ, concernsTracking) || !this.isChunkPlayerLoaded(chunkX, chunkZ)) { // Martijn - per-player track and see view distance
             // if we don't have player tickets, then the load logic will pick this up and queue to send
             return;
         }
 
-        if (!data.chunksToBeSent.remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
+        if (!data.getChunksToBeSent(concernsTracking).remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) { // Martijn - per-player track and see view distance
             // don't queue to send, we don't want the chunk
             return;
         }
 
-        final long playerPos = this.broadcastMap.getLastCoordinate(player);
+        final long playerPos = this.broadcastMapForSeeing.getLastCoordinate(player); // Martijn - per-player track and see view distance
         final int playerChunkX = CoordinateUtils.getChunkX(playerPos);
         final int playerChunkZ = CoordinateUtils.getChunkZ(playerPos);
         final int manhattanDistance = Math.abs(playerChunkX - chunkX) + Math.abs(playerChunkZ - chunkZ);
 
         final ChunkPriorityHolder holder = new ChunkPriorityHolder(chunkX, chunkZ, manhattanDistance, 0.0);
-        data.sendQueue.add(holder);
+        data.getSendQueue(concernsTracking).add(holder); // Martijn - per-player track and see view distance
     }
 
     public void onChunkLoad(final int chunkX, final int chunkZ) {
@@ -449,14 +488,14 @@ public final class PlayerChunkLoader {
         }
     }
 
-    public void onChunkLeave(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public void onChunkLeave(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) { // Martijn - per-player track and see view distance
         final PlayerLoaderData data = this.playerMap.get(player);
 
         if (data == null) {
             return;
         }
 
-        data.unloadChunk(chunkX, chunkZ);
+        data.unloadChunk(chunkX, chunkZ, concernsTracking); // Martijn - per-player track and see view distance
     }
 
     public void addPlayer(final ServerPlayer player) {
@@ -559,7 +598,14 @@ public final class PlayerChunkLoader {
 
             final PlayerLoaderData data = this.chunkSendQueue.removeFirst();
 
-            final ChunkPriorityHolder queuedSend = data.sendQueue.pollFirst();
+            // Martijn start - per-player track and see view distance
+            ChunkPriorityHolder queuedSend = data.getSendQueue(true).pollFirst();
+            boolean concernsTracking = true;
+            if (queuedSend == null) {
+                queuedSend = data.getSendQueue(false).pollFirst();
+                concernsTracking = false;
+            }
+            // Martijn end - per-player track and see view distance
             if (queuedSend == null) {
                 concurrentChunkSends.getAndDecrement(); // we never sent, so decrease
                 // stop iterating over players who have nothing to send
@@ -596,7 +642,7 @@ public final class PlayerChunkLoader {
                 }
 
                 concurrentChunkSends.getAndDecrement();
-            });
+            }, concernsTracking);
 
             nextChunkSend = this.getMaxSendAddend() + time;
             if (time < nextChunkSend) {
@@ -776,7 +822,10 @@ public final class PlayerChunkLoader {
         // this is corrected so that 0 is along the positive x-axis
         protected float lastYaw = Float.NEGATIVE_INFINITY;
 
-        protected int lastSendDistance = Integer.MIN_VALUE;
+        // Martijn start - per-player track and see view distance
+        protected int lastTrackDistance = Integer.MIN_VALUE;
+        protected int lastSeeDistance = Integer.MIN_VALUE;
+        // Martijn end - per-player track and see view distance
         protected int lastLoadDistance = Integer.MIN_VALUE;
         protected int lastTickDistance = Integer.MIN_VALUE;
         protected boolean usingLookingPriority;
@@ -787,28 +836,29 @@ public final class PlayerChunkLoader {
         // warning: modifications of this field must be aware that the loadQueue inside PlayerChunkLoader uses this field
         // in a comparator!
         protected final ArrayDeque<ChunkPriorityHolder> loadQueue = new ArrayDeque<>();
-        protected final LongOpenHashSet sentChunks = new LongOpenHashSet();
-        protected final LongOpenHashSet chunksToBeSent = new LongOpenHashSet();
 
-        protected final TreeSet<ChunkPriorityHolder> sendQueue = new TreeSet<>((final ChunkPriorityHolder p1, final ChunkPriorityHolder p2) -> {
-            final int distanceCompare = Integer.compare(p1.manhattanDistanceToPlayer, p2.manhattanDistanceToPlayer);
-            if (distanceCompare != 0) {
-                return distanceCompare;
-            }
+        // Martijn start - per-player view distance
 
-            final int coordinateXCompare = Integer.compare(p1.chunkX, p2.chunkX);
-            if (coordinateXCompare != 0) {
-                return coordinateXCompare;
-            }
+        protected final LongOpenHashSet sentChunksForTracking = new LongOpenHashSet();
+        protected final LongOpenHashSet chunksToBeSentForTracking = new LongOpenHashSet();
 
-            return Integer.compare(p1.chunkZ, p2.chunkZ);
-        });
+        protected final LongOpenHashSet sentChunksForSeeing = new LongOpenHashSet();
+        protected final LongOpenHashSet chunksToBeSentForSeeing = new LongOpenHashSet();
 
-        protected int sendViewDistance = -1;
-        protected int loadViewDistance = -1;
-        protected int tickViewDistance = -1;
+        private TreeSet<ChunkPriorityHolder> createSendQueue() {
+            return new TreeSet<>((final ChunkPriorityHolder p1, final ChunkPriorityHolder p2) -> {
+                final int distanceCompare = Integer.compare(p1.manhattanDistanceToPlayer, p2.manhattanDistanceToPlayer);
+                if (distanceCompare != 0) {
+                    return distanceCompare;
+                }
 
-        protected long nextChunkSendTarget;
+                final int coordinateXCompare = Integer.compare(p1.chunkX, p2.chunkX);
+                if (coordinateXCompare != 0) {
+                    return coordinateXCompare;
+                }
+                return Integer.compare(p1.chunkZ, p2.chunkZ);
+            });
+        }
 
         // this interval prevents bursting a lot of chunk loads
         protected final IntervalledCounter ticketAdditionCounterShort = new IntervalledCounter((long)(1.0e6 * 50.0)); // 50ms
@@ -822,35 +872,59 @@ public final class PlayerChunkLoader {
             this.loader = loader;
         }
 
-        // these view distance methods are for api
-        public int getTargetSendViewDistance() {
-            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
-            final int loadViewDistance = Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
-            final int clientViewDistance = this.getClientViewDistance();
-            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!GlobalConfiguration.get().chunkLoading.autoconfigSendDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
-            return sendViewDistance;
-        }
+        protected final TreeSet<ChunkPriorityHolder> sendQueueForTracking = createSendQueue();
+        protected final TreeSet<ChunkPriorityHolder> sendQueueForSeeing = createSendQueue();
 
-        public void setTargetSendViewDistance(final int distance) {
-            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
-                throw new IllegalArgumentException("Send view distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + " or -1, got: " + distance);
-            }
-            this.sendViewDistance = distance;
+        protected LongOpenHashSet getSentChunks(final boolean concernsTracking) {
+            return concernsTracking ? this.sentChunksForTracking : this.sentChunksForSeeing;
         }
-
-        public int getTargetNoTickViewDistance() {
-            return (this.loadViewDistance == -1 ? this.getLoadDistance() : this.loadViewDistance) - 1;
+        protected LongOpenHashSet getChunksToBeSent(final boolean concernsTracking) {
+            return concernsTracking ? this.chunksToBeSentForTracking : this.chunksToBeSentForSeeing;
         }
 
-        public void setTargetNoTickViewDistance(final int distance) {
-            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE)) {
-                throw new IllegalArgumentException("Simulation distance must be a number between " + MIN_VIEW_DISTANCE + " and " + MAX_VIEW_DISTANCE + " or -1, got: " + distance);
-            }
-            this.loadViewDistance = distance == -1 ? -1 : distance + 1;
+        protected TreeSet<ChunkPriorityHolder> getSendQueue(final boolean concernsTracking) {
+            return concernsTracking ? this.sendQueueForTracking : this.sendQueueForSeeing;
         }
 
+//        protected int sendViewDistance = -1;
+//        protected int loadViewDistance = -1;
+        public int tickViewDistance = -1;
+
+        // Martijn end - per-player view distance
+
+        protected long nextChunkSendTarget;
+
+//        // these view distance methods are for api
+//        public int getTargetSendViewDistance() {
+//            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+//            final int loadViewDistance = Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
+//            final int clientViewDistance = this.getClientViewDistance();
+//            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!PaperConfig.playerAutoConfigureSendViewDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
+//            return sendViewDistance;
+//        }
+//
+//        public void setTargetSendViewDistance(final int distance) {
+//            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
+//                throw new IllegalArgumentException("Send view distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + " or -1, got: " + distance);
+//            }
+//            this.sendViewDistance = distance;
+//        }
+//
+//        public int getTargetNoTickViewDistance() {
+//            return (this.loadViewDistance == -1 ? this.getLoadDistance() : this.loadViewDistance) - 1;
+//        }
+//
+//        public void setTargetNoTickViewDistance(final int distance) {
+//            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE)) {
+//                throw new IllegalArgumentException("Simulation distance must be a number between " + MIN_VIEW_DISTANCE + " and " + MAX_VIEW_DISTANCE + " or -1, got: " + distance);
+//            }
+//            this.loadViewDistance = distance == -1 ? -1 : distance + 1;
+//        }
+
         public int getTargetTickViewDistance() {
-            return this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+            // Martijn start - per-player load distance
+            return player.getTickingViewDistance();
+            // Martijn end - per-player load distance
         }
 
         public void setTargetTickViewDistance(final int distance) {
@@ -860,33 +934,37 @@ public final class PlayerChunkLoader {
             this.tickViewDistance = distance;
         }
 
-        protected int getLoadDistance() {
-            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+//        protected int getLoadDistance() {
+//            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+//
+//            return Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
+//        }
 
-            return Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
-        }
+        // Martijn start - per-player view distance
 
-        public boolean hasSentChunk(final int chunkX, final int chunkZ) {
-            return this.sentChunks.contains(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+        public boolean hasSentChunk(final int chunkX, final int chunkZ, final boolean concernsTracking) {
+            return this.getSentChunks(concernsTracking).contains(CoordinateUtils.getChunkKey(chunkX, chunkZ));
         }
 
-        public void sendChunk(final int chunkX, final int chunkZ, final Runnable onChunkSend) {
-            if (this.sentChunks.add(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
+        public void sendChunk(final int chunkX, final int chunkZ, final Runnable onChunkSend, final boolean concernsTracking) {
+            if (this.getSentChunks(concernsTracking).add(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
                 this.player.getLevel().getChunkSource().chunkMap.updateChunkTracking(this.player,
-                        new ChunkPos(chunkX, chunkZ), new MutableObject<>(), false, true); // unloaded, loaded
+                        new ChunkPos(chunkX, chunkZ), new MutableObject<>(), false, true, concernsTracking); // unloaded, loaded
                 this.player.connection.connection.execute(onChunkSend);
             } else {
                 throw new IllegalStateException();
             }
         }
 
-        public void unloadChunk(final int chunkX, final int chunkZ) {
-            if (this.sentChunks.remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
+        public void unloadChunk(final int chunkX, final int chunkZ, final boolean concernsTracking) {
+            if (this.getSentChunks(concernsTracking).remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
                 this.player.getLevel().getChunkSource().chunkMap.updateChunkTracking(this.player,
-                        new ChunkPos(chunkX, chunkZ), null, true, false); // unloaded, loaded
+                        new ChunkPos(chunkX, chunkZ), null, true, false, concernsTracking); // unloaded, loaded
             }
         }
 
+        // Martijn end - per-player view distance
+
         protected static boolean wantChunkLoaded(final int centerX, final int centerZ, final int chunkX, final int chunkZ,
                                                  final int sendRadius) {
             // expect sendRadius to be = 1 + target viewable radius
@@ -928,7 +1006,10 @@ public final class PlayerChunkLoader {
         }
 
         public void remove() {
-            this.loader.broadcastMap.remove(this.player);
+            // Martijn start - per-player track and see view distance
+            this.loader.getBroadcastMap(false).remove(this.player);
+            this.loader.getBroadcastMap(true).remove(this.player);
+            // Martijn end - per-player track and see view distance
             this.loader.loadMap.remove(this.player);
             this.loader.loadTicketCleanup.remove(this.player);
             this.loader.tickMap.remove(this.player);
@@ -939,12 +1020,17 @@ public final class PlayerChunkLoader {
         }
 
         public void update() {
-            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+            // Martijn start - per-player view distance
+            this.player.level.timings.playerChunkLoaderUpdate.startTiming();
+            final int loadViewDistance = this.player.getLoadViewDistance();
             // load view cannot be less-than tick view + 1
-            final int loadViewDistance = Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
+            final int tickViewDistance = this.player.getTickingViewDistance();
             // send view cannot be greater-than load view
             final int clientViewDistance = this.getClientViewDistance();
-            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!GlobalConfiguration.get().chunkLoading.autoconfigSendDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
+//            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!GlobalConfiguration.get().chunkLoading.autoconfigSendDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
+            final int trackViewDistance = this.player.getTrackViewDistance();
+            final int seeViewDistance = this.player.getSeeViewDistance();
+            // Martijn end - per-player view distance
 
             final double posX = this.player.getX();
             final double posZ = this.player.getZ();
@@ -959,7 +1045,7 @@ public final class PlayerChunkLoader {
 
             if (
                 // has view distance stayed the same?
-                    sendViewDistance == this.lastSendDistance
+                    trackViewDistance == this.lastTrackDistance && seeViewDistance == this.lastSeeDistance // Martijn - per-player track and see view distance
                             && loadViewDistance == this.lastLoadDistance
                             && tickViewDistance == this.lastTickDistance
 
@@ -980,6 +1066,7 @@ public final class PlayerChunkLoader {
                             && (!this.usingLookingPriority || Math.abs(yaw - this.lastYaw) <= LOOK_PRIORITY_YAW_DELTA_RECALC_THRESHOLD)
             ) {
                 // nothing we care about changed, so we're not re-calculating
+                this.player.level.timings.playerChunkLoaderUpdate.stopTiming(); // Martijn - per-player view distance
                 return;
             }
 
@@ -987,16 +1074,20 @@ public final class PlayerChunkLoader {
             final int centerChunkZ = Mth.floor(posZ) >> 4;
 
             final boolean needsChunkCenterUpdate = (centerChunkX != this.lastChunkX) || (centerChunkZ != this.lastChunkZ);
-            this.loader.broadcastMap.addOrUpdate(this.player, centerChunkX, centerChunkZ, sendViewDistance);
+
+            // Martijn start - per-player track and see view distance
+            this.loader.getBroadcastMap(false).addOrUpdate(this.player, centerChunkX, centerChunkZ, seeViewDistance);
+            this.loader.getBroadcastMap(true).addOrUpdate(this.player, centerChunkX, centerChunkZ, trackViewDistance);
+            // Martijn end - per-player track and see view distance
             this.loader.loadMap.addOrUpdate(this.player, centerChunkX, centerChunkZ, loadViewDistance);
             this.loader.loadTicketCleanup.addOrUpdate(this.player, centerChunkX, centerChunkZ, loadViewDistance + 1);
             this.loader.tickMap.addOrUpdate(this.player, centerChunkX, centerChunkZ, tickViewDistance);
 
-            if (sendViewDistance != this.lastSendDistance) {
+            if (seeViewDistance != this.lastSeeDistance) { // Martijn - per-player track and see view distance
                 // update the view radius for client
                 // note that this should be after the map calls because the client wont expect unload calls not in its VD
                 // and it's possible we decreased VD here
-                this.player.connection.send(new ClientboundSetChunkCacheRadiusPacket(sendViewDistance));
+                this.player.connection.send(new ClientboundSetChunkCacheRadiusPacket(seeViewDistance)); // Martijn - per-player track and see view distance
             }
             if (tickViewDistance != this.lastTickDistance) {
                 this.player.connection.send(new ClientboundSetSimulationDistancePacket(tickViewDistance));
@@ -1005,7 +1096,10 @@ public final class PlayerChunkLoader {
             this.lastLocX = posX;
             this.lastLocZ = posZ;
             this.lastYaw = yaw;
-            this.lastSendDistance = sendViewDistance;
+            // Martijn start - per-player track and see view distance
+            this.lastTrackDistance = trackViewDistance;
+            this.lastSeeDistance = seeViewDistance;
+            // Martijn start - per-player track and see view distance
             this.lastLoadDistance = loadViewDistance;
             this.lastTickDistance = tickViewDistance;
             this.usingLookingPriority = useLookPriority;
@@ -1035,76 +1129,87 @@ public final class PlayerChunkLoader {
 
             final List<ChunkPriorityHolder> loadQueue = new ArrayList<>();
 
+            // Martijn start - per-player track and see view distance
+
             // clear send queue, we are re-sorting
-            this.sendQueue.clear();
+            this.getSendQueue(false).clear();
+            this.getSendQueue(true).clear();
             // clear chunk want set, vd/position might have changed
-            this.chunksToBeSent.clear();
-
-            final int searchViewDistance = Math.max(loadViewDistance, sendViewDistance);
-
-            for (int dx = -searchViewDistance; dx <= searchViewDistance; ++dx) {
-                for (int dz = -searchViewDistance; dz <= searchViewDistance; ++dz) {
-                    final int chunkX = dx + centerChunkX;
-                    final int chunkZ = dz + centerChunkZ;
-                    final int squareDistance = Math.max(Math.abs(dx), Math.abs(dz));
-                    final boolean sendChunk = squareDistance <= sendViewDistance && wantChunkLoaded(centerChunkX, centerChunkZ, chunkX, chunkZ, sendViewDistance);
-
-                    if (this.hasSentChunk(chunkX, chunkZ)) {
-                        // already sent (which means it is also loaded)
-                        if (!sendChunk) {
-                            // have sent the chunk, but don't want it anymore
-                            // unload it now
-                            this.unloadChunk(chunkX, chunkZ);
+            this.getChunksToBeSent(false).clear();
+            this.getChunksToBeSent(true).clear();
+
+            for (boolean concernsTracking : new boolean[] {false, true}) {
+
+                final int sendViewDistance = concernsTracking ? trackViewDistance : seeViewDistance;
+
+                final int searchViewDistance = Math.max(loadViewDistance, sendViewDistance);
+
+                for (int dx = -searchViewDistance; dx <= searchViewDistance; ++dx) {
+                    for (int dz = -searchViewDistance; dz <= searchViewDistance; ++dz) {
+                        final int chunkX = dx + centerChunkX;
+                        final int chunkZ = dz + centerChunkZ;
+                        final int squareDistance = Math.max(Math.abs(dx), Math.abs(dz));
+                        final boolean sendChunk = squareDistance <= sendViewDistance && wantChunkLoaded(centerChunkX, centerChunkZ, chunkX, chunkZ, sendViewDistance);
+
+                        if (this.hasSentChunk(chunkX, chunkZ, concernsTracking)) {
+                            // already sent (which means it is also loaded)
+                            if (!sendChunk) {
+                                // have sent the chunk, but don't want it anymore
+                                // unload it now
+                                this.unloadChunk(chunkX, chunkZ, concernsTracking);
+                            }
+                            continue;
                         }
-                        continue;
-                    }
 
-                    final boolean loadChunk = squareDistance <= loadViewDistance;
+                        final boolean loadChunk = squareDistance <= loadViewDistance;
 
-                    final boolean prioritised = useLookPriority && triangleIntersects(
+                        final boolean prioritised = useLookPriority && triangleIntersects(
                             // prioritisation triangle
                             p1x, p1z, p2x, p2z, p3x, p3z,
 
                             // center of chunk
-                            (double)((chunkX << 4) | 8), (double)((chunkZ << 4) | 8)
-                    );
+                            (double) ((chunkX << 4) | 8), (double) ((chunkZ << 4) | 8)
+                        );
 
-                    final int manhattanDistance = Math.abs(dx) + Math.abs(dz);
+                        final int manhattanDistance = Math.abs(dx) + Math.abs(dz);
 
-                    final double priority;
+                        final double priority;
 
-                    if (squareDistance <= GlobalConfiguration.get().chunkLoading.minLoadRadius) {
-                        // priority should be negative, and we also want to order it from center outwards
-                        // so we want (0,0) to be the smallest, and (minLoadedRadius,minLoadedRadius) to be the greatest
-                        priority = -((2 * GlobalConfiguration.get().chunkLoading.minLoadRadius + 1) - manhattanDistance);
-                    } else {
-                        if (prioritised) {
-                            // we don't prioritise these chunks above others because we also want to make sure some chunks
-                            // will be loaded if the player changes direction
-                            priority = (double)manhattanDistance / 6.0;
+                        if (squareDistance <= GlobalConfiguration.get().chunkLoading.minLoadRadius) {
+                            // priority should be negative, and we also want to order it from center outwards
+                            // so we want (0,0) to be the smallest, and (minLoadedRadius,minLoadedRadius) to be the greatest
+                            priority = -((2 * GlobalConfiguration.get().chunkLoading.minLoadRadius + 1) - manhattanDistance);
                         } else {
-                            priority = (double)manhattanDistance;
+                            if (prioritised) {
+                                // we don't prioritise these chunks above others because we also want to make sure some chunks
+                                // will be loaded if the player changes direction
+                                priority = (double) manhattanDistance / 6.0;
+                            } else {
+                                priority = (double) manhattanDistance;
+                            }
                         }
-                    }
 
-                    final ChunkPriorityHolder holder = new ChunkPriorityHolder(chunkX, chunkZ, manhattanDistance, priority);
+                        final ChunkPriorityHolder holder = new ChunkPriorityHolder(chunkX, chunkZ, manhattanDistance, priority);
 
-                    if (!this.loader.isChunkPlayerLoaded(chunkX, chunkZ)) {
-                        if (loadChunk) {
-                            loadQueue.add(holder);
+                        if (!this.loader.isChunkPlayerLoaded(chunkX, chunkZ)) {
+                            if (loadChunk) {
+                                loadQueue.add(holder);
+                                if (sendChunk) {
+                                    this.getChunksToBeSent(concernsTracking).add(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+                                }
+                            }
+                        } else {
+                            // loaded but not sent: so queue it!
                             if (sendChunk) {
-                                this.chunksToBeSent.add(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+                                this.getSendQueue(concernsTracking).add(holder);
                             }
                         }
-                    } else {
-                        // loaded but not sent: so queue it!
-                        if (sendChunk) {
-                            this.sendQueue.add(holder);
-                        }
                     }
                 }
             }
 
+            // Martijn end - per-player track and see view distance
+
             loadQueue.sort((final ChunkPriorityHolder p1, final ChunkPriorityHolder p2) -> {
                 return Double.compare(p1.priority, p2.priority);
             });
@@ -1123,6 +1228,9 @@ public final class PlayerChunkLoader {
             if (needsChunkCenterUpdate) {
                 this.player.connection.send(new ClientboundSetChunkCacheCenterPacket(centerChunkX, centerChunkZ));
             }
+
+            this.player.level.timings.playerChunkLoaderUpdate.stopTiming(); // Martijn - per-player view distance
+
         }
     }
 }
diff --git a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
index f226492ac4bad22b8cd9219ecf7aeb0ac6bdf743..6c561e0683842a9a7951e19324814822b21c1b4e 100644
--- a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
@@ -8,6 +8,7 @@ import net.kyori.adventure.text.Component;
 import net.kyori.adventure.text.format.NamedTextColor;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ServerboundPlaceRecipePacket;
+import net.minecraft.server.level.ServerPlayer;
 import org.bukkit.Bukkit;
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.spongepowered.configurate.objectmapping.ConfigSerializable;
@@ -296,6 +297,79 @@ public class GlobalConfiguration extends ConfigurationPart {
 
     // Martijn end - configurable proportion of skipped active entities
 
+    // Martijn start - per-player track and see view distance
+
+    public ViewDistances viewDistances;
+
+    public class ViewDistances extends ConfigurationPart {
+
+        public TrackAndSee trackAndSee;
+
+        public class TrackAndSee extends ConfigurationPart {
+
+            public IfCanSeeButNotTracking ifCanSeeButNotTracking;
+
+            public class IfCanSeeButNotTracking extends ConfigurationPart {
+                public boolean sendChunkRefresh = true;
+                public boolean sendWitherSpawnSound = true;
+                public boolean sendEnderDragonSpawnSound = true;
+                public boolean sendEndPortalFillSound = true;
+            }
+
+        }
+
+        public Track track;
+
+        public class Track extends ViewDistance {
+
+            @Override
+            protected void onMaxTotalChunksChanged() {
+                ServerPlayer.maxTrackViewDistanceDueToTotalTrackedChunksMayHaveChanged();
+            }
+
+        }
+
+        public See see;
+
+        public class See extends ViewDistance {
+
+            @Override
+            protected void onMaxTotalChunksChanged() {
+                ServerPlayer.maxSeeViewDistanceDueToTotalSeenChunksMayHaveChanged();
+            }
+
+        }
+
+        public abstract class ViewDistance extends ConfigurationPart {
+
+            /**
+             * -1 indicates no limit
+             *
+             * @deprecated Because this variable should not be used:
+             * use getMaxTotalChunks and setMaxTotalChunks instead
+             */
+            @Deprecated
+            public int maxTotalChunks = -1;
+
+            public int getMaxTotalChunks() {
+                return maxTotalChunks;
+            }
+
+            protected abstract void onMaxTotalChunksChanged();
+
+            public void setMaxTotalChunks(int maxTotalChunks) {
+                if (this.maxTotalChunks != maxTotalChunks) {
+                    this.maxTotalChunks = maxTotalChunks;
+                    onMaxTotalChunksChanged();
+                }
+            }
+
+        }
+
+    }
+
+    // Martijn end - per-player track and see view distance
+
     public Messages messages;
 
     public class Messages extends ConfigurationPart {
diff --git a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
index 1ea703fafec3b8b484e88b0e8f6ec4f1063e36fd..1f4798ed801c7953a50535a23427f0521e13a515 100644
--- a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
@@ -24,6 +24,7 @@ import net.minecraft.Util;
 import net.minecraft.core.Holder;
 import net.minecraft.core.Registry;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.Difficulty;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.MobCategory;
@@ -33,6 +34,8 @@ import net.minecraft.world.item.Item;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.level.NaturalSpawner;
 import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.slf4j.Logger;
 import org.spigotmc.SpigotWorldConfig;
 import org.spongepowered.configurate.objectmapping.ConfigSerializable;
@@ -91,6 +94,148 @@ public class WorldConfiguration extends ConfigurationPart {
 
     // Martijn end - difficulty changes
 
+    // Martijn start - per-player view distance
+
+    public ViewDistances viewDistances;
+
+    public class ViewDistances extends ConfigurationPart {
+
+        public Track track;
+
+        public class Track extends UpdateAllPlayersOnChangeViewDistance {
+
+            @Override
+            protected void updatePlayer(ServerPlayer player) {
+                player.trackViewDistanceMayHaveChanged();
+            }
+
+        }
+
+        public See see;
+
+        public class See extends UpdateAllPlayersOnChangeViewDistance {
+
+            @Override
+            protected void updatePlayer(ServerPlayer player) {
+                player.seeViewDistanceMayHaveChanged();
+            }
+
+        }
+
+        public Load load;
+
+        public class Load extends UpdateAllPlayersOnChangeViewDistance {
+
+            @Override
+            protected void updatePlayer(ServerPlayer player) {
+                player.loadViewDistanceMayHaveChanged();
+            }
+
+            /**
+             * @deprecated Because this variable should not be used:
+             * use getLimitBySeeViewDistance and setLimitBySeeViewDistance instead
+             */
+            @Deprecated
+            public boolean limitBySeeViewDistance = false;
+
+            public boolean getLimitBySeeViewDistance() {
+                return limitBySeeViewDistance;
+            }
+
+            public void setLimitBySeeViewDistance(boolean limitBySeeViewDistance) {
+                this.limitBySeeViewDistance = limitBySeeViewDistance;
+                updateAllPlayers();
+            }
+
+            /**
+             * In ticks
+             * A nonpositive integer disables this feature
+             */
+            public int printLoadedChunksInterval = -1;
+
+        }
+
+        public abstract class UpdateAllPlayersOnChangeViewDistance extends ViewDistance {
+
+            protected abstract void updatePlayer(ServerPlayer player);
+
+            protected void updateAllPlayers() {
+                Bukkit.getOnlinePlayers().forEach(player -> updatePlayer(((CraftPlayer) player).getHandle()));
+            }
+
+            @Override
+            protected void onMaxChanged() {
+                updateAllPlayers();
+            }
+
+            @Override
+            protected void onLimitByClientViewDistanceChanged() {
+                updateAllPlayers();
+            }
+
+        }
+
+        public abstract class ViewDistance extends ConfigurationPart {
+
+            /**
+             * @deprecated Because this variable should not be used:
+             * use getPerPlayer instead
+             */
+            @Deprecated
+            public boolean perPlayer = false;
+
+            public boolean getPerPlayer() {
+                return perPlayer;
+            }
+
+            /**
+             * This is only used if perPlayer is true
+             * -1 indicates no limit (it is still limited by the Bukkit world view distance)
+             * Valid values are -1,
+             * or an integer in the range [2, 32] for the track and see view distances and in the range [3, 33] for the
+             * load view distance
+             *
+             * @deprecated Because this variable should not be used:
+             * use getMax and setMax instead
+             */
+            @Deprecated
+            public int max = -1;
+
+            public int getMax() {
+                return max;
+            }
+
+            protected abstract void onMaxChanged();
+
+            public void setMax(int max) {
+                this.max = max;
+                onMaxChanged();
+            }
+
+            /**
+             * @deprecated Because this variable should not be used:
+             * use getLimitByClientViewDistance and setLimitByClientViewDistance instead
+             */
+            @Deprecated
+            public boolean limitByClientViewDistance = false;
+
+            public boolean getLimitByClientViewDistance() {
+                return limitByClientViewDistance;
+            }
+
+            protected abstract void onLimitByClientViewDistanceChanged();
+
+            public void setLimitByClientViewDistance(boolean limitByClientViewDistance) {
+                this.limitByClientViewDistance = limitByClientViewDistance;
+                onLimitByClientViewDistanceChanged();
+            }
+
+        }
+
+    }
+
+    // Martijn end - per-player view distance
+
     public AntiCheat anticheat;
 
     public class AntiCheat extends ConfigurationPart {
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index c0fdc5a79107f8694a514a12d5526bd431fc45e9..4ddcd826a131c397e166e0e1f308e96c5ec62d13 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -647,7 +647,12 @@ public final class MCUtil {
             });
 
             worldData.addProperty("name", world.getWorld().getName());
-            worldData.addProperty("view-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetNoTickViewDistance()); // Paper - replace chunk loader system
+            // Martijn start - per-player view distance
+            worldData.addProperty("view-distance", world.getChunkSource().chunkMap.getVanillaWorldViewDistance()); // Paper - replace chunk loader system
+            worldData.addProperty("max-track-view-distance", world.paperConfig().viewDistances.track.getMax());
+            worldData.addProperty("max-see-view-distance", world.paperConfig().viewDistances.see.getMax());
+            worldData.addProperty("max-load-view-distance", world.paperConfig().viewDistances.load.getMax());
+            // Martijn end - per-player view distance
             worldData.addProperty("tick-view-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance()); // Paper - replace chunk loader system
             worldData.addProperty("keep-spawn-loaded", world.keepSpawnInMemory);
             worldData.addProperty("keep-spawn-loaded-range", world.paperConfig().spawn.keepSpawnLoadedRange * 16);
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index 11cd31691307749e925930c4b6e10e3f3b4fad25..90568bc8ab14f7b141bb3d95d4e0bf8ca1f6884c 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -409,7 +409,7 @@ public class ChunkHolder {
         // Paper start - per player view distance
         // there can be potential desync with player's last mapped section and the view distance map, so use the
         // view distance map here.
-        com.destroystokyo.paper.util.misc.PlayerAreaMap viewDistanceMap = this.chunkMap.playerChunkManager.broadcastMap; // Paper - replace old player chunk manager
+        com.destroystokyo.paper.util.misc.PlayerAreaMap viewDistanceMap = this.chunkMap.playerChunkManager.broadcastMapForTracking; // Paper - replace old player chunk manager // Martijn - per-player track and see view distance
         com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> players = viewDistanceMap.getObjectsInRange(this.pos);
         if (players == null) {
             return;
@@ -422,7 +422,7 @@ public class ChunkHolder {
                 continue;
             }
             ServerPlayer player = (ServerPlayer)temp;
-            if (!this.chunkMap.playerChunkManager.isChunkSent(player, this.pos.x, this.pos.z, onlyOnWatchDistanceEdge)) {
+            if (!this.chunkMap.playerChunkManager.isChunkSent(player, this.pos.x, this.pos.z, onlyOnWatchDistanceEdge, true)) { // Martijn - per-player track and see view distance
                 continue;
             }
             player.connection.send(packet);
@@ -853,7 +853,8 @@ public class ChunkHolder {
 
     public interface PlayerProvider {
 
-        List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge);
+        List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge, boolean concernsTracking); // Martijn - per-player track and see view distance
+
     }
 
     private static final class ChunkSaveDebug {
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 83d761353c97f854a8458ff2dd7aceca08407692..94a96e5f85334b46261e2960ca2fec6c8c4bdd43 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -4,10 +4,7 @@ import co.aikar.timings.Timing; // Paper
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableList.Builder;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.ComparisonChain; // Paper
 import com.google.common.collect.Lists;
-import com.google.common.collect.Queues;
-import com.google.common.collect.Sets;
 import com.google.gson.JsonElement;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Either;
@@ -34,11 +31,8 @@ import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.Comparator;
-import java.util.HashMap; // Paper
-import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map; // Paper
 import java.util.Objects;
 import java.util.Optional;
 import java.util.Queue;
@@ -70,7 +64,6 @@ import net.minecraft.core.SectionPos;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
-import net.minecraft.network.protocol.game.ClientboundSetChunkCacheCenterPacket;
 import net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket;
 import net.minecraft.network.protocol.game.ClientboundSetPassengersPacket;
 import net.minecraft.network.protocol.game.DebugPackets;
@@ -111,7 +104,6 @@ import net.minecraft.world.level.levelgen.structure.StructureStart;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
 import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelStorageSource;
-import net.minecraft.world.phys.Vec3;
 import it.unimi.dsi.fastutil.objects.ObjectRBTreeSet; // Paper
 import org.apache.commons.lang3.mutable.MutableBoolean;
 import org.apache.commons.lang3.mutable.MutableObject;
@@ -170,7 +162,10 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     private final Long2ByteMap chunkTypeCache;
     private final Long2LongMap chunkSaveCooldowns;
     private final Queue<Runnable> unloadQueue;
-    int viewDistance;
+    // Martijn start- per-player view distance
+    // This value is the intended world send view distance + 1
+    private int vanillaWorldViewDistancePlusOne;
+    // Martijn end - per-player view distance
     public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerMobDistanceMap; // Paper
     public final ReferenceOpenHashSet<ChunkHolder> needsChangeBroadcasting = new ReferenceOpenHashSet<>();
 
@@ -255,7 +250,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
             int trackRange = this.entityTrackerTrackRanges[i];
 
-            trackMap.add(player, chunkX, chunkZ, Math.min(trackRange, io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player))); // Paper - per player view distances
+            trackMap.add(player, chunkX, chunkZ, Math.min(trackRange, player.getTrackViewDistance())); // Paper - per player view distances // Martijn - per-player track view distance
         }
         // Paper end - use distance map to optimise entity tracker
         // Note: players need to be explicitly added to distance maps before they can be updated
@@ -297,7 +292,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
             int trackRange = this.entityTrackerTrackRanges[i];
 
-            trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player))); // Paper - per player view distances
+            trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, player.getTrackViewDistance())); // Paper - per player view distances // Martijn - per-player track view distance
         }
         // Paper end - use distance map to optimise entity tracker
         this.playerChunkTickRangeMap.update(player, chunkX, chunkZ, DistanceManager.MOB_SPAWN_RANGE); // Paper - optimise ChunkMap#anyPlayerCloseEnoughForSpawning
@@ -474,7 +469,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // Martijn end - sort chunks by distance
 
     boolean unloadingPlayerChunk = false; // Paper - do not allow ticket level changes while unloading chunks
-    public ChunkMap(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureTemplateManager structureTemplateManager, Executor executor, BlockableEventLoop<Runnable> mainThreadExecutor, LightChunkGetter chunkProvider, ChunkGenerator chunkGenerator, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory, int viewDistance, boolean dsync) {
+    public ChunkMap(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureTemplateManager structureTemplateManager, Executor executor, BlockableEventLoop<Runnable> mainThreadExecutor, LightChunkGetter chunkProvider, ChunkGenerator chunkGenerator, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory, int vanillaWorldViewDistance, boolean dsync) { // Martijn - per-player view distance
         super(session.getDimensionPath(world.dimension()).resolve("region"), dataFixer, dsync);
         // Paper - don't copy
         this.pendingUnloads = new Long2ObjectLinkedOpenHashMap();
@@ -532,7 +527,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         this.distanceManager = new ChunkMap.ChunkDistanceManager(executor, mainThreadExecutor);
         this.overworldDataStorage = persistentStateManagerFactory;
         this.poiManager = new PoiManager(path.resolve("poi"), dataFixer, dsync, world.registryAccess(), world);
-        this.setViewDistance(viewDistance);
+        this.setVanillaWorldViewDistance(vanillaWorldViewDistance); // Martijn - per-player view distance
         // Paper start
         this.dataRegionManager = new io.papermc.paper.chunk.SingleThreadChunkRegionManager(this.level, 2, (1.0 / 3.0), 1, 6, "Data", DataRegionData::new, DataRegionSectionData::new);
         this.regionManagers.add(this.dataRegionManager);
@@ -780,13 +775,15 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
     }
 
+    // Martijn start - per-player view distance
     // Paper start
-    public final int getEffectiveViewDistance() {
+    public final int getVanillaWorldViewDistance() {
         // TODO this needs to be checked on update
         // Mojang currently sets it to +1 of the configured view distance. So subtract one to get the one we really want.
-        return this.viewDistance - 1;
+        return this.vanillaWorldViewDistancePlusOne - 1;
     }
     // Paper end
+    // Martijn end - per-player view distance
 
     private CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> getChunkRangeFuture(ChunkPos centerChunk, int margin, IntFunction<ChunkStatus> distanceToStatus) {
         List<CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> list = new ArrayList();
@@ -1681,17 +1678,20 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
     }
 
-    public void setViewDistance(int watchDistance) {
-        int j = Mth.clamp(watchDistance + 1, (int) 3, (int) 33);
+    // Martijn start - per-player view distance
+    public void setVanillaWorldViewDistance(int vanillaWorldViewDistance) {
+        int newVanillaWorldViewDistancePlusOne = Mth.clamp(vanillaWorldViewDistance + 1, (int) 3, (int) 33);
 
-        if (j != this.viewDistance) {
-            int k = this.viewDistance;
+        if (newVanillaWorldViewDistancePlusOne != this.vanillaWorldViewDistancePlusOne) {
+            int k = this.vanillaWorldViewDistancePlusOne;
 
-            this.viewDistance = j;
-            this.playerChunkManager.setLoadDistance(this.viewDistance); // Paper - replace player loader system
+            this.vanillaWorldViewDistancePlusOne = newVanillaWorldViewDistancePlusOne;
+            // No longer needed since PlayerChunkLoader.update() will pull the most current load view distance when it executes
+//            this.playerChunkManager.setLoadDistance(Mth.clamp(this.vanillaWorldViewDistancePlusOne, 2, 32)); // Paper - replace player loader system
         }
 
     }
+    // Martijn end - per-player view distance
 
     // Paper start - replace player loader system
     public void setTickViewDistance(int distance) {
@@ -1699,7 +1699,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
     // Paper end - replace player loader system
 
-    public void updateChunkTracking(ServerPlayer player, ChunkPos pos, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> packet, boolean oldWithinViewDistance, boolean newWithinViewDistance) { // Paper - Anti-Xray - Bypass // Paper - public
+    public void updateChunkTracking(ServerPlayer player, ChunkPos pos, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> packet, boolean oldWithinViewDistance, boolean newWithinViewDistance, boolean concernsTracking) { // Paper - Anti-Xray - Bypass // Paper - public // Martijn - per-player track and see view distance
         if (player.level == this.level) {
             if (newWithinViewDistance && !oldWithinViewDistance) {
                 ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos.toLong());
@@ -1708,7 +1708,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                     LevelChunk chunk = playerchunk.getSendingChunk(); // Paper - replace chunk loader system
 
                     if (chunk != null) {
-                        this.playerLoadedChunk(player, packet, chunk);
+                        this.playerLoadedChunk(player, packet, chunk, concernsTracking); // Martijn - per-player track and see view distance
                     }
 
                     DebugPackets.sendPoiPacketsForChunk(this.level, pos);
@@ -1716,7 +1716,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
 
             if (!newWithinViewDistance && oldWithinViewDistance) {
-                player.untrackChunk(pos);
+                player.untrackChunk(pos, concernsTracking); // Martijn - per-player track and see view distance
             }
 
         }
@@ -2001,6 +2001,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public void move(ServerPlayer player) {
         // Paper - delay this logic for the entity tracker tick, no need to duplicate it
 
+        this.level.timings.chunkMapPlayerMove.startTiming(); // Martijn - per-player view distance
+
         int i = SectionPos.blockToSectionCoord(player.getBlockX());
         int j = SectionPos.blockToSectionCoord(player.getBlockZ());
         SectionPos sectionposition = player.getLastSectionPos();
@@ -2013,6 +2015,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
         if (flag2 || flag != flag1) {
             this.updatePlayerPos(player);
+
             if (!flag) {
                 this.distanceManager.removePlayer(sectionposition, player);
             }
@@ -2044,16 +2047,18 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         this.updateMaps(player); // Paper - distance maps
         this.playerChunkManager.updatePlayer(player); // Paper - respond to movement immediately
 
+        this.level.timings.chunkMapPlayerMove.stopTiming(); // Martijn - per-player view distance
+
     }
 
     @Override
-    public List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge) {
+    public List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge, boolean concernsTracking) { // Martijn - per-player track and see view distance
         // Paper start - per player view distance
         // there can be potential desync with player's last mapped section and the view distance map, so use the
         // view distance map here.
         List<ServerPlayer> ret = new java.util.ArrayList<>(4);
 
-        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> players = this.playerChunkManager.broadcastMap.getObjectsInRange(chunkPos);
+        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> players = this.playerChunkManager.getBroadcastMap(concernsTracking).getObjectsInRange(chunkPos); // Martijn - per-player track and see view distance
         if (players == null) {
             return ret;
         }
@@ -2170,6 +2175,13 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // Paper end - optimised tracker
 
     protected void tick() {
+
+        // Martijn start - temporary debug message containing the number of loaded chunks
+        if (this.level.paperConfig().viewDistances.load.printLoadedChunksInterval > 0 && Math.random() < 1.0 / this.level.paperConfig().viewDistances.load.printLoadedChunksInterval) {
+            org.bukkit.Bukkit.getLogger().info("Number of loaded chunks in " + this.level.getWorld().getName() + ": " + this.level.getWorld().getLoadedChunks().length);
+        }
+        // Martijn end - temporary debug message containing the number of loaded chunks
+
         // Paper start - optimized tracker
         if (true) {
             this.processTrackQueue();
@@ -2238,7 +2250,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     // Paper start - Anti-Xray - Bypass
-    private void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk) {
+    private void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk, boolean concernsTracking) { // Martijn - per-player track and see view distance
         if (cachedDataPackets.getValue() == null) {
             cachedDataPackets.setValue(new java.util.HashMap<>());
         }
@@ -2246,58 +2258,66 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
         player.trackChunk(chunk.getPos(), cachedDataPackets.getValue().computeIfAbsent(shouldModify, (s) -> {
             return new ClientboundLevelChunkWithLightPacket(chunk, this.lightEngine, (BitSet) null, (BitSet) null, true, (Boolean) s);
-        }));
+        }), concernsTracking);
         // Paper end
         DebugPackets.sendPoiPacketsForChunk(this.level, chunk.getPos());
-        List<Entity> list = Lists.newArrayList();
-        List<Entity> list1 = Lists.newArrayList();
-        // Paper start - optimise entity tracker
-        // use the chunk entity list, not the whole trackedEntities map...
-        Entity[] entities = chunk.entities.getRawData();
-        for (int i = 0, size = chunk.entities.size(); i < size; ++i) {
-            Entity entity = entities[i];
-            if (entity == player) {
-                continue;
-            }
-            ChunkMap.TrackedEntity tracker = this.entityMap.get(entity.getId());
-            if (tracker != null) { // dumb plugins... move on...
-                tracker.updatePlayer(player);
-            }
 
-            // keep the vanilla logic here - this is REQUIRED or else passengers and their vehicles disappear!
-            // (and god knows what the leash thing is)
+        // Martijn start - per-player track and see view distance
+        if (concernsTracking) {
+
+            List<Entity> list = Lists.newArrayList();
+            List<Entity> list1 = Lists.newArrayList();
+            // Paper start - optimise entity tracker
+            // use the chunk entity list, not the whole trackedEntities map...
+            Entity[] entities = chunk.entities.getRawData();
+            for (int i = 0, size = chunk.entities.size(); i < size; ++i) {
+                Entity entity = entities[i];
+                if (entity == player) {
+                    continue;
+                }
+                ChunkMap.TrackedEntity tracker = this.entityMap.get(entity.getId());
+                if (tracker != null) { // dumb plugins... move on...
+                    tracker.updatePlayer(player);
+                }
+
+                // keep the vanilla logic here - this is REQUIRED or else passengers and their vehicles disappear!
+                // (and god knows what the leash thing is)
 
-            if (entity instanceof Mob && ((Mob)entity).getLeashHolder() != null) {
-                list.add(entity);
-            }
+                if (entity instanceof Mob && ((Mob) entity).getLeashHolder() != null) {
+                    list.add(entity);
+                }
 
-            if (!entity.getPassengers().isEmpty()) {
-                list1.add(entity);
+                if (!entity.getPassengers().isEmpty()) {
+                    list1.add(entity);
+                }
             }
-        }
-        // Paper end - optimise entity tracker
+            // Paper end - optimise entity tracker
 
-        Iterator iterator;
-        Entity entity1;
+            Iterator iterator;
+            Entity entity1;
 
-        if (!list.isEmpty()) {
-            iterator = list.iterator();
+            if (!list.isEmpty()) {
+                iterator = list.iterator();
 
-            while (iterator.hasNext()) {
-                entity1 = (Entity) iterator.next();
-                player.connection.send(new ClientboundSetEntityLinkPacket(entity1, ((Mob) entity1).getLeashHolder()));
+                while (iterator.hasNext()) {
+                    entity1 = (Entity) iterator.next();
+                    player.connection.send(new ClientboundSetEntityLinkPacket(entity1, ((Mob) entity1).getLeashHolder()));
+                }
             }
-        }
 
-        if (!list1.isEmpty()) {
-            iterator = list1.iterator();
+            if (!list1.isEmpty()) {
+                iterator = list1.iterator();
 
-            while (iterator.hasNext()) {
-                entity1 = (Entity) iterator.next();
-                player.connection.send(new ClientboundSetPassengersPacket(entity1));
+                while (iterator.hasNext()) {
+                    entity1 = (Entity) iterator.next();
+                    player.connection.send(new ClientboundSetPassengersPacket(entity1));
+                }
             }
+
         }
 
+        // Martijn end - per-player track and see view distance
+
     }
 
     public PoiManager getPoiManager() {
@@ -2441,7 +2461,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 double vec3d_dx = player.getX() - this.entity.getX();
                 double vec3d_dz = player.getZ() - this.entity.getZ();
                 // Paper end - remove allocation of Vec3D here
-                double d0 = (double) Math.min(this.getEffectiveRange(), io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player) * 16); // Paper - per player view distance
+                double d0 = (double) Math.min(this.getEffectiveRange(), player.getTrackViewDistance() * 16); // Paper - per player view distance // Martijn - per-player track view distance
                 double d1 = vec3d_dx * vec3d_dx + vec3d_dz * vec3d_dz; // Paper
                 double d2 = d0 * d0;
                 boolean flag = d1 <= d2 && this.entity.broadcastToPlayer(player);
diff --git a/src/main/java/net/minecraft/server/level/DistanceManager.java b/src/main/java/net/minecraft/server/level/DistanceManager.java
index d1b5c25b7455174e908cd6ed66789fa700190604..7922ced4e86d49df02169ac820fc5cbde974a18b 100644
--- a/src/main/java/net/minecraft/server/level/DistanceManager.java
+++ b/src/main/java/net/minecraft/server/level/DistanceManager.java
@@ -548,9 +548,12 @@ public abstract class DistanceManager {
         return arraysetsorted != null && !arraysetsorted.isEmpty() ? ((Ticket) arraysetsorted.first()).toString() : "no_ticket";
     }
 
-    protected void updatePlayerTickets(int viewDistance) {
-        this.chunkMap.playerChunkManager.setTargetNoTickViewDistance(viewDistance); // Paper - route to player chunk manager
-    }
+    // Martijn start - per-player load view distance
+    // No longer needed since PlayerChunkLoader.update() will pull the most current load view distance when it executes
+//    protected void updatePlayerTickets(int viewDistance) {
+//        this.chunkMap.playerChunkManager.setTargetNoTickViewDistance(viewDistance); // Paper - route to player chunk manager
+//    }
+    // Martijn end - per-player load view distance
 
     public void updateSimulationDistance(int simulationDistance) {
         this.chunkMap.playerChunkManager.setTargetTickViewDistance(simulationDistance); // Paper - route to player chunk manager
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 378cc1f9e19eb9b18037ab8af92f65897e15a405..0eaa714ba9d6c7829d0f9ac3b6ccd59ed9a9baa2 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -938,7 +938,7 @@ public class ServerChunkCache extends ChunkSource {
                     continue;
                 }
 
-                int viewDistance = this.chunkMap.getEffectiveViewDistance();
+                int viewDistance = this.chunkMap.getVanillaWorldViewDistance(); // Martijn - per-player view distance
 
                 // copied and modified from isOutisdeRange
                 int chunkRange = level.spigotConfig.mobSpawnRange;
@@ -1211,9 +1211,11 @@ public class ServerChunkCache extends ChunkSource {
         this.chunkMap.broadcast(entity, packet);
     }
 
-    public void setViewDistance(int watchDistance) {
-        this.chunkMap.setViewDistance(watchDistance);
+    // Martijn start - per-player view distance
+    public void setVanillaWorldViewDistance(int vanillaWorldViewDistance) {
+        this.chunkMap.setVanillaWorldViewDistance(vanillaWorldViewDistance);
     }
+    // Martijn end - per-player view distance
 
     public void setSimulationDistance(int simulationDistance) {
         this.distanceManager.updateSimulationDistance(simulationDistance);
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index c316e84615858942f6d71eb972950a766d95c2d4..ecc7eb09e8f3791e31efa5082f6e61d2da099eef 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -1,6 +1,5 @@
 package net.minecraft.server.level;
 
-import com.destroystokyo.paper.PaperConfig;
 import com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent;
 import com.google.common.collect.Lists;
 import com.mojang.authlib.GameProfile;
@@ -8,8 +7,6 @@ import com.mojang.datafixers.util.Either;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.DataResult;
 
-import java.util.ArrayDeque;
-import java.util.BitSet;
 import java.util.Collection;
 import java.util.Comparator;
 import java.util.Iterator;
@@ -17,17 +14,14 @@ import java.util.List;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.OptionalInt;
-import java.util.Random;
 import java.util.UUID;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 
+import io.papermc.paper.chunk.PlayerChunkLoader;
+import io.papermc.paper.configuration.GlobalConfiguration;
 import it.unimi.dsi.fastutil.Pair;
 import it.unimi.dsi.fastutil.ints.IntIntPair;
-import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import it.unimi.dsi.fastutil.longs.LongSet;
-import it.unimi.dsi.fastutil.objects.Object2ObjectMap;
-import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectObjectImmutablePair;
 import net.minecraft.BlockUtil;
 import net.minecraft.ChatFormatting;
@@ -67,8 +61,6 @@ import net.minecraft.network.protocol.game.ClientboundEntityEventPacket;
 import net.minecraft.network.protocol.game.ClientboundForgetLevelChunkPacket;
 import net.minecraft.network.protocol.game.ClientboundGameEventPacket;
 import net.minecraft.network.protocol.game.ClientboundHorseScreenOpenPacket;
-import net.minecraft.network.protocol.game.ClientboundKeepAlivePacket;
-import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
 import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
 import net.minecraft.network.protocol.game.ClientboundMerchantOffersPacket;
 import net.minecraft.network.protocol.game.ClientboundOpenBookPacket;
@@ -85,14 +77,11 @@ import net.minecraft.network.protocol.game.ClientboundResourcePackPacket;
 import net.minecraft.network.protocol.game.ClientboundRespawnPacket;
 import net.minecraft.network.protocol.game.ClientboundServerDataPacket;
 import net.minecraft.network.protocol.game.ClientboundSetCameraPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket;
 import net.minecraft.network.protocol.game.ClientboundSetExperiencePacket;
 import net.minecraft.network.protocol.game.ClientboundSetHealthPacket;
-import net.minecraft.network.protocol.game.ClientboundSetPassengersPacket;
 import net.minecraft.network.protocol.game.ClientboundSoundPacket;
 import net.minecraft.network.protocol.game.ClientboundSystemChatPacket;
 import net.minecraft.network.protocol.game.ClientboundUpdateMobEffectPacket;
-import net.minecraft.network.protocol.game.DebugPackets;
 import net.minecraft.network.protocol.game.ServerboundClientInformationPacket;
 import net.minecraft.network.protocol.status.ServerStatus;
 import net.minecraft.resources.ResourceKey;
@@ -159,7 +148,6 @@ import net.minecraft.world.level.block.entity.CommandBlockEntity;
 import net.minecraft.world.level.block.entity.SignBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.border.WorldBorder;
-import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.dimension.LevelStem;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.portal.PortalInfo;
@@ -194,11 +182,280 @@ import org.bukkit.event.player.PlayerPortalEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 import org.bukkit.inventory.MainHand;
+import org.jetbrains.annotations.NotNull;
 // CraftBukkit end
 
 public class ServerPlayer extends Player {
 
     private static final Logger LOGGER = LogUtils.getLogger();
+
+    // Martijn start - per-player view distance
+
+    private static int[] maxViewDistanceDueToTotalViewedChunks = {32, 32};
+
+    /**
+     * Does not change any state
+     * Is called only from ServerPlayer.maxViewDistanceDueToTotalViewedChunksMayHaveChanged(type)
+     */
+    private static int computeMaxViewDistanceDueToTotalViewedChunks(int type) {
+        int maxTotalChunks = ((type == 0) ? GlobalConfiguration.get().viewDistances.track : GlobalConfiguration.get().viewDistances.see).getMaxTotalChunks();
+        if (maxTotalChunks == -1) return -1;
+        int candidateViewDistance = maxViewDistanceDueToTotalViewedChunks[type];
+        int[] playerViewDistances = new int[MinecraftServer.getServer().getPlayerCount()];
+        int playerI = 0;
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().players) {
+            playerViewDistances[playerI] = player.getViewDistance(type);
+            playerI++;
+        }
+        for (boolean increase : new boolean[] {false, true}) {
+            int chunks = 0;
+            for (int playerViewDistance : playerViewDistances) {
+                // We assume the worst: that if the player's view distance is equal to the current limit, that it will definitely grow to the new limit
+                int playerViewDistanceUnderCandidateAssumption = playerViewDistance >= ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type] ? candidateViewDistance : Math.min(candidateViewDistance, playerViewDistance);
+                int playerViewDimensionUnderCandidateAssumption = playerViewDistanceUnderCandidateAssumption * 2 + 1;
+                chunks += playerViewDimensionUnderCandidateAssumption * playerViewDimensionUnderCandidateAssumption;
+            }
+            if (candidateViewDistance > 2 && (chunks > maxTotalChunks || candidateViewDistance > 32)) {
+                candidateViewDistance--;
+                if (increase) {
+                    continue;
+                }
+            } else {
+                candidateViewDistance++;
+                if (!increase) {
+                    continue;
+                }
+            }
+        }
+        return candidateViewDistance;
+    }
+
+    /**
+     * Is called only from ServerPlayer.maxViewDistanceDueToTotalViewedChunksMayHaveChanged(type)
+     */
+    private static void processMaxViewDistanceDueToTotalViewedChunksChange(int oldMaxViewDistanceDueToTotalViewedChunks, int type) {
+        if (oldMaxViewDistanceDueToTotalViewedChunks == ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type]) return;
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().players) {
+            player.viewDistanceMayHaveChanged(type);
+        }
+    }
+
+    public static void maxTrackViewDistanceDueToTotalTrackedChunksMayHaveChanged() {
+        ServerPlayer.maxViewDistanceDueToTotalViewedChunksMayHaveChanged(0);
+    }
+
+    public static void maxSeeViewDistanceDueToTotalSeenChunksMayHaveChanged() {
+        ServerPlayer.maxViewDistanceDueToTotalViewedChunksMayHaveChanged(1);
+    }
+
+    /**
+     * Is called only from ServerPlayer.processViewDistanceChange(type)
+     */
+    private static void maxViewDistanceDueToTotalViewedChunksMayHaveChanged(int type) {
+        int oldMaxViewDistanceDueToTotalViewedChunks = ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type];
+        ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type] = ServerPlayer.computeMaxViewDistanceDueToTotalViewedChunks(type);
+        ServerPlayer.processMaxViewDistanceDueToTotalViewedChunksChange(oldMaxViewDistanceDueToTotalViewedChunks, type);
+    }
+
+    private final int getWorldSeeViewDistance() { return this.getLevel().getChunkSource().chunkMap.getVanillaWorldViewDistance() - 1; } // Paper - placeholder
+
+    private final int getWorldTrackViewDistance() {
+        return this.getWorldSeeViewDistance();
+    }
+
+    private final int getWorldLoadViewDistance() {
+        return this.getWorldSeeViewDistance() + 1;
+    }
+
+    private final int getWorldViewDistance(int type) {
+        switch (type) {
+            case 0: return this.getWorldTrackViewDistance();
+            case 1: return this.getWorldSeeViewDistance();
+            case 2: return this.getWorldLoadViewDistance();
+        }
+        throw new IllegalArgumentException();
+    }
+
+    private @Nullable Integer @NotNull [] viewDistances = {null, null, null};
+
+    public final int getTrackViewDistance() {
+        return this.getViewDistance(0);
+    }
+
+    public final int getSeeViewDistance() {
+        return this.getViewDistance(1);
+    }
+
+    public final int getLoadViewDistance() {
+        return this.getViewDistance(2);
+    }
+    
+    public final int getTickingViewDistance() {
+        int loadViewDistanceMinusOne = this.getLoadViewDistance() - 1;
+        ServerLevel level = this.getLevel();
+        if (level != null) {
+            PlayerChunkLoader playerChunkLoader = level.getChunkSource().chunkMap.playerChunkManager;
+            PlayerChunkLoader.PlayerLoaderData data = playerChunkLoader.getData(this);
+            if (data != null && data.tickViewDistance != -1) {
+                return Math.min(loadViewDistanceMinusOne, data.tickViewDistance);
+            }
+            return Math.min(loadViewDistanceMinusOne, playerChunkLoader.getTickDistance());
+        }
+        return loadViewDistanceMinusOne;
+    }
+
+    private final int getViewDistance(int type) {
+        if (this.viewDistances[type] == null) {
+            this.viewDistanceMayHaveChanged(type);
+        }
+        return this.viewDistances[type];
+    }
+
+    public final void trackViewDistanceMayHaveChanged() {
+        this.viewDistanceMayHaveChanged(0);
+    }
+
+    public final void seeViewDistanceMayHaveChanged() {
+        this.viewDistanceMayHaveChanged(1);
+    }
+
+    public final void loadViewDistanceMayHaveChanged() {
+        this.viewDistanceMayHaveChanged(2);
+    }
+
+    /**
+     * Does not change any state
+     * Is called only from ServerPlayer.viewDistanceMayHaveChanged(type)
+     */
+    private final int computeViewDistance(int type) {
+        switch (type) {
+            case 0: {
+                this.level.timings.computeTrackViewDistance.startTiming();
+
+                // Limit by world view distance
+                int trackViewDistance = this.getWorldTrackViewDistance();
+                // Limit by see view distance
+                trackViewDistance = Math.min(trackViewDistance, this.getSeeViewDistance());
+                if (this.getLevel().paperConfig().viewDistances.track.getPerPlayer()) {
+                    // Limit by world max track view distance
+                    int levelMaxTrackViewDistance = this.getLevel().paperConfig().viewDistances.track.getMax();
+                    if (levelMaxTrackViewDistance != -1) {
+                        trackViewDistance = Math.min(trackViewDistance, levelMaxTrackViewDistance);
+                    }
+                    // Limit by client view distance
+                    if (this.getLevel().paperConfig().viewDistances.track.getLimitByClientViewDistance()) {
+                        if (this.clientViewDistance != null && this.clientViewDistance >= 1) {
+                            trackViewDistance = Math.min(trackViewDistance, this.clientViewDistance + 1);
+                        }
+                    }
+                }
+                // Limit by max total tracked chunks
+                if (ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type] != -1) {
+                    trackViewDistance = Math.min(trackViewDistance, ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type]);
+                }
+                // Clamp to possible values
+                trackViewDistance = Mth.clamp(trackViewDistance, 2, 32);
+
+                this.level.timings.computeTrackViewDistance.stopTiming();
+
+                return trackViewDistance;
+            }
+            case 1: {
+                this.level.timings.computeSeeViewDistance.startTiming();
+
+                // Limit by world view distance
+                int seeViewDistance = this.getWorldSeeViewDistance();
+                if (this.getLevel().paperConfig().viewDistances.see.getPerPlayer()) {
+                    // Limit by world max see view distance
+                    int levelMaxSeeViewDistance = this.getLevel().paperConfig().viewDistances.see.getMax();
+                    if (levelMaxSeeViewDistance != -1) {
+                        seeViewDistance = Math.min(seeViewDistance, levelMaxSeeViewDistance);
+                    }
+                    // Limit by client view distance
+                    if (this.getLevel().paperConfig().viewDistances.see.getLimitByClientViewDistance()) {
+                        if (this.clientViewDistance != null && this.clientViewDistance >= 1) {
+                            seeViewDistance = Math.min(seeViewDistance, this.clientViewDistance + 1);
+                        }
+                    }
+                }
+                // Limit by max total seen chunks
+                if (ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type] != -1) {
+                    seeViewDistance = Math.min(seeViewDistance, ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type]);
+                }
+                // Clamp to possible values
+                seeViewDistance = Mth.clamp(seeViewDistance, 2, 32);
+
+                this.level.timings.computeSeeViewDistance.stopTiming();
+
+                return seeViewDistance;
+            }
+            case 2: {
+                this.level.timings.computeLoadViewDistance.startTiming();
+
+                // Limit by world view distance
+                int loadViewDistance = this.getWorldLoadViewDistance();
+                if (this.getLevel().paperConfig().viewDistances.load.getPerPlayer()) {
+                    // Limit by world max load view distance
+                    int levelMaxLoadViewDistance = this.getLevel().paperConfig().viewDistances.load.getMax();
+                    if (levelMaxLoadViewDistance != -1) {
+                        loadViewDistance = Math.min(loadViewDistance, levelMaxLoadViewDistance);
+                    }
+                    // Limit by see view distance
+                    if (this.getLevel().paperConfig().viewDistances.load.getLimitBySeeViewDistance()) {
+                        loadViewDistance = Math.min(loadViewDistance, this.getSeeViewDistance() + 1);
+                    }
+                    // Limit by client view distance
+                    if (this.getLevel().paperConfig().viewDistances.load.getLimitByClientViewDistance()) {
+                        if (this.clientViewDistance != null && this.clientViewDistance >= 1) {
+                            loadViewDistance = Math.min(loadViewDistance, this.clientViewDistance + 2);
+                        }
+                    }
+                }
+                // Clamp to possible values
+                loadViewDistance = Mth.clamp(loadViewDistance, 3, 33);
+
+                this.level.timings.computeLoadViewDistance.stopTiming();
+
+                return loadViewDistance;
+            }
+        }
+        throw new IllegalArgumentException();
+    }
+
+    /**
+     * Is called only from ServerPlayer.viewDistanceMayHaveChanged(type)
+     */
+    private final void processViewDistanceChange(@Nullable Integer oldViewDistance, int type) {
+
+        int newViewDistance = this.viewDistances[type];
+        if (oldViewDistance != null && oldViewDistance == newViewDistance) return;
+
+        switch (type) {
+            case 0: {
+                // Update track view distance of other players
+                maxViewDistanceDueToTotalViewedChunksMayHaveChanged(type);
+                break;
+            }
+            case 1: {
+                // Update track view distance
+                this.trackViewDistanceMayHaveChanged();
+                // Update load view distance
+                this.loadViewDistanceMayHaveChanged();
+                // Update see view distance of other players
+                maxViewDistanceDueToTotalViewedChunksMayHaveChanged(type);
+                break;
+            }
+        }
+    }
+
+    private final void viewDistanceMayHaveChanged(int type) {
+        Integer oldViewDistance = this.viewDistances[type];
+        this.viewDistances[type] = this.computeViewDistance(type);
+        this.processViewDistanceChange(oldViewDistance, type);
+    }
+
+    // Martijn end - per-player view distance
+
     public long lastSave = MinecraftServer.currentTick; // Paper
     private static final int NEUTRAL_MOB_DEATH_NOTIFICATION_RADII_XZ = 32;
     private static final int NEUTRAL_MOB_DEATH_NOTIFICATION_RADII_Y = 10;
@@ -1982,6 +2239,11 @@ public class ServerPlayer extends Player {
         this.connection.connection.channel.attr(PaperAdventure.LOCALE_ATTRIBUTE).set(this.adventure$locale);
         // Paper end
         this.clientViewDistance = packet.getAcceptableViewDistance(); // Martijn - do not use invalid client view distance
+        // Martijn start - per-player view distance
+        this.trackViewDistanceMayHaveChanged();
+        this.seeViewDistanceMayHaveChanged();
+        this.loadViewDistanceMayHaveChanged();
+        // Martijn end - per-player view distance
         // CraftBukkit end
         this.chatVisibility = packet.chatVisibility();
         this.canChatColor = packet.chatColors();
@@ -2246,27 +2508,37 @@ public class ServerPlayer extends Player {
         return true; // Paper
     }
 
-    public void trackChunk(ChunkPos chunkPos, Packet<?> chunkDataPacket) {
+    // Martijn start - per-player track and see view distance
+
+    public void trackChunk(ChunkPos chunkPos, Packet<?> chunkDataPacket, boolean concernsTracking) {
         this.connection.send(chunkDataPacket);
-        // Paper start
-        if(io.papermc.paper.event.packet.PlayerChunkLoadEvent.getHandlerList().getRegisteredListeners().length > 0){
-            new io.papermc.paper.event.packet.PlayerChunkLoadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+        if (concernsTracking) {
+            // Paper start
+            if (io.papermc.paper.event.packet.PlayerChunkLoadEvent.getHandlerList().getRegisteredListeners().length > 0) {
+                new io.papermc.paper.event.packet.PlayerChunkLoadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+            }
+            // Paper end
         }
-        // Paper end
     }
 
-    public void untrackChunk(ChunkPos chunkPos) {
+    public void untrackChunk(ChunkPos chunkPos, boolean concernsTracking) {
         if (this.isAlive()) {
-            this.connection.send(new ClientboundForgetLevelChunkPacket(chunkPos.x, chunkPos.z));
-            // Paper start
-            if(io.papermc.paper.event.packet.PlayerChunkUnloadEvent.getHandlerList().getRegisteredListeners().length > 0){
-                new io.papermc.paper.event.packet.PlayerChunkUnloadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+            if (!concernsTracking) {
+                this.connection.send(new ClientboundForgetLevelChunkPacket(chunkPos.x, chunkPos.z));
+            }
+            if (concernsTracking) {
+                // Paper start
+                if (io.papermc.paper.event.packet.PlayerChunkUnloadEvent.getHandlerList().getRegisteredListeners().length > 0) {
+                    new io.papermc.paper.event.packet.PlayerChunkUnloadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+                }
+                // Paper end
             }
-            // Paper end
         }
 
     }
 
+    // Martijn end - per-player track and see view distance
+
     public SectionPos getLastSectionPos() {
         return this.lastSectionPos;
     }
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 20cdfdb3b9351f74e89bc45b3ab972384165659a..def57a2f44bf20c06b161f144e1122ad0ba4b705 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -103,7 +103,6 @@ import net.minecraft.world.scores.Team;
 import org.slf4j.Logger;
 
 // CraftBukkit start
-import io.papermc.paper.adventure.PaperAdventure; // Paper
 import com.google.common.base.Predicate;
 import java.util.stream.Collectors;
 import net.minecraft.server.dedicated.DedicatedServer;
@@ -113,7 +112,6 @@ import org.bukkit.Location;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
-import org.bukkit.craftbukkit.util.CraftChatMessage;
 import org.bukkit.entity.Player;
 import org.bukkit.event.player.PlayerChangedWorldEvent;
 import org.bukkit.event.player.PlayerJoinEvent;
@@ -273,7 +271,8 @@ public abstract class PlayerList {
         boolean flag1 = gamerules.getBoolean(GameRules.RULE_REDUCEDDEBUGINFO);
 
         // Spigot - view distance
-        playerconnection.send(new ClientboundLoginPacket(player.getId(), worlddata.isHardcore(), player.gameMode.getGameModeForPlayer(), player.gameMode.getPreviousGameModeForPlayer(), this.server.levelKeys(), this.registryHolder, worldserver1.dimensionTypeId(), worldserver1.dimension(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), this.getMaxPlayers(), worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance(), worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance(), flag1, !flag, worldserver1.isDebug(), worldserver1.isFlat(), player.getLastDeathLocation())); // Paper - replace old player chunk management
+        playerconnection.send(new ClientboundLoginPacket(player.getId(), worlddata.isHardcore(), player.gameMode.getGameModeForPlayer(), player.gameMode.getPreviousGameModeForPlayer(), this.server.levelKeys(), this.registryHolder, worldserver1.dimensionTypeId(), worldserver1.dimension(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), this.getMaxPlayers(), player.getSeeViewDistance(), worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance(), flag1, !flag, worldserver1.isDebug(), worldserver1.isFlat(), player.getLastDeathLocation())); // Paper - replace old player chunk management // Martijn - per-player view distance
+
         player.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         playerconnection.send(new ClientboundCustomPayloadPacket(ClientboundCustomPayloadPacket.BRAND, (new FriendlyByteBuf(Unpooled.buffer())).writeUtf(this.getServer().getServerModName())));
         playerconnection.send(new ClientboundChangeDifficultyPacket(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
@@ -952,7 +951,7 @@ public abstract class PlayerList {
         // CraftBukkit start
         LevelData worlddata = worldserver1.getLevelData();
         entityplayer1.connection.send(new ClientboundRespawnPacket(worldserver1.dimensionTypeId(), worldserver1.dimension(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), entityplayer1.gameMode.getGameModeForPlayer(), entityplayer1.gameMode.getPreviousGameModeForPlayer(), worldserver1.isDebug(), worldserver1.isFlat(), flag, entityplayer1.getLastDeathLocation()));
-        entityplayer1.connection.send(new ClientboundSetChunkCacheRadiusPacket(worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance())); // Spigot // Paper - replace old player chunk management
+        entityplayer1.connection.send(new ClientboundSetChunkCacheRadiusPacket(entityplayer1.getSeeViewDistance())); // Spigot // Paper - replace old player chunk management // Martijn - per-player see view distance
         entityplayer1.connection.send(new ClientboundSetSimulationDistancePacket(worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance())); // Spigot // Paper - replace old player chunk management
         entityplayer1.spawnIn(worldserver1);
         entityplayer1.unsetRemoved();
@@ -1502,7 +1501,7 @@ public abstract class PlayerList {
             ServerLevel worldserver = (ServerLevel) iterator.next();
 
             if (worldserver != null) {
-                worldserver.getChunkSource().setViewDistance(viewDistance);
+                worldserver.getChunkSource().setVanillaWorldViewDistance(viewDistance); // Martijn - per-player view distance
             }
         }
 
diff --git a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
index 219877901fb5fc6401646253d6e5d7bd8416ffe1..03a435e8ae5896af11739b2c997b9b7b60ee9be8 100644
--- a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
+++ b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
@@ -5,6 +5,8 @@ import com.mojang.logging.LogUtils;
 import java.util.Iterator;
 import java.util.List;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.configuration.GlobalConfiguration;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.particles.ParticleTypes;
 import net.minecraft.nbt.CompoundTag;
@@ -657,7 +659,7 @@ public class EnderDragon extends Mob implements Enemy {
                 // this.world.b(1028, this.getChunkCoordinates(), 0);
                 //int viewDistance = ((WorldServer) this.world).getServer().getViewDistance() * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
                 for (net.minecraft.server.level.ServerPlayer player : (List<net.minecraft.server.level.ServerPlayer>) ((ServerLevel)level).players()) {
-                    final int viewDistance = io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player); // Paper - route to player chunk loader
+                    final int viewDistance = GlobalConfiguration.get().viewDistances.trackAndSee.ifCanSeeButNotTracking.sendEnderDragonSpawnSound ? player.getSeeViewDistance() : player.getTrackViewDistance(); // Paper - route to player chunk loader // Martijn - per-player track and see view distance
                     double deltaX = this.getX() - player.getX();
                     double deltaZ = this.getZ() - player.getZ();
                     double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
index 3a3c2211585278b236fad7cc0d809a5e25e0fc58..88816bb1df4ef16b0d463719729ed95ec89e01cc 100644
--- a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
+++ b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
@@ -5,6 +5,8 @@ import java.util.EnumSet;
 import java.util.List;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.configuration.GlobalConfiguration;
 import net.minecraft.world.BossEvent;
 import net.minecraft.world.Difficulty;
 import net.minecraft.world.damagesource.DamageSource;
@@ -47,9 +49,7 @@ import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
 import net.minecraft.network.syncher.EntityDataAccessor;
 import net.minecraft.network.syncher.EntityDataSerializers;
 import net.minecraft.network.syncher.SynchedEntityData;
-import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerBossEvent;
-import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
@@ -278,7 +278,7 @@ public class WitherBoss extends Monster implements PowerableMob, RangedAttackMob
                     // this.world.globalLevelEvent(1023, new BlockPosition(this), 0);
                     //int viewDistance = ((ServerLevel) this.level).getCraftServer().getViewDistance() * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
                     for (ServerPlayer player : (List<ServerPlayer>)this.level.players()) { // Paper
-                        final int viewDistance = io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player); // Paper - route to player chunk loader
+                        final int viewDistance = GlobalConfiguration.get().viewDistances.trackAndSee.ifCanSeeButNotTracking.sendWitherSpawnSound ? player.getSeeViewDistance() : player.getTrackViewDistance(); // Paper - route to player chunk loader // Martijn - per-player track and see view distance
                         double deltaX = this.getX() - player.getX();
                         double deltaZ = this.getZ() - player.getZ();
                         double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/net/minecraft/world/item/EnderEyeItem.java b/src/main/java/net/minecraft/world/item/EnderEyeItem.java
index fa1ff2e79954089552974cefedfcbff2225738ec..eca3c9beb026c30174caaf38fa9e964180510baf 100644
--- a/src/main/java/net/minecraft/world/item/EnderEyeItem.java
+++ b/src/main/java/net/minecraft/world/item/EnderEyeItem.java
@@ -1,5 +1,6 @@
 package net.minecraft.world.item;
 
+import io.papermc.paper.configuration.GlobalConfiguration;
 import net.minecraft.advancements.CriteriaTriggers;
 import net.minecraft.core.BlockPos;
 import net.minecraft.server.level.ServerLevel;
@@ -65,7 +66,7 @@ public class EnderEyeItem extends Item {
                     //int viewDistance = world.getCraftServer().getViewDistance() * 16; // Paper - apply view distance patch
                     BlockPos soundPos = blockposition1.offset(1, 0, 1);
                     for (ServerPlayer player : world.getServer().getPlayerList().players) {
-                        final int viewDistance = io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player); // Paper - apply view distance patch
+                        final int viewDistance = GlobalConfiguration.get().viewDistances.trackAndSee.ifCanSeeButNotTracking.sendEndPortalFillSound ? player.getSeeViewDistance() : player.getTrackViewDistance(); // Paper - apply view distance patch // Martijn - per-player track and see view distance
                         double deltaX = soundPos.getX() - player.getX();
                         double deltaZ = soundPos.getZ() - player.getZ();
                         double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 0aa591fae5082bd9126cd391f35738695a44df3a..94dd87584de8cf23ff8fc4396400ff39730709f0 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -733,7 +733,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
                 this.sendBlockUpdated(blockposition, iblockdata1, iblockdata, i);
                 // Paper start - per player view distance - allow block updates for non-ticking chunks in player view distance
                 // if copied from above
-            } else if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || ((ServerLevel)this).getChunkSource().chunkMap.playerChunkManager.broadcastMap.getObjectsInRange(MCUtil.getCoordinateKey(blockposition)) != null)) { // Paper - replace old player chunk management
+            } else if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || ((ServerLevel)this).getChunkSource().chunkMap.playerChunkManager.getBroadcastMap(true).getObjectsInRange(MCUtil.getCoordinateKey(blockposition)) != null)) { // Paper - replace old player chunk management // Martijn - per-player track and see view distance
                 ((ServerLevel)this).getChunkSource().blockChanged(blockposition);
                 // Paper end - per player view distance
             }
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index ec23064d5a6d70508fad7cffc6126cfd6f7a62cb..eeb05b35a3a026f46791b3e4f9cff65460dccbdf 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -224,7 +224,7 @@ public class LevelChunk extends ChunkAccess {
         // this code handles the chunk sending
         if (!areNeighboursLoaded(bitsetBefore, 1) && areNeighboursLoaded(bitsetAfter, 1)) {
             // Paper start - replace old player chunk loading system
-            if (chunkMap.playerChunkManager.isChunkNearPlayers(this.chunkPos.x, this.chunkPos.z)) {
+            if (chunkMap.playerChunkManager.isChunkNearPlayers(this.chunkPos.x, this.chunkPos.z, false)) { // Martijn - per-player track and see view distance
                 // the post processing is expensive, so we don't want to run it unless we're actually near
                 // a player.
                 chunkProviderServer.mainThreadProcessor.execute(() -> {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 3d0ec706cea7715042c9e7cd51eb6a5b87ea76f5..50d8c6d75e3ab4d1109e591091438f01e7ae64af 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -4,6 +4,7 @@ import com.google.common.base.Preconditions;
 import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
+import io.papermc.paper.configuration.GlobalConfiguration;
 import io.papermc.paper.world.structure.ConfiguredStructure;
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
@@ -21,13 +22,11 @@ import java.util.Objects;
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
-import java.util.concurrent.ExecutionException;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
 import net.minecraft.core.Registry;
-import net.minecraft.core.SectionPos;
 import net.minecraft.data.BuiltinRegistries;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.Tag;
@@ -45,7 +44,6 @@ import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.server.level.Ticket;
 import net.minecraft.server.level.TicketType;
 import net.minecraft.sounds.SoundSource;
-import net.minecraft.tags.TagKey;
 import net.minecraft.util.SortedArraySet;
 import net.minecraft.util.Unit;
 import net.minecraft.world.entity.EntityType;
@@ -67,7 +65,6 @@ import net.minecraft.world.level.storage.LevelResource;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
-import nl.martijnmuijsers.paper.structure.CraftWorldStructure;
 import nl.martijnmuijsers.paper.structure.WorldStructure;
 import org.apache.commons.lang.Validate;
 import org.bukkit.BlockChangeDelegate;
@@ -120,7 +117,6 @@ import org.bukkit.entity.TippedArrow;
 import org.bukkit.entity.Trident;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
 import org.bukkit.event.weather.LightningStrikeEvent;
-import org.bukkit.event.world.SpawnChangeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 import org.bukkit.generator.BiomeProvider;
 import org.bukkit.generator.BlockPopulator;
@@ -539,7 +535,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
         playerChunk.getTickingChunkFuture().thenAccept(either -> {
             either.left().ifPresent(chunk -> {
-                List<ServerPlayer> playersInRange = playerChunk.playerProvider.getPlayers(playerChunk.getPos(), false);
+                List<ServerPlayer> playersInRange = playerChunk.playerProvider.getPlayers(playerChunk.getPos(), false, !GlobalConfiguration.get().viewDistances.trackAndSee.ifCanSeeButNotTracking.sendChunkRefresh); // Martijn - per-player track and see view distance
                 if (playersInRange.isEmpty()) return;
 
                 // Paper start - Anti-Xray - Bypass
@@ -2272,7 +2268,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     // Spigot start
     @Override
     public int getViewDistance() {
-        return getHandle().getChunkSource().chunkMap.playerChunkManager.getTargetNoTickViewDistance(); // Paper - replace old player chunk management
+        return getHandle().getChunkSource().chunkMap.getVanillaWorldViewDistance(); // Paper - replace old player chunk management // Martijn - per-player view distance
     }
 
     @Override
@@ -2288,7 +2284,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
             throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
         }
         net.minecraft.server.level.ChunkMap chunkMap = getHandle().getChunkSource().chunkMap;
-        chunkMap.setViewDistance(viewDistance);
+        chunkMap.setVanillaWorldViewDistance(viewDistance); // Martijn - per-player view distance
         // Paper end - replace old player chunk management
     }
 
@@ -2304,25 +2300,27 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     }
     // Paper end - replace old player chunk management
 
-    @Override
-    public int getNoTickViewDistance() {
-        return this.getViewDistance(); // Paper - replace old player chunk management
-    }
-
-    @Override
-    public void setNoTickViewDistance(int viewDistance) {
-        this.setViewDistance(viewDistance); // Paper - replace old player chunk management
-    }
-
-    @Override
-    public int getSendViewDistance() {
-        return getHandle().getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance(); // Paper - replace old player chunk management
-    }
-
-    @Override
-    public void setSendViewDistance(int viewDistance) {
-        getHandle().getChunkSource().chunkMap.playerChunkManager.setSendDistance(viewDistance); // Paper - replace old player chunk management
-    }
+    // Martijn start - per-player view distance
+//    @Override
+//    public int getNoTickViewDistance() {
+//        return this.getViewDistance(); // Paper - replace old player chunk management
+//    }
+//
+//    @Override
+//    public void setNoTickViewDistance(int viewDistance) {
+//        this.setViewDistance(viewDistance); // Paper - replace old player chunk management
+//    }
+//
+//    @Override
+//    public int getSendViewDistance() {
+//        return getHandle().getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance(); // Paper - replace old player chunk management
+//    }
+//
+//    @Override
+//    public void setSendViewDistance(int viewDistance) {
+//        getHandle().getChunkSource().chunkMap.playerChunkManager.setSendDistance(viewDistance); // Paper - replace old player chunk management
+//    }
+    // Martijn end - per-player view distance
     // Paper end - view distance api
 
     // Spigot start
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index abcce6bd0b32d0188751393a6f56f2e82530912c..2a7c9a82e5b5797f9a49889ae6fc251870258d49 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -541,80 +541,82 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         }
     }
 
-    // Paper start - implement view distances
-    @Override
-    public int getViewDistance() {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            return chunkMap.playerChunkManager.getTargetNoTickViewDistance();
-        }
-        return data.getTargetNoTickViewDistance();
-    }
-
-    @Override
-    public void setViewDistance(int viewDistance) {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            throw new IllegalStateException("Player is not attached to world");
-        }
-
-        data.setTargetNoTickViewDistance(viewDistance);
-    }
-
-    @Override
-    public int getSimulationDistance() {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            return chunkMap.playerChunkManager.getTargetTickViewDistance();
-        }
-        return data.getTargetTickViewDistance();
-    }
-
-    @Override
-    public void setSimulationDistance(int simulationDistance) {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            throw new IllegalStateException("Player is not attached to world");
-        }
-
-        data.setTargetTickViewDistance(simulationDistance);
-    }
-
-    @Override
-    public int getNoTickViewDistance() {
-        return this.getViewDistance();
-    }
-
-    @Override
-    public void setNoTickViewDistance(int viewDistance) {
-        this.setViewDistance(viewDistance);
-    }
-
-    @Override
-    public int getSendViewDistance() {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            return chunkMap.playerChunkManager.getTargetSendDistance();
-        }
-        return data.getTargetSendViewDistance();
-    }
-
-    @Override
-    public void setSendViewDistance(int viewDistance) {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            throw new IllegalStateException("Player is not attached to world");
-        }
-
-        data.setTargetSendViewDistance(viewDistance);
-    }
-    // Paper end - implement view distances
+    // Martijn start - per-player view distance
+//    // Paper start - implement view distances
+//    @Override
+//    public int getViewDistance() {
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            return chunkMap.playerChunkManager.getTargetNoTickViewDistance();
+//        }
+//        return data.getTargetNoTickViewDistance();
+//    }
+//
+//    @Override
+//    public void setViewDistance(int viewDistance) {
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            throw new IllegalStateException("Player is not attached to world");
+//        }
+//
+//        data.setTargetNoTickViewDistance(viewDistance);
+//    }
+//
+//    @Override
+//    public int getSimulationDistance() {
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            return chunkMap.playerChunkManager.getTargetTickViewDistance();
+//        }
+//        return data.getTargetTickViewDistance();
+//    }
+//
+//    @Override
+//    public void setSimulationDistance(int simulationDistance) {
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            throw new IllegalStateException("Player is not attached to world");
+//        }
+//
+//        data.setTargetTickViewDistance(simulationDistance);
+//    }
+//
+//    @Override
+//    public int getNoTickViewDistance() {
+//        return this.getViewDistance();
+//    }
+//
+//    @Override
+//    public void setNoTickViewDistance(int viewDistance) {
+//        this.setViewDistance(viewDistance);
+//    }
+//
+//    @Override
+//    public int getSendViewDistance() {
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            return chunkMap.playerChunkManager.getTargetSendDistance();
+//        }
+//        return data.getTargetSendViewDistance();
+//    }
+//
+//    @Override
+//    public void setSendViewDistance(int viewDistance) {
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            throw new IllegalStateException("Player is not attached to world");
+//        }
+//
+//        data.setTargetSendViewDistance(viewDistance);
+//    }
+//    // Paper end - implement view distances
+    // Martijn end - per-player view distance
 
     @Override
     public <T> T getClientOption(com.destroystokyo.paper.ClientOption<T> type) {
