From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Thu, 25 Aug 2022 21:21:08 +0200
Subject: [PATCH] Limit some packet sending per tick


diff --git a/src/main/java/net/minecraft/network/Connection.java b/src/main/java/net/minecraft/network/Connection.java
index 801617dc36f9d103f1a36a73bd82ce45663ca236..1a9a8cd366abf8107fb0575c78f3c9def8959392 100644
--- a/src/main/java/net/minecraft/network/Connection.java
+++ b/src/main/java/net/minecraft/network/Connection.java
@@ -27,12 +27,20 @@ import io.netty.handler.timeout.TimeoutException;
 import io.netty.util.AttributeKey;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.BitSet;
 import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
 import java.util.Queue;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.TreeSet;
 import java.util.UUID;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.locks.ReentrantLock;
+import java.util.stream.Collectors;
 import javax.annotation.Nullable;
 
 import io.papermc.paper.util.CoordinateUtils;
@@ -57,15 +65,20 @@ import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.PacketFlow;
 import net.minecraft.network.protocol.game.ClientboundAddEntityPacket;
+import net.minecraft.network.protocol.game.ClientboundBlockEventPacket;
+import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundDisconnectPacket;
+import net.minecraft.network.protocol.game.ClientboundLightUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundMoveEntityPacket;
 import net.minecraft.network.protocol.game.ClientboundRemoveEntitiesPacket;
+import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundSetEntityDataPacket;
 import net.minecraft.network.protocol.game.ClientboundSetEquipmentPacket;
 import net.minecraft.network.protocol.login.ClientboundLoginDisconnectPacket;
 import net.minecraft.network.syncher.SynchedEntityData;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.RunningOnDifferentThreadException;
+import net.minecraft.tags.BlockTags;
 import net.minecraft.util.LazyLoadedValue;
 import net.minecraft.util.Mth;
 import net.minecraft.world.entity.Entity;
@@ -73,7 +86,9 @@ import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.EquipmentSlot;
 import net.minecraft.world.entity.decoration.ArmorStand;
 import net.minecraft.world.entity.item.FallingBlockEntity;
+import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.phys.Vec3;
@@ -365,8 +380,22 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     private @NotNull LongArrayFIFOQueue sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewList= new LongArrayFIFOQueue(64);
     private @Nullable Long lastChunkInitializationPacketInTransitKeepaliveIdWhenLastUpdatingPotentialBlockEntitiesInSection = null;
 
+    /**
+     * If we cross this limit, we will wait some time to attempt this again.
+     */
+    public static final long maxNanosUpdatingPotentialBlockEntitiesInSectionPerTick = 5_000_000L; // 5 milliseconds
+
+    private @Nullable Long nextMinNanoTimeToUpdatePotentialBlockEntitiesInSection = null;
+
     private void tickUpdatePotentialBlockEntitiesInSectionSpawnNew() {
 
+        if (nextMinNanoTimeToUpdatePotentialBlockEntitiesInSection != null) {
+            if (System.nanoTime() < nextMinNanoTimeToUpdatePotentialBlockEntitiesInSection) {
+                return;
+            }
+            nextMinNanoTimeToUpdatePotentialBlockEntitiesInSection = null;
+        }
+
         var player = getPlayer();
 
         // Skip this tick if we are still waiting for chunks in transit
@@ -396,7 +425,14 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             }
         }
 //        MinecraftServer.LOGGER.info("TEMP DEBUG - Section update new during tick: " + SectionPos.of(sectionKey).x() + ", " + SectionPos.of(sectionKey).y() + ", " + SectionPos.of(sectionKey).z());
+        // Measure the absolute time this takes to decide how many next ticks we should skip this action
+        long startTime = System.nanoTime();
         this.updatePotentialBlockEntitiesInSectionSpawnNew(SectionPos.of(sectionKey), updateOutsideSectionBounds, null);
+        long endTime = System.nanoTime();
+        long extraTicksWorthOfUpdatesDone = (endTime - startTime) / maxNanosUpdatingPotentialBlockEntitiesInSectionPerTick;
+        if (extraTicksWorthOfUpdatesDone > 0) {
+            nextMinNanoTimeToUpdatePotentialBlockEntitiesInSection = System.nanoTime() + extraTicksWorthOfUpdatesDone * 50_000_000; // 50 milliseconds = 1 tick
+        }
 
         // Update when we performed this tick update, to prevent doing this too often before chunks are sent
         lastChunkInitializationPacketInTransitKeepaliveIdWhenLastUpdatingPotentialBlockEntitiesInSection = player.getLastChunkInitializationPacketInTransitKeepaliveId();
@@ -490,15 +526,31 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     }
 
     public void updatePotentialBlockEntitiesInSection(@NotNull SectionPos sectionPos, boolean updateOutsideSectionBounds, @Nullable LevelChunk precomputedChunk) {
+
+        var sectionKey = sectionPos.asLong();
+
+        @Nullable Boolean existingUpdateOutsideSectionBounds;
+        try {
+            scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.lock();
+            existingUpdateOutsideSectionBounds = sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewAndWhetherToUpdateOutsideSectionBounds.get(sectionKey);
+        } finally {
+            scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.unlock();
+        }
+        if (existingUpdateOutsideSectionBounds != null) {
+            if (existingUpdateOutsideSectionBounds || !updateOutsideSectionBounds) {
+                // We are already planning to update the potential block entities in this section, do not process the chunk again here
+                return;
+            }
+        }
+
         var player = this.getPlayer();
         var level = player.getLevel();
         @Nullable LevelChunk chunk = precomputedChunk != null ? precomputedChunk : level.getChunkIfLoaded(sectionPos.x(), sectionPos.z());
         if (chunk != null) {
 //            MinecraftServer.LOGGER.info("TEMP DEBUG - Section update start: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
-            var sectionKey = sectionPos.asLong();
             // Attempt to despawn any sent block entities where one no longer exists
             @Nullable LongSet sectionSentBlockKeys = this.getBlockEntityBlockPosKeysForChunkSectionKey(sectionKey);
-            if (sectionSentBlockKeys != null) {
+            if (sectionSentBlockKeys != null && !sectionSentBlockKeys.isEmpty()) {
 //                MinecraftServer.LOGGER.info("TEMP DEBUG - Section update old: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
                 @Nullable LongList toRemoveBlockKeys = null;
                 for (long sentBlockKey : sectionSentBlockKeys) {
@@ -530,6 +582,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
 //                MinecraftServer.LOGGER.info("TEMP DEBUG - Section update done: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
             }
         }
+
     }
 
     /**
@@ -926,6 +979,619 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     }
     // Paper end
 
+    // Martijn start - limit packets per tick
+
+    private final ReentrantLock queuedPacketsLock = new ReentrantLock();
+    private long nextQueuedPacketIndex = 0;
+    private final TreeMap<Long, QueuedPacket> queuedPackets = new TreeMap<>();
+    private static final int creditsPerTick = 100;
+    private static final int maxTotalCredits = creditsPerTick * 7;
+    private static final int[] creditCostPerType = {4, 1, 0/* Determined automatically based on creditCostPerType[1]*/, 48/*256*/};
+    private static final int maxBlocksToCountForSectionUpdateCreditCost = 20;
+    private int creditsForThisTick = maxTotalCredits;
+    private @org.jetbrains.annotations.Nullable Packet<?> immuneQueuedPacketBeingSent = null;
+    private Long2ObjectMap<QueuedPistonBlockEventPacket> lastPistonBlockEventPacketPerBlockPosKey = new Long2ObjectOpenHashMap<>(64);
+//    private Long2ObjectMap<QueuedBlockUpdatePacket> lastBlockUpdatePacketPerBlockPosKey = new Long2ObjectOpenHashMap<>(256);
+    private Long2ObjectMap<QueuedSomeBlocksUpdatePacket> lastSomeBlocksUpdatePacketPerBlockPosKey = new Long2ObjectOpenHashMap<>(256);
+//    private Long2ObjectMap<LongSet> blockPosKeysWithLastBlockUpdatePacketPerSectionPosKey = new Long2ObjectOpenHashMap<>(16);
+//    private Long2ObjectMap<QueuedSectionBlocksUpdatePacket> lastSectionBlocksUpdatePacketPerSectionPosKey = new Long2ObjectOpenHashMap<>(16);
+    private Long2ObjectMap<QueuedPacket> lastLightUpdatePacketPerChunkPosKey = new Long2ObjectOpenHashMap<>(8);
+
+    private class QueuedPacket {
+
+        /**b1
+         * How many'th packet this is that has been queued
+         */
+        public final long index;
+        /**
+         * Is null only when this queued packet has been cancelled but the callbacks are non-null
+         */
+        public @org.jetbrains.annotations.Nullable Packet<?> packet;
+        public final @org.jetbrains.annotations.Nullable PacketSendListener callbacks;
+        /**
+         * 0 = ClientboundBlockEventPacket
+         * 1 = ClientboundBlockUpdatePacket
+         * 2 = ClientboundSectionBlockUpdatesPacket
+         * 3 = ClientboundLightUpdatePacket
+         */
+        public final int type;
+
+        QueuedPacket(long index, @NotNull Packet<?> packet, @org.jetbrains.annotations.Nullable PacketSendListener callbacks, int type) {
+            this.index = index;
+            this.packet = packet;
+            this.callbacks = callbacks;
+            this.type = type;
+        }
+
+        /**
+         * Calling this will never remove the packet from any 'last packet for position' map because
+         * this must never be called while the packet is the last packet of a type for a position,
+         * because then the packet must not be cancelled
+         */
+        void cancel() {
+            packet = null;
+            if (callbacks == null) {
+                queuedPackets.remove(index);
+            }
+        }
+
+    }
+
+    private class QueuedPistonBlockEventPacket extends QueuedPacket {
+
+        private @org.jetbrains.annotations.Nullable ClientboundBlockEventPacket blockEventPacket;
+        private @org.jetbrains.annotations.Nullable QueuedSomeBlocksUpdatePacket @org.jetbrains.annotations.Nullable [] protectedPackets;
+
+        QueuedPistonBlockEventPacket(long index, @NotNull ClientboundBlockEventPacket packet, @org.jetbrains.annotations.Nullable PacketSendListener callbacks, @org.jetbrains.annotations.Nullable QueuedSomeBlocksUpdatePacket @org.jetbrains.annotations.Nullable [] protectedPackets) {
+            super(index, packet, callbacks, 0);
+            this.blockEventPacket = packet;
+            this.protectedPackets = protectedPackets;
+        }
+
+        @Override
+        void cancel() {
+            pistonPacketsInQueue--;
+            if (pistonPacketsInQueue % 100 == 0) {
+                MinecraftServer.LOGGER.info("Piston packets in queue: " + pistonPacketsInQueue);
+            }
+            if (queuedPackets.size() % 1000 == 0) {
+                MinecraftServer.LOGGER.info("Total in queue: " + queuedPackets.size());
+            }
+            blockEventPacket = null;
+            super.cancel();
+            // Remove the protection this was giving to any block update packets
+//            MinecraftServer.LOGGER.info("   Piston packet " + index + " is being cancelled, was protecting " + (protectedPackets == null ? "null" : Arrays.stream(protectedPackets).map(it -> it == null ? "null" : it.index).toList()));
+            if (protectedPackets != null) {
+                for (QueuedSomeBlocksUpdatePacket protectedPacket : protectedPackets) {
+                    if (protectedPacket != null) {
+                        protectedPacket.protectingPistonBlockEventPackets.remove(this);
+//                        MinecraftServer.LOGGER.info("     Removed from protected packet " + protectedPacket.index + " which is now protected by " + protectedPacket.protectingPistonBlockEventPackets.stream().map(it -> it.index).toList());
+                        // Remove the previously protected packet if it is no longer protected
+                        if (protectedPacket.canBeSafelyCancelledFromQueue(null)) {
+                            protectedPacket.cancel();
+                        }
+                    }
+                }
+            }
+        }
+
+        @Override
+        public String toString() {
+            return index + ":Piston(" + blockEventPacket.getPos().getX() + "," + blockEventPacket.getPos().getY() + "," + blockEventPacket.getPos().getZ() + ")";
+        }
+
+    }
+
+    private class QueuedSomeBlocksUpdatePacket extends QueuedPacket {
+
+        protected @org.jetbrains.annotations.Nullable List<QueuedPistonBlockEventPacket> protectingPistonBlockEventPackets = null;
+
+        QueuedSomeBlocksUpdatePacket(long index, @NotNull Packet<?> packet, @org.jetbrains.annotations.Nullable PacketSendListener callbacks, int type) {
+            super(index, packet, callbacks, type);
+        }
+
+        boolean canBeSafelyCancelledFromQueue(@org.jetbrains.annotations.Nullable Long blockKeyBeingRemovedFrom) {
+            if (protectingPistonBlockEventPackets != null && !protectingPistonBlockEventPackets.isEmpty()) {
+                return false;
+            }
+            return true;
+        }
+
+        @Override
+        void cancel() {
+//            MinecraftServer.LOGGER.info("   Protectable packet " + index + " is being cancelled");
+            super.cancel();
+        }
+
+    }
+
+    private class QueuedBlockUpdatePacket extends QueuedSomeBlocksUpdatePacket {
+
+        private @org.jetbrains.annotations.Nullable ClientboundBlockUpdatePacket blockUpdatePacket;
+
+        QueuedBlockUpdatePacket(long index, @NotNull ClientboundBlockUpdatePacket packet, @org.jetbrains.annotations.Nullable PacketSendListener callbacks) {
+            super(index, packet, callbacks, 1);
+            this.blockUpdatePacket = packet;
+        }
+
+        @Override
+        boolean canBeSafelyCancelledFromQueue(@org.jetbrains.annotations.Nullable Long blockKeyBeingRemovedFrom) {
+            if (blockKeyBeingRemovedFrom == null && lastSomeBlocksUpdatePacketPerBlockPosKey.get(blockUpdatePacket.getPos().asLong()) == this) {
+                return false;
+            }
+            return super.canBeSafelyCancelledFromQueue(blockKeyBeingRemovedFrom);
+        }
+
+        void cancel() {
+//            MinecraftServer.LOGGER.info("   Block update packet " + index + " is being cancelled");
+            this.blockUpdatePacket = null;
+            super.cancel();
+        }
+
+        @Override
+        public String toString() {
+            return index + ":Block(" + blockUpdatePacket.getPos().getX() + "," + blockUpdatePacket.getPos().getY() + "," + blockUpdatePacket.getPos().getZ() + ")";
+        }
+
+    }
+
+    private class QueuedSectionBlocksUpdatePacket extends QueuedSomeBlocksUpdatePacket {
+
+        private @org.jetbrains.annotations.Nullable ClientboundSectionBlocksUpdatePacket sectionBlocksUpdatePacket;
+
+        QueuedSectionBlocksUpdatePacket(long index, @NotNull ClientboundSectionBlocksUpdatePacket packet, @org.jetbrains.annotations.Nullable PacketSendListener callbacks) {
+            super(index, packet, callbacks, 2);
+            this.sectionBlocksUpdatePacket = packet;
+        }
+
+        @Override
+        boolean canBeSafelyCancelledFromQueue(@org.jetbrains.annotations.Nullable Long blockKeyBeingRemovedFrom) {
+            SectionPos sectionPos = sectionBlocksUpdatePacket.sectionPos;
+            for (short shortRelativePosition : sectionBlocksUpdatePacket.positions) {
+                int x = sectionPos.relativeToBlockX(shortRelativePosition);
+                int y = sectionPos.relativeToBlockY(shortRelativePosition);
+                int z = sectionPos.relativeToBlockZ(shortRelativePosition);
+                long blockKey = BlockPos.asLong(x, y, z);
+                if (blockKeyBeingRemovedFrom == null || blockKey != blockKeyBeingRemovedFrom) {
+                    if (lastSomeBlocksUpdatePacketPerBlockPosKey.get(blockKey) == this) {
+                        return false;
+                    }
+                }
+            }
+            return super.canBeSafelyCancelledFromQueue(blockKeyBeingRemovedFrom);
+        }
+
+        void cancel() {
+//            MinecraftServer.LOGGER.info("   Section update packet " + index + " is being cancelled");
+            this.sectionBlocksUpdatePacket = null;
+            super.cancel();
+        }
+
+        @Override
+        public String toString() {
+            return index + ":Section(" + sectionBlocksUpdatePacket.sectionPos.getX() + "," + sectionBlocksUpdatePacket.sectionPos.getY() + "," + sectionBlocksUpdatePacket.sectionPos.getZ() + ")";
+        }
+
+    }
+
+    private int pistonPacketsInQueue = 0; // TEMP DEBUG
+
+    private QueuedBlockUpdatePacket processBlockUpdateToQueue(long queuedPacketIndex, ClientboundBlockUpdatePacket blockUpdatePacket, @org.jetbrains.annotations.Nullable PacketSendListener callbacks) {
+        BlockPos blockPos = blockUpdatePacket.getPos();
+        long blockKey = blockPos.asLong();
+        // Create the queued packet
+        var queuedBlockUpdatePacket = new QueuedBlockUpdatePacket(queuedPacketIndex, blockUpdatePacket, callbacks);
+//                MinecraftServer.LOGGER.info("+ Block update = " + queuedPacket.index + "  " + blockPos.getX() + ", " + blockPos.getY() + ", " + blockPos.getZ());
+        // Replace the last update packet for the position
+        lastSomeBlocksUpdatePacketPerBlockPosKey.compute(blockKey, ($, existingQueuedPacket) -> {
+            if (existingQueuedPacket != null) {
+                // Cancel the existing queued packet if not protected
+//                        MinecraftServer.LOGGER.info("   Considering deleting old at position: " + existingQueuedPacket.index);
+                if (existingQueuedPacket.canBeSafelyCancelledFromQueue(blockKey)) {
+                    existingQueuedPacket.cancel();
+                }
+            }
+            // Return this new packet so it is now the last update packet for the position
+            return queuedBlockUpdatePacket;
+        });
+        // Mark this block update packet as a last block update packet within its section
+        SectionPos sectionPos = SectionPos.of(blockPos);
+        long sectionKey = sectionPos.asLong();
+//                blockPosKeysWithLastBlockUpdatePacketPerSectionPosKey.computeIfAbsent(sectionKey, $ -> new LongOpenHashSet(4)).add(blockKey);
+        return queuedBlockUpdatePacket;
+    }
+
+    /**
+     * Returns true if the packet is allowed to pass because we are sending it after it had been scheduled
+     */
+    private boolean isImmuneOtherwiseQueue(Packet<?> packet, @org.jetbrains.annotations.Nullable PacketSendListener callbacks) {
+
+        if (packet == immuneQueuedPacketBeingSent) {
+            return true;
+        }
+        int type;
+        if (packet instanceof ClientboundBlockEventPacket) {
+            type = 0;
+        } else if (packet instanceof ClientboundBlockUpdatePacket) {
+            type = 1;
+        } else if (packet instanceof ClientboundSectionBlocksUpdatePacket) {
+            type = 2;
+        } else if (packet instanceof ClientboundLightUpdatePacket) {
+            type = 3;
+        } else {
+            return true;
+        }
+
+        queuedPacketsLock.lock();
+        try {
+
+            // Check if we have enough credit left, and if so, and no packets are queued, send it right away
+            int creditCost;
+            if (type == 2) {
+                creditCost = creditCostPerType[1] * Math.min(maxBlocksToCountForSectionUpdateCreditCost, ((ClientboundSectionBlocksUpdatePacket) packet).positions.length);
+            } else {
+                creditCost = creditCostPerType[type];
+            }
+            if (creditsForThisTick >= creditCost && queuedPackets.isEmpty()) {
+                // Subtract the credit cost
+                creditsForThisTick -= creditCost;
+                // Send the packet
+                return true;
+            }
+
+            long queuedPacketIndex = nextQueuedPacketIndex;
+            nextQueuedPacketIndex++;
+            QueuedPacket queuedPacket;
+
+            if (type == 0) {
+                ClientboundBlockEventPacket blockEventPacket = (ClientboundBlockEventPacket) packet;
+                Block block = blockEventPacket.getBlock();
+                boolean isPiston = block.equals(Blocks.PISTON) || block.equals(Blocks.STICKY_PISTON);
+                if (isPiston) {
+                    BlockPos blockPos = blockEventPacket.getPos();
+                    long blockKey = blockPos.asLong();
+                    pistonPacketsInQueue++;
+                    if (pistonPacketsInQueue % 100 == 0) {
+                        MinecraftServer.LOGGER.info("Piston packets in queue: " + pistonPacketsInQueue);
+                    }
+                    if (queuedPackets.size() % 1000 == 0) {
+                        MinecraftServer.LOGGER.info("Total in queue: " + queuedPackets.size());
+                    }
+                    // Get the direction of the piston
+                    Direction pistonDirection = switch (blockEventPacket.getB1()) {
+                        case 0 -> Direction.DOWN;
+                        case 1 -> Direction.UP;
+                        case 2 -> Direction.SOUTH;
+                        case 3 -> Direction.WEST;
+                        case 4 -> Direction.NORTH;
+                        case 5 -> Direction.EAST;
+                        default -> Direction.DOWN; // Should not happen
+                    };
+//                    MinecraftServer.LOGGER.info("+ Piston  " + blockPos.getX() + ", " + blockPos.getY() + ", " + blockPos.getZ() + "   direction = " + pistonDirection.name());
+                    // Potentially protect 3 block update packets: the block itself, relative in direction of piston (where head would be if extended) and twice relative in direction of piston (where block would be moved to due to extending)
+                    @org.jetbrains.annotations.Nullable QueuedSomeBlocksUpdatePacket @org.jetbrains.annotations.Nullable [] protectedPackets = null;
+                    for (int blockI = 0; blockI < 3; blockI++) {
+                        // Get the position of the block to protect
+                        BlockPos relativeBlockPos = blockPos;
+                        if (blockI > 0) {
+                            relativeBlockPos = blockPos.relative(pistonDirection, blockI);
+                        }
+//                        MinecraftServer.LOGGER.info("   Considering (" + blockI + ") protecting " + relativeBlockPos.getX() + ", " + relativeBlockPos.getY() + ", " + relativeBlockPos.getZ());
+                        // Check if there is a scheduled block update, and if so, protect it
+                        QueuedSomeBlocksUpdatePacket blocksUpdatePacket = lastSomeBlocksUpdatePacketPerBlockPosKey.get(relativeBlockPos.asLong());
+                        if (blocksUpdatePacket != null) {
+                            // Protect it
+                            if (protectedPackets == null) {
+                                protectedPackets = new QueuedSomeBlocksUpdatePacket[3];
+                            }
+                            protectedPackets[blockI] = blocksUpdatePacket;
+//                            MinecraftServer.LOGGER.info("     -> Protecting blocks update packet " + blocksUpdatePacket.index);
+                        }
+//                        else {
+//                            // Maybe there is a scheduled section blocks update instead, and if so, protect it
+//                            long relativeSectionKey = SectionPos.of(relativeBlockPos).asLong();
+//                            QueuedSectionBlocksUpdatePacket sectionBlocksUpdatePacket = lastSectionBlocksUpdatePacketPerSectionPosKey.get(relativeSectionKey);
+//                            if (sectionBlocksUpdatePacket != null) {
+//                                // Protect it
+//                                if (protectedPackets == null) {
+//                                    protectedPackets = new QueuedSomeBlocksUpdatePacket[3];
+//                                }
+//                                // Make sure we did not already protect it
+//                                boolean alreadyProtected = false;
+//                                for (int blockJ = 0; blockJ < blockI; blockJ++) {
+//                                    if (protectedPackets[blockJ] == sectionBlocksUpdatePacket) {
+//                                        alreadyProtected = true;
+//                                        break;
+//                                    }
+//                                }
+//                                if (!alreadyProtected) {
+//                                    protectedPackets[blockI] = sectionBlocksUpdatePacket;
+//                                    MinecraftServer.LOGGER.info("     -> Protecting section " + sectionBlocksUpdatePacket.index + " = " + sectionBlocksUpdatePacket.sectionBlocksUpdatePacket.sectionPos.getX() + ", " + sectionBlocksUpdatePacket.sectionBlocksUpdatePacket.sectionPos.getY() + ", " + sectionBlocksUpdatePacket.sectionBlocksUpdatePacket.sectionPos.getZ());
+//                                }
+//                            }
+//                        }
+                    }
+                    // Create the queued packet
+                    var queuedPistonBlockEventPacket = new QueuedPistonBlockEventPacket(queuedPacketIndex, blockEventPacket, callbacks, protectedPackets);
+                    queuedPacket = queuedPistonBlockEventPacket;
+//                    MinecraftServer.LOGGER.info("   Newly created piston = " + queuedPacketIndex);
+                    // Also mark the protected packets as protected by the newly created queued piston packet
+                    if (queuedPistonBlockEventPacket.protectedPackets != null) {
+                        for (QueuedSomeBlocksUpdatePacket protectedPacket : queuedPistonBlockEventPacket.protectedPackets) {
+                            if (protectedPacket != null) {
+                                if (protectedPacket.protectingPistonBlockEventPackets == null) {
+                                    protectedPacket.protectingPistonBlockEventPackets = new ArrayList<>(1);
+                                }
+                                protectedPacket.protectingPistonBlockEventPackets.add(queuedPistonBlockEventPacket);
+//                                MinecraftServer.LOGGER.info("   Protected packet " + protectedPacket.index + " is now protected by " + protectedPacket.protectingPistonBlockEventPackets.stream().map(it -> it.index).toList());
+                            }
+                        }
+                    }
+                    // Replace the last piston packet for the position
+                    lastPistonBlockEventPacketPerBlockPosKey.compute(blockKey, ($, existingQueuedPacket) -> {
+                        if (existingQueuedPacket != null) {
+                            // Cancel the existing queued packet
+                            existingQueuedPacket.cancel();
+                        }
+                        // Return this new packet so it is now the last piston packet for the position
+                        return queuedPistonBlockEventPacket;
+                    });
+                } else {
+                    queuedPacket = new QueuedPacket(queuedPacketIndex, packet, callbacks, type);
+                }
+            } else if (type == 1) {
+                ClientboundBlockUpdatePacket blockUpdatePacket = (ClientboundBlockUpdatePacket) packet;
+                queuedPacket = processBlockUpdateToQueue(queuedPacketIndex, blockUpdatePacket, callbacks);
+            } else if (type == 2) {
+                ClientboundSectionBlocksUpdatePacket sectionBlocksUpdatePacket = (ClientboundSectionBlocksUpdatePacket) packet;
+                SectionPos sectionPos = sectionBlocksUpdatePacket.sectionPos;
+                boolean scheduleSeparately = false;
+                for (short shortRelativePosition : sectionBlocksUpdatePacket.positions) {
+                    int x = sectionPos.relativeToBlockX(shortRelativePosition);
+                    int y = sectionPos.relativeToBlockY(shortRelativePosition);
+                    int z = sectionPos.relativeToBlockZ(shortRelativePosition);
+                    long blockKey = BlockPos.asLong(x, y, z);
+//                    var lastPacket = lastSomeBlocksUpdatePacketPerBlockPosKey.get(blockKey);
+//                    if (lastPacket != null && lastPacket.protectingPistonBlockEventPackets != null && !lastPacket.protectingPistonBlockEventPackets.isEmpty()) {
+                    if (lastSomeBlocksUpdatePacketPerBlockPosKey.containsKey(blockKey)) {
+                        scheduleSeparately = true;
+                        break;
+                    }
+                }
+                if (scheduleSeparately) {
+                    // We will schedule the packet as separate block updates
+                    for (int i = 0; i < sectionBlocksUpdatePacket.positions.length; i++) {
+                        short shortRelativePosition = sectionBlocksUpdatePacket.positions[i];
+                        int x = sectionPos.relativeToBlockX(shortRelativePosition);
+                        int y = sectionPos.relativeToBlockY(shortRelativePosition);
+                        int z = sectionPos.relativeToBlockZ(shortRelativePosition);
+                        BlockPos blockPos = new BlockPos(x, y, z);
+
+                        if (i > 0) {
+                            queuedPacketIndex = nextQueuedPacketIndex;
+                            nextQueuedPacketIndex++;
+                        }
+
+                        // Create and enqueue the individual block update packet
+                        ClientboundBlockUpdatePacket blockUpdatePacket = new ClientboundBlockUpdatePacket(blockPos, sectionBlocksUpdatePacket.states[i]);
+                        queuedPacket = processBlockUpdateToQueue(queuedPacketIndex, blockUpdatePacket, i == sectionBlocksUpdatePacket.positions.length - 1 ? callbacks : null);
+                        queuedPackets.put(queuedPacketIndex, queuedPacket);
+
+                    }
+                    return false;
+                }
+                // Create the queued packet
+                var queuedSectionBlocksUpdatePacket = new QueuedSectionBlocksUpdatePacket(queuedPacketIndex, sectionBlocksUpdatePacket, callbacks);
+                queuedPacket = queuedSectionBlocksUpdatePacket;
+//                MinecraftServer.LOGGER.info("+ Section update = " + queuedPacket.index + "  " + sectionPos.getX() + ", " + sectionPos.getY() + ", " + sectionPos.getZ());
+                // Replace the last update packet for the positions
+                for (short shortRelativePosition : sectionBlocksUpdatePacket.positions) {
+                    int x = sectionPos.relativeToBlockX(shortRelativePosition);
+                    int y = sectionPos.relativeToBlockY(shortRelativePosition);
+                    int z = sectionPos.relativeToBlockZ(shortRelativePosition);
+                    long blockKey = BlockPos.asLong(x, y, z);
+                    lastSomeBlocksUpdatePacketPerBlockPosKey.compute(blockKey, ($, existingQueuedPacket) -> {
+                        if (existingQueuedPacket != null) {
+                            // Cancel the existing queued packet if not protected
+//                            MinecraftServer.LOGGER.info("   Considering deleting old at position: " + existingQueuedPacket.index);
+                            if (existingQueuedPacket.canBeSafelyCancelledFromQueue(blockKey)) {
+                                existingQueuedPacket.cancel();
+                            }
+                        }
+                        // Return this new packet so it is now the last update packet for the position
+                        return queuedSectionBlocksUpdatePacket;
+                    });
+                }
+                // Remove any last block update packets within this section, since this packet is now the last update there
+//                LongSet blockPosKeys = blockPosKeysWithLastBlockUpdatePacketPerSectionPosKey.remove(sectionKey);
+//                if (blockPosKeys != null) {
+//                    for (long blockPosKey : blockPosKeys) {
+//                        QueuedBlockUpdatePacket blockUpdatePacket = lastBlockUpdatePacketPerBlockPosKey.remove(blockPosKey);
+//                        if (blockUpdatePacket.canBeSafelyCancelledFromQueue(false)) {
+//                            blockUpdatePacket.cancel();
+//                        }
+//                    }
+//                }
+            } else if (type == 3) {
+                ClientboundLightUpdatePacket lightUpdatePacket = (ClientboundLightUpdatePacket) packet;
+                long chunkKey = ChunkPos.asLong(lightUpdatePacket.getX(), lightUpdatePacket.getZ());
+                // Create the queued packet
+                queuedPacket = new QueuedPacket(queuedPacketIndex, packet, callbacks, type);
+                // Replace the last update packet for the position
+                final var finalQueuedPacket = queuedPacket;
+                lastLightUpdatePacketPerChunkPosKey.compute(chunkKey, ($, existingQueuedPacket) -> {
+                    if (existingQueuedPacket != null) {
+                        // Cancel the existing queued packet
+                        existingQueuedPacket.cancel();
+                    }
+                    // Return this new packet so it is now the last update packet for the position
+                    return finalQueuedPacket;
+                });
+            } else {
+                queuedPacket = new QueuedPacket(queuedPacketIndex, packet, callbacks, type);
+            }
+
+            // Enqueue the new packet
+            queuedPackets.put(queuedPacketIndex, queuedPacket);
+//            if (queuedPacket instanceof QueuedPistonBlockEventPacket || queuedPacket instanceof QueuedSomeBlocksUpdatePacket) {
+//                MinecraftServer.LOGGER.info("Enqueued a packet, queue is now: " + queuedPackets.values().stream().filter(it -> it instanceof QueuedPistonBlockEventPacket || it instanceof QueuedSomeBlocksUpdatePacket).map(it -> it.toString()).toList());
+//            }
+
+            return false;
+
+        } finally {
+            queuedPacketsLock.unlock();
+        }
+
+    }
+
+    private void tickQueuedPackets() {
+
+        // Update the available credits
+        queuedPacketsLock.lock();
+        try {
+            creditsForThisTick += creditsPerTick;
+            if (creditsForThisTick > maxTotalCredits) {
+                creditsForThisTick = maxTotalCredits;
+            }
+        } finally {
+            queuedPacketsLock.unlock();
+        }
+
+        // Send packets while possible
+        while (true) {
+            queuedPacketsLock.lock();
+            try {
+
+                if (creditsForThisTick <= 0 || queuedPackets.isEmpty()) {
+                    break;
+                }
+
+                QueuedPacket queuedPacket = queuedPackets.firstEntry().getValue();
+
+                // If this packet was cancelled, execute its callbacks at no credit cost
+                if (queuedPacket.packet == null) {
+                    if (queuedPacket.callbacks != null) {
+                        try {
+                            queuedPacket.callbacks.onSuccess();
+                        } catch (Exception e) {
+                            LOGGER.warn("An exception occurred while executing the callbacks of a cancelled queued packet:");
+                            e.printStackTrace();
+                        }
+                    }
+                    queuedPackets.pollFirstEntry();
+                    continue;
+                }
+
+                // Check if we have enough credit left, otherwise stop sending queued packets
+                int creditCost;
+                if (queuedPacket.type == 2) {
+                    creditCost = creditCostPerType[1] * Math.min(maxBlocksToCountForSectionUpdateCreditCost, ((QueuedSectionBlocksUpdatePacket) queuedPacket).sectionBlocksUpdatePacket.positions.length);
+                } else {
+                    creditCost = creditCostPerType[queuedPacket.type];
+                }
+                if (creditsForThisTick < creditCost) {
+                    break;
+                }
+                queuedPackets.pollFirstEntry();
+//                if (queuedPacket instanceof QueuedPistonBlockEventPacket || queuedPacket instanceof QueuedSomeBlocksUpdatePacket) {
+//                    MinecraftServer.LOGGER.info("Polled a packet, queue is now: " + queuedPackets.values().stream().filter(it -> it instanceof QueuedPistonBlockEventPacket || it instanceof QueuedSomeBlocksUpdatePacket).map(it -> it.toString()).toList());
+//                }
+                // Subtract the credit cost
+                creditsForThisTick -= creditCost;
+                if (queuedPacket.type == 0 && queuedPacket instanceof QueuedPistonBlockEventPacket pistonBlockEventPacket) {
+                    long blockKey = pistonBlockEventPacket.blockEventPacket.getPos().asLong();
+//                    MinecraftServer.LOGGER.info("- Piston = " + pistonBlockEventPacket.index + "  " + pistonBlockEventPacket.blockEventPacket.getPos().getX() + ", " + pistonBlockEventPacket.blockEventPacket.getPos().getY() + ", " + pistonBlockEventPacket.blockEventPacket.getPos().getZ());
+                    // Remove the last packet for the position if this is it
+                    lastPistonBlockEventPacketPerBlockPosKey.compute(blockKey, ($, existingLastPacket) -> {
+                        if (existingLastPacket == queuedPacket) {
+//                            MinecraftServer.LOGGER.info("   It was last so no longer last piston");
+                            return null;
+                        }
+                        return existingLastPacket;
+                    });
+                    pistonPacketsInQueue--;
+                    if (pistonPacketsInQueue % 100 == 0) {
+                        MinecraftServer.LOGGER.info("Piston packets in queue: " + pistonPacketsInQueue);
+                    }
+                    if (queuedPackets.size() % 1000 == 0) {
+                        MinecraftServer.LOGGER.info("Total in queue: " + queuedPackets.size());
+                    }
+                } else if (queuedPacket.type == 1 && queuedPacket instanceof QueuedBlockUpdatePacket blockUpdatePacket) {
+                    long blockKey = blockUpdatePacket.blockUpdatePacket.getPos().asLong();
+//                    MinecraftServer.LOGGER.info("- Block update = " + blockUpdatePacket.index + "  " + blockUpdatePacket.blockUpdatePacket.getPos().getX() + ", " + blockUpdatePacket.blockUpdatePacket.getPos().getY() + ", " + blockUpdatePacket.blockUpdatePacket.getPos().getZ());
+                    // Remove the last packet for the position if this is it
+                    lastSomeBlocksUpdatePacketPerBlockPosKey.compute(blockKey, ($, existingLastPacket) -> {
+                        if (existingLastPacket == queuedPacket) {
+                            // We must also remove it as being present in the last block keys of the section
+//                            long sectionKey = SectionPos.asLong(BlockPos.of(blockKey));
+//                            LongSet lastBlockKeys = blockPosKeysWithLastBlockUpdatePacketPerSectionPosKey.get(sectionKey);
+//                            if (lastBlockKeys != null) {
+//                                lastBlockKeys.remove(blockKey);
+//                            }
+//                            MinecraftServer.LOGGER.info("   It was last so no longer last block update");
+                            return null;
+                        }
+                        return existingLastPacket;
+                    });
+                } else if (queuedPacket.type == 2 && queuedPacket instanceof QueuedSectionBlocksUpdatePacket sectionBlocksUpdatePacket) {
+                    SectionPos sectionPos = sectionBlocksUpdatePacket.sectionBlocksUpdatePacket.sectionPos;
+//                    MinecraftServer.LOGGER.info("Sending section update of size " + sectionBlocksUpdatePacket.sectionBlocksUpdatePacket.positions.length);
+                    long sectionKey = sectionPos.asLong();
+//                    MinecraftServer.LOGGER.info("- Section update = " + sectionBlocksUpdatePacket.index + "  " + sectionBlocksUpdatePacket.sectionBlocksUpdatePacket.sectionPos.getX() + ", " + sectionBlocksUpdatePacket.sectionBlocksUpdatePacket.sectionPos.getY() + ", " + sectionBlocksUpdatePacket.sectionBlocksUpdatePacket.sectionPos.getZ());
+                    // Remove the last packet for the positions if this is it
+                    for (short shortRelativePosition : sectionBlocksUpdatePacket.sectionBlocksUpdatePacket.positions) {
+                        int x = sectionPos.relativeToBlockX(shortRelativePosition);
+                        int y = sectionPos.relativeToBlockY(shortRelativePosition);
+                        int z = sectionPos.relativeToBlockZ(shortRelativePosition);
+                        long blockKey = BlockPos.asLong(x, y, z);
+                        lastSomeBlocksUpdatePacketPerBlockPosKey.compute(blockKey, ($, existingLastPacket) -> {
+                            if (existingLastPacket == queuedPacket) {
+//                                MinecraftServer.LOGGER.info("   It was last so no longer last section update");
+                                return null;
+                            }
+                            return existingLastPacket;
+                        });
+                    }
+                } else if (queuedPacket.type == 3) {
+                    var lightUpdatePacket = (ClientboundLightUpdatePacket) queuedPacket.packet;
+                    long chunkKey = ChunkPos.asLong(lightUpdatePacket.getX(), lightUpdatePacket.getZ());
+                    // Remove the last packet for the position if this is it
+                    lastLightUpdatePacketPerChunkPosKey.compute(chunkKey, ($, existingLastPacket) -> {
+                        if (existingLastPacket == queuedPacket) {
+                            return null;
+                        }
+                        return existingLastPacket;
+                    });
+                }
+                if ((queuedPacket.type == 1 || queuedPacket.type == 2) && queuedPacket instanceof QueuedSomeBlocksUpdatePacket someBlocksUpdatePacket) {
+                    // Remove any known protections (otherwise this packet instance cannot be garbage collected due to an existing reference in the protecting queued piston packet)
+                    if (someBlocksUpdatePacket.protectingPistonBlockEventPackets != null) {
+                        for (QueuedPistonBlockEventPacket protectingPacket : someBlocksUpdatePacket.protectingPistonBlockEventPackets) {
+                            if (protectingPacket.protectedPackets != null) {
+                                for (int i = 0; i < protectingPacket.protectedPackets.length; i++) {
+                                    if (protectingPacket.protectedPackets[i] == someBlocksUpdatePacket) {
+                                        protectingPacket.protectedPackets[i] = null;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+                // Send the packet
+                immuneQueuedPacketBeingSent = queuedPacket.packet;
+                this.sendPacket(queuedPacket.packet, queuedPacket.callbacks);
+                immuneQueuedPacketBeingSent = null;
+
+            } finally {
+                queuedPacketsLock.unlock();
+            }
+        }
+
+    }
+
+    // Martijn end - limit packets per tick
+
     public void send(Packet<?> packet) {
         this.send(packet, (PacketSendListener) null);
     }
@@ -974,6 +1640,28 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         this.sendPacket(packet, callbacks, Boolean.TRUE);
     }
     private void sendPacket(Packet<?> packet, @Nullable PacketSendListener callbacks, Boolean flushConditional) {
+        // Martijn start - limit packets per tick
+        if (!isImmuneOtherwiseQueue(packet, callbacks)) {
+            return;
+        }
+//        if (packet instanceof ClientboundBlockEventPacket blockEventPacket) {
+//            if (!blockEventPacketsPerTickLimiter.isImmuneOtherwiseAdd(blockEventPacket, callbacks)) {
+//                return;
+//            }
+//        } else if (packet instanceof ClientboundBlockUpdatePacket blockUpdatePacket) {
+//            if (!blockUpdatePacketsPerTickLimiter.isImmuneOtherwiseAdd(blockUpdatePacket, callbacks)) {
+//                return;
+//            }
+//        } else if (packet instanceof ClientboundLightUpdatePacket lightUpdatePacket) {
+//            if (!lightUpdatePacketsPerTickLimiter.isImmuneOtherwiseAdd(lightUpdatePacket, callbacks)) {
+//                return;
+//            }
+//        } else if (packet instanceof ClientboundSectionBlocksUpdatePacket sectionBlocksUpdatePacket) {
+//            if (!sectionBlocksUpdatePacketsPerTickLimiter.isImmuneOtherwiseAdd(sectionBlocksUpdatePacket, callbacks)) {
+//                return;
+//            }
+//        }
+        // Martijn end - limit packets per tick
         this.packetWrites.getAndIncrement(); // must be befeore using canFlush
         // Martijn start - custom blocks and items
         // Replace the packet in case of custom falling blocks
@@ -1202,6 +1890,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     private static int currTick; // Paper
     public void tick() {
         this.tickUpdatePotentialBlockEntitiesInSectionSpawnNew(); // Martijn - custom blocks and items
+        this.tickQueuedPackets(); // Martijn - limit packets per tick
         this.flushQueue();
         // Paper start
         if (currTick != net.minecraft.server.MinecraftServer.currentTick) {
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
index 835954827bd9f57685ccb06e29c9d5b7fad50d52..a961fc28a5df6fe84bafd9cd1172ad7d671b73c6 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
@@ -30,9 +30,11 @@ import javax.annotation.Nullable;
 public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePacketListener>, CachableCustomContentReplaceable<ClientboundSectionBlocksUpdatePacket> { // Martijn - custom blocks and items
 
     private static final int POS_IN_SECTION_BITS = 12;
-    private final SectionPos sectionPos;
-    private final short[] positions;
-    private final BlockState[] states;
+    // Martijn start - limit packets per tick
+    public final SectionPos sectionPos;
+    public final short[] positions;
+    public final BlockState[] states;
+    // Martijn end - limit packets per tick
     private final boolean suppressLightUpdates;
 
     // Martijn start - custom blocks and items
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index bd98a2b48311d6c7c317e2e014da45d440573954..7ef2844b42745a186bf251881b4d3e84d9314fab 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -26,6 +26,8 @@ import java.util.Set;
 import java.util.UUID;
 import java.util.function.Function;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.chunk.PlayerChunkLoader;
 import net.minecraft.ChatFormatting;
 import net.minecraft.FileUtil;
 import net.minecraft.commands.CommandSourceStack;
@@ -43,6 +45,7 @@ import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.chat.OutgoingPlayerChatMessage;
 import net.minecraft.network.chat.PlayerChatMessage;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundBlockEventPacket;
 import net.minecraft.network.protocol.game.ClientboundChangeDifficultyPacket;
 import net.minecraft.network.protocol.game.ClientboundCustomPayloadPacket;
 import net.minecraft.network.protocol.game.ClientboundEntityEventPacket;
@@ -80,6 +83,7 @@ import net.minecraft.world.effect.MobEffectInstance;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.player.ProfilePublicKey;
+import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.GameRules;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.biome.BiomeManager;
@@ -1223,7 +1227,7 @@ public abstract class PlayerList {
     }
 
     public void broadcast(@Nullable net.minecraft.world.entity.player.Player player, double x, double y, double z, double distance, ResourceKey<Level> worldKey, Packet<?> packet) {
-        for (int i = 0; i < this.players.size(); ++i) {
+        forEachPlayer: for (int i = 0; i < this.players.size(); ++i) { // Martijn - limit packets per tick
             ServerPlayer entityplayer = (ServerPlayer) this.players.get(i);
 
             // CraftBukkit start - Test if player receiving packet can see the source of the packet
@@ -1233,6 +1237,21 @@ public abstract class PlayerList {
             // CraftBukkit end
 
             if (entityplayer != player && entityplayer.level.dimension() == worldKey) {
+                // Martijn start - limit packets per tick
+                if (packet instanceof ClientboundBlockEventPacket blockEventPacket) {
+                    var block = blockEventPacket;
+                    if (block.equals(Blocks.PISTON) || block.equals(Blocks.STICKY_PISTON)) {
+                        if (entityplayer.level instanceof ServerLevel serverLevel) {
+                            var chunkPos = new ChunkPos(blockEventPacket.getPos());
+                            PlayerChunkLoader playerChunkLoader = serverLevel.getChunkSource().chunkMap.playerChunkManager;
+                            PlayerChunkLoader.PlayerLoaderData data = playerChunkLoader.getData(entityplayer);
+                            if (!data.hasSentChunk(chunkPos.x, chunkPos.z, true)) {
+                                continue forEachPlayer;
+                            }
+                        }
+                    }
+                }
+                // Martijn end - limit packets per tick
                 double d4 = x - entityplayer.getX();
                 double d5 = y - entityplayer.getY();
                 double d6 = z - entityplayer.getZ();
diff --git a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
index c4b1a7f8743e81a9baddfa1b18140ff75b2f1dae..096b920c61e95723b3a93e8557e47870d5ffe7ff 100644
--- a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
@@ -288,6 +288,7 @@ public class PistonBaseBlock extends DirectionalBlock {
                     world.removeBlock(headPos, false);
                 } else {
                     ((ServerLevel)world).getChunkSource().blockChanged(headPos); // ... fix client desync
+                    ((ServerLevel)world).getChunkSource().blockChanged(headPos.relative(enumdirection)); // Martijn - limit packets per tick
                 }
                 // Paper end - fix headless pistons breaking blocks
             }
