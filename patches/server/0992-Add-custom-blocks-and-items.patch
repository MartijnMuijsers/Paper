From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Mon, 27 Jun 2022 01:04:35 +0200
Subject: [PATCH] Add custom blocks and items


diff --git a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java
index aabad39d13ead83042ec2e4dd7f4ed4966af650d..3cda0b29f3b56188d7b671ed55e9d52bfff1a1f2 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java
@@ -13,7 +13,7 @@ import net.minecraft.world.level.chunk.LevelChunk;
 
 public class ChunkPacketBlockController {
 
-    public static final ChunkPacketBlockController NO_OPERATION_INSTANCE = new ChunkPacketBlockController();
+    //public static final ChunkPacketBlockController NO_OPERATION_INSTANCE = new ChunkPacketBlockController(); // Martijn - custom blocks and items
 
     protected ChunkPacketBlockController() {
 
@@ -27,7 +27,7 @@ public class ChunkPacketBlockController {
         return false;
     }
 
-    public ChunkPacketInfo<BlockState> getChunkPacketInfo(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk) {
+    public ChunkPacketInfo<BlockState> getChunkPacketInfo(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk, boolean doesPlayerHaveResourcePack) { // Martijn - custom blocks and items
         return null;
     }
 
diff --git a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java
index a5d43901595f864c8a5dd5d013aa42d7f294e489..0fec5b98077ce888362870e5bc33b9d20bb093d2 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java
@@ -19,6 +19,8 @@ import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.EntityBlock;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.*;
+import nl.martijnmuijsers.paper.antixray.ChunkPacketBlockControllerModifier;
+import nl.martijnmuijsers.paper.antixray.ChunkPacketBlockControllerModifierBase;
 import org.bukkit.Bukkit;
 import org.spongepowered.configurate.serialize.ScalarSerializer;
 import org.spongepowered.configurate.serialize.SerializationException;
@@ -30,11 +32,9 @@ import java.util.concurrent.ThreadLocalRandom;
 import java.util.function.IntSupplier;
 import java.util.function.Predicate;
 
-public final class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockController {
+// Martijn start - custom blocks and items
+public class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockControllerModifierBase { // Martijn - custom blocks and items
 
-    private static final Palette<BlockState> GLOBAL_BLOCKSTATE_PALETTE = new GlobalPalette<>(Block.BLOCK_STATE_REGISTRY);
-    private static final LevelChunkSection EMPTY_SECTION = null;
-    private final Executor executor;
     private final EngineMode engineMode;
     private final int maxBlockHeight;
     private final int updateRadius;
@@ -56,7 +56,7 @@ public final class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockCo
     private final int maxBlockHeightUpdatePosition;
 
     public ChunkPacketBlockControllerAntiXray(Level level, Executor executor) {
-        this.executor = executor;
+        super(level, executor);
         WorldConfiguration.AntiCheat.AntiXRay paperWorldConfig = level.paperConfig().anticheat.antiXray;
         engineMode = paperWorldConfig.engineMode;
         maxBlockHeight = paperWorldConfig.maxBlockHeight >> 4 << 4;
@@ -168,44 +168,24 @@ public final class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockCo
         return !usePermission || !player.getBukkitEntity().hasPermission("paper.antixray.bypass");
     }
 
-    @Override
-    public ChunkPacketInfoAntiXray getChunkPacketInfo(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk) {
-        // Return a new instance to collect data and objects in the right state while creating the chunk packet for thread safe access later
-        return new ChunkPacketInfoAntiXray(chunkPacket, chunk, this);
-    }
-
-    @Override
-    public void modifyBlocks(ClientboundLevelChunkWithLightPacket chunkPacket, ChunkPacketInfo<BlockState> chunkPacketInfo) {
-        if (!(chunkPacketInfo instanceof ChunkPacketInfoAntiXray)) {
-            chunkPacket.setReady(true);
-            return;
-        }
-
-        if (!Bukkit.isPrimaryThread()) {
-            // Plugins?
-            MinecraftServer.getServer().scheduleOnMain(() -> modifyBlocks(chunkPacket, chunkPacketInfo));
-            return;
-        }
-
-        LevelChunk chunk = chunkPacketInfo.getChunk();
-        int x = chunk.getPos().x;
-        int z = chunk.getPos().z;
-        Level level = chunk.getLevel();
-        ((ChunkPacketInfoAntiXray) chunkPacketInfo).setNearbyChunks(level.getChunkIfLoaded(x - 1, z), level.getChunkIfLoaded(x + 1, z), level.getChunkIfLoaded(x, z - 1), level.getChunkIfLoaded(x, z + 1));
-        executor.execute((Runnable) chunkPacketInfo);
-    }
-
     // Actually these fields should be variables inside the obfuscate method but in sync mode or with SingleThreadExecutor in async mode it's okay (even without ThreadLocal)
     // If an ExecutorService with multiple threads is used, ThreadLocal must be used here
     private final ThreadLocal<int[]> presetBlockStateBits = ThreadLocal.withInitial(() -> new int[getPresetBlockStatesFullLength()]);
-    private static final ThreadLocal<boolean[]> SOLID = ThreadLocal.withInitial(() -> new boolean[Block.BLOCK_STATE_REGISTRY.size()]);
-    private static final ThreadLocal<boolean[]> OBFUSCATE = ThreadLocal.withInitial(() -> new boolean[Block.BLOCK_STATE_REGISTRY.size()]);
+    protected static final ThreadLocal<boolean[]> SOLID = ThreadLocal.withInitial(() -> new boolean[Block.BLOCK_STATE_REGISTRY.size()]);
+    protected static final ThreadLocal<boolean[]> OBFUSCATE = ThreadLocal.withInitial(() -> new boolean[Block.BLOCK_STATE_REGISTRY.size()]);
     // These boolean arrays represent chunk layers, true means don't obfuscate, false means obfuscate
-    private static final ThreadLocal<boolean[][]> CURRENT = ThreadLocal.withInitial(() -> new boolean[16][16]);
-    private static final ThreadLocal<boolean[][]> NEXT = ThreadLocal.withInitial(() -> new boolean[16][16]);
-    private static final ThreadLocal<boolean[][]> NEXT_NEXT = ThreadLocal.withInitial(() -> new boolean[16][16]);
+    protected static final ThreadLocal<boolean[][]> CURRENT = ThreadLocal.withInitial(() -> new boolean[16][16]);
+    protected static final ThreadLocal<boolean[][]> NEXT = ThreadLocal.withInitial(() -> new boolean[16][16]);
+    protected static final ThreadLocal<boolean[][]> NEXT_NEXT = ThreadLocal.withInitial(() -> new boolean[16][16]);
 
-    public void obfuscate(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+    // Martijn start- custom blocks and items
+    @Override
+    public void obfuscateInternal(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        this.obfuscateXray(chunkPacketInfoAntiXray);
+    }
+
+    public void obfuscateXray(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        // Martijn end - custom blocks and items
         int[] presetBlockStateBits = this.presetBlockStateBits.get();
         boolean[] solid = SOLID.get();
         boolean[] obfuscate = OBFUSCATE.get();
@@ -349,8 +329,6 @@ public final class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockCo
                 bitStorageWriter.flush();
             }
         }
-
-        chunkPacketInfoAntiXray.getChunkPacket().setReady(true);
     }
 
     private void obfuscateLayer(int y, BitStorageReader bitStorageReader, BitStorageWriter bitStorageWriter, boolean[] solid, boolean[] obfuscate, int[] presetBlockStateBits, boolean[][] current, boolean[][] next, boolean[][] nextNext, LevelChunkSection[] nearbyChunkSections, IntSupplier random) {
@@ -690,3 +668,4 @@ public final class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockCo
         }
     }
 }
+// Martijn end - custom blocks and items
diff --git a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfo.java b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfo.java
index d98a3f5c54c67a673eb7dc456dd039cd78f9c34d..7e9b89c8d18df38831f0e5a4945c65b1285fc7a0 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfo.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfo.java
@@ -13,6 +13,7 @@ public class ChunkPacketInfo<T> {
     private final int[] indexes;
     private final Object[][] presetValues;
     private byte[] buffer;
+    private final int[] paletteIndexes; // Martijn - custom blocks and items
 
     public ChunkPacketInfo(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk) {
         this.chunkPacket = chunkPacket;
@@ -22,6 +23,7 @@ public class ChunkPacketInfo<T> {
         palettes = new Object[sections];
         indexes = new int[sections];
         presetValues = new Object[sections][];
+        paletteIndexes = new int[sections]; // Martijn - custom blocks and items
     }
 
     public ClientboundLevelChunkWithLightPacket getChunkPacket() {
@@ -74,6 +76,18 @@ public class ChunkPacketInfo<T> {
         this.presetValues[chunkSectionIndex] = presetValues;
     }
 
+    // Martijn start - custom blocks and items
+
+    public int getPaletteIndex(int chunkSectionIndex) {
+        return paletteIndexes[chunkSectionIndex];
+    }
+
+    public void setPaletteIndex(int chunkSectionIndex, int paletteIndex) {
+        paletteIndexes[chunkSectionIndex] = paletteIndex;
+    }
+
+    // Martijn end - custom blocks and items
+
     public boolean isWritten(int chunkSectionIndex) {
         return bits[chunkSectionIndex] != 0;
     }
diff --git a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfoAntiXray.java b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfoAntiXray.java
index 80a2dfb266ae1221680a7b24fee2f7e2a8330b7d..48bc2e20e45183733ec5b1e545ce0d371b3e1ad0 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfoAntiXray.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfoAntiXray.java
@@ -3,15 +3,21 @@ package com.destroystokyo.paper.antixray;
 import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.LevelChunk;
+import nl.martijnmuijsers.paper.antixray.ChunkPacketBlockControllerAntiXrayCustom;
+import nl.martijnmuijsers.paper.antixray.ChunkPacketBlockControllerModifier;
 
 public final class ChunkPacketInfoAntiXray extends ChunkPacketInfo<BlockState> implements Runnable {
 
-    private final ChunkPacketBlockControllerAntiXray chunkPacketBlockControllerAntiXray;
+    // Martijn start - custom blocks and items
+    private final ChunkPacketBlockControllerModifier chunkPacketBlockControllerAntiXray;
+    public final boolean doesPlayerHaveResourcePack;
+    // Martijn end - custom blocks and items
     private LevelChunk[] nearbyChunks;
 
-    public ChunkPacketInfoAntiXray(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk, ChunkPacketBlockControllerAntiXray chunkPacketBlockControllerAntiXray) {
+    public ChunkPacketInfoAntiXray(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk, ChunkPacketBlockControllerModifier chunkPacketBlockControllerAntiXray, boolean doesPlayerHaveResourcePack) { // Martijn - custom blocks and items
         super(chunkPacket, chunk);
         this.chunkPacketBlockControllerAntiXray = chunkPacketBlockControllerAntiXray;
+        this.doesPlayerHaveResourcePack = doesPlayerHaveResourcePack;
     }
 
     public LevelChunk[] getNearbyChunks() {
diff --git a/src/main/java/net/minecraft/data/loot/BlockLoot.java b/src/main/java/net/minecraft/data/loot/BlockLoot.java
index 2ae3cf188ed5ab1266b1aae796fecce02f517908..ebad557399e1f3e965a45a1f0252762ed9dd91af 100644
--- a/src/main/java/net/minecraft/data/loot/BlockLoot.java
+++ b/src/main/java/net/minecraft/data/loot/BlockLoot.java
@@ -88,6 +88,7 @@ import net.minecraft.world.level.storage.loot.providers.number.BinomialDistribut
 import net.minecraft.world.level.storage.loot.providers.number.ConstantValue;
 import net.minecraft.world.level.storage.loot.providers.number.NumberProvider;
 import net.minecraft.world.level.storage.loot.providers.number.UniformGenerator;
+import nl.martijnmuijsers.paper.block.SuCraftBlockLoot;
 
 public class BlockLoot implements Consumer<BiConsumer<ResourceLocation, LootTable.Builder>> {
     private static final LootItemCondition.Builder HAS_SILK_TOUCH = MatchTool.toolMatches(ItemPredicate.Builder.item().hasEnchantment(new EnchantmentPredicate(Enchantments.SILK_TOUCH, MinMaxBounds.Ints.atLeast(1))));
@@ -1312,6 +1313,10 @@ public class BlockLoot implements Consumer<BiConsumer<ResourceLocation, LootTabl
         this.add(Blocks.POWDER_SNOW, noDrop());
         this.add(Blocks.FROGSPAWN, noDrop());
         this.add(Blocks.REINFORCED_DEEPSLATE, noDrop());
+
+        // Martijn start - custom blocks and items
+        SuCraftBlockLoot.accept(this, biConsumer);
+
         Set<ResourceLocation> set = Sets.newHashSet();
 
         for(Block block : Registry.BLOCK) {
diff --git a/src/main/java/net/minecraft/network/Connection.java b/src/main/java/net/minecraft/network/Connection.java
index aca0dc4ce75b25409b057fe94362276c682cdc21..8e6acb8d6abd5ecfed6b0a72e68ea6320e08fc17 100644
--- a/src/main/java/net/minecraft/network/Connection.java
+++ b/src/main/java/net/minecraft/network/Connection.java
@@ -40,13 +40,17 @@ import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.PacketFlow;
 import net.minecraft.network.protocol.game.ClientboundDisconnectPacket;
 import net.minecraft.network.protocol.login.ClientboundLoginDisconnectPacket;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.RunningOnDifferentThreadException;
 import net.minecraft.server.network.ServerGamePacketListenerImpl;
 import net.minecraft.server.network.ServerLoginPacketListenerImpl;
 import net.minecraft.util.LazyLoadedValue;
 import net.minecraft.util.Mth;
+import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.level.chunk.LevelChunk;
 import org.apache.commons.lang3.Validate;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.slf4j.Logger;
 import org.slf4j.Marker;
 import org.slf4j.MarkerFactory;
@@ -327,6 +331,19 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             return null;
         }
     }
+
+    // Martijn start - custom blocks and items
+
+    public boolean doesPlayerHaveSuCraftResourcePack() {
+        var player = getPlayer();
+        if (player == null) {
+            return false;
+        }
+        return player.hasSuCraftResourcePack();
+    }
+
+    // Martijn end - custom blocks and items
+
     private static class InnerUtil { // Attempt to hide these methods from ProtocolLib so it doesn't accidently pick them up.
         private static java.util.List<Packet> buildExtraPackets(Packet packet) {
             java.util.List<Packet> extra = packet.getExtraPackets();
@@ -433,20 +450,22 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             this.channel.config().setAutoRead(false);
         }
 
+        Packet<?> modifiedPacket = packet.replaceCustomContent(this.doesPlayerHaveSuCraftResourcePack()); // Martijn - custom blocks and items
+
         if (this.channel.eventLoop().inEventLoop()) {
-            this.doSendPacket(packet, callback, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter
+            this.doSendPacket(modifiedPacket, callback, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter // Martijn - custom blocks and items
         } else {
             // Paper start - optimise packets that are not flushed
             // note: since the type is not dynamic here, we need to actually copy the old executor code
             // into two branches. On conflict, just re-copy - no changes were made inside the executor code.
             if (!flush) {
                 AbstractEventExecutor.LazyRunnable run = () -> {
-                    this.doSendPacket(packet, callback, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter
+                    this.doSendPacket(modifiedPacket, callback, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter // Martijn - custom blocks and items
                 };
                 this.channel.eventLoop().execute(run);
             } else { // Paper end - optimise packets that are not flushed
             this.channel.eventLoop().execute(() -> {
-                this.doSendPacket(packet, callback, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter // Paper - diff on change
+                this.doSendPacket(modifiedPacket, callback, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter // Paper - diff on change // Martijn - custom blocks and items
             });
             } // Paper
         }
diff --git a/src/main/java/net/minecraft/network/FriendlyByteBuf.java b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
index 35377576ed182814051c11f902e02e8e921e84e3..3f51ff05e21190b828c10e098bf96ec70ca3ea9b 100644
--- a/src/main/java/net/minecraft/network/FriendlyByteBuf.java
+++ b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
@@ -83,6 +83,8 @@ public class FriendlyByteBuf extends ByteBuf {
     private static final int MAX_PUBLIC_KEY_HEADER_SIZE = 256;
     private static final int MAX_PUBLIC_KEY_LENGTH = 512;
 
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack = null; // Martijn - custom blocks and items
+
     public FriendlyByteBuf(ByteBuf parent) {
         this.source = parent;
     }
@@ -513,6 +515,28 @@ public class FriendlyByteBuf extends ByteBuf {
         return this;
     }
 
+    // Martijn start - custom blocks and items
+
+    /**
+     * We may want to change the palette of chunk packets on the fly, but we can't do that if the palette values are already written to the buffer with a VarInt type (since then, if they are no longer the same length in bytes as a VarInt, we would have to move up all following data in the buffer)
+     * <br>
+     * Therefore, we introduce this method: it will write exactly 3 bytes (which is the minimum needed to encode all possible block states using a VarInt), but still in the VarInt format so that the client can read it properly
+     *
+     * @see #writeVarInt
+     */
+    public FriendlyByteBuf writeVarIntThreeBytes(int value) {
+        // First write two bytes
+        this.writeByte(value & 127 | 128);
+        value >>>= 7;
+        this.writeByte(value & 127 | 128);
+        value >>>= 7;
+        // Then write the last byte
+        this.writeByte(value);
+        return this;
+    }
+
+    // Martijn end - custom blocks and items
+
     public FriendlyByteBuf writeVarLong(long value) {
         while ((value & -128L) != 0L) {
             this.writeByte((int) (value & 127L) | 128);
@@ -572,6 +596,16 @@ public class FriendlyByteBuf extends ByteBuf {
             this.writeBoolean(true);
             Item item = stack.getItem();
 
+            // Martijn start - custom blocks and items
+            if (item.replacementRule != null && doesNetworkTargetHaveResourcePack != null) {
+                ItemStack replacedStack = item.replacementRule.replace(stack, doesNetworkTargetHaveResourcePack);
+                if (replacedStack != null) {
+                    stack = replacedStack;
+                    item = replacedStack.getItem();
+                }
+            }
+            // Martijn end - custom blocks and items
+
             this.writeId(Registry.ITEM, item);
             this.writeByte(stack.getCount());
             CompoundTag nbttagcompound = null;
diff --git a/src/main/java/net/minecraft/network/PacketEncoder.java b/src/main/java/net/minecraft/network/PacketEncoder.java
index 5fce1177e7198d791d4ab1c64b394c5b1c145782..aa71fb123042375367792d300ac80ca78aed36d8 100644
--- a/src/main/java/net/minecraft/network/PacketEncoder.java
+++ b/src/main/java/net/minecraft/network/PacketEncoder.java
@@ -38,6 +38,9 @@ public class PacketEncoder extends MessageToByteEncoder<Packet<?>> {
 
                 try {
                     int i = friendlyByteBuf.writerIndex();
+                    // Martijn start - custom blocks and items
+                    friendlyByteBuf.doesNetworkTargetHaveResourcePack = packet.doesNetworkTargetHaveResourcePack();
+                    // Martijn end - custom blocks and items
                     packet.write(friendlyByteBuf);
                     int j = friendlyByteBuf.writerIndex() - i;
                     if (j > 8388608) {
diff --git a/src/main/java/net/minecraft/network/protocol/Packet.java b/src/main/java/net/minecraft/network/protocol/Packet.java
index e8fcd56906d26f6dc87959e32c4c7c78cfea9658..87093defb3d443b9a90e6fb7bc48b0acd8318269 100644
--- a/src/main/java/net/minecraft/network/protocol/Packet.java
+++ b/src/main/java/net/minecraft/network/protocol/Packet.java
@@ -2,6 +2,9 @@ package net.minecraft.network.protocol;
 
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.PacketListener;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
 public interface Packet<T extends PacketListener> {
     void write(FriendlyByteBuf buf);
@@ -30,4 +33,25 @@ public interface Packet<T extends PacketListener> {
     default boolean isSkippable() {
         return false;
     }
+
+    // Martijn start - custom blocks and items
+
+    /**
+     * Replaces any custom blocks or items in this packet will their intended replacement, based
+     * on whether a player has accepted the resource pack.
+     *
+     * This will usually replace the custom content in-place, returning this instance itself. However, when there is
+     * a real risk of a single packet instance with custom content to be replaced being sent to multiple players with
+     * differing resource pack statuses, this method may return a different instance.
+     */
+    default @NotNull Packet<T> replaceCustomContent(boolean hasResourcePack) {
+        return this;
+    }
+
+    default @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return null;
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockUpdatePacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockUpdatePacket.java
index 7b4947aa2cdd7f359184689bf348560bde1016dd..71a6b1ce0f4116578a99ed255ae94ab9896f95f9 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockUpdatePacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockUpdatePacket.java
@@ -6,10 +6,15 @@ import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.state.BlockState;
+import nl.martijnmuijsers.paper.protocol.CachableCustomContentReplaceable;
+import nl.martijnmuijsers.paper.protocol.ReplacedCustomContentCache;
+import org.jetbrains.annotations.NotNull;
 
-public class ClientboundBlockUpdatePacket implements Packet<ClientGamePacketListener> {
+import java.util.Arrays;
+
+public class ClientboundBlockUpdatePacket implements Packet<ClientGamePacketListener>, CachableCustomContentReplaceable<ClientboundBlockUpdatePacket> { // Martijn - custom blocks and items
     private final BlockPos pos;
-    public final BlockState blockState;
+    public BlockState blockState; // Martijn - custom blocks and items
 
     public ClientboundBlockUpdatePacket(BlockPos pos, BlockState state) {
         this.pos = pos;
@@ -43,4 +48,34 @@ public class ClientboundBlockUpdatePacket implements Packet<ClientGamePacketList
     public BlockPos getPos() {
         return this.pos;
     }
+
+    // Martijn start - custom blocks and items
+
+    private final ReplacedCustomContentCache<ClientboundBlockUpdatePacket> replacedCustomContentCache = new ReplacedCustomContentCache<>(this);
+
+    @Override
+    public @NotNull ClientboundBlockUpdatePacket replaceCustomContent(boolean hasResourcePack) {
+        return this.replacedCustomContentCache.get(hasResourcePack);
+    }
+
+    @Override
+    public @NotNull ClientboundBlockUpdatePacket copy() {
+        return new ClientboundBlockUpdatePacket(
+            this.pos,
+            this.blockState
+        );
+    }
+
+    @Override
+    public void replaceCustomContentInPlace(boolean hasResourcePack) {
+        var stateIdReplacementArray = hasResourcePack ? Block.stateIdReplacementArrayWithResourcePack : Block.stateIdReplacementArrayWithoutResourcePack;
+        int oldId = Block.BLOCK_STATE_REGISTRY.getId(this.blockState);
+        int newId = stateIdReplacementArray[oldId];
+        if (oldId != newId) {
+            this.blockState = Block.BLOCK_STATE_REGISTRY.byId(newId);
+        }
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetContentPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetContentPacket.java
index dbd8b9b09b82c1b75e8be9dc7416d9f0863c8c87..9c365f5e2690d4550aa5d9c74e3e2773b5584424 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetContentPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetContentPacket.java
@@ -5,12 +5,16 @@ import net.minecraft.core.NonNullList;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.item.ItemStack;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
 public class ClientboundContainerSetContentPacket implements Packet<ClientGamePacketListener> {
     private final int containerId;
     private final int stateId;
     private final List<ItemStack> items;
     private final ItemStack carriedItem;
+    private @Nullable Boolean doesNetworkTargetHaveResourcePack = null; // Martijn - custom blocks and items
 
     public ClientboundContainerSetContentPacket(int syncId, int revision, NonNullList<ItemStack> contents, ItemStack cursorStack) {
         this.containerId = syncId;
@@ -69,4 +73,20 @@ public class ClientboundContainerSetContentPacket implements Packet<ClientGamePa
     public int getStateId() {
         return this.stateId;
     }
+
+    // Martijn start - custom blocks and items
+
+    @Override
+    public @NotNull ClientboundContainerSetContentPacket replaceCustomContent(boolean hasResourcePack) {
+        this.doesNetworkTargetHaveResourcePack = hasResourcePack;
+        return this;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return this.doesNetworkTargetHaveResourcePack;
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetSlotPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetSlotPacket.java
index 13ee7ad9c9415cd785b5487de7131c932c2198a0..ae5f670d7ef1f1a482a6e3429f2213dff2270be8 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetSlotPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetSlotPacket.java
@@ -3,6 +3,9 @@ package net.minecraft.network.protocol.game;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.item.ItemStack;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
 public class ClientboundContainerSetSlotPacket implements Packet<ClientGamePacketListener> {
     public static final int CARRIED_ITEM = -1;
@@ -11,6 +14,7 @@ public class ClientboundContainerSetSlotPacket implements Packet<ClientGamePacke
     private final int stateId;
     private final int slot;
     private final ItemStack itemStack;
+    private @Nullable Boolean doesNetworkTargetHaveResourcePack = null; // Martijn - custom blocks and items
 
     public ClientboundContainerSetSlotPacket(int syncId, int revision, int slot, ItemStack stack) {
         this.containerId = syncId;
@@ -54,4 +58,20 @@ public class ClientboundContainerSetSlotPacket implements Packet<ClientGamePacke
     public int getStateId() {
         return this.stateId;
     }
+
+    // Martijn start - custom blocks and items
+
+    @Override
+    public @NotNull ClientboundContainerSetSlotPacket replaceCustomContent(boolean hasResourcePack) {
+        this.doesNetworkTargetHaveResourcePack = hasResourcePack;
+        return this;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return this.doesNetworkTargetHaveResourcePack;
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
index 6c30f3bf85ec0e0dfbae1b5ed192b43b1dbd48be..721840c7e1280be5cb79add9f0da76c424573975 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
@@ -191,4 +191,19 @@ public class ClientboundLevelChunkPacketData {
     public interface BlockEntityTagOutput {
         void accept(BlockPos pos, BlockEntityType<?> type, @Nullable CompoundTag nbt);
     }
+
+    // Martijn start - custom blocks and items
+
+//    /**
+//     * Replaces any custom blocks or items in this packet will their intended replacement, based
+//     * on whether a player has accepted the resource pack.
+//     *
+//     * The replacement is performed in-place.
+//     */
+//    default void replaceCustomContent(boolean hasResourcePack) {
+//
+//    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
index 2072aa8710f6e285f7c8f76c63b7bcf85cc11030..b0fbfd9f32bb73d9ac7f6487235c9ea52f4fbf7c 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
@@ -27,9 +27,11 @@ public class ClientboundLevelChunkWithLightPacket implements Packet<ClientGamePa
     // Paper end
 
     // Paper start - Anti-Xray - Add chunk packet info
-    @Deprecated public ClientboundLevelChunkWithLightPacket(LevelChunk chunk, LevelLightEngine lightProvider, @Nullable BitSet skyBits, @Nullable BitSet blockBits, boolean nonEdge) { this(chunk, lightProvider, skyBits, blockBits, nonEdge, true); } // Notice for updates: Please make sure this constructor isn't used anywhere
-    public ClientboundLevelChunkWithLightPacket(LevelChunk chunk, LevelLightEngine lightProvider, @Nullable BitSet skyBits, @Nullable BitSet blockBits, boolean nonEdge, boolean modifyBlocks) {
-        com.destroystokyo.paper.antixray.ChunkPacketInfo<net.minecraft.world.level.block.state.BlockState> chunkPacketInfo = modifyBlocks ? chunk.getLevel().chunkPacketBlockController.getChunkPacketInfo(this, chunk) : null;
+    // Martijn start - custom blocks and items
+    @Deprecated public ClientboundLevelChunkWithLightPacket(LevelChunk chunk, LevelLightEngine lightProvider, @Nullable BitSet skyBits, @Nullable BitSet blockBits, boolean nonEdge, boolean doesPlayerHaveResourcePack) { this(chunk, lightProvider, skyBits, blockBits, nonEdge, true, doesPlayerHaveResourcePack); } // Notice for updates: Please make sure this constructor isn't used anywhere
+    public ClientboundLevelChunkWithLightPacket(LevelChunk chunk, LevelLightEngine lightProvider, @Nullable BitSet skyBits, @Nullable BitSet blockBits, boolean nonEdge, boolean modifyBlocks, boolean doesPlayerHaveResourcePack) {
+        com.destroystokyo.paper.antixray.ChunkPacketInfo<net.minecraft.world.level.block.state.BlockState> chunkPacketInfo = modifyBlocks ? chunk.getLevel().chunkPacketBlockController.getChunkPacketInfo(this, chunk, doesPlayerHaveResourcePack) : null;
+        // Martijn end - custom blocks and items
         ChunkPos chunkPos = chunk.getPos();
         this.x = chunkPos.x;
         this.z = chunkPos.z;
@@ -81,4 +83,15 @@ public class ClientboundLevelChunkWithLightPacket implements Packet<ClientGamePa
         return this.chunkData.getExtraPackets();
     }
     // Paper end
+
+    // Martijn start - custom blocks and items
+
+//    @Override
+//    public @NotNull ClientboundLevelChunkWithLightPacket replaceCustomContent(boolean hasResourcePack) {
+//        chunkData.replaceCustomContent(hasResourcePack);
+//        return this;
+//    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundMerchantOffersPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundMerchantOffersPacket.java
index dc31aa80ead5765e0b8cc63aa890966ab0bf94a4..e9a0730ad565fb00cdfa82f5a5cd7fdebfcfed9e 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundMerchantOffersPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundMerchantOffersPacket.java
@@ -3,6 +3,9 @@ package net.minecraft.network.protocol.game;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.item.trading.MerchantOffers;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
 public class ClientboundMerchantOffersPacket implements Packet<ClientGamePacketListener> {
     private final int containerId;
@@ -11,6 +14,7 @@ public class ClientboundMerchantOffersPacket implements Packet<ClientGamePacketL
     private final int villagerXp;
     private final boolean showProgress;
     private final boolean canRestock;
+    private @Nullable Boolean doesNetworkTargetHaveResourcePack = null; // Martijn - custom blocks and items
 
     public ClientboundMerchantOffersPacket(int syncId, MerchantOffers recipes, int levelProgress, int experience, boolean leveled, boolean refreshable) {
         this.containerId = syncId;
@@ -68,4 +72,20 @@ public class ClientboundMerchantOffersPacket implements Packet<ClientGamePacketL
     public boolean canRestock() {
         return this.canRestock;
     }
+
+    // Martijn start - custom blocks and items
+
+    @Override
+    public @NotNull ClientboundMerchantOffersPacket replaceCustomContent(boolean hasResourcePack) {
+        this.doesNetworkTargetHaveResourcePack = hasResourcePack;
+        return this;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return this.doesNetworkTargetHaveResourcePack;
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
index 652bea6868a03a5315965f79c76172fb9dbb93fb..2198a52553c569d5b7ec9588e412b8f9e7314ee3 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
@@ -2,6 +2,8 @@ package net.minecraft.network.protocol.game;
 
 import it.unimi.dsi.fastutil.shorts.ShortIterator;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
+
+import java.util.Arrays;
 import java.util.function.BiConsumer;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
@@ -10,8 +12,11 @@ import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.LevelChunkSection;
+import nl.martijnmuijsers.paper.protocol.CachableCustomContentReplaceable;
+import nl.martijnmuijsers.paper.protocol.ReplacedCustomContentCache;
+import org.jetbrains.annotations.NotNull;
 
-public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePacketListener> {
+public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePacketListener>, CachableCustomContentReplaceable<ClientboundSectionBlocksUpdatePacket> { // Martijn - custom blocks and items
 
     private static final int POS_IN_SECTION_BITS = 12;
     private final SectionPos sectionPos;
@@ -19,6 +24,17 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
     private final BlockState[] states;
     private final boolean suppressLightUpdates;
 
+    // Martijn start - custom blocks and items
+
+    public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, short[] positions, BlockState[] states, boolean suppressLightUpdates) {
+        this.sectionPos = sectionPos;
+        this.positions = positions;
+        this.states = states;
+        this.suppressLightUpdates = suppressLightUpdates;
+    }
+
+    // Martijn end - custom blocks and items
+
     public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, ShortSet positions, LevelChunkSection section, boolean noLightingUpdates) {
         this.sectionPos = sectionPos;
         this.suppressLightUpdates = noLightingUpdates;
@@ -94,4 +110,38 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
     public boolean shouldSuppressLightUpdates() {
         return this.suppressLightUpdates;
     }
+
+    // Martijn start - custom blocks and items
+
+    private final ReplacedCustomContentCache<ClientboundSectionBlocksUpdatePacket> replacedCustomContentCache = new ReplacedCustomContentCache<>(this);
+
+    @Override
+    public @NotNull ClientboundSectionBlocksUpdatePacket replaceCustomContent(boolean hasResourcePack) {
+       return this.replacedCustomContentCache.get(hasResourcePack);
+    }
+
+    @Override
+    public @NotNull ClientboundSectionBlocksUpdatePacket copy() {
+        return new ClientboundSectionBlocksUpdatePacket(
+            this.sectionPos,
+            this.positions,
+            Arrays.copyOf(this.states, this.states.length),
+            this.suppressLightUpdates
+        );
+    }
+
+    @Override
+    public void replaceCustomContentInPlace(boolean hasResourcePack) {
+        var stateIdReplacementArray = hasResourcePack ? Block.stateIdReplacementArrayWithResourcePack : Block.stateIdReplacementArrayWithoutResourcePack;
+        for (int i = 0; i < this.states.length; i++) {
+            int oldId = Block.BLOCK_STATE_REGISTRY.getId(states[i]);
+            int newId = stateIdReplacementArray[oldId];
+            if (oldId != newId) {
+                this.states[i] = Block.BLOCK_STATE_REGISTRY.byId(newId);
+            }
+        }
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityDataPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityDataPacket.java
index 3e17f6131bf590d7c4a16b79c1c145cb4f565bc9..bcb7128942e4c21ae86d38ded369b5a54644f6e2 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityDataPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityDataPacket.java
@@ -5,11 +5,13 @@ import javax.annotation.Nullable;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.syncher.SynchedEntityData;
+import org.jetbrains.annotations.NotNull;
 
 public class ClientboundSetEntityDataPacket implements Packet<ClientGamePacketListener> {
     private final int id;
     @Nullable
     private final List<SynchedEntityData.DataItem<?>> packedItems;
+    private @Nullable Boolean doesNetworkTargetHaveResourcePack = null; // Martijn - custom blocks and items
 
     public ClientboundSetEntityDataPacket(int id, SynchedEntityData tracker, boolean forceUpdateAll) {
         this.id = id;
@@ -46,4 +48,20 @@ public class ClientboundSetEntityDataPacket implements Packet<ClientGamePacketLi
     public int getId() {
         return this.id;
     }
+
+    // Martijn start - custom blocks and items
+
+    @Override
+    public @NotNull ClientboundSetEntityDataPacket replaceCustomContent(boolean hasResourcePack) {
+        this.doesNetworkTargetHaveResourcePack = hasResourcePack;
+        return this;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return this.doesNetworkTargetHaveResourcePack;
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEquipmentPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEquipmentPacket.java
index 5a8f850b447fc3a4bd0eb0c505bbdfc8be7115e8..ee192354da1d257407f6f1131a1b4a0a56bb0bcc 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEquipmentPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEquipmentPacket.java
@@ -7,11 +7,15 @@ import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.entity.EquipmentSlot;
 import net.minecraft.world.item.ItemStack;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
 public class ClientboundSetEquipmentPacket implements Packet<ClientGamePacketListener> {
     private static final byte CONTINUE_MASK = -128;
     private final int entity;
     private final List<Pair<EquipmentSlot, ItemStack>> slots;
+    private @Nullable Boolean doesNetworkTargetHaveResourcePack = null; // Martijn - custom blocks and items
 
     public ClientboundSetEquipmentPacket(int id, List<Pair<EquipmentSlot, ItemStack>> equipmentList) {
         this.entity = id;
@@ -61,4 +65,20 @@ public class ClientboundSetEquipmentPacket implements Packet<ClientGamePacketLis
     public List<Pair<EquipmentSlot, ItemStack>> getSlots() {
         return this.slots;
     }
+
+    // Martijn start - custom blocks and items
+
+    @Override
+    public @NotNull ClientboundSetEquipmentPacket replaceCustomContent(boolean hasResourcePack) {
+        this.doesNetworkTargetHaveResourcePack = hasResourcePack;
+        return this;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return this.doesNetworkTargetHaveResourcePack;
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateAdvancementsPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateAdvancementsPacket.java
index 053a66d714168f5e8a7cc5ff532190e80de887ca..3b9f109f8fe1e8d00113ccb9234b6e0d81b448d1 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateAdvancementsPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateAdvancementsPacket.java
@@ -11,12 +11,16 @@ import net.minecraft.advancements.AdvancementProgress;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.resources.ResourceLocation;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
 public class ClientboundUpdateAdvancementsPacket implements Packet<ClientGamePacketListener> {
     private final boolean reset;
     private final Map<ResourceLocation, Advancement.Builder> added;
     private final Set<ResourceLocation> removed;
     private final Map<ResourceLocation, AdvancementProgress> progress;
+    private @Nullable Boolean doesNetworkTargetHaveResourcePack = null; // Martijn - custom blocks and items
 
     public ClientboundUpdateAdvancementsPacket(boolean clearCurrent, Collection<Advancement> toEarn, Set<ResourceLocation> toRemove, Map<ResourceLocation, AdvancementProgress> toSetProgress) {
         this.reset = clearCurrent;
@@ -70,4 +74,20 @@ public class ClientboundUpdateAdvancementsPacket implements Packet<ClientGamePac
     public boolean shouldReset() {
         return this.reset;
     }
+
+    // Martijn start - custom blocks and items
+
+    @Override
+    public @NotNull ClientboundUpdateAdvancementsPacket replaceCustomContent(boolean hasResourcePack) {
+        this.doesNetworkTargetHaveResourcePack = hasResourcePack;
+        return this;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return this.doesNetworkTargetHaveResourcePack;
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateRecipesPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateRecipesPacket.java
index 07d96cca04c9658291eea91e7b0a7f5a3fc9882e..f2b46382b2414735e4c42a85ba4e5fb582311404 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateRecipesPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateRecipesPacket.java
@@ -8,9 +8,14 @@ import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.world.item.crafting.Recipe;
+import net.minecraft.world.item.crafting.RecipeSerializer;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
 public class ClientboundUpdateRecipesPacket implements Packet<ClientGamePacketListener> {
     private final List<Recipe<?>> recipes;
+    private @Nullable Boolean doesNetworkTargetHaveResourcePack = null; // Martijn - custom blocks and items
 
     public ClientboundUpdateRecipesPacket(Collection<Recipe<?>> recipes) {
         this.recipes = Lists.newArrayList(recipes);
@@ -45,6 +50,22 @@ public class ClientboundUpdateRecipesPacket implements Packet<ClientGamePacketLi
     public static <T extends Recipe<?>> void toNetwork(FriendlyByteBuf buf, T recipe) {
         buf.writeResourceLocation(Registry.RECIPE_SERIALIZER.getKey(recipe.getSerializer()));
         buf.writeResourceLocation(recipe.getId());
-        recipe.getSerializer().toNetwork(buf, recipe);
+        ((RecipeSerializer<T>) recipe.getSerializer()).toNetwork(buf, recipe);
+    }
+
+    // Martijn start - custom blocks and items
+
+    @Override
+    public @NotNull ClientboundUpdateRecipesPacket replaceCustomContent(boolean hasResourcePack) {
+        this.doesNetworkTargetHaveResourcePack = hasResourcePack;
+        return this;
     }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return this.doesNetworkTargetHaveResourcePack;
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/resources/ResourceKey.java b/src/main/java/net/minecraft/resources/ResourceKey.java
index b8cd7177d82c08604bc3654cc2098e78484551d2..092f99ab1f169932f8bfe8a629a131fb97438a58 100644
--- a/src/main/java/net/minecraft/resources/ResourceKey.java
+++ b/src/main/java/net/minecraft/resources/ResourceKey.java
@@ -6,6 +6,8 @@ import java.util.Collections;
 import java.util.Map;
 import java.util.Optional;
 import net.minecraft.core.Registry;
+import org.bukkit.NamespacedKey;
+import org.jetbrains.annotations.NotNull;
 
 public class ResourceKey<T> {
 
@@ -56,6 +58,14 @@ public class ResourceKey<T> {
         return this.location;
     }
 
+    // Martijn start - custom resources
+
+    public @NotNull NamespacedKey asBukkit() {
+        return location().asBukkit();
+    }
+
+    // Martijn end - custom resources
+
     public ResourceLocation registry() {
         return this.registryName;
     }
diff --git a/src/main/java/net/minecraft/resources/ResourceLocation.java b/src/main/java/net/minecraft/resources/ResourceLocation.java
index bb92ba63e91a637b18154a154672acc413acf5ca..a4d569e63b5caf2dd7e04597588a3ee7a48a5534 100644
--- a/src/main/java/net/minecraft/resources/ResourceLocation.java
+++ b/src/main/java/net/minecraft/resources/ResourceLocation.java
@@ -18,6 +18,8 @@ import net.minecraft.ResourceLocationException;
 import net.minecraft.network.chat.Component;
 import net.minecraft.util.GsonHelper;
 import org.apache.commons.lang3.StringUtils;
+import org.bukkit.NamespacedKey;
+import org.jetbrains.annotations.NotNull;
 
 public class ResourceLocation implements Comparable<ResourceLocation> {
     public static final Codec<ResourceLocation> CODEC = Codec.STRING.comapFlatMap(ResourceLocation::read, ResourceLocation::toString).stable();
@@ -53,6 +55,10 @@ public class ResourceLocation implements Comparable<ResourceLocation> {
         return new ResourceLocation(SUCRAFT_NAMESPACE, id);
     }
 
+    public @NotNull NamespacedKey asBukkit() {
+        return new NamespacedKey(this.namespace, this.path);
+    }
+
     // Martijn end - custom resources
 
     public static ResourceLocation of(String id, char delimiter) {
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 94a96e5f85334b46261e2960ca2fec6c8c4bdd43..959af26e523eec92fbe3c4d1d71eb7fb97e16d8e 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -107,6 +107,7 @@ import net.minecraft.world.level.storage.LevelStorageSource;
 import it.unimi.dsi.fastutil.objects.ObjectRBTreeSet; // Paper
 import org.apache.commons.lang3.mutable.MutableBoolean;
 import org.apache.commons.lang3.mutable.MutableObject;
+import org.apache.commons.lang3.tuple.ImmutablePair;
 import org.slf4j.Logger;
 import org.bukkit.craftbukkit.generator.CustomChunkGenerator;
 import org.bukkit.entity.Player;
@@ -1699,7 +1700,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
     // Paper end - replace player loader system
 
-    public void updateChunkTracking(ServerPlayer player, ChunkPos pos, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> packet, boolean oldWithinViewDistance, boolean newWithinViewDistance, boolean concernsTracking) { // Paper - Anti-Xray - Bypass // Paper - public // Martijn - per-player track and see view distance
+    public void updateChunkTracking(ServerPlayer player, ChunkPos pos, MutableObject<java.util.Map<ImmutablePair<Boolean, Boolean>, ClientboundLevelChunkWithLightPacket>> packet, boolean oldWithinViewDistance, boolean newWithinViewDistance, boolean concernsTracking) { // Paper - Anti-Xray - Bypass // Paper - public // Martijn - per-player track and see view distance // Martijn - custom blocks and items
         if (player.level == this.level) {
             if (newWithinViewDistance && !oldWithinViewDistance) {
                 ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos.toLong());
@@ -2250,14 +2251,17 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     // Paper start - Anti-Xray - Bypass
-    private void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk, boolean concernsTracking) { // Martijn - per-player track and see view distance
+    private void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<ImmutablePair<Boolean, Boolean>, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk, boolean concernsTracking) { // Martijn - per-player track and see view distance // Martijn - custom blocks and items
         if (cachedDataPackets.getValue() == null) {
             cachedDataPackets.setValue(new java.util.HashMap<>());
         }
 
         Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
-        player.trackChunk(chunk.getPos(), cachedDataPackets.getValue().computeIfAbsent(shouldModify, (s) -> {
-            return new ClientboundLevelChunkWithLightPacket(chunk, this.lightEngine, (BitSet) null, (BitSet) null, true, (Boolean) s);
+        // Martijn start - custom blocks and items
+        boolean hasResourcePack = player.hasSuCraftResourcePack();
+        player.trackChunk(chunk.getPos(), cachedDataPackets.getValue().computeIfAbsent(new ImmutablePair<>(shouldModify, hasResourcePack), (s) -> {
+            return new ClientboundLevelChunkWithLightPacket(chunk, this.lightEngine, (BitSet) null, (BitSet) null, true, s.left, s.right);
+            // Martijn end - custom blocks and items
         }), concernsTracking);
         // Paper end
         DebugPackets.sendPoiPacketsForChunk(this.level, chunk.getPos());
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index cebf8782b35bdaadae3d7feef1ffd8faf169b23a..3c8c0cc28ab28acc5700fffb9ebd57f898940083 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -2914,4 +2914,17 @@ public class ServerPlayer extends Player {
     // CraftBukkit end
 
     public final int getViewDistance() { throw new UnsupportedOperationException("Use PlayerChunkLoader"); } // Paper - placeholder
+
+    // Martijn start - custom blocks and items
+
+    public boolean hasSuCraftResourcePack() {
+        var bukkitPlayer = getBukkitEntity();
+        if (bukkitPlayer == null) {
+            return false;
+        }
+        return bukkitPlayer.hasSuCraftResourcePack();
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index def57a2f44bf20c06b161f144e1122ad0ba4b705..be387aaca1e88bf4506ea1fea6cda9dd1b00bddd 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -427,7 +427,7 @@ public abstract class PlayerList {
                 .getHolderOrThrow(net.minecraft.world.level.biome.Biomes.PLAINS);
             player.connection.send(new net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket(
                 new net.minecraft.world.level.chunk.EmptyLevelChunk(worldserver1, player.chunkPosition(), plains),
-                worldserver1.getLightEngine(), null, null, true, false)
+                worldserver1.getLightEngine(), null, null, true, false, player.hasSuCraftResourcePack()) // Martijn - custom blocks and items
             );
         }
         // Paper end
diff --git a/src/main/java/net/minecraft/world/item/Item.java b/src/main/java/net/minecraft/world/item/Item.java
index 8b250dab8f3cb788ae1cfad43737afda31b72c0f..7d16c59dd196e24d313d3146fb74a201c9063ae0 100644
--- a/src/main/java/net/minecraft/world/item/Item.java
+++ b/src/main/java/net/minecraft/world/item/Item.java
@@ -44,6 +44,9 @@ import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.Vec3;
+import nl.martijnmuijsers.paper.block.BlockReplacementRule;
+import nl.martijnmuijsers.paper.item.ItemReplacementRule;
+import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 
 public class Item implements ItemLike {
@@ -68,6 +71,32 @@ public class Item implements ItemLike {
     @Nullable
     private final FoodProperties foodProperties;
 
+    // Martijn start - custom blocks and items
+
+    public boolean isVanilla = true;
+
+    /**
+     * Must be non-null for SuCraft items
+     */
+    public @Nullable ItemReplacementRule replacementRule = null;
+
+    /**
+     * Must be non-null for SuCraft items
+     */
+    public @Nullable net.kyori.adventure.text.Component customDisplayName = null;
+
+    /**
+     * Must be non-null for SuCraft items
+     */
+    public @Nullable String customDisplayNameJSON = null;
+
+    /**
+     * Must be non-null for SuCraft items
+     */
+    public @Nullable String customDisplayNameInLoreJSON = null;
+
+    // Martijn end - custom blocks and items
+
     public static int getId(Item item) {
         return item == null ? 0 : Registry.ITEM.getId(item);
     }
diff --git a/src/main/java/net/minecraft/world/item/Items.java b/src/main/java/net/minecraft/world/item/Items.java
index d9ba3ae228791ebf6ea29353fb88c1765fa4d20c..fa7dfe52155bf93e60f28d8af1b33961cb97f2e2 100644
--- a/src/main/java/net/minecraft/world/item/Items.java
+++ b/src/main/java/net/minecraft/world/item/Items.java
@@ -14,6 +14,8 @@ import net.minecraft.world.food.Foods;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.material.Fluids;
+import nl.martijnmuijsers.paper.item.SuCraftItems;
+import nl.martijnmuijsers.paper.resourcepack.sucraft.CreateSuCraftResourcePack;
 
 public class Items {
     public static final Item AIR = registerBlock(Blocks.AIR, new AirItem(Blocks.AIR, new Item.Properties()));
@@ -1173,15 +1175,15 @@ public class Items {
         return Optional.empty();
     }
 
-    private static Item registerBlock(Block block) {
+    public static Item registerBlock(Block block) { // Martijn - custom blocks and items
         return registerBlock(new BlockItem(block, new Item.Properties()));
     }
 
-    private static Item registerBlock(Block block, CreativeModeTab group) {
+    public static Item registerBlock(Block block, CreativeModeTab group) { // Martijn - custom blocks and items
         return registerBlock(new BlockItem(block, (new Item.Properties()).tab(group)));
     }
 
-    private static Item registerBlock(Block block, Optional<CreativeModeTab> group) {
+    public static Item registerBlock(Block block, Optional<CreativeModeTab> group) { // Martijn - custom blocks and items
         return group.map((groupx) -> {
             return registerBlock(block, groupx);
         }).orElseGet(() -> {
@@ -1189,7 +1191,7 @@ public class Items {
         });
     }
 
-    private static Item registerBlock(Block block, CreativeModeTab group, Block... blocks) {
+    public static Item registerBlock(Block block, CreativeModeTab group, Block... blocks) { // Martijn - custom blocks and items
         BlockItem blockItem = new BlockItem(block, (new Item.Properties()).tab(group));
 
         for(Block block2 : blocks) {
@@ -1199,23 +1201,36 @@ public class Items {
         return registerBlock(blockItem);
     }
 
-    private static Item registerBlock(BlockItem item) {
+    public static Item registerBlock(BlockItem item) { // Martijn - custom blocks and items
         return registerBlock(item.getBlock(), item);
     }
 
-    protected static Item registerBlock(Block block, Item item) {
+    public static Item registerBlock(Block block, Item item) { // Martijn - custom blocks and items
         return registerItem(Registry.BLOCK.getKey(block), item);
     }
 
-    private static Item registerItem(String id, Item item) {
+    public static Item registerItem(String id, Item item) { // Martijn - custom blocks and items
         return registerItem(new ResourceLocation(id), item);
     }
 
-    private static Item registerItem(ResourceLocation id, Item item) {
+    public static Item registerItem(ResourceLocation id, Item item) { // Martijn - custom blocks and items
         if (item instanceof BlockItem) {
             ((BlockItem)item).registerBlocks(Item.BY_BLOCK, item);
         }
 
         return Registry.register(Registry.ITEM, id, item);
     }
+
+    // Martijn start - custom blocks and items
+    static {
+        // Evaluate the last element to bootstrap Items
+        ECHO_SHARD.asItem();
+        // Then bootstrap SuCraftItems
+        SuCraftItems.bootstrap();
+        // This is the a reasonable time to create the resource pack
+        CreateSuCraftResourcePack.createAndWrite();
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 94dd87584de8cf23ff8fc4396400ff39730709f0..d5cae13c0cdf4171541d43e512970ea2cdca34b1 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -1,10 +1,7 @@
 package net.minecraft.world.level;
 
-import co.aikar.timings.Timing;
-import co.aikar.timings.Timings;
 import com.destroystokyo.paper.event.server.ServerExceptionEvent;
 import com.destroystokyo.paper.exception.ServerInternalException;
-import com.google.common.base.MoreObjects;
 import com.google.common.collect.Lists;
 import com.mojang.serialization.Codec;
 import java.io.IOException;
@@ -17,7 +14,6 @@ import java.util.function.Supplier;
 import javax.annotation.Nullable;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
-import net.minecraft.ReportedException;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Holder;
@@ -40,8 +36,6 @@ import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.DifficultyInstance;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.boss.EnderDragonPart;
-import net.minecraft.world.entity.boss.enderdragon.EnderDragon;
 import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
@@ -89,18 +83,17 @@ import net.minecraft.network.protocol.game.ClientboundSetBorderLerpSizePacket;
 import net.minecraft.network.protocol.game.ClientboundSetBorderSizePacket;
 import net.minecraft.network.protocol.game.ClientboundSetBorderWarningDelayPacket;
 import net.minecraft.network.protocol.game.ClientboundSetBorderWarningDistancePacket;
+import nl.martijnmuijsers.paper.antixray.ChunkPacketBlockControllerAntiXrayCustom;
+import nl.martijnmuijsers.paper.antixray.ChunkPacketBlockControllerCustom;
 import org.bukkit.Bukkit;
-import org.bukkit.Location;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.block.CapturedBlockState;
 import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.craftbukkit.util.CraftSpawnCategory;
-import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.entity.SpawnCategory;
 import org.bukkit.event.block.BlockPhysicsEvent;
-import org.bukkit.event.world.GenericGameEvent;
 // CraftBukkit end
 
 public abstract class Level implements LevelAccessor, AutoCloseable {
@@ -374,7 +367,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         this.keepSpawnInMemory = this.paperConfig().spawn.keepSpawnLoaded; // Paper
         this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
         this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
-        this.chunkPacketBlockController = this.paperConfig().anticheat.antiXray.enabled ? new com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray(this, executor) : com.destroystokyo.paper.antixray.ChunkPacketBlockController.NO_OPERATION_INSTANCE; // Paper - Anti-Xray
+        this.chunkPacketBlockController = this.paperConfig().anticheat.antiXray.enabled ? new ChunkPacketBlockControllerAntiXrayCustom(this, executor) : new ChunkPacketBlockControllerCustom(this, executor); // Paper - Anti-Xray // Martijn - custom blocks and items
         this.entitySliceManager = new io.papermc.paper.world.EntitySliceManager((ServerLevel)this); // Paper
     }
 
diff --git a/src/main/java/net/minecraft/world/level/block/Block.java b/src/main/java/net/minecraft/world/level/block/Block.java
index 224ce424b9a22548212ac157ec273c6dd80d6cfb..6cc6ae1059f2ca410ba5bbe2cd766dac932a65f6 100644
--- a/src/main/java/net/minecraft/world/level/block/Block.java
+++ b/src/main/java/net/minecraft/world/level/block/Block.java
@@ -63,6 +63,7 @@ import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.phys.shapes.BooleanOp;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
+import nl.martijnmuijsers.paper.block.BlockReplacementRule;
 import org.slf4j.Logger;
 
 public class Block extends BlockBehaviour implements ItemLike {
@@ -70,6 +71,11 @@ public class Block extends BlockBehaviour implements ItemLike {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Holder.Reference<Block> builtInRegistryHolder;
     public static final IdMapper<BlockState> BLOCK_STATE_REGISTRY = new IdMapper<>();
+    // Martijn start - custom blocks and items
+    public static final IdMapper<BlockState> BLOCK_STATE_REGISTRY_VANILLA = new IdMapper<>();
+    public static int[] stateIdReplacementArrayWithResourcePack;
+    public static int[] stateIdReplacementArrayWithoutResourcePack;
+    // Martijn end - custom blocks and items
     private static final LoadingCache<VoxelShape, Boolean> SHAPE_FULL_BLOCK_CACHE = CacheBuilder.newBuilder().maximumSize(512L).weakKeys().build(new CacheLoader<VoxelShape, Boolean>() {
         public Boolean load(VoxelShape voxelshape) {
             return !Shapes.joinIsNotEmpty(Shapes.block(), voxelshape, BooleanOp.NOT_SAME);
@@ -127,6 +133,17 @@ public class Block extends BlockBehaviour implements ItemLike {
         return object2bytelinkedopenhashmap;
     });
 
+    // Martijn start - custom blocks and items
+
+    public boolean isVanilla = true;
+
+    /**
+     * Must be non-null for SuCraft blocks
+     */
+    public @Nullable BlockReplacementRule replacementRule = null;
+
+    // Martijn end - custom blocks and items
+
     public static int getId(@Nullable BlockState state) {
         if (state == null) {
             return 0;
diff --git a/src/main/java/net/minecraft/world/level/block/Blocks.java b/src/main/java/net/minecraft/world/level/block/Blocks.java
index 5b5086f4016fc9015ac53bafd2c80bc724d575e4..80c812ed5ae6e7099000457625af916245e5b221 100644
--- a/src/main/java/net/minecraft/world/level/block/Blocks.java
+++ b/src/main/java/net/minecraft/world/level/block/Blocks.java
@@ -34,6 +34,7 @@ import net.minecraft.world.level.block.state.properties.WoodType;
 import net.minecraft.world.level.material.Fluids;
 import net.minecraft.world.level.material.Material;
 import net.minecraft.world.level.material.MaterialColor;
+import nl.martijnmuijsers.paper.block.SuCraftBlocks;
 import org.jetbrains.annotations.NotNull;
 
 public class Blocks {
@@ -1182,13 +1183,39 @@ public class Blocks {
     }
 
     static {
+        // Martijn start - custom blocks and items
+        // Evaluate the last element to bootstrap Blocks
+        REINFORCED_DEEPSLATE.asBlock();
+        // Then bootstrap SuCraftBlocks
+        SuCraftBlocks.bootstrap();
+        // Martijn end - custom blocks and items
         for(Block block : Registry.BLOCK) {
             for(BlockState blockState : block.getStateDefinition().getPossibleStates()) {
                 Block.BLOCK_STATE_REGISTRY.add(blockState);
+                // Martijn start - custom blocks and items
+                if (block.isVanilla) {
+                    Block.BLOCK_STATE_REGISTRY_VANILLA.add(blockState);
+                }
+                // Martijn end - custom blocks and items
             }
 
             block.getLootTable();
         }
-
+        // Martijn start - custom blocks and items
+        // Initialize the global state replacement arrays so we can populate them
+        Block.stateIdReplacementArrayWithResourcePack = new int[Block.BLOCK_STATE_REGISTRY.size()];
+        Block.stateIdReplacementArrayWithoutResourcePack = new int[Block.BLOCK_STATE_REGISTRY.size()];
+        // Initialize the global state replacement arrays with identities (aka no replacement is done)
+        for (int id = 0; id < Block.BLOCK_STATE_REGISTRY.size(); id++) {
+            Block.stateIdReplacementArrayWithResourcePack[id] = id;
+            Block.stateIdReplacementArrayWithoutResourcePack[id] = id;
+        }
+        // Then overwrite them where necessary with all the needed replacements
+        for (Block block : Registry.BLOCK) {
+            if (block.replacementRule != null) {
+                block.replacementRule.writeToStateIdReplacementArrays();
+            }
+        }
+        // Martijn end - custom blocks and items
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
index e8eb061181e9b5e6bde99253079864626bc8ad4b..2f69f56e4573b60c4c84bda549130841e2d1f562 100644
--- a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
+++ b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
@@ -83,7 +83,7 @@ public abstract class BlockBehaviour {
     protected final float speedFactor;
     protected final float jumpFactor;
     protected final boolean dynamicShape;
-    protected final BlockBehaviour.Properties properties;
+    public final BlockBehaviour.Properties properties; // Martijn - custom blocks and items
     @Nullable
     protected ResourceLocation drops;
 
@@ -434,7 +434,7 @@ public abstract class BlockBehaviour {
         SoundType soundType;
         ToIntFunction<BlockState> lightEmission;
         float explosionResistance;
-        float destroyTime;
+        public float destroyTime; // Martijn - custom blocks and items
         boolean requiresCorrectToolForDrops;
         boolean isRandomlyTicking;
         float friction;
diff --git a/src/main/java/net/minecraft/world/level/chunk/HashMapPalette.java b/src/main/java/net/minecraft/world/level/chunk/HashMapPalette.java
index ba9b0f419b0785a0b1e3bc57f18bfe5edaa192bd..b21d11d08f7b69240e416bee1a7a2f0be49d627a 100644
--- a/src/main/java/net/minecraft/world/level/chunk/HashMapPalette.java
+++ b/src/main/java/net/minecraft/world/level/chunk/HashMapPalette.java
@@ -11,7 +11,7 @@ public class HashMapPalette<T> implements Palette<T> {
     private final IdMap<T> registry;
     private final CrudeIncrementalIntIdentityHashBiMap<T> values;
     private final PaletteResize<T> resizeHandler;
-    private final int bits;
+    public final int bits; // Martijn - custom blocks and items
 
     public HashMapPalette(IdMap<T> idList, int bits, PaletteResize<T> listener, List<T> entries) {
         this(idList, bits, listener);
@@ -90,7 +90,7 @@ public class HashMapPalette<T> implements Palette<T> {
         buf.writeVarInt(i);
 
         for(int j = 0; j < i; ++j) {
-            buf.writeVarInt(this.registry.getId(this.values.byId(j)));
+            buf.writeVarIntThreeBytes(this.registry.getId(this.values.byId(j))); // Martijn - custom blocks and items
         }
 
     }
@@ -99,9 +99,7 @@ public class HashMapPalette<T> implements Palette<T> {
     public int getSerializedSize() {
         int i = FriendlyByteBuf.getVarIntSize(this.getSize());
 
-        for(int j = 0; j < this.getSize(); ++j) {
-            i += FriendlyByteBuf.getVarIntSize(this.registry.getId(this.values.byId(j)));
-        }
+        i += this.getSize() * 3; // Martijn - custom blocks and items
 
         return i;
     }
@@ -121,4 +119,13 @@ public class HashMapPalette<T> implements Palette<T> {
     public Palette<T> copy() {
         return new HashMapPalette<>(this.registry, this.bits, this.resizeHandler, this.values.copy());
     }
+
+    // Martijn start - custom blocks and items
+
+    public HashMapPalette<T> copyBlank(List<T> entries) {
+        return new HashMapPalette<>(this.registry, this.bits, (newSize, added) -> 0, entries);
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/world/level/chunk/LinearPalette.java b/src/main/java/net/minecraft/world/level/chunk/LinearPalette.java
index fb65457bc03a24b5f67e8eef538da8d6c2aabd6e..1732975254176f19f80d3563488b7f30959dbbff 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LinearPalette.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LinearPalette.java
@@ -10,7 +10,7 @@ public class LinearPalette<T> implements Palette<T> {
     private final IdMap<T> registry;
     private final T[] values;
     private final PaletteResize<T> resizeHandler;
-    private final int bits;
+    public final int bits; // Martijn start - custom blocks and items
     private int size;
 
     private LinearPalette(IdMap<T> idList, int bits, PaletteResize<T> listener, List<T> list) {
@@ -92,7 +92,7 @@ public class LinearPalette<T> implements Palette<T> {
         buf.writeVarInt(this.size);
 
         for(int i = 0; i < this.size; ++i) {
-            buf.writeVarInt(this.registry.getId(this.values[i]));
+            buf.writeVarIntThreeBytes(this.registry.getId(this.values[i])); // Martijn - custom blocks and items
         }
 
     }
@@ -101,9 +101,7 @@ public class LinearPalette<T> implements Palette<T> {
     public int getSerializedSize() {
         int i = FriendlyByteBuf.getVarIntSize(this.getSize());
 
-        for(int j = 0; j < this.getSize(); ++j) {
-            i += FriendlyByteBuf.getVarIntSize(this.registry.getId(this.values[j]));
-        }
+        i += this.getSize() * 3; // Martijn - custom blocks and items
 
         return i;
     }
@@ -117,4 +115,13 @@ public class LinearPalette<T> implements Palette<T> {
     public Palette<T> copy() {
         return new LinearPalette<>(this.registry, (T[])((Object[])this.values.clone()), this.resizeHandler, this.bits, this.size);
     }
+
+    // Martijn start - custom blocks and items
+
+    public LinearPalette<T> copyBlank(List<T> entries) {
+        return new LinearPalette<>(this.registry, this.bits, (newSize, added) -> 0, entries);
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
index 08e1309e618377d170c446a1568c21b7bf4e5683..35014a305d1388d117bddb9b7e03e28b95ab8e5d 100644
--- a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
+++ b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
@@ -374,7 +374,7 @@ public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainer
         }
     }
 
-    static record Configuration<T>(Palette.Factory factory, int bits) {
+    public static record Configuration<T>(Palette.Factory factory, int bits) { // Martijn - custom blocks and items
         public PalettedContainer.Data<T> createData(IdMap<T> idList, PaletteResize<T> listener, int size) {
             BitStorage bitStorage = (BitStorage)(this.bits == 0 ? new ZeroBitStorage(size) : new SimpleBitStorage(this.bits, size));
             Palette<T> palette = this.factory.create(this.bits, idList, listener, List.of());
@@ -411,6 +411,12 @@ public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainer
         // Paper start - Anti-Xray - Add chunk packet info
         public void write(FriendlyByteBuf buf, @Nullable com.destroystokyo.paper.antixray.ChunkPacketInfo<T> chunkPacketInfo, int bottomBlockY) {
             buf.writeByte(this.storage.getBits());
+            // Martijn start - custom blocks and items
+            if (chunkPacketInfo != null) {
+                int chunkSectionIndex = (bottomBlockY >> 4) - chunkPacketInfo.getChunk().getMinSection();
+                chunkPacketInfo.setPaletteIndex(chunkSectionIndex, buf.writerIndex());
+            }
+            // Martijn end - custom blocks and items
             this.palette.write(buf);
 
             if (chunkPacketInfo != null) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/SingleValuePalette.java b/src/main/java/net/minecraft/world/level/chunk/SingleValuePalette.java
index 76cfa5797a71df34c7b933798815863f437debcd..f7b8bcbc27c52176b68dcd558531ec8349f06bec 100644
--- a/src/main/java/net/minecraft/world/level/chunk/SingleValuePalette.java
+++ b/src/main/java/net/minecraft/world/level/chunk/SingleValuePalette.java
@@ -8,12 +8,12 @@ import net.minecraft.network.FriendlyByteBuf;
 import org.apache.commons.lang3.Validate;
 
 public class SingleValuePalette<T> implements Palette<T> {
-    private final IdMap<T> registry;
+    public final IdMap<T> registry; // Martijn - custom blocks and items
     @Nullable
     private T value;
-    private final PaletteResize<T> resizeHandler;
+    private final @Nullable PaletteResize<T> resizeHandler; // Martijn - custom blocks and items
 
-    public SingleValuePalette(IdMap<T> idList, PaletteResize<T> listener, List<T> entries) {
+    public SingleValuePalette(IdMap<T> idList, @Nullable PaletteResize<T> listener, List<T> entries) { // Martijn - custom blocks and items
         this.registry = idList;
         this.resizeHandler = listener;
         if (entries.size() > 0) {
@@ -23,13 +23,18 @@ public class SingleValuePalette<T> implements Palette<T> {
 
     }
 
-    public static <A> Palette<A> create(int bitSize, IdMap<A> idList, PaletteResize<A> listener, List<A> entries) {
+    public static <A> Palette<A> create(int bitSize, IdMap<A> idList, @Nullable PaletteResize<A> listener, List<A> entries) { // Martijn - custom blocks and items
         return new SingleValuePalette<>(idList, listener, entries);
     }
 
     @Override
     public int idFor(T object) {
         if (this.value != null && this.value != object) {
+            // Martijn start - custom blocks and items
+            if (this.resizeHandler == null) {
+                throw new IllegalStateException("Tried to expand SingleValuePalette without a resizeHandler");
+            }
+            // Martijn end - custom blocks and items
             return this.resizeHandler.onResize(1, object);
         } else {
             this.value = object;
@@ -65,7 +70,7 @@ public class SingleValuePalette<T> implements Palette<T> {
         if (this.value == null) {
             throw new IllegalStateException("Use of an uninitialized palette");
         } else {
-            buf.writeVarInt(this.registry.getId(this.value));
+            buf.writeVarIntThreeBytes(this.registry.getId(this.value)); // Martijn - custom blocks and items
         }
     }
 
@@ -74,7 +79,7 @@ public class SingleValuePalette<T> implements Palette<T> {
         if (this.value == null) {
             throw new IllegalStateException("Use of an uninitialized palette");
         } else {
-            return FriendlyByteBuf.getVarIntSize(this.registry.getId(this.value));
+            return 3; // Martijn - custom blocks and items
         }
     }
 
@@ -91,4 +96,13 @@ public class SingleValuePalette<T> implements Palette<T> {
             return this;
         }
     }
+
+    // Martijn start - custom blocks and items
+
+    public SingleValuePalette<T> copyBlank(List<T> entries) {
+        return new SingleValuePalette<>(this.registry, (newSize, added) -> 0, entries);
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerAntiXrayCustom.java b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerAntiXrayCustom.java
new file mode 100644
index 0000000000000000000000000000000000000000..8437ad716fc469e43579c7197aad7b541162a48e
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerAntiXrayCustom.java
@@ -0,0 +1,29 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.antixray;
+
+import com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray;
+import com.destroystokyo.paper.antixray.ChunkPacketInfoAntiXray;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.chunk.LevelChunk;
+import java.util.concurrent.Executor;
+
+public final class ChunkPacketBlockControllerAntiXrayCustom extends ChunkPacketBlockControllerAntiXray {
+
+    public ChunkPacketBlockControllerAntiXrayCustom(Level level, Executor executor) {
+        super(level, executor);
+    }
+
+    @Override
+    public boolean shouldModify(ServerPlayer player, LevelChunk chunk) {
+        return true;
+    }
+
+    @Override
+    public void obfuscateInternal(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        obfuscateXray(chunkPacketInfoAntiXray);
+        ChunkPacketBlockControllerCustom.replaceCustom(chunkPacketInfoAntiXray);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerCustom.java b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerCustom.java
new file mode 100644
index 0000000000000000000000000000000000000000..d2ffa53275aee4a582e88f3560244b5a2e7da901
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerCustom.java
@@ -0,0 +1,205 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.antixray;
+
+import com.destroystokyo.paper.antixray.BitStorageReader;
+import com.destroystokyo.paper.antixray.BitStorageWriter;
+import com.destroystokyo.paper.antixray.ChunkPacketInfoAntiXray;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import it.unimi.dsi.fastutil.ints.Int2IntArrayMap;
+import it.unimi.dsi.fastutil.ints.Int2IntMap;
+import it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap;
+import it.unimi.dsi.fastutil.ints.IntArraySet;
+import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.GlobalPalette;
+import net.minecraft.world.level.chunk.HashMapPalette;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.LinearPalette;
+import net.minecraft.world.level.chunk.Palette;
+import net.minecraft.world.level.chunk.SingleValuePalette;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.Executor;
+
+public final class ChunkPacketBlockControllerCustom extends ChunkPacketBlockControllerModifierBase {
+
+    public ChunkPacketBlockControllerCustom(Level level, Executor executor) {
+        super(level, executor);
+    }
+
+    @Override
+    public boolean shouldModify(ServerPlayer player, LevelChunk chunk) {
+        return true;
+    }
+
+    @Override
+    public void obfuscateInternal(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        replaceCustom(chunkPacketInfoAntiXray);
+    }
+
+    public static void replaceCustom(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+
+        // bitStorageReader, bitStorageWriter and nearbyChunkSections could also be reused (with ThreadLocal if necessary) but it's not worth it
+        BitStorageReader bitStorageReader = new BitStorageReader();
+        BitStorageWriter bitStorageWriter = new BitStorageWriter();
+        LevelChunk chunk = chunkPacketInfoAntiXray.getChunk();
+        int sectionsCount = chunk.getSectionsCount();
+        Level level = chunk.getLevel();
+        boolean[] obfuscateTemp = null;
+        bitStorageReader.setBuffer(chunkPacketInfoAntiXray.getBuffer());
+        bitStorageWriter.setBuffer(chunkPacketInfoAntiXray.getBuffer());
+
+        for (int chunkSectionIndex = 0; chunkSectionIndex < sectionsCount; chunkSectionIndex++) {
+            if (chunkPacketInfoAntiXray.isWritten(chunkSectionIndex)) {
+
+                // Get the current (potentially to be replaced) palette
+                var oldPalette = chunkPacketInfoAntiXray.getPalette(chunkSectionIndex);
+                int oldPaletteSize = oldPalette.getSize();
+
+                // Get the appropriate global replacements
+                int[] globalBlockStateReplacementsForResourcePackStatus = chunkPacketInfoAntiXray.doesPlayerHaveResourcePack ? Block.stateIdReplacementArrayWithResourcePack : Block.stateIdReplacementArrayWithoutResourcePack;
+
+                // First we store the old and new global ids, and flag if there will be any replacements
+                int[] oldStateRegistryIdsByOldPaletteId = new int[oldPaletteSize];
+                int[] newStateRegistryIdsByOldPaletteId = new int[oldPaletteSize];
+                boolean anyReplacements = false;
+                for (int oldPaletteId = 0; oldPaletteId < oldPaletteSize; oldPaletteId++) {
+                    BlockState oldValue = oldPalette.valueFor(oldPaletteId);
+                    int oldStateRegistryId = Block.BLOCK_STATE_REGISTRY.getId(oldValue);
+                    oldStateRegistryIdsByOldPaletteId[oldPaletteId] = oldStateRegistryId;
+                    int newStateRegistryId = globalBlockStateReplacementsForResourcePackStatus[oldStateRegistryId];
+                    newStateRegistryIdsByOldPaletteId[oldPaletteId] = newStateRegistryId;
+                    anyReplacements |= oldStateRegistryId != newStateRegistryId;
+                }
+
+                // If no replacements are necessary, we are done with this section (this will always be false in the case of a global palette that contains some non-vanilla block states)
+                if (!anyReplacements) {
+                    continue;
+                }
+
+                // Prepare for potential block replacements later
+                int[] blockStateReplacements = null;
+
+                // Special case for the global palette, where we don't have to find a new list of which global ids are needed in the new palette: we can just use the palette containing all vanilla blocks
+                // But the palette isn't written at all to the packet in this case (the client simply expects the vanilla global palette), so we simply need to compute the needed block replacements
+                if (oldPalette instanceof GlobalPalette<BlockState>) {
+
+                    // We can just straight up use the appropriate precomputed array over all block states
+                    blockStateReplacements = globalBlockStateReplacementsForResourcePackStatus;
+
+                } else {
+                    // If not a global palette, we must figure out what will go into the new palette
+
+                    // We create sets of the old and new global ids so that we can for example check for old global ids whether they will be still present
+                    IntSet newStateRegistryIds = (oldPaletteSize <= 16) ? new IntArraySet(oldPaletteSize) : new IntOpenHashSet(oldPaletteSize * 2);
+                    Arrays.stream(newStateRegistryIdsByOldPaletteId).forEach(newStateRegistryIds::add);
+                    int newPaletteSize = newStateRegistryIds.size();
+
+                    // Create the global ids that will be in the new palette
+                    int[] newStateRegistryIdsByNewPaletteId = new int[newStateRegistryIds.size()];
+                    Arrays.fill(newStateRegistryIdsByNewPaletteId, -1); // -1 marks we have not decided which new palette state registry id to put at this palette id yet
+
+                    // Put the new global ids in the same position as the old global id they replace, if possible
+                    Int2IntMap newPaletteIdByNewStateRegistryId = newStateRegistryIds.size() <= 16 ? new Int2IntArrayMap(newStateRegistryIds.size()) : new Int2IntOpenHashMap(newStateRegistryIds.size() * 2);
+                    for (int oldPaletteId = 0; oldPaletteId < oldPaletteSize && oldPaletteId < newPaletteSize /* We cannot store them in the same palette id beyond the new palette size */; oldPaletteId++) {
+                        int newStateRegistryId = newStateRegistryIdsByOldPaletteId[oldPaletteId];
+                        // Get the existing new palette id, or use the current old palette id
+                        final int finalOldPaletteId = oldPaletteId;
+                        int newPaletteId = newPaletteIdByNewStateRegistryId.computeIfAbsent(newStateRegistryId, key -> finalOldPaletteId);
+                        newStateRegistryIdsByNewPaletteId[newPaletteId] = newStateRegistryId;
+                    }
+
+                    // Go over all new global ids and assign any of them that still need it a new palette id
+                    int[] nextNewPaletteId = {0};
+                    while (nextNewPaletteId[0] < newStateRegistryIdsByNewPaletteId.length && newStateRegistryIdsByNewPaletteId[nextNewPaletteId[0]] != -1) {
+                        nextNewPaletteId[0]++;
+                    }
+                    for (int newStateRegistryId : newStateRegistryIds) {
+                        newPaletteIdByNewStateRegistryId.computeIfAbsent(newStateRegistryId, key -> {
+                            int newPaletteId = nextNewPaletteId[0];
+                            do {
+                                nextNewPaletteId[0]++;
+                            } while (nextNewPaletteId[0] < newStateRegistryIdsByNewPaletteId.length && newStateRegistryIdsByNewPaletteId[nextNewPaletteId[0]] != -1);
+                            newStateRegistryIdsByNewPaletteId[newPaletteId] = key;
+                            return newPaletteId;
+                        });
+                    }
+
+                    // Create the necessary entries for the new palette
+                    List<BlockState> newPaletteBlockStateList = new ArrayList<>(Arrays.stream(newStateRegistryIdsByNewPaletteId).mapToObj(stateRegistryId -> Block.BLOCK_STATE_REGISTRY.byId(stateRegistryId)).toList());
+
+                    // Make sure we fit into the protocol by keeping the exact same number of bits and such, so we add some unused block states to the palette to get the same size as before
+                    for (BlockState paddingBlockState : Block.BLOCK_STATE_REGISTRY) {
+                        if (newPaletteBlockStateList.size() == oldPaletteSize) {
+                            break;
+                        }
+                        if (!newPaletteBlockStateList.contains(paddingBlockState)) {
+                            newPaletteBlockStateList.add(paddingBlockState);
+                        }
+                    }
+
+                    // We clone the palette with the new entries, so that we can then write it to the buffer
+                    Palette<BlockState> newPalette = null; // Will be initialized in one of the cases below for sure
+                    if (oldPalette instanceof SingleValuePalette<BlockState> oldSingleValuePalette) {
+                        newPalette = oldSingleValuePalette.copyBlank(newPaletteBlockStateList);
+                    } else if (oldPalette instanceof LinearPalette<BlockState> oldLinearPalette) {
+                        newPalette = oldLinearPalette.copyBlank(newPaletteBlockStateList);
+                    } else if (oldPalette instanceof HashMapPalette<BlockState> oldHashMapPalette) {
+                        newPalette = oldHashMapPalette.copyBlank(newPaletteBlockStateList);
+                    }
+
+                    // Write the new palette to the buffer
+                    FriendlyByteBuf paletteWriter;
+                    {
+                        ByteBuf byteBuf = Unpooled.wrappedBuffer(chunkPacketInfoAntiXray.getBuffer());
+                        byteBuf.writerIndex(chunkPacketInfoAntiXray.getPaletteIndex(chunkSectionIndex));
+                        paletteWriter = new FriendlyByteBuf(byteBuf);
+                    }
+                    newPalette.write(paletteWriter);
+
+                    // For any palette id where the global id at that index in the new palette is not the replacement for the global id at that index in the old palette, we must replace the palette id of all block occurrences to the palette id where the replacement is in fact stored in the new palette
+                    for (int oldPaletteId = 0; oldPaletteId < oldPaletteSize; oldPaletteId++) {
+                        // If the replacement is no longer in the right position
+                        int newStateRegistryId = newStateRegistryIdsByOldPaletteId[oldPaletteId];
+                        int newPaletteIdOfNewStateRegistryId = newPaletteIdByNewStateRegistryId.get(newStateRegistryId);
+                        if (newPaletteIdOfNewStateRegistryId != oldPaletteId) {
+                            if (blockStateReplacements == null) {
+                                blockStateReplacements = new int[oldPaletteSize];
+                                for (int i = 0; i < oldPaletteSize; i++) {
+                                    blockStateReplacements[i] = i;
+                                }
+                            }
+                            blockStateReplacements[oldPaletteId] = newPaletteIdOfNewStateRegistryId;
+                        }
+                    }
+
+                }
+
+                if (blockStateReplacements != null) {
+                    bitStorageReader.setBits(chunkPacketInfoAntiXray.getBits(chunkSectionIndex));
+                    bitStorageReader.setIndex(chunkPacketInfoAntiXray.getIndex(chunkSectionIndex));
+                    bitStorageWriter.setBits(chunkPacketInfoAntiXray.getBits(chunkSectionIndex));
+                    bitStorageWriter.setIndex(chunkPacketInfoAntiXray.getIndex(chunkSectionIndex));
+
+                    // Modify all layers of the current chunk section
+                    for (int xyz = 0; xyz < 4096/* = 16*16*16 */; xyz++) {
+                        int bits = bitStorageReader.read();
+                        bitStorageWriter.write(blockStateReplacements[bits]);
+                    }
+                    bitStorageWriter.flush();
+                }
+            }
+        }
+
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerModifier.java b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerModifier.java
new file mode 100644
index 0000000000000000000000000000000000000000..5657efde50d31c1661b9c47a596f0df58c137803
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerModifier.java
@@ -0,0 +1,15 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.antixray;
+
+import com.destroystokyo.paper.antixray.ChunkPacketInfoAntiXray;
+
+public interface ChunkPacketBlockControllerModifier {
+
+    /**
+     * This method represents modifying the blocks, which can be obfuscation, but doesn't have to be
+     * (naming based on existing method in ChunkPacketBlockControllerAntiXray)
+     */
+    void obfuscate(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerModifierBase.java b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerModifierBase.java
new file mode 100644
index 0000000000000000000000000000000000000000..a50c702b7e653d74a1f8f7d0f472c6ae5ac624e2
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerModifierBase.java
@@ -0,0 +1,66 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.antixray;
+
+import com.destroystokyo.paper.antixray.ChunkPacketBlockController;
+import com.destroystokyo.paper.antixray.ChunkPacketInfo;
+import com.destroystokyo.paper.antixray.ChunkPacketInfoAntiXray;
+import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.GlobalPalette;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.LevelChunkSection;
+import net.minecraft.world.level.chunk.Palette;
+import org.bukkit.Bukkit;
+
+import java.util.concurrent.Executor;
+
+public abstract class ChunkPacketBlockControllerModifierBase extends ChunkPacketBlockController implements ChunkPacketBlockControllerModifier { // Martijn - custom blocks and items
+
+    public static final Palette<BlockState> GLOBAL_BLOCKSTATE_PALETTE = new GlobalPalette<>(Block.BLOCK_STATE_REGISTRY);
+    public static final LevelChunkSection EMPTY_SECTION = null;
+    protected final Executor executor;
+
+    public ChunkPacketBlockControllerModifierBase(Level level, Executor executor) {
+        this.executor = executor;
+    }
+
+    @Override
+    public void obfuscate(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        this.obfuscateInternal(chunkPacketInfoAntiXray);
+        chunkPacketInfoAntiXray.getChunkPacket().setReady(true);
+    }
+
+    public abstract void obfuscateInternal(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray);
+
+    @Override
+    public ChunkPacketInfoAntiXray getChunkPacketInfo(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk, boolean doesPlayerHaveResourcePack) {
+        // Return a new instance to collect data and objects in the right state while creating the chunk packet for thread safe access later
+        return new ChunkPacketInfoAntiXray(chunkPacket, chunk, this, doesPlayerHaveResourcePack);
+    }
+
+    @Override
+    public void modifyBlocks(ClientboundLevelChunkWithLightPacket chunkPacket, ChunkPacketInfo<BlockState> chunkPacketInfo) {
+        if (!(chunkPacketInfo instanceof ChunkPacketInfoAntiXray)) {
+            chunkPacket.setReady(true);
+            return;
+        }
+
+        if (!Bukkit.isPrimaryThread()) {
+            // Plugins?
+            MinecraftServer.getServer().scheduleOnMain(() -> modifyBlocks(chunkPacket, chunkPacketInfo));
+            return;
+        }
+
+        LevelChunk chunk = chunkPacketInfo.getChunk();
+        int x = chunk.getPos().x;
+        int z = chunk.getPos().z;
+        Level level = chunk.getLevel();
+        ((ChunkPacketInfoAntiXray) chunkPacketInfo).setNearbyChunks(level.getChunkIfLoaded(x - 1, z), level.getChunkIfLoaded(x + 1, z), level.getChunkIfLoaded(x, z - 1), level.getChunkIfLoaded(x, z + 1));
+        executor.execute((Runnable) chunkPacketInfo);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/BlockReplacementRule.java b/src/main/java/nl/martijnmuijsers/paper/block/BlockReplacementRule.java
new file mode 100644
index 0000000000000000000000000000000000000000..ecf2ed96a5a55dcf328b03db19fe94cdb085405a
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/block/BlockReplacementRule.java
@@ -0,0 +1,430 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.block;
+
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.BlockState;
+import nl.martijnmuijsers.paper.resourcepack.MutableResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.blockstates.MutableResourcePackBlockStates;
+import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelContent;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.apache.commons.lang3.Validate;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Collections;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.function.Supplier;
+
+public interface BlockReplacementRule {
+
+    interface Builder<B extends Builder<B>> {
+
+        @NotNull B withHostItem(@NotNull Supplier<@NotNull Item> hostItemSupplier);
+
+        default @NotNull B withFullBlockBoundingBoxHostItem() {
+            return this.withHostItem(() -> Items.BARRIER);
+        }
+
+        @NotNull B withReal(@NotNull Block real);
+
+        @NotNull B withFallbackItem(@NotNull Supplier<@NotNull Item> fallbackItemSupplier);
+
+        @NotNull BlockReplacementRule build();
+
+    }
+
+    @Nullable BlockState replace(@NotNull BlockState state, boolean hasResourcePack);
+
+    @NotNull Block getReal();
+
+    @Nullable Item getHostItem();
+
+    @Nullable Item getFallbackItem();
+
+    /**
+     * Returns whether this item, when placing it as a block, would place a block state that serves as a host for this block
+     */
+    boolean isHostReplacing(@NotNull Item item);
+
+    /**
+     * Returns all items for which {@link #isHostReplacing} is true
+     */
+    @NotNull Iterable<@NotNull Item> getHostReplacingItems();
+
+    @Nullable Item getHostReplacingItemReplacement(@NotNull Item item);
+
+    @Nullable Model getModelForStatePlacedByItem();
+
+    void writeToStateIdReplacementArrays();
+
+    void addToResourcePack(@NotNull MutableResourcePack resourcePack);
+
+    default void updateMinDestroyTimes() {
+        updateMinDestroyTimeOfReal(); // Some will see it as the host, others as the fallback
+        updateMinDestroyTimeOfHost(); // Some may see it as the host replacement
+    }
+
+    default void updateMinDestroyTimeOfReal() {
+        getReal().properties.destroyTime(Math.min(
+            getReal().properties.destroyTime,
+            getMinDestroyTimeOfHostAndFallback()
+        ));
+    }
+
+    void updateMinDestroyTimeOfHost();
+
+    float getMinDestroyTimeOfHostAndFallback();
+
+    float getMinDestroyTimeOfHostAndHostReplacement();
+
+    class StatelessBlockReplacementRule implements BlockReplacementRule {
+
+        public static class Builder implements BlockReplacementRule.Builder<Builder> {
+
+            private @Nullable Block real;
+            private @Nullable BlockState host;
+            private @Nullable Supplier<@NotNull Item> hostItemSupplier;
+            private @Nullable BlockState hostReplacement;
+            private @Nullable BlockState fallback;
+            private @Nullable Supplier<@NotNull Item> fallbackItemSupplier;
+            private @Nullable Supplier<@NotNull Item> hostReplacingItemSupplier;
+            private @Nullable Supplier<@NotNull Item> hostReplacingItemReplacementSupplier;
+            private @Nullable Supplier<@NotNull Model> modelSupplier;
+
+            @Override
+            public @NotNull StatelessBlockReplacementRule.Builder withReal(@NotNull Block real) {
+                this.real = real;
+                return this;
+            }
+
+            public @NotNull StatelessBlockReplacementRule.Builder withHost(@NotNull BlockState host) {
+                this.host = host;
+                return this;
+            }
+
+            public @NotNull StatelessBlockReplacementRule.Builder withHost(@NotNull Block host) {
+                return this.withHost(host.defaultBlockState());
+            }
+
+            public @NotNull StatelessBlockReplacementRule.Builder withHostReplacement(@NotNull BlockState hostReplacement) {
+                this.hostReplacement = hostReplacement;
+                return this;
+            }
+
+            public @NotNull StatelessBlockReplacementRule.Builder withHostReplacement(@NotNull Block hostReplacement) {
+                return this.withHostReplacement(hostReplacement.defaultBlockState());
+            }
+
+            public @NotNull StatelessBlockReplacementRule.Builder withHostDefaultAsHostReplacement() {
+                return this.withHostReplacement(this.host.getBlock().defaultBlockState());
+            }
+
+            @Override
+            public @NotNull StatelessBlockReplacementRule.Builder withHostItem(@NotNull Supplier<@NotNull Item> hostItemSupplier) {
+                this.hostItemSupplier = hostItemSupplier;
+                return this;
+            }
+
+            public @NotNull StatelessBlockReplacementRule.Builder withFallback(@NotNull BlockState fallback) {
+                this.fallback = fallback;
+                return this;
+            }
+
+            public @NotNull StatelessBlockReplacementRule.Builder withFallback(@NotNull Block fallback) {
+                return this.withFallback(fallback.defaultBlockState());
+            }
+
+            @Override
+            public @NotNull StatelessBlockReplacementRule.Builder withFallbackItem(@NotNull Supplier<@NotNull Item> fallbackItemSupplier) {
+                this.fallbackItemSupplier = fallbackItemSupplier;
+                return this;
+            }
+
+            public @NotNull StatelessBlockReplacementRule.Builder withFallbackBlockAsFallbackItem() {
+                Validate.notNull(this.fallback);
+                return this.withFallbackItem(() -> this.fallback.getBlock().asItem());
+            }
+
+            public @NotNull StatelessBlockReplacementRule.Builder withModel(@NotNull Model model) {
+                this.modelSupplier = () -> model;
+                return this;
+            }
+
+            public @NotNull StatelessBlockReplacementRule.Builder withHostReplacingItem(@NotNull Supplier<@NotNull Item> hostReplacingItemSupplier) {
+                this.hostReplacingItemSupplier = hostReplacingItemSupplier;
+                return this;
+            }
+
+            public @NotNull StatelessBlockReplacementRule.Builder withHostReplacingItemFromHostBlock() {
+                Validate.notNull(this.host);
+                return this.withHostReplacingItem(() -> this.host.getBlock().asItem());
+            }
+
+            public @NotNull StatelessBlockReplacementRule.Builder withHostReplacingItemReplacement(@NotNull Supplier<@NotNull Item> hostReplacingItemReplacementSupplier) {
+                this.hostReplacingItemReplacementSupplier = hostReplacingItemReplacementSupplier;
+                return this;
+            }
+
+            public @NotNull StatelessBlockReplacementRule.Builder withHostReplacingItemReplacementFromHostReplacementBlock() {
+                Validate.notNull(this.hostReplacement);
+                return this.withHostReplacingItemReplacement(() -> this.hostReplacement.getBlock().asItem());
+            }
+
+            /**
+             * The provided function will be called with the {@link ResourceLocation} of the real block of this rule
+             */
+            public @NotNull StatelessBlockReplacementRule.Builder withModel(@NotNull Function<@NotNull ResourceLocation, @NotNull Model> modelFunction) {
+                this.modelSupplier = () -> {
+                    Validate.notNull(this.real);
+                    @NotNull ResourceLocation key = Registry.BLOCK.getKey(this.real);
+                    return modelFunction.apply(key);
+                };
+                return this;
+            }
+
+            public @NotNull StatelessBlockReplacementRule.Builder withModelContent(@NotNull ModelContent modelContent) {
+                return this.withModel(resourceLocation ->
+                    modelContent.asModel(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.forMinecraft(resourceLocation)));
+            }
+
+            @Override
+            public @NotNull StatelessBlockReplacementRule build() {
+                Validate.notNull(this.real);
+                Validate.notNull(this.host);
+                Validate.notNull(this.hostReplacement);
+                Validate.notNull(this.hostItemSupplier);
+                Validate.notNull(this.fallback);
+                Validate.notNull(this.modelSupplier);
+                @Nullable Supplier<@NotNull Pair<@NotNull Item, @NotNull Item>> hostReplacingItemAndReplacementSupplier = null;
+                if (this.hostReplacingItemSupplier != null || this.hostReplacingItemReplacementSupplier != null) {
+                    Validate.notNull(this.hostReplacingItemSupplier);
+                    Validate.notNull(this.hostReplacingItemReplacementSupplier);
+                    hostReplacingItemAndReplacementSupplier = () -> Pair.of(this.hostReplacingItemSupplier.get(), this.hostReplacingItemReplacementSupplier.get());
+                }
+                return new StatelessBlockReplacementRule(this.real, this.host, this.hostReplacement, this.hostItemSupplier, this.fallback, this.fallbackItemSupplier, hostReplacingItemAndReplacementSupplier, this.modelSupplier.get());
+            }
+
+        }
+
+        private final @NotNull Block real;
+        private final @NotNull BlockState host;
+        private final @NotNull BlockState hostReplacement;
+
+        /**
+         * May be null if this block has no item form, must be non-null if this block has an item form
+         * <br>
+         * Will also be null if not initialized yet
+         */
+        private @Nullable Item hostItem;
+
+        /**
+         * This is used to get the host item the first time it is needed: this is to ensure no calls to the Items class are made before the blocks have finished initializing, otherwise we cannot refer to the blocks when we wish to create items for them
+         * <br><br>
+         * May be null if this block has no item form, must be non-null if this block has an item form
+         * <br>
+         * Will also be set to null after the first evaluation
+         */
+        private @Nullable Supplier<@NotNull Item> hostItemSupplier;
+
+        private final @NotNull BlockState fallback;
+
+        /**
+         * May be null if this block has no item form, must be non-null if this block has an item form
+         * <br>
+         * Will also be null if not initialized yet
+         */
+        private @Nullable Item fallbackItem = null;
+
+        /**
+         * This is used to get the fallback item the first time it is needed: this is to ensure no calls to the Items class are made before the blocks have finished initializing, otherwise we cannot refer to the blocks when we wish to create items for them
+         * <br><br>
+         * May be null if this block has no item form, must be non-null if this block has an item form
+         * <br>
+         * Will also be set to null after the first evaluation
+         */
+        private @Nullable Supplier<@NotNull Item> fallbackItemSupplier;
+
+        /**
+         * May be null if this block has no host for which an item exists that would replace it on being used to place as a block
+         * <br>
+         * Will also be set to null after the first evaluation
+         */
+        private @Nullable Item hostReplacingItem;
+
+        /**
+         * May be null if this block has no host for which an item exists that would replace it on being used to place as a block
+         * <br>
+         * Will also be set to null after the first evaluation
+         */
+        private @Nullable Item hostReplacingItemReplacement;
+
+        /**
+         * May be null if this block has no host for which an item exists that would replace it on being used to place as a block
+         * <br>
+         * Will also be set to null after the first evaluation
+         */
+        private @Nullable Supplier<@NotNull Pair<@NotNull Item, @NotNull Item>> hostReplacingItemAndReplacementSupplier;
+
+        private final @NotNull Model model;
+
+        private StatelessBlockReplacementRule(@NotNull Block real, @NotNull BlockState host, @NotNull BlockState hostReplacement, @Nullable Supplier<@NotNull Item> hostItemSupplier, @NotNull BlockState fallback, @Nullable Supplier<@NotNull Item> fallbackItemSupplier, @Nullable Supplier<@NotNull Pair<@NotNull Item, @NotNull Item>> hostReplacingItemAndReplacementSupplier, @NotNull Model model) {
+            this.real = real;
+            this.host = host;
+            this.hostReplacement = hostReplacement;
+            this.hostItemSupplier = hostItemSupplier;
+            this.fallback = fallback;
+            this.fallbackItemSupplier = fallbackItemSupplier;
+            this.hostReplacingItemAndReplacementSupplier = hostReplacingItemAndReplacementSupplier;
+            this.model = model;
+            Validate.isTrue(this.model.getIntention() == ResourcePackAssetIntention.BLOCK);
+        }
+
+        @Override
+        public @Nullable BlockState replace(@NotNull BlockState state, boolean hasResourcePack) {
+            if (state.is(this.real)) {
+                return hasResourcePack ? this.host : this.fallback;
+            } else if (state.equals(this.host)) {
+                return hasResourcePack ? this.hostReplacement : this.host;
+            }
+            return null;
+        }
+
+        @Override
+        public @NotNull Block getReal() {
+            return this.real;
+        }
+
+        @Override
+        public @Nullable Item getHostItem() {
+            if (this.hostItem == null) {
+                if (this.hostItemSupplier == null) {
+                    return null;
+                }
+                this.hostItem = this.hostItemSupplier.get();
+                this.hostItemSupplier = null;
+            }
+            return this.hostItem;
+        }
+
+        @Override
+        public @Nullable Item getFallbackItem() {
+            if (this.fallbackItem == null) {
+                if (this.fallbackItemSupplier == null) {
+                    return null;
+                }
+                this.fallbackItem = this.fallbackItemSupplier.get();
+                this.fallbackItemSupplier = null;
+            }
+            return this.fallbackItem;
+        }
+
+        private @Nullable Item getHostReplacingItem() {
+            if (this.hostReplacingItem == null) {
+                if (this.hostReplacingItemAndReplacementSupplier != null) {
+                    @NotNull Pair<@NotNull Item, @NotNull Item> hostReplacingItemAndReplacement = this.hostReplacingItemAndReplacementSupplier.get();
+                    this.hostReplacingItem = hostReplacingItemAndReplacement.left();
+                    this.hostReplacingItemReplacement = hostReplacingItemAndReplacement.right();
+                    this.hostReplacingItemAndReplacementSupplier = null;
+                }
+            }
+            return this.hostReplacingItem;
+        }
+
+        private @Nullable Item getHostReplacingItemReplacement() {
+            if (this.hostReplacingItemReplacement == null) {
+                if (this.hostReplacingItemAndReplacementSupplier != null) {
+                    @NotNull Pair<@NotNull Item, @NotNull Item> hostReplacingItemAndReplacement = this.hostReplacingItemAndReplacementSupplier.get();
+                    this.hostReplacingItem = hostReplacingItemAndReplacement.left();
+                    this.hostReplacingItemReplacement = hostReplacingItemAndReplacement.right();
+                    this.hostReplacingItemAndReplacementSupplier = null;
+                }
+            }
+            return this.hostReplacingItemReplacement;
+        }
+
+        @Override
+        public boolean isHostReplacing(@NotNull Item item) {
+            return item.equals(this.getHostReplacingItem());
+        }
+
+        @Override
+        public @NotNull Iterable<@NotNull Item> getHostReplacingItems() {
+            @Nullable Item hostReplacingItem = this.getHostReplacingItem();
+            if (hostReplacingItem == null) {
+                return Collections.emptyList();
+            } else {
+                return Collections.singletonList(hostReplacingItem);
+            }
+        }
+
+        @Override
+        public @Nullable Item getHostReplacingItemReplacement(@NotNull Item item) {
+            if (this.isHostReplacing(item)) {
+                return this.getHostReplacingItemReplacement();
+            }
+            return null;
+        }
+
+        @Override
+        public @Nullable Model getModelForStatePlacedByItem() {
+            return this.model;
+        }
+
+        @Override
+        public void updateMinDestroyTimeOfHost() {
+            this.host.getBlock().properties.destroyTime(this.getMinDestroyTimeOfHostAndHostReplacement());
+        }
+
+        @Override
+        public float getMinDestroyTimeOfHostAndFallback() {
+            return Math.min(
+                this.host.getBlock().properties.destroyTime,
+                this.fallback.getBlock().properties.destroyTime
+            );
+        }
+
+        @Override
+        public float getMinDestroyTimeOfHostAndHostReplacement() {
+            return Math.min(
+                this.host.getBlock().properties.destroyTime,
+                this.hostReplacement.getBlock().properties.destroyTime
+            );
+        }
+
+        @Override
+        public void writeToStateIdReplacementArrays() {
+            int realId = Block.BLOCK_STATE_REGISTRY.getId(this.real.defaultBlockState());
+            int hostId = Block.BLOCK_STATE_REGISTRY.getId(this.host);
+            int hostReplacementId = Block.BLOCK_STATE_REGISTRY.getId(this.hostReplacement);
+            int fallbackId = Block.BLOCK_STATE_REGISTRY.getId(this.fallback);
+            Block.stateIdReplacementArrayWithResourcePack[realId] = hostId;
+            Block.stateIdReplacementArrayWithResourcePack[hostId] = hostReplacementId;
+            Block.stateIdReplacementArrayWithoutResourcePack[realId] = fallbackId;
+        }
+
+        @Override
+        public void addToResourcePack(@NotNull MutableResourcePack resourcePack) {
+            @NotNull NamespacedKeyWithIntention hostKey = NamespacedKeyWithoutIntention.forMinecraft(Registry.BLOCK.getKey(this.host.getBlock())).withEmptyIntention();
+            @NotNull MutableResourcePackBlockStates minecraftBlockStates = resourcePack.getBlockStates(hostKey);
+            minecraftBlockStates.setNoVariantModel(this.model, resourcePack, false);
+        }
+
+    }
+
+    // Blocks with item form
+
+    static @NotNull StatelessBlockReplacementRule.Builder stateless() {
+        return new StatelessBlockReplacementRule.Builder();
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlockLoot.java b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlockLoot.java
new file mode 100644
index 0000000000000000000000000000000000000000..49c1bb5766ff2766bf106412633d788e3b08a4a7
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlockLoot.java
@@ -0,0 +1,20 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.block;
+
+import net.minecraft.data.loot.BlockLoot;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.level.storage.loot.LootTable;
+
+import java.util.function.BiConsumer;
+
+/**
+ * Based on {@link net.minecraft.data.loot.BlockLoot}
+ */
+public class SuCraftBlockLoot {
+
+    public static void accept(BlockLoot vanilla, BiConsumer<ResourceLocation, LootTable.Builder> biConsumer) {
+        vanilla.dropSelf(SuCraftBlocks.SNOWY_STONE_BRICKS);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlocks.java b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlocks.java
new file mode 100644
index 0000000000000000000000000000000000000000..19c70f29f8d8165387a5604722fe5709c1b875f2
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlocks.java
@@ -0,0 +1,50 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.block;
+
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockBehaviour;
+import net.minecraft.world.level.material.Material;
+import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+
+/**
+ * Based on {@link net.minecraft.world.level.block.Blocks}
+ */
+public class SuCraftBlocks {
+
+    /**
+     * Based on {@link Blocks#STONE_BRICKS}
+     */
+    public static final Block SNOWY_STONE_BRICKS = register(
+        "snowy_stone_bricks",
+        BlockReplacementRule.stateless()
+            .withHost(Blocks.INFESTED_STONE_BRICKS)
+            .withHostReplacement(Blocks.STONE_BRICKS)
+            .withFullBlockBoundingBoxHostItem()
+            .withFallback(Blocks.STONE_BRICKS)
+            .withFallbackBlockAsFallbackItem()
+            .withHostReplacingItemFromHostBlock()
+            .withHostReplacingItemReplacementFromHostReplacementBlock()
+            .withModel(Model.DEFAULT_CUBE_MODEL(ResourcePackAssetIntention.BLOCK)),
+        new Block(BlockBehaviour.Properties.of(Material.STONE).requiresCorrectToolForDrops().strength(1.5F, 6.0F))
+    );
+
+    private static Block register(String id, BlockReplacementRule.Builder<?> replacementRuleBuilder, Block block) {
+        Block registeredBlock = Registry.register(Registry.BLOCK, ResourceLocation.sucraft(id), block);
+        registeredBlock.isVanilla = false;
+        registeredBlock.replacementRule = replacementRuleBuilder.withReal(registeredBlock).build();
+        // Patch the break time, because the vanilla client will assume its own breaking time and if we do not allow for it, we get desync in whether the block is finished being broken
+        registeredBlock.replacementRule.updateMinDestroyTimes();
+        return registeredBlock;
+    }
+
+    public static Block bootstrap() {
+        SNOWY_STONE_BRICKS.toString();
+        return SNOWY_STONE_BRICKS;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ExistingModelContent.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ExistingModelContent.java
new file mode 100644
index 0000000000000000000000000000000000000000..df9aa99f4928a6be33f9db9f104ba462c4d5ad08
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ExistingModelContent.java
@@ -0,0 +1,35 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.blockanditemdata.model;
+
+import nl.martijnmuijsers.paper.blockanditemdata.texture.TextureContent;
+import nl.martijnmuijsers.paper.resourcepack.MutableResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.ResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.MutableResourcePackModel;
+import nl.martijnmuijsers.paper.resourcepack.asset.texture.MutableResourcePackTexture;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A reference to some model that is outside the scope of our own resource pack (for example a model already existing) that we do not seek to modify
+ */
+public class ExistingModelContent extends ModelContent {
+
+    private static @Nullable ExistingModelContent instance;
+
+    public static @NotNull ExistingModelContent getInstance() {
+        if (instance == null) {
+            instance = new ExistingModelContent();
+        }
+        return instance;
+    }
+
+    private ExistingModelContent() {}
+
+    /**
+     * Since this is content that already exists, it does not need to be written
+     */
+    @Override
+    void writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack) {}
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/Model.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/Model.java
new file mode 100644
index 0000000000000000000000000000000000000000..f0a5d8043d1eb970f4cd7842ed3f9765d062d5b9
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/Model.java
@@ -0,0 +1,52 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.blockanditemdata.model;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import nl.martijnmuijsers.paper.resourcepack.MutableResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.MutableResourcePackModel;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackIntentionedAssetDataByContent;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.function.Function;
+
+/**
+ * An immutable item or block model
+ */
+public class Model extends ResourcePackIntentionedAssetDataByContent<ModelContent> {
+
+    public Model(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key, @NotNull ModelContent content) {
+       super(intention, key, content);
+    }
+
+    public @NotNull Model getReference(@NotNull ResourcePackAssetIntention newIntention) {
+        return new Model(newIntention, this.key, ModelContent.reference(this));
+    }
+
+    public void addToResourcePack(@NotNull MutableResourcePack resourcePack, boolean overwriteExisting) {
+        @NotNull MutableResourcePackModel resourcePackModel = resourcePack.getOrCreateModel(this.intention, this.key);
+        if (!resourcePackModel.isJsonEmpty() && !overwriteExisting) {
+            return;
+        }
+        if (!resourcePackModel.isJsonEmpty()) {
+            resourcePackModel.clearJson();
+        }
+        this.content.writeToClearResourcePackModel(resourcePackModel, resourcePack);
+    }
+
+    // Some default model builder method argument functions (easy to pass to StatelessBlockReplacementRule.Builder.withModel and similar methods)
+
+    // Model by content (for replacement rule builders)
+
+    public static @NotNull Function<@NotNull ResourceLocation, @NotNull Model> MODEL_BY_MODEL_CONTENT(@NotNull Function<@NotNull ResourceLocation, @NotNull ModelContent> modelContentFunction) {
+        return resourceLocation -> new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.forMinecraft(resourceLocation), modelContentFunction.apply(resourceLocation));
+    }
+
+    public static @NotNull Function<@NotNull ResourceLocation, @NotNull Model> DEFAULT_CUBE_MODEL(@NotNull ResourcePackAssetIntention intention) {
+        return MODEL_BY_MODEL_CONTENT(ModelContent.DEFAULT_CUBE_MODEL_CONTENT(intention));
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelContent.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelContent.java
new file mode 100644
index 0000000000000000000000000000000000000000..58aabc4fc0f4b9f2feba2c47e13ed3f98a5b3cc3
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelContent.java
@@ -0,0 +1,56 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.blockanditemdata.model;
+
+import net.minecraft.resources.ResourceLocation;
+import nl.martijnmuijsers.paper.blockanditemdata.texture.ExistingTextureContent;
+import nl.martijnmuijsers.paper.blockanditemdata.texture.Texture;
+import nl.martijnmuijsers.paper.blockanditemdata.texture.TextureContent;
+import nl.martijnmuijsers.paper.resourcepack.MutableResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.MutableResourcePackModel;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAssetDataContent;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.function.Function;
+
+/**
+ * The immutable content of a model: a {@link Model} without any information about its appropriate location in a resource pack
+ */
+public abstract class ModelContent implements ResourcePackAssetDataContent {
+
+    protected ModelContent() {}
+
+    public @NotNull Model asModel(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) {
+        return new Model(intention, key, this);
+    }
+
+    /**
+     * Note that this method will attempt to add any used textures to the resource pack, but will not overwrite any existing ones
+     */
+    abstract void writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack);
+
+    public static @NotNull ModelContent existing() {
+        return ExistingModelContent.getInstance();
+    }
+
+    public static @NotNull ModelContent reference(@NotNull Model parent) {
+        return new ReferenceModelContent(parent);
+    }
+
+    public static @NotNull ModelContent cube(@NotNull Texture texture) {
+        return new OneTextureCubeModelContent(texture);
+    }
+
+    // Model content by textures (for replacement rule builders)
+
+    public static @NotNull Function<@NotNull ResourceLocation, @NotNull ModelContent> CUBE_MODEL_CONTENT_BY_TEXTURE(@NotNull Function<@NotNull ResourceLocation, @NotNull Texture> textureFunction) {
+        return resourceLocation -> ModelContent.cube(textureFunction.apply(resourceLocation));
+    }
+
+    public static @NotNull Function<@NotNull ResourceLocation, @NotNull ModelContent> DEFAULT_CUBE_MODEL_CONTENT(@NotNull ResourcePackAssetIntention intention) {
+        return CUBE_MODEL_CONTENT_BY_TEXTURE(Texture.DEFAULT_TEXTURE(intention));
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/OneTextureCubeModelContent.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/OneTextureCubeModelContent.java
new file mode 100644
index 0000000000000000000000000000000000000000..2b162b6151be105b8724c7aaa1939a4e06e2f283
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/OneTextureCubeModelContent.java
@@ -0,0 +1,33 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.blockanditemdata.model;
+
+import nl.martijnmuijsers.paper.resourcepack.MutableResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.MutableResourcePackModel;
+import nl.martijnmuijsers.paper.blockanditemdata.texture.Texture;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A basic form of {@link ModelContent}: a full cube with the same texture on all 6 sides
+ */
+public class OneTextureCubeModelContent extends ModelContent {
+
+    private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("cube_all"), ModelContent.existing());
+
+    private final @NotNull Texture texture;
+
+    OneTextureCubeModelContent(@NotNull Texture texture) {
+        super();
+        this.texture = texture;
+    }
+
+    @Override
+    void writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack) {
+        resourcePackModel.setParent(parent);
+        resourcePackModel.setAllTextures(this.texture);
+        this.texture.addToResourcePack(resourcePack, false);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ReferenceModelContent.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ReferenceModelContent.java
new file mode 100644
index 0000000000000000000000000000000000000000..80f830be5b604b1189822cad2fe0a32bf7b395fa
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ReferenceModelContent.java
@@ -0,0 +1,29 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.blockanditemdata.model;
+
+import nl.martijnmuijsers.paper.blockanditemdata.texture.Texture;
+import nl.martijnmuijsers.paper.resourcepack.MutableResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.MutableResourcePackModel;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A reference to some model that is outside the scope of our own resource pack (for example a model already existing, for use as a parent)
+ */
+public class ReferenceModelContent extends ModelContent {
+
+    private final @NotNull Model parent;
+
+    ReferenceModelContent(@NotNull Model parent) {
+        this.parent = parent;
+    }
+
+    @Override
+    void writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack) {
+        resourcePackModel.setParent(parent);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/ExistingTextureContent.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/ExistingTextureContent.java
new file mode 100644
index 0000000000000000000000000000000000000000..555dae6ead496d78ea6bdccff33b22a657136c35
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/ExistingTextureContent.java
@@ -0,0 +1,31 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.blockanditemdata.texture;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.texture.MutableResourcePackTexture;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A reference to some texture that is outside the scope of our own resource pack (for example a texture already existing)
+ */
+public class ExistingTextureContent extends TextureContent {
+
+    private static @Nullable ExistingTextureContent instance;
+
+    public static @NotNull ExistingTextureContent getInstance() {
+        if (instance == null) {
+            instance = new ExistingTextureContent();
+        }
+        return instance;
+    }
+
+    private ExistingTextureContent() {}
+
+    /**
+     * Since this is content that already exists, it does not need to be written
+     */
+    @Override
+    void writeToResourcePackTexture(@NotNull MutableResourcePackTexture resourcePackTexture) {}
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/FileToImportPathTextureContent.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/FileToImportPathTextureContent.java
new file mode 100644
index 0000000000000000000000000000000000000000..d31d9dca41de97c57c51e0ca9c19abea7ea19e8a
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/FileToImportPathTextureContent.java
@@ -0,0 +1,39 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.blockanditemdata.texture;
+
+import net.minecraft.resources.ResourceLocation;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAssetType;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.texture.MutableResourcePackTexture;
+import nl.martijnmuijsers.paper.resourcepack.sucraft.CreateSuCraftResourcePack;
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Path;
+import java.util.function.Function;
+
+/**
+ * A basic form of {@link TextureContent}: whatever is in the file that the stored path points to
+ */
+public class FileToImportPathTextureContent extends TextureContent {
+
+    private final @NotNull String fileToImportPath;
+
+    FileToImportPathTextureContent(@NotNull String fileToImportPath) {
+        super();
+        this.fileToImportPath = fileToImportPath;
+    }
+
+    @Override
+    void writeToResourcePackTexture(@NotNull MutableResourcePackTexture resourcePackTexture) {
+        resourcePackTexture.setBasedOnFileToImport(this.fileToImportPath);
+    }
+
+    // Default import file path (for replacement rule builders)
+
+    public static @NotNull Function<@NotNull ResourceLocation, @NotNull String> DEFAULT_FILE_TO_IMPORT_PATH(@NotNull ResourcePackAssetIntention intention) {
+        return resourceLocation -> Path.of(CreateSuCraftResourcePack.INPUT_TEXTURES_FOLDER_PATH, NamespacedKeyWithoutIntention.forMinecraft(resourceLocation).withIntention(intention).keyWithIntention() + ResourcePackAssetType.TEXTURE.getDefaultFileExtension()).toString();
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/Texture.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/Texture.java
new file mode 100644
index 0000000000000000000000000000000000000000..541fabcc1f0205235d980fc934101aa630aa8bbc
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/Texture.java
@@ -0,0 +1,42 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.blockanditemdata.texture;
+
+import net.minecraft.resources.ResourceLocation;
+import nl.martijnmuijsers.paper.resourcepack.MutableResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackIntentionedAssetDataByContent;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.texture.MutableResourcePackTexture;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.function.Function;
+
+/**
+ * An immutable item or block texture
+ */
+public class Texture extends ResourcePackIntentionedAssetDataByContent<TextureContent> {
+
+    public Texture(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key, @NotNull TextureContent content) {
+        super(intention, key, content);
+    }
+
+    public void addToResourcePack(@NotNull MutableResourcePack resourcePack, boolean overwriteExisting) {
+        @NotNull MutableResourcePackTexture resourcePackTexture = resourcePack.getOrCreateTexture(this.intention, this.key);
+        if (!resourcePackTexture.hasData() && !overwriteExisting) {
+            return;
+        }
+        this.content.writeToResourcePackTexture(resourcePackTexture);
+    }
+
+    // Texture by texture content (for replacement rule builders)
+
+    public static @NotNull Function<@NotNull ResourceLocation, @NotNull Texture> TEXTURE_BY_TEXTURE_CONTENT(@NotNull Function<@NotNull ResourceLocation, @NotNull TextureContent> textureContentFunction) {
+        return resourceLocation -> new Texture(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.forMinecraft(resourceLocation), textureContentFunction.apply(resourceLocation));
+    }
+
+    public static @NotNull Function<@NotNull ResourceLocation, @NotNull Texture> DEFAULT_TEXTURE(@NotNull ResourcePackAssetIntention intention) {
+        return TEXTURE_BY_TEXTURE_CONTENT(TextureContent.DEFAULT_TEXTURE_CONTENT(intention));
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/TextureContent.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/TextureContent.java
new file mode 100644
index 0000000000000000000000000000000000000000..243b3072f942f044239f793443c03aa5d2cbbd13
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/TextureContent.java
@@ -0,0 +1,45 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.blockanditemdata.texture;
+
+import net.minecraft.resources.ResourceLocation;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAssetDataContent;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.texture.MutableResourcePackTexture;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.function.Function;
+
+/**
+ * The immutable content of a texture: a {@link Texture} without any information about its appropriate location in a resource pack
+ */
+public abstract class TextureContent implements ResourcePackAssetDataContent {
+
+    protected TextureContent() {}
+
+    public @NotNull Texture asTexture(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) {
+        return new Texture(intention, key, this);
+    }
+
+    abstract void writeToResourcePackTexture(@NotNull MutableResourcePackTexture resourcePackTexture);
+
+    public static @NotNull TextureContent existing() {
+        return ExistingTextureContent.getInstance();
+    }
+
+    public static @NotNull TextureContent fileToImport(@NotNull String fileToImportPath) {
+        return new FileToImportPathTextureContent(fileToImportPath);
+    }
+
+    // Texture content by file path (for replacement rule builders)
+
+    public static @NotNull Function<@NotNull ResourceLocation, @NotNull TextureContent> TEXTURE_CONTENT_BY_FILE_TO_IMPORT_PATH(@NotNull Function<@NotNull ResourceLocation, @NotNull String> fileToImportFunction) {
+        return resourceLocation -> TextureContent.fileToImport(fileToImportFunction.apply(resourceLocation));
+    }
+
+    public static @NotNull Function<@NotNull ResourceLocation, @NotNull TextureContent> DEFAULT_TEXTURE_CONTENT(@NotNull ResourcePackAssetIntention intention) {
+        return TEXTURE_CONTENT_BY_FILE_TO_IMPORT_PATH(FileToImportPathTextureContent.DEFAULT_FILE_TO_IMPORT_PATH(intention));
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/data/BlackHoleCachedOutput.java b/src/main/java/nl/martijnmuijsers/paper/data/BlackHoleCachedOutput.java
index 6af9cb40f08526365030843ca609220c6c16b120..9f609f9b9df23040416b3907f92cdda28153d0ad 100644
--- a/src/main/java/nl/martijnmuijsers/paper/data/BlackHoleCachedOutput.java
+++ b/src/main/java/nl/martijnmuijsers/paper/data/BlackHoleCachedOutput.java
@@ -4,8 +4,8 @@ package nl.martijnmuijsers.paper.data;
 
 import com.google.common.hash.HashCode;
 import net.minecraft.data.CachedOutput;
+import org.jetbrains.annotations.NotNull;
 
-import java.io.IOException;
 import java.nio.file.Path;
 
 /**
@@ -14,6 +14,6 @@ import java.nio.file.Path;
 public class BlackHoleCachedOutput implements CachedOutput {
 
     @Override
-    public void writeIfNeeded(Path path, byte[] data, HashCode hashCode) {}
+    public void writeIfNeeded(@NotNull Path path, byte @NotNull [] data, @NotNull HashCode hashCode) {}
 
 }
diff --git a/src/main/java/nl/martijnmuijsers/paper/data/SuCraftTagsProvider.java b/src/main/java/nl/martijnmuijsers/paper/data/SuCraftTagsProvider.java
index 1491d5ff59ee49cd230f67eebf705d81c4e17dfb..4b30f9b23f095e6850d34161547c15cb23ac839e 100644
--- a/src/main/java/nl/martijnmuijsers/paper/data/SuCraftTagsProvider.java
+++ b/src/main/java/nl/martijnmuijsers/paper/data/SuCraftTagsProvider.java
@@ -11,6 +11,7 @@ import net.minecraft.server.MinecraftServer;
 import net.minecraft.tags.TagBuilder;
 import net.minecraft.tags.TagEntry;
 import net.minecraft.tags.TagKey;
+import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -43,13 +44,13 @@ public abstract class SuCraftTagsProvider<T> {
 
             @Nullable
             @Override
-            public T element(ResourceLocation elementId) {
+            public T element(@NotNull ResourceLocation elementId) {
                 return SuCraftTagsProvider.this.registry.get(elementId);
             }
 
             @Nullable
             @Override
-            public Collection<T> tag(ResourceLocation otherTagId) {
+            public Collection<T> tag(@NotNull ResourceLocation otherTagId) {
                 TagKey<T> otherTagKey = TagKey.create(SuCraftTagsProvider.this.registry.key(), otherTagId);
                 return updatedRegistryTagEntries.get(otherTagKey).stream().map(Holder::value).toList();
             }
@@ -63,10 +64,10 @@ public abstract class SuCraftTagsProvider<T> {
             TagKey<T> tagKey = TagKey.create(SuCraftTagsProvider.this.registry.key(), tagId);
             // Get the tag entries that were added for this tag in addTags
             List<TagEntry> tagEntriesToMerge = builder.build();
-            // Filter only thetag  entries that exist (i.e. elements that exist in the registry, or tags that were defined earlier)
+            // Filter only the tag entries that exist (i.e. elements that exist in the registry, or tags that were defined earlier)
             List<TagEntry> validTagEntriesToMerge = new ArrayList<>(tagEntriesToMerge.size());
             tagEntriesToMerge.forEach(tagEntry -> {
-                if (tagEntry.verifyIfPresent(this.registry::containsKey, this.builders::containsKey)) { // Actually using existingRegistryEntries instead of this.builders seems more logical but the vanilla code uses builders so we'll just go with that
+                if (tagEntry.verifyIfPresent(this.registry::containsKey, this.builders::containsKey)) { // Actually using existingRegistryEntries instead of this.builders seems more logical but the vanilla code uses builders, so we'll just go with that
                     validTagEntriesToMerge.add(tagEntry);
                 } else {
                     MinecraftServer.LOGGER.error(String.format("The tag definition %s could not be fully defined as it is missing following reference: %s", tagId, tagEntry));
@@ -76,7 +77,7 @@ public abstract class SuCraftTagsProvider<T> {
             validTagEntriesToMerge.forEach(tagEntry ->
                 tagEntry.build(
                     lookup,
-                    newElement -> {
+                    newElement ->
                         updatedRegistryTagEntries.compute(tagKey, (sameTagKey, elementsForTag) -> {
                             if (elementsForTag == null) {
                                 // Make sure the list of elements for this tag exists
@@ -90,8 +91,7 @@ public abstract class SuCraftTagsProvider<T> {
                             elementsForTag.add(holder);
                             // Return the new list of elements for this tag
                             return elementsForTag;
-                        });
-                    }
+                        })
                 )
             );
         });
@@ -106,9 +106,7 @@ public abstract class SuCraftTagsProvider<T> {
     }
 
     protected TagBuilder getOrCreateRawBuilder(TagKey<T> tag) {
-        return this.builders.computeIfAbsent(tag.location(), (id) -> {
-            return TagBuilder.create();
-        });
+        return this.builders.computeIfAbsent(tag.location(), (id) -> TagBuilder.create());
     }
 
     protected static class TagAppender<T> {
diff --git a/src/main/java/nl/martijnmuijsers/paper/item/ItemReplacementRule.java b/src/main/java/nl/martijnmuijsers/paper/item/ItemReplacementRule.java
new file mode 100644
index 0000000000000000000000000000000000000000..be9a7e40394c5a7bd705b4e5c44240e71a96eeea
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/item/ItemReplacementRule.java
@@ -0,0 +1,276 @@
+package nl.martijnmuijsers.paper.item;
+
+import com.google.common.collect.Lists;
+import net.minecraft.ChatFormatting;
+import net.minecraft.core.Registry;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.StringTag;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.Style;
+import net.minecraft.network.chat.TextColor;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Rarity;
+import net.minecraft.world.level.block.Block;
+import nl.martijnmuijsers.paper.resourcepack.MutableResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.MutableResourcePackModel;
+import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelContent;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+
+public interface ItemReplacementRule {
+
+    interface Builder {
+
+        @NotNull ItemReplacementRule.Builder withReal(@NotNull Item real);
+
+        @NotNull ItemReplacementRule build();
+
+    }
+
+    @Nullable ItemStack replace(ItemStack item, boolean hasResourcePack);
+
+    @NotNull Item getReal();
+
+    @NotNull Model getModel();
+
+    void addToResourcePack(@NotNull MutableResourcePack resourcePack);
+
+    class SimpleItemReplacementRule implements ItemReplacementRule {
+
+        public static class Builder implements ItemReplacementRule.Builder {
+
+            private @Nullable Item real;
+            private @Nullable Supplier<@NotNull Item> hostSupplier;
+            private @Nullable Function<@NotNull Item, @NotNull Integer> computeHostCustomModelData;
+            private @Nullable Supplier<@NotNull Item> fallbackSupplier;
+            private @NotNull Predicate<@NotNull Item> isBlockHostReplacingPredicate = item -> false;
+            private @NotNull Function<@NotNull Item, @Nullable Item> blockHostReplacingItemReplacementFunction = item -> null;
+            private @Nullable Supplier<@NotNull Model> modelSupplier;
+
+            @Override
+            public @NotNull SimpleItemReplacementRule.Builder withReal(@NotNull Item real) {
+                this.real = real;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withHost(@NotNull Supplier<@NotNull Item> hostSupplier) {
+                this.hostSupplier = hostSupplier;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withHostCustomModelData(int hostCustomModelData) {
+                this.computeHostCustomModelData = host -> hostCustomModelData;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withNextUnusedHostCustomModelData() {
+                this.computeHostCustomModelData = UsedHostCustomModelData::generateUnusedHostCustomModelData;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withFallback(@NotNull Supplier<@NotNull Item> fallbackSupplier) {
+                this.fallbackSupplier = fallbackSupplier;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withIsBlockHostReplacing(@NotNull Predicate<@NotNull Item> isBlockHostReplacingPredicate) {
+                this.isBlockHostReplacingPredicate = isBlockHostReplacingPredicate;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withBlockHostReplacingItemReplacement(@NotNull Function<@NotNull Item, @Nullable Item> blockHostReplacingItemReplacementFunction) {
+                this.blockHostReplacingItemReplacementFunction = blockHostReplacingItemReplacementFunction;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withModel(@NotNull Model model) {
+                this.modelSupplier = () -> model;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withModelContent(@NotNull ModelContent modelContent) {
+                this.modelSupplier = () -> {
+                    Validate.notNull(this.real);
+                    return modelContent.asModel(ResourcePackAssetIntention.ITEM, NamespacedKeyWithoutIntention.forMinecraft(Registry.ITEM.getKey(this.real)));
+                };
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder forBlock(@NotNull Block block) {
+                return this
+                    .withHost(() -> block.replacementRule.getHostItem())
+                    .withNextUnusedHostCustomModelData()
+                    .withFallback(() -> block.replacementRule.getFallbackItem())
+                    .withIsBlockHostReplacing(item -> block.replacementRule.isHostReplacing(item))
+                    .withBlockHostReplacingItemReplacement(item -> block.replacementRule.getHostReplacingItemReplacement(item))
+                    .withModel(block.replacementRule.getModelForStatePlacedByItem().getReference(ResourcePackAssetIntention.ITEM));
+            }
+
+            @Override
+            public @NotNull SimpleItemReplacementRule build() {
+                Validate.notNull(this.real);
+                Validate.notNull(this.hostSupplier);
+                Validate.notNull(this.computeHostCustomModelData);
+                Validate.notNull(this.fallbackSupplier);
+                Validate.notNull(this.modelSupplier);
+                return new SimpleItemReplacementRule(this.real, this.hostSupplier, this.computeHostCustomModelData, this.fallbackSupplier, this.isBlockHostReplacingPredicate, this.blockHostReplacingItemReplacementFunction, this.modelSupplier.get());
+            }
+
+        }
+
+        private final @NotNull Item real;
+        private @Nullable Item host = null;
+        private @Nullable Supplier<@NotNull Item> hostSupplier;
+        private int hostCustomModelData = -1;
+        private @Nullable Function<@NotNull Item, @NotNull Integer> computeHostCustomModelData;
+        private @Nullable Item fallback = null;
+        private @Nullable Supplier<@NotNull Item> fallbackSupplier;
+        private final @NotNull Predicate<@NotNull Item> isBlockHostReplacingPredicate;
+        private final @NotNull Function<@NotNull Item, @Nullable Item> blockHostReplacingItemReplacementFunction;
+        private final @NotNull Model model;
+
+        private SimpleItemReplacementRule(@NotNull Item real, @NotNull Supplier<@NotNull Item> hostSupplier, @NotNull Function<@NotNull Item, @NotNull Integer> computeHostCustomModelData, @NotNull Supplier<@NotNull Item> fallbackSupplier, @NotNull Predicate<@NotNull Item> isBlockHostReplacingPredicate, @NotNull Function<@NotNull Item, @Nullable Item> blockHostReplacingItemReplacementFunction, @NotNull Model model) {
+            this.real = real;
+            this.hostSupplier = hostSupplier;
+            this.computeHostCustomModelData = computeHostCustomModelData;
+            this.fallbackSupplier = fallbackSupplier;
+            this.isBlockHostReplacingPredicate = isBlockHostReplacingPredicate;
+            this.blockHostReplacingItemReplacementFunction = blockHostReplacingItemReplacementFunction;
+            this.model = model;
+            Validate.isTrue(this.model.getIntention() == ResourcePackAssetIntention.ITEM);
+        }
+
+        /**
+         * Will set the display name if there is no custom display name set, and if a custom display name is set, will set the given string as a prefix line in lore (to avoid confusion, by avoiding players having to look at the namespaced key shown with F3+H, which would typically be wrong)
+         * @param tag Optional, just for convenience in case we already have it to avoid unnecessarily retrieving it twice
+         * @param rarity Optional as an override, will otherwise be retrieved from the item if needed
+         */
+        private void replaceItemStackDisplayName(@NotNull ItemStack item, @Nullable CompoundTag tag, @Nullable Rarity rarity, @NotNull String displayNameJSON, @NotNull String displayNameInLoreJSON) {
+            if (tag == null) {
+                tag = item.getOrCreateTag();
+            }
+            if (rarity == null) {
+                rarity = item.getRarity();
+            }
+            // Setting display name is based on CraftMetaItem.applyToItem(CompoundTag)
+            // Could potentially also be based on ItemStack.setHoverName(Component)
+            final CompoundTag display = tag.getCompound(CraftMetaItem.DISPLAY.NBT);
+            if (!tag.contains(CraftMetaItem.DISPLAY.NBT)) {
+                tag.put(CraftMetaItem.DISPLAY.NBT, display);
+            }
+            if (!display.contains(CraftMetaItem.NAME.NBT)) {
+                display.putString(CraftMetaItem.NAME.NBT, displayNameJSON);
+            } else {
+                display.putString(CraftMetaItem.NAME.NBT, Component.Serializer.toJson(Component.Serializer.fromJson(display.getString(CraftMetaItem.NAME.NBT)).withStyle(Style.EMPTY.withColor(rarity.color))));
+                ListTag lore;
+                if (!display.contains(CraftMetaItem.LORE.NBT)) {
+                    lore = new ListTag();
+                    display.put(CraftMetaItem.LORE.NBT, lore);
+                } else {
+                    lore = display.getList(CraftMetaItem.LORE.NBT, 8);
+                }
+                lore.add(0, StringTag.valueOf(displayNameInLoreJSON));
+            }
+        }
+
+        @Override
+        public @Nullable ItemStack replace(@NotNull ItemStack item, boolean hasResourcePack) {
+            if (item.is(this.getReal())) {
+                @NotNull ItemStack clone = item.copy();
+                CompoundTag tag = clone.getOrCreateTag();
+                if (hasResourcePack) {
+                    clone.setItem(this.getHost());
+                    // Setting custom model data is based on CraftMetaItem.applyToItem(CompoundTag)
+                    tag.putInt(CraftMetaItem.CUSTOM_MODEL_DATA.NBT, this.getHostCustomModelData());
+                } else {
+                    clone.setItem(this.getFallback());
+                }
+                replaceItemStackDisplayName(clone, tag, item.getRarity(), this.real.customDisplayNameJSON, this.real.customDisplayNameInLoreJSON);
+                return clone;
+            } else if (this.isBlockHostReplacing(item.getItem()) && hasResourcePack) {
+                @NotNull ItemStack clone = item.copy();
+                clone.setItem(this.getBlockHostReplacingItemReplacement(item.getItem()));
+                var description = Component.translatable(item.getDescriptionId());
+                replaceItemStackDisplayName(clone, null, item.getRarity(), Component.Serializer.toJson(description.withStyle(Style.EMPTY.withColor(clone.getRarity().color).withItalic(false))), Component.Serializer.toJson(description.withStyle(Style.EMPTY.withColor(SuCraftItems.CUSTOM_DISPLAY_NAME_IN_LORE_DEFAULT_COLOR).withItalic(false))));
+                return clone;
+            }
+            return null;
+        }
+
+        @Override
+        public @NotNull Item getReal() {
+            return this.real;
+        }
+
+        public @NotNull Item getHost() {
+            if (this.host == null) {
+                this.host = this.hostSupplier.get();
+                this.hostSupplier = null;
+            }
+            return this.host;
+        }
+
+        public int getHostCustomModelData() {
+            if (this.hostCustomModelData == -1) {
+                this.hostCustomModelData = this.computeHostCustomModelData.apply(this.getHost());
+                this.computeHostCustomModelData = null;
+            }
+            return this.hostCustomModelData;
+        }
+
+        public @NotNull Item getFallback() {
+            if (this.fallback == null) {
+                this.fallback = this.fallbackSupplier.get();
+                this.fallbackSupplier = null;
+            }
+            return this.fallback;
+        }
+
+        /**
+         * Returns true if the given item is a block item that if placed by a player, would place a block in a state that serves as a host for this item's block,
+         * <br>
+         * or false if:
+         * <ul>
+         *     <li>this item is not for a block, or</li>
+         *     <li>if the block this item is for does not have any hosts that can be the state for a block to appear on using some host block's item to place it</li>
+         * </ul>
+         */
+        private boolean isBlockHostReplacing(@NotNull Item item) {
+            return this.isBlockHostReplacingPredicate.test(item);
+        }
+
+        private @Nullable Item getBlockHostReplacingItemReplacement(@NotNull Item item) {
+            return this.blockHostReplacingItemReplacementFunction.apply(item);
+        }
+
+        @Override
+        public @NotNull Model getModel() {
+            return this.model;
+        }
+
+        @Override
+        public void addToResourcePack(@NotNull MutableResourcePack resourcePack) {
+            @NotNull NamespacedKeyWithoutIntention hostKey = NamespacedKeyWithoutIntention.forMinecraft(Registry.ITEM.getKey(this.getHost()));
+            @NotNull MutableResourcePackModel minecraftItemModel = resourcePack.getModel(ResourcePackAssetIntention.ITEM, hostKey);
+            minecraftItemModel.addModelOverride(this.getHostCustomModelData(), this.model, resourcePack, false);
+        }
+
+    }
+
+    static @NotNull SimpleItemReplacementRule.Builder simple() {
+        return new SimpleItemReplacementRule.Builder();
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/item/SuCraftItems.java b/src/main/java/nl/martijnmuijsers/paper/item/SuCraftItems.java
new file mode 100644
index 0000000000000000000000000000000000000000..5425beab643177ca22edbb721f62a13a564f0bd5
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/item/SuCraftItems.java
@@ -0,0 +1,58 @@
+
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.item;
+
+import io.papermc.paper.adventure.PaperAdventure;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.TextDecoration;
+import net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;
+import net.minecraft.ChatFormatting;
+import net.minecraft.core.Registry;
+import net.minecraft.network.chat.TextColor;
+import net.minecraft.world.item.CreativeModeTab;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.item.Items;
+import nl.martijnmuijsers.paper.block.BlockReplacementRule;
+import nl.martijnmuijsers.paper.block.SuCraftBlocks;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Based on {@link net.minecraft.world.item.Items}
+ */
+public class SuCraftItems {
+
+    public static final @NotNull ChatFormatting CUSTOM_DISPLAY_NAME_IN_LORE_DEFAULT_COLOR = ChatFormatting.DARK_GRAY;
+
+    /**
+     * Based on {@link Items#STONE_BRICKS}
+     */
+    public static final Item SNOWY_STONE_BRICKS = registerBlock(SuCraftBlocks.SNOWY_STONE_BRICKS, "Snowy Stone Bricks", CreativeModeTab.TAB_BUILDING_BLOCKS);
+
+    public static Item registerBlock(Block block, String displayName, CreativeModeTab group) {
+        Item registeredItem = Items.registerBlock(block, group);
+        registeredItem.isVanilla = false;
+        registeredItem.replacementRule = ItemReplacementRule.simple().withReal(registeredItem).forBlock(block).build();
+        registeredItem.customDisplayName = Component.text(displayName, PaperAdventure.asAdventure(registeredItem.rarity.color)).decoration(TextDecoration.ITALIC, false);
+        registeredItem.customDisplayNameJSON = GsonComponentSerializer.gson().serialize(registeredItem.customDisplayName);
+        registeredItem.customDisplayName = Component.text(displayName, PaperAdventure.asAdventure(CUSTOM_DISPLAY_NAME_IN_LORE_DEFAULT_COLOR)).decoration(TextDecoration.ITALIC, false);
+        registeredItem.customDisplayNameInLoreJSON = GsonComponentSerializer.gson().serialize(registeredItem.customDisplayName);
+        return registeredItem;
+    }
+
+    public static Item bootstrap() {
+        SNOWY_STONE_BRICKS.toString();
+        // Make sure that the item replacement rule for block items for which the block has some hosts that are potentially placed by vanilla items is registered with those vanilla items
+        for (Block block : Registry.BLOCK) {
+            BlockReplacementRule replacementRule = block.replacementRule;
+            if (replacementRule != null) {
+                for (Item item : replacementRule.getHostReplacingItems()) {
+                    item.replacementRule = block.asItem().replacementRule;
+                }
+            }
+        }
+        return SNOWY_STONE_BRICKS;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/item/UsedHostCustomModelData.java b/src/main/java/nl/martijnmuijsers/paper/item/UsedHostCustomModelData.java
new file mode 100644
index 0000000000000000000000000000000000000000..06a0dc24555614354b73c1d863d9e628e4ff84bc
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/item/UsedHostCustomModelData.java
@@ -0,0 +1,30 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.item;
+
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+import net.minecraft.world.item.Item;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A utility class that keeps track of used custom model data in item replacement hosts
+ */
+public final class UsedHostCustomModelData {
+
+    private UsedHostCustomModelData() {}
+
+    private static final @NotNull Object2IntMap<@NotNull Item> lastUsed = new Object2IntOpenHashMap<>(0);
+
+    static {
+        lastUsed.defaultReturnValue(0); // After all, the custom model data 0 is always in use
+    }
+
+    public static int generateUnusedHostCustomModelData(Item host) {
+        int lastUsedCustomModelData = lastUsed.getInt(host);
+        lastUsedCustomModelData++;
+        lastUsed.put(host, lastUsedCustomModelData);
+        return lastUsedCustomModelData;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/json/JsonMerging.java b/src/main/java/nl/martijnmuijsers/paper/json/JsonMerging.java
new file mode 100644
index 0000000000000000000000000000000000000000..be98f3856147b681feb9895423e5f2a49a7f87f5
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/json/JsonMerging.java
@@ -0,0 +1,59 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.json;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Utility class to merge JSON data, with the first provided instance taking precedent over the second one when any conflict arises
+ */
+public final class JsonMerging {
+
+    private JsonMerging() {}
+
+    /**
+     * Returns a new JSON object, the result of merging the two given JSON objects (where the first provided JSON object takes precedence in any conflicts)
+     */
+    public static @NotNull JsonObject merge(@NotNull JsonObject json1, @NotNull JsonObject json2) {
+        JsonObject newJson = json1.deepCopy();
+        mergeIntoObject(newJson, json2);
+        return newJson;
+    }
+
+    /**
+     * Merges the second given JSON object into the first given JSON object (where the first provided JSON object takes precedence in any conflicts)
+     */
+    public static void mergeIntoObject(@NotNull JsonObject json1, @NotNull JsonObject json2) {
+        for (String key : json2.keySet()) {
+            @Nullable JsonElement element2 = json2.get(key);
+            if (element2 != null) {
+                @Nullable JsonElement element1 = json1.get(key);
+                if (element1 == null) {
+                    json1.add(key, element2.deepCopy());
+                } else {
+                    mergeInto(element1, element2);
+                }
+            }
+        }
+    }
+
+    /**
+     * Merges the second given JSON element into the first given JSON element (where the first provided JSON element takes precedence in any conflicts)
+     */
+    public static void mergeInto(@NotNull JsonElement json1, @NotNull JsonElement json2) {
+        if (json1 instanceof JsonArray jsonArray1) {
+            if (json2 instanceof JsonArray jsonArray2) {
+                jsonArray1.addAll(jsonArray2);
+            }
+        } else if (json1 instanceof JsonObject jsonObject1) {
+            if (json2 instanceof JsonObject jsonObject2) {
+                mergeIntoObject(jsonObject1, jsonObject2);
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/protocol/CachableCustomContentReplaceable.java b/src/main/java/nl/martijnmuijsers/paper/protocol/CachableCustomContentReplaceable.java
new file mode 100644
index 0000000000000000000000000000000000000000..c6967b23c422a0e4a0bf6f1a2bcf6465f99106cc
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/protocol/CachableCustomContentReplaceable.java
@@ -0,0 +1,21 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.protocol;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An interface for classes that have custom content that may need to be replaced when being sent to a player
+ */
+public interface CachableCustomContentReplaceable<T extends CachableCustomContentReplaceable<T>> {
+
+    /**
+     * Note: this may not make a full independent copy, merely a copy for the purpose of replacing custom content
+     *
+     * @return A copy of this instances so that it can be modified in-place
+     */
+    @NotNull T copy();
+
+    void replaceCustomContentInPlace(boolean hasResourcePack);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/protocol/ReplacedCustomContentCache.java b/src/main/java/nl/martijnmuijsers/paper/protocol/ReplacedCustomContentCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..f5dabd85a486b834daa902c16b9b960ff385f8b2
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/protocol/ReplacedCustomContentCache.java
@@ -0,0 +1,37 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.protocol;
+
+import javax.annotation.Nullable;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Class to contain a version of an instance that has been modified for players with the resource pack,
+ * and a version for players without the resource pack
+ */
+public class ReplacedCustomContentCache<T extends CachableCustomContentReplaceable<T>> {
+
+    public final @NotNull T original;
+    private @Nullable T withResourcePack;
+    private @Nullable T withoutResourcePack;
+
+    public ReplacedCustomContentCache(@NotNull T original) {
+        this.original = original;
+    }
+
+    public @NotNull T get(boolean hasResourcePack) {
+        if (hasResourcePack) {
+            if (this.withResourcePack == null) {
+                this.withResourcePack = this.original.copy();
+                this.withResourcePack.replaceCustomContentInPlace(true);
+            }
+            return this.withResourcePack;
+        }
+        if (this.withoutResourcePack == null) {
+            this.withoutResourcePack = this.original.copy();
+            this.withoutResourcePack.replaceCustomContentInPlace(false);
+        }
+        return this.withoutResourcePack;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/KeyConstants.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/KeyConstants.java
new file mode 100644
index 0000000000000000000000000000000000000000..8d002ace564f2df10f3cc47c1c569f14dd43b5c1
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/KeyConstants.java
@@ -0,0 +1,74 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A utility class providing the keys of JSON elements in the resource pack format
+ */
+public final class KeyConstants {
+
+    private KeyConstants() {}
+
+    /**
+     * The key for the global pack instance in pack.mcmeta
+     */
+    public static final @NotNull String pack = "pack";
+
+    /**
+     * The resource pack format version
+     */
+    public static final @NotNull String packFormat = "pack_format";
+
+    /**
+     * The description of a resource pack
+     */
+    public static final @NotNull String packDescription = "description";
+
+    /**
+     * The variants of a block (the block states)
+     */
+    public static final @NotNull String variants = "variants";
+
+    /**
+     * The variant key used as block state variant for blocks that have no block states
+     */
+    public static final @NotNull String noVariant = "";
+
+    /**
+     * The model of a variant (block state) of a block, or of a model override
+     */
+    public static final @NotNull String model = "model";
+
+    /**
+     * The parent of an asset
+     */
+    public static final @NotNull String assetParent = "parent";
+
+    /**
+     * The textures of a model
+     */
+    public static final @NotNull String modelTextures = "textures";
+
+    /**
+     * The inner key of textures of a model representing setting all textures
+     */
+    public static final @NotNull String allModelTextures = "all";
+
+    /**
+     * The overrides of a model
+     */
+    public static final @NotNull String modelOverrides = "overrides";
+
+    /**
+     * The predicate of a model override
+     */
+    public static final @NotNull String overridePredicate = "predicate";
+
+    /**
+     * The key for custom model data
+     */
+    public static final @NotNull String customModelData = "custom_model_data";
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/MutableResourcePack.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/MutableResourcePack.java
new file mode 100644
index 0000000000000000000000000000000000000000..40482092b4e5132462d7947741366d2612f47a9e
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/MutableResourcePack.java
@@ -0,0 +1,75 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.InitializableResourcePackAssetType;
+import nl.martijnmuijsers.paper.resourcepack.asset.MutableResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAssetType;
+import nl.martijnmuijsers.paper.resourcepack.asset.blockstates.MutableResourcePackBlockStates;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.MutableResourcePackModel;
+import nl.martijnmuijsers.paper.resourcepack.asset.texture.MutableResourcePackTexture;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A mutable {@link ResourcePack}
+ */
+public interface MutableResourcePack extends ResourcePack {
+
+    @NotNull ResourcePackSettings getSettings();
+
+    @Override
+    @NotNull MutableResourcePackAsset getAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException;
+
+    @Override
+    default @Nullable MutableResourcePackAsset getOptionalAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) {
+        return (MutableResourcePackAsset) ResourcePack.super.getOptionalAsset(type, key);
+    }
+
+    @NotNull MutableResourcePackAsset getOrCreateAsset(@NotNull InitializableResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException;
+
+    default <T extends MutableResourcePackAsset> @NotNull T getOrCreateAsset(@NotNull InitializableResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key, @NotNull Class<T> clazz) throws IllegalArgumentException {
+        //noinspection unchecked
+        return (T) this.getOrCreateAsset(type, key);
+    }
+
+    default @NotNull MutableResourcePackBlockStates getBlockStates(@NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException {
+        return this.getAsset(ResourcePackAssetType.BLOCK_STATES, key, MutableResourcePackBlockStates.class);
+    }
+
+    default @Nullable MutableResourcePackBlockStates getOptionalBlockStates(@NotNull NamespacedKeyWithIntention key) {
+        return this.getOptionalAsset(ResourcePackAssetType.BLOCK_STATES, key, MutableResourcePackBlockStates.class);
+    }
+
+    default @NotNull MutableResourcePackBlockStates getOrCreateBlockStates(@NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException {
+        return this.getOrCreateAsset(ResourcePackAssetType.BLOCK_STATES, key, MutableResourcePackBlockStates.class);
+    }
+
+    default @NotNull MutableResourcePackModel getModel(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) throws IllegalArgumentException {
+        return this.getAsset(ResourcePackAssetType.MODEL, key.withIntention(intention), MutableResourcePackModel.class);
+    }
+
+    default @Nullable MutableResourcePackModel getOptionalModel(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) {
+        return this.getOptionalAsset(ResourcePackAssetType.MODEL, key.withIntention(intention), MutableResourcePackModel.class);
+    }
+
+    default @NotNull MutableResourcePackModel getOrCreateModel(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) throws IllegalArgumentException {
+        return this.getOrCreateAsset(ResourcePackAssetType.MODEL, key.withIntention(intention), MutableResourcePackModel.class);
+    }
+
+    default @NotNull MutableResourcePackTexture getTexture(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) throws IllegalArgumentException {
+        return this.getAsset(ResourcePackAssetType.TEXTURE, key.withIntention(intention), MutableResourcePackTexture.class);
+    }
+
+    default @Nullable MutableResourcePackTexture getOptionalTexture(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) {
+        return this.getOptionalAsset(ResourcePackAssetType.TEXTURE, key.withIntention(intention), MutableResourcePackTexture.class);
+    }
+
+    default @NotNull MutableResourcePackTexture getOrCreateTexture(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) throws IllegalArgumentException {
+        return this.getOrCreateAsset(ResourcePackAssetType.TEXTURE, key.withIntention(intention), MutableResourcePackTexture.class);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/PathConstants.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/PathConstants.java
new file mode 100644
index 0000000000000000000000000000000000000000..54e79eda1d9bba343959b224e35fd3caa0f1492f
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/PathConstants.java
@@ -0,0 +1,109 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A utility class providing the paths of files in the resource pack format
+ */
+public final class PathConstants {
+
+    private PathConstants() {}
+
+    /**
+     * The pack.mcmeta file
+     */
+    public static final class PackMeta {
+
+        public static final @NotNull String name = "pack.mcmeta";
+        public static final @NotNull String pathFromRoot = name;
+
+    }
+
+    /**
+     * The assets folder
+     */
+    public static final class Assets {
+
+        public static final @NotNull String name = "assets";
+        public static final @NotNull String pathFromRoot = name;
+
+    }
+
+    /**
+     * The blockstates folder
+     */
+    public static final class BlockStates {
+
+        public static final @NotNull String name = "blockstates";
+        public static final @NotNull String pathInNamespaceFolder = name;
+
+    }
+
+    /**
+     * The models folder
+     */
+    public static final class Models {
+
+        public static final @NotNull String name = "models";
+        public static final @NotNull String pathInNamespaceFolder = name;
+
+        /**
+         * The block models folder
+         */
+        public static final class Block {
+
+            public static final @NotNull String name = ResourcePackAssetIntention.BLOCK.prefix;
+            public static final @NotNull String pathInNamespaceFolder = Models.pathInNamespaceFolder + "/" + name;
+
+        }
+
+        /**
+         * The item models folder
+         */
+        public static final class Item {
+
+            public static final @NotNull String name = ResourcePackAssetIntention.ITEM.prefix;
+            public static final @NotNull String pathInNamespaceFolder = Models.pathInNamespaceFolder + "/" + name;
+
+        }
+
+    }
+
+    /**
+     * The textures folder
+     */
+    public static final class Textures {
+
+        public static final @NotNull String name = "textures";
+        public static final @NotNull String pathInNamespaceFolder = name;
+
+        /**
+         * The block textures folder
+         */
+        public static final class Block {
+
+            public static final @NotNull String name = ResourcePackAssetIntention.BLOCK.prefix;
+            public static final @NotNull String pathInNamespaceFolder = Textures.pathInNamespaceFolder + "/" + name;
+
+        }
+
+        /**
+         * The item textures folder
+         */
+        public static final class Item {
+
+            public static final @NotNull String name = ResourcePackAssetIntention.ITEM.prefix;
+            public static final @NotNull String pathInNamespaceFolder = Textures.pathInNamespaceFolder + "/" + name;
+
+        }
+
+    }
+
+    public static @NotNull String getNamespaceFolderPathFromRoot(@NotNull String namespace) {
+        return Assets.pathFromRoot + "/" + namespace;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/ResourcePack.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/ResourcePack.java
new file mode 100644
index 0000000000000000000000000000000000000000..2cd9daad642bb1a76e8173a8231d1742c74e86e9
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/ResourcePack.java
@@ -0,0 +1,75 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack;
+
+import it.unimi.dsi.fastutil.Pair;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAssetType;
+import nl.martijnmuijsers.paper.resourcepack.asset.blockstates.ResourcePackBlockStates;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.ResourcePackModel;
+import nl.martijnmuijsers.paper.resourcepack.asset.texture.ResourcePackTexture;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.concurrent.Callable;
+import java.util.stream.Stream;
+
+/**
+ * An interface that provides getters to get things out of an existing resource pack, for example one defined by an archive filename, or one currently being built in memory.
+ */
+public interface ResourcePack {
+
+    @NotNull Stream<@NotNull Pair<@NotNull String, @NotNull Callable<@NotNull InputStream>>> getAllFilesStream() throws IOException;
+
+    @NotNull ResourcePackSettings getSettings();
+
+    @NotNull ResourcePackAsset getAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException;
+
+    default @Nullable ResourcePackAsset getOptionalAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) {
+        try {
+            return this.getAsset(type, key);
+        } catch (Exception e) {
+            return null;
+        }
+    }
+
+    default <T extends ResourcePackAsset> @NotNull T getAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key, @NotNull Class<T> clazz) throws IllegalArgumentException {
+        //noinspection unchecked
+        return (T) this.getAsset(type, key);
+    }
+
+    default <T extends ResourcePackAsset> @Nullable T getOptionalAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key, @NotNull Class<T> clazz) {
+        //noinspection unchecked
+        return (T) this.getOptionalAsset(type, key);
+    }
+
+    default @NotNull ResourcePackBlockStates getBlockStates(@NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException {
+        return this.getAsset(ResourcePackAssetType.BLOCK_STATES, key, ResourcePackBlockStates.class);
+    }
+
+    default @Nullable ResourcePackBlockStates getOptionalBlockStates(@NotNull NamespacedKeyWithIntention key) {
+        return this.getOptionalAsset(ResourcePackAssetType.BLOCK_STATES, key, ResourcePackBlockStates.class);
+    }
+
+    default @NotNull ResourcePackModel getModel(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) throws IllegalArgumentException {
+        return this.getAsset(ResourcePackAssetType.MODEL, key.withIntention(intention), ResourcePackModel.class);
+    }
+
+    default @Nullable ResourcePackModel getOptionalModel(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) {
+        return this.getOptionalAsset(ResourcePackAssetType.MODEL, key.withIntention(intention), ResourcePackModel.class);
+    }
+
+    default @NotNull ResourcePackTexture getTexture(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) throws IllegalArgumentException {
+        return this.getAsset(ResourcePackAssetType.TEXTURE, key.withIntention(intention), ResourcePackTexture.class);
+    }
+
+    default @Nullable ResourcePackTexture getOptionalTexture(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) {
+        return this.getOptionalAsset(ResourcePackAssetType.TEXTURE, key.withIntention(intention), ResourcePackTexture.class);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/ResourcePackSettings.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/ResourcePackSettings.java
new file mode 100644
index 0000000000000000000000000000000000000000..0735331150608e9ee745263ae8f2bda7ccb3aea0
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/ResourcePackSettings.java
@@ -0,0 +1,26 @@
+package nl.martijnmuijsers.paper.resourcepack;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import nl.martijnmuijsers.paper.resourcepack.sucraft.CreateSuCraftResourcePack;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * The top-level settings of a {@link ResourcePack}
+ */
+public interface ResourcePackSettings {
+
+    @NotNull String getName();
+
+    @NotNull JsonElement getDescription();
+
+    default @NotNull JsonObject createJson() {
+        JsonObject json = new JsonObject();
+        JsonObject packJson = new JsonObject();
+        json.add(KeyConstants.pack, packJson);
+        packJson.addProperty(KeyConstants.packFormat, CreateSuCraftResourcePack.RESOURCE_PACK_FORMAT);
+        packJson.add(KeyConstants.packDescription, getDescription());
+        return json;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/InitializableResourcePackAssetType.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/InitializableResourcePackAssetType.java
new file mode 100644
index 0000000000000000000000000000000000000000..d668f71be625cd3ad1f2de4a821146b004d665b5
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/InitializableResourcePackAssetType.java
@@ -0,0 +1,17 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A {@link ResourcePackAssetType} that can be initialized to some empty state
+ */
+public class InitializableResourcePackAssetType extends ResourcePackAssetType {
+
+    protected InitializableResourcePackAssetType(@NotNull String folderPathInNamespaceFolder, @Nullable String defaultFileExtension) {
+        super(folderPathInNamespaceFolder, defaultFileExtension);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/MutableResourcePackAsset.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/MutableResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..d85c52b3cbb4eaad314e7fe66bfd83ef50615a65
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/MutableResourcePackAsset.java
@@ -0,0 +1,41 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A mutable {@link ResourcePackAsset}
+ */
+public interface MutableResourcePackAsset extends ResourcePackAsset {
+
+    /**
+     * Note that merging two assets sets the {@link #isDirty} flag if any of the two assets have it set to true
+     */
+    @Override
+    @NotNull MutableResourcePackAsset merge(@NotNull ResourcePackAsset other);
+
+    /**
+     * Whether this asset would need to be added to a resource pack when written
+     * <br>
+     * This is false when:
+     * <ul>
+     * <li>The asset was created from a default asset and has not been modified</li>
+     * <li>The asset was newly created (not based on a default asset) in an empty state and has not been modified</li>
+     * </ul>
+     * This is true otherwise, for example but not limited to:
+     * <ul>
+     * <li>The asset was created from an included asset</li>
+     * <li>The asset was newly created (not based on a default asset) in a non-empty state</li>
+     * <li>The asset was has modifications since creation that make it non-equal to the default asset, if any</li>
+     * </ul>
+     * Note that this flag may (and will usually) be true if the asset is created from a default asset and then modified in such a way that it ends up being the same as the original again, even though it would be valid (and better) to have it be false
+     */
+    boolean isDirty();
+
+    /**
+     * Sets {@link #isDirty} to true
+     */
+    void setDirty();
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackAsset.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..eb8f64afe4c505bc3703ac9ccea9bf011646c868
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackAsset.java
@@ -0,0 +1,37 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset;
+
+import nl.martijnmuijsers.paper.resourcepack.ResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * An asset (element of some asset type) in a {@link ResourcePack}
+ */
+public interface ResourcePackAsset {
+
+    @NotNull ResourcePackAssetType getType();
+
+    /**
+     * This key does not include the asset type folder (such as models) but does include any subfolders that are an intention (such as block)
+     */
+    @NotNull NamespacedKeyWithIntention getKey();
+
+    default @NotNull String getPathInResourcePack() {
+        return this.getType().getPathInResourcePack(this.getKey());
+    }
+
+    void writeTo(@NotNull OutputStream outputStream) throws IOException;
+
+    /**
+     * Gets the result of merging this asset with the given one
+     * <br>
+     * In any conflicts, this asset will take precedence over the given one
+     */
+    @NotNull ResourcePackAsset merge(@NotNull ResourcePackAsset other);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackAssetDataContent.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackAssetDataContent.java
new file mode 100644
index 0000000000000000000000000000000000000000..25237ac03a56ac1e26e09c651380786cb45e7bc6
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackAssetDataContent.java
@@ -0,0 +1,5 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset;
+
+public interface ResourcePackAssetDataContent {}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackAssetType.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackAssetType.java
new file mode 100644
index 0000000000000000000000000000000000000000..fb4c1abc97dfa44b9eaa5d1843e01808c1182ef6
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackAssetType.java
@@ -0,0 +1,51 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset;
+
+import net.minecraft.server.MinecraftServer;
+import nl.martijnmuijsers.paper.resourcepack.PathConstants;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.apache.commons.lang3.Validate;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A type of {@link ResourcePackAsset}
+ */
+public class ResourcePackAssetType {
+
+    public static final @NotNull InitializableResourcePackAssetType BLOCK_STATES = new InitializableResourcePackAssetType(PathConstants.BlockStates.pathInNamespaceFolder, ".json");
+    public static final @NotNull InitializableResourcePackAssetType MODEL = new InitializableResourcePackAssetType(PathConstants.Models.pathInNamespaceFolder, ".json");
+    public static final @NotNull InitializableResourcePackAssetType TEXTURE = new InitializableResourcePackAssetType(PathConstants.Textures.pathInNamespaceFolder, ".png");
+
+    private final @NotNull String folderPathInNamespaceFolder;
+    /**
+     * This extension includes the dot separating the filename from the extension (so this may be an empty string to indicate that this asset type's files have no extension at all)
+     */
+    public final @Nullable String defaultFileExtension;
+
+    protected ResourcePackAssetType(@NotNull String folderName, @Nullable String defaultFileExtension) {
+        this.folderPathInNamespaceFolder = folderName;
+        this.defaultFileExtension = defaultFileExtension;
+    }
+
+    public @NotNull String getFolderPathInNamespaceFolder() {
+        return this.folderPathInNamespaceFolder;
+    }
+
+    public @NotNull String getDefaultFileExtension() throws IllegalStateException {
+        try {
+            return Validate.notNull(this.defaultFileExtension);
+        } catch (NullPointerException e) {
+            throw new IllegalStateException("Called ResourcePackAssetType.getDefaultFileExtension for a type that does not have a default file extension");
+        }
+    }
+
+    public @NotNull String getPathInResourcePack(@NotNull NamespacedKeyWithIntention assetKey) {
+        if (this.defaultFileExtension == null) {
+            throw new IllegalStateException("Called ResourcePackAssetType.getPathInResourcePack while defaultFileExtension was not set: if a type has multiple extensions, this method cannot be used, and ResourcePackAsset.getPathInResourcePack should be overridden as appropriate");
+        }
+        return PathConstants.getNamespaceFolderPathFromRoot(assetKey.namespace()) + "/" + this.getFolderPathInNamespaceFolder() + "/" + assetKey.keyWithIntention() + this.defaultFileExtension;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackIntentionedAssetData.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackIntentionedAssetData.java
new file mode 100644
index 0000000000000000000000000000000000000000..66e5d7775df20d785860abe085356d3c8cd379ae
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackIntentionedAssetData.java
@@ -0,0 +1,32 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+public abstract class ResourcePackIntentionedAssetData {
+
+    protected final @NotNull ResourcePackAssetIntention intention;
+    protected final @NotNull NamespacedKeyWithoutIntention key;
+
+    protected ResourcePackIntentionedAssetData(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) {
+        this.intention = intention;
+        this.key = key;
+    }
+
+    public @NotNull ResourcePackAssetIntention getIntention() {
+        return this.intention;
+    }
+
+    public @NotNull NamespacedKeyWithoutIntention getKey() {
+        return this.key;
+    }
+
+    public @NotNull NamespacedKeyWithIntention getKeyWithIntention() {
+        return this.key.withIntention(this.intention);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackIntentionedAssetDataByContent.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackIntentionedAssetDataByContent.java
new file mode 100644
index 0000000000000000000000000000000000000000..3c24d7070a2958d94fb925197f8f47bc70f05bfe
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackIntentionedAssetDataByContent.java
@@ -0,0 +1,22 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+public abstract class ResourcePackIntentionedAssetDataByContent<T extends ResourcePackAssetDataContent> extends ResourcePackIntentionedAssetData {
+
+    protected final @NotNull T content;
+
+    protected ResourcePackIntentionedAssetDataByContent(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key, @NotNull T content) {
+        super(intention, key);
+        this.content = content;
+    }
+
+    public @NotNull T getContent() {
+        return this.content;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/SimpleResourcePackAsset.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/SimpleResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..d2c7592594da0701ed1fcd03261fd8ec6a8bcc53
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/SimpleResourcePackAsset.java
@@ -0,0 +1,44 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * Base implementation of {@link MutableResourcePackAsset}
+ */
+public abstract class SimpleResourcePackAsset implements MutableResourcePackAsset {
+
+    private final @NotNull NamespacedKeyWithIntention key;
+
+    private boolean dirty;
+
+    protected SimpleResourcePackAsset(@NotNull NamespacedKeyWithIntention key, boolean dirty) {
+        this.key = key;
+        this.dirty = dirty;
+    }
+
+    protected SimpleResourcePackAsset(@NotNull NamespacedKeyWithIntention key) {
+        this(key, false);
+    }
+
+    @Override
+    public @NotNull NamespacedKeyWithIntention getKey() {
+        return this.key;
+    }
+
+    @Override
+    public boolean isDirty() {
+        return this.dirty;
+    }
+
+    @Override
+    public void setDirty() {
+        this.dirty = true;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/blockstates/ConcreteResourcePackBlockStates.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/blockstates/ConcreteResourcePackBlockStates.java
new file mode 100644
index 0000000000000000000000000000000000000000..a39d8dc6645276d7ed997a4cc18ad93deed37a72
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/blockstates/ConcreteResourcePackBlockStates.java
@@ -0,0 +1,55 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.blockstates;
+
+import com.google.gson.JsonObject;
+import nl.martijnmuijsers.paper.resourcepack.KeyConstants;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAssetType;
+import nl.martijnmuijsers.paper.resourcepack.asset.json.SimpleJsonResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Concrete implementation of {@link MutableResourcePackBlockStates}
+ */
+public class ConcreteResourcePackBlockStates extends SimpleJsonResourcePackAsset<ConcreteResourcePackBlockStates> implements MutableResourcePackBlockStates {
+
+    public ConcreteResourcePackBlockStates(@NotNull JsonObject json, @NotNull NamespacedKeyWithIntention key, boolean dirty) {
+        super(ConcreteResourcePackBlockStates::new, json, key, dirty);
+    }
+
+    public ConcreteResourcePackBlockStates(@NotNull JsonObject json, @NotNull NamespacedKeyWithIntention key) {
+        super(ConcreteResourcePackBlockStates::new, json, key);
+    }
+
+    public ConcreteResourcePackBlockStates(@NotNull ResourcePackBlockStates reference) {
+        this(reference.getJsonCopy(), reference.getKey());
+    }
+
+    @Override
+    public @NotNull ResourcePackAssetType getType() {
+        return ResourcePackAssetType.BLOCK_STATES;
+    }
+
+    @Override
+    public void setModel(@NotNull String variant, @NotNull Model model) {
+        @NotNull JsonObject variantsJson;
+        if (this.json.has(KeyConstants.variants)) {
+            variantsJson = this.json.getAsJsonObject(KeyConstants.variants);
+        } else {
+            variantsJson = new JsonObject();
+            this.json.add(KeyConstants.variants, variantsJson);
+        }
+        @NotNull JsonObject variantJson;
+        if (variantsJson.has(variant)) {
+            variantJson = variantsJson.getAsJsonObject(variant);
+        } else {
+            variantJson = new JsonObject();
+            variantsJson.add(variant, variantJson);
+        }
+        variantJson.addProperty(KeyConstants.model, model.getKeyWithIntention().toString());
+        this.setDirty();
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/blockstates/MutableResourcePackBlockStates.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/blockstates/MutableResourcePackBlockStates.java
new file mode 100644
index 0000000000000000000000000000000000000000..f13b28870052ee67afb3eaf6b7ff3004366fcbd3
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/blockstates/MutableResourcePackBlockStates.java
@@ -0,0 +1,42 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.blockstates;
+
+import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
+import nl.martijnmuijsers.paper.resourcepack.KeyConstants;
+import nl.martijnmuijsers.paper.resourcepack.asset.json.MutableJsonResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.MutableResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A mutable {@link ResourcePackBlockStates}
+ */
+public interface MutableResourcePackBlockStates extends MutableJsonResourcePackAsset, ResourcePackBlockStates {
+
+    @Override
+    @NotNull MutableResourcePackBlockStates merge(@NotNull ResourcePackAsset other);
+
+    /**
+     * @param pack Because this instance is not aware of the resource pack it is in, this pack must be provided to automatically add the given model to the resource pack
+     * @param overwriteExistingModel Whether to overwrite an existing model in the resource pack (this has to do with the model, not with this {@link MutableResourcePackBlockStates} instance: this instance's model property is always overwritten by this method)
+     */
+    default void setModel(@NotNull String variant, @NotNull Model model, @NotNull MutableResourcePack pack, boolean overwriteExistingModel) {
+        this.setModel(variant, model);
+        model.addToResourcePack(pack, overwriteExistingModel);
+    }
+
+    /**
+     * This does not automatically add the model to the resource pack
+     */
+    void setModel(@NotNull String variant, @NotNull Model model);
+
+    default void setNoVariantModel(@NotNull Model model, @NotNull MutableResourcePack pack, boolean overwriteExistingModel) {
+        this.setModel(KeyConstants.noVariant, model, pack, overwriteExistingModel);
+    }
+
+    default void setNoVariantModel(@NotNull Model model) {
+        this.setModel(KeyConstants.noVariant, model);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/blockstates/ResourcePackBlockStates.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/blockstates/ResourcePackBlockStates.java
new file mode 100644
index 0000000000000000000000000000000000000000..9716eca9c118700f8476661f981b31b592753c13
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/blockstates/ResourcePackBlockStates.java
@@ -0,0 +1,18 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.blockstates;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.json.JsonResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.ResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An element of 'blockstates' in a {@link ResourcePack}
+ */
+public interface ResourcePackBlockStates extends JsonResourcePackAsset {
+
+    @Override
+    @NotNull ResourcePackBlockStates merge(@NotNull ResourcePackAsset other);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/image/ImageResourcePackAsset.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/image/ImageResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..b6a85e9f19d80a0aacc16450fe53e1801a4e9606
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/image/ImageResourcePackAsset.java
@@ -0,0 +1,20 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.image;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A {@link ResourcePackAsset} that is intended to hold an image (though, it is possible that {@link #hasData} is false, indicating that there is no data stored in this asset instance yet, although eventually, there always must be)
+ * <br>
+ * Note that this does not necessarily store any of the data referenced in memory, an image asset can also simply hold a filename that we assume points to an image
+ */
+public interface ImageResourcePackAsset extends ResourcePackAsset {
+
+    @Override
+    @NotNull ImageResourcePackAsset merge(@NotNull ResourcePackAsset other);
+
+    boolean hasData();
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/image/MutableImageResourcePackAsset.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/image/MutableImageResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..c57ae7f9074a4fd30834e59362fc7f931d4716a3
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/image/MutableImageResourcePackAsset.java
@@ -0,0 +1,17 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.image;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.MutableResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A mutable {@link ImageResourcePackAsset}
+ */
+public interface MutableImageResourcePackAsset extends MutableResourcePackAsset, ImageResourcePackAsset {
+
+    @Override
+    @NotNull MutableImageResourcePackAsset merge(@NotNull ResourcePackAsset other);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/image/SimpleImageFileResourcePackAsset.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/image/SimpleImageFileResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..94193c7a57b64669dd06ef8e3fbccbfe9b63d10b
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/image/SimpleImageFileResourcePackAsset.java
@@ -0,0 +1,64 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.image;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.SimpleResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.apache.commons.lang3.Validate;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * Base implementation of {@link MutableImageResourcePackAsset} that reference images by a file path (and thus does not support any operations or checks on the content of the image)
+ */
+public abstract class SimpleImageFileResourcePackAsset extends SimpleResourcePackAsset implements MutableImageResourcePackAsset {
+
+    private boolean existsInIncludedResourcePack;
+    private @Nullable String imageFilePath;
+
+    protected SimpleImageFileResourcePackAsset(boolean existsInIncludedResourcePack, @Nullable String imageFilePath, @NotNull NamespacedKeyWithIntention key, boolean dirty) {
+        super(key, dirty);
+        this.existsInIncludedResourcePack = existsInIncludedResourcePack;
+        this.imageFilePath = imageFilePath;
+    }
+
+    protected SimpleImageFileResourcePackAsset(boolean existsInIncludedResourcePack, @Nullable String imageFilePath, @NotNull NamespacedKeyWithIntention key) {
+        super(key);
+        this.existsInIncludedResourcePack = existsInIncludedResourcePack;
+        this.imageFilePath = imageFilePath;
+    }
+
+    @Override
+    public void writeTo(@NotNull OutputStream outputStream) throws IOException {
+        Validate.notNull(this.imageFilePath);
+        try (@NotNull FileInputStream fileInputStream = new FileInputStream(this.imageFilePath)) {
+            outputStream.write(fileInputStream.readAllBytes());
+        }
+    }
+
+    public @NotNull MutableImageResourcePackAsset merge(@NotNull ResourcePackAsset other) {
+        Validate.isInstanceOf(MutableImageResourcePackAsset.class, other);
+        if (this.hasData()) {
+            return this;
+        }
+        return (MutableImageResourcePackAsset) other;
+    }
+
+    @Override
+    public boolean hasData() {
+        return this.existsInIncludedResourcePack || this.imageFilePath != null;
+    }
+
+    public void setImageFilePath(@NotNull String imageFilePath) {
+        if (!imageFilePath.equals(this.imageFilePath)) {
+            this.imageFilePath = imageFilePath;
+            this.setDirty();
+        }
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/intention/NamespacedKeyWithIntention.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/intention/NamespacedKeyWithIntention.java
new file mode 100644
index 0000000000000000000000000000000000000000..41a361d656b3fb8b7393830a54bdba8fbcc069f3
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/intention/NamespacedKeyWithIntention.java
@@ -0,0 +1,23 @@
+package nl.martijnmuijsers.paper.resourcepack.asset.intention;
+
+import org.jetbrains.annotations.NotNull;
+import org.bukkit.NamespacedKey;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A simple record that represents a {@link NamespacedKey} that includes the intention in the key
+ * <br>
+ * This record just indicates that the intention, if any, was certainly included: if there is no intention for the resource this key represents, the intention can be null
+ */
+public record NamespacedKeyWithIntention(@NotNull String namespace, @Nullable ResourcePackAssetIntention intention, @NotNull String keyWithoutIntention) {
+
+    public @NotNull String keyWithIntention() {
+        return this.intention == null ? this.keyWithoutIntention : this.intention.prefix + "/" + this.keyWithoutIntention;
+    }
+
+    @Override
+    public @NotNull String toString() {
+        return this.namespace + ":" + this.keyWithIntention();
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/intention/NamespacedKeyWithoutIntention.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/intention/NamespacedKeyWithoutIntention.java
new file mode 100644
index 0000000000000000000000000000000000000000..51d105dd82f08e41a12502d7a5642605a1a45b90
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/intention/NamespacedKeyWithoutIntention.java
@@ -0,0 +1,39 @@
+package nl.martijnmuijsers.paper.resourcepack.asset.intention;
+
+import net.minecraft.resources.ResourceLocation;
+import org.bukkit.NamespacedKey;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A simple record that represents a {@link NamespacedKey} that certainly does not include the intention in the key
+ * <br>
+ * This record just indicates that the intention, if any, was certainly excluded: if there is no intention for the resource this key represents, {@link NamespacedKeyWithIntention} should still be used when the potential (but not certainly existing) intention is required
+ */
+public record NamespacedKeyWithoutIntention(@NotNull String namespace, @NotNull String keyWithoutIntention) {
+
+    public @NotNull NamespacedKeyWithIntention withIntention(@NotNull ResourcePackAssetIntention intention) {
+        return new NamespacedKeyWithIntention(namespace, intention, keyWithoutIntention);
+    }
+
+    public @NotNull NamespacedKeyWithIntention withEmptyIntention() {
+        return new NamespacedKeyWithIntention(namespace, null, keyWithoutIntention);
+    }
+
+    @Override
+    public @NotNull String toString() {
+        return this.namespace + ":" + this.keyWithoutIntention();
+    }
+
+    public static @NotNull NamespacedKeyWithoutIntention forBukkit(@NotNull NamespacedKey key) {
+        return new NamespacedKeyWithoutIntention(key.getNamespace(), key.getKey());
+    }
+
+    public static @NotNull NamespacedKeyWithoutIntention forMinecraft(@NotNull ResourceLocation resourceLocation) {
+        return new NamespacedKeyWithoutIntention(resourceLocation.getNamespace(), resourceLocation.getPath());
+    }
+
+    public static @NotNull NamespacedKeyWithoutIntention minecraft(@NotNull String keyWithoutIntention) {
+        return new NamespacedKeyWithoutIntention(ResourceLocation.DEFAULT_NAMESPACE, keyWithoutIntention);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/intention/ResourcePackAssetIntention.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/intention/ResourcePackAssetIntention.java
new file mode 100644
index 0000000000000000000000000000000000000000..114b57c69156c584bd818dcd902e0b72e0c67990
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/intention/ResourcePackAssetIntention.java
@@ -0,0 +1,22 @@
+package nl.martijnmuijsers.paper.resourcepack.asset.intention;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * The intention of a {@link ResourcePackAsset}
+ * <br>
+ * Not all asset types use intentions
+ */
+public enum ResourcePackAssetIntention {
+
+    BLOCK("block"),
+    ITEM("item");
+
+    public final @NotNull String prefix;
+
+    ResourcePackAssetIntention(@NotNull String prefix) {
+        this.prefix = prefix;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/json/JsonResourcePackAsset.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/json/JsonResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..876fe33b34243ddd37696bcdace1b8ee048e7c8e
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/json/JsonResourcePackAsset.java
@@ -0,0 +1,21 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.json;
+
+import com.google.gson.JsonObject;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A {@link ResourcePackAsset} with JSON data
+ */
+public interface JsonResourcePackAsset extends ResourcePackAsset {
+
+    @Override
+    @NotNull JsonResourcePackAsset merge(@NotNull ResourcePackAsset other);
+
+    @NotNull JsonObject getJsonCopy();
+
+    boolean isJsonEmpty();
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/json/MutableJsonResourcePackAsset.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/json/MutableJsonResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..e36cb8277fa667532f558ced487808dbef1d6841
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/json/MutableJsonResourcePackAsset.java
@@ -0,0 +1,19 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.json;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.MutableResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A mutable {@link JsonResourcePackAsset}
+ */
+public interface MutableJsonResourcePackAsset extends MutableResourcePackAsset, JsonResourcePackAsset {
+
+    @Override
+    @NotNull MutableJsonResourcePackAsset merge(@NotNull ResourcePackAsset other);
+
+    void clearJson();
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/json/SimpleJsonResourcePackAsset.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/json/SimpleJsonResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..57740cdc57610ed068bfe5254dde264b7f9c5e6d
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/json/SimpleJsonResourcePackAsset.java
@@ -0,0 +1,81 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.json;
+
+import com.google.common.base.Charsets;
+import com.google.gson.JsonObject;
+import nl.martijnmuijsers.paper.json.JsonMerging;
+import nl.martijnmuijsers.paper.resourcepack.asset.MutableResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.SimpleResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.apache.commons.lang3.Validate;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * Base implementation of {@link MutableJsonResourcePackAsset}
+ */
+public abstract class SimpleJsonResourcePackAsset<T extends SimpleJsonResourcePackAsset<T>> extends SimpleResourcePackAsset implements MutableJsonResourcePackAsset {
+
+    protected interface JsonResourcePackAssetConstructor<T extends SimpleJsonResourcePackAsset<T>> {
+
+        @NotNull T construct(@NotNull JsonObject json, @NotNull NamespacedKeyWithIntention key, boolean dirty);
+
+    }
+
+    private final @NotNull JsonResourcePackAssetConstructor<T> constructor;
+    protected @NotNull JsonObject json;
+
+    protected SimpleJsonResourcePackAsset(@NotNull JsonResourcePackAssetConstructor<T> constructor, @NotNull JsonObject json, @NotNull NamespacedKeyWithIntention key, boolean dirty) {
+        super(key, dirty);
+        this.constructor = constructor;
+        this.json = json;
+    }
+
+    protected SimpleJsonResourcePackAsset(@NotNull JsonResourcePackAssetConstructor<T> constructor, @NotNull JsonObject json, @NotNull NamespacedKeyWithIntention key) {
+        super(key);
+        this.constructor = constructor;
+        this.json = json;
+    }
+
+    @Override
+    public void writeTo(@NotNull OutputStream outputStream) throws IOException {
+        outputStream.write(this.json.toString().getBytes(Charsets.UTF_8));
+    }
+
+    public @NotNull T merge(@NotNull ResourcePackAsset other) {
+        Validate.isTrue(this.getType() == other.getType());
+        @NotNull JsonObject otherJson;
+        if (other instanceof SimpleJsonResourcePackAsset<?> simpleOther) {
+            otherJson = simpleOther.json;
+        } else {
+            otherJson = ((JsonResourcePackAsset) other).getJsonCopy();
+        }
+        boolean otherDirty;
+        if (other instanceof MutableResourcePackAsset mutableOther) {
+            otherDirty = mutableOther.isDirty();
+        } else {
+            otherDirty = false;
+        }
+        return this.constructor.construct(JsonMerging.merge(this.json, otherJson), this.getKey(), this.isDirty() || otherDirty);
+    }
+
+    public @NotNull JsonObject getJsonCopy() {
+        return this.json.deepCopy();
+    }
+
+    @Override
+    public boolean isJsonEmpty() {
+        return this.json.keySet().isEmpty();
+    }
+
+    @Override
+    public void clearJson() {
+        this.json = new JsonObject();
+        this.setDirty();
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/model/ConcreteResourcePackModel.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/model/ConcreteResourcePackModel.java
new file mode 100644
index 0000000000000000000000000000000000000000..d7da1798c70e570baa6dcbb08cd74d252b19cce9
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/model/ConcreteResourcePackModel.java
@@ -0,0 +1,85 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.model;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import nl.martijnmuijsers.paper.resourcepack.KeyConstants;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAssetType;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
+import nl.martijnmuijsers.paper.blockanditemdata.texture.Texture;
+import nl.martijnmuijsers.paper.resourcepack.asset.json.SimpleJsonResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Concrete implementation of {@link MutableResourcePackModel}
+ */
+public class ConcreteResourcePackModel extends SimpleJsonResourcePackAsset<ConcreteResourcePackModel> implements MutableResourcePackModel {
+
+    public ConcreteResourcePackModel(@NotNull JsonObject json, @NotNull NamespacedKeyWithIntention key, boolean dirty) {
+        super(ConcreteResourcePackModel::new, json, key, dirty);
+    }
+
+    public ConcreteResourcePackModel(@NotNull JsonObject json, @NotNull NamespacedKeyWithIntention key) {
+        super(ConcreteResourcePackModel::new, json, key);
+    }
+
+    public ConcreteResourcePackModel(@NotNull ResourcePackModel reference) {
+        this(reference.getJsonCopy(), reference.getKey());
+    }
+
+    @Override
+    public @NotNull ResourcePackAssetType getType() {
+        return ResourcePackAssetType.MODEL;
+    }
+
+    @Override
+    public void setParent(@NotNull Model parent) {
+        this.json.addProperty(KeyConstants.assetParent, parent.getKeyWithIntention().toString());
+        this.setDirty();
+    }
+
+    @Override
+    public void setAllTextures(@NotNull Texture texture) {
+        @NotNull JsonObject texturesJson = new JsonObject();
+        texturesJson.addProperty(KeyConstants.allModelTextures, texture.getKeyWithIntention().toString());
+        this.json.add(KeyConstants.modelTextures, texturesJson);
+        this.setDirty();
+    }
+
+    @Override
+    public void addModelOverride(int customModelData, @NotNull Model overridingModel) {
+        @NotNull JsonArray overridesJson;
+        if (this.json.has(KeyConstants.modelOverrides)) {
+            overridesJson = this.json.getAsJsonArray(KeyConstants.modelOverrides);
+        } else {
+            overridesJson = new JsonArray();
+            this.json.add(KeyConstants.modelOverrides, overridesJson);
+        }
+        // Make sure we try to find an override with the same predicate as that we're trying to create
+        @NotNull JsonObject predicateJson = new JsonObject();
+        predicateJson.addProperty(KeyConstants.customModelData, customModelData);
+        @Nullable JsonObject overrideJson = null;
+        for (JsonElement existingOverrideJson : overridesJson) {
+            if (existingOverrideJson instanceof JsonObject existingOverrideJsonObject) {
+                @Nullable JsonElement existingOverridePredicateJson = existingOverrideJsonObject.get(KeyConstants.overridePredicate);
+                if (existingOverridePredicateJson != null && existingOverridePredicateJson.equals(predicateJson)) {
+                    overrideJson = existingOverrideJsonObject;
+                    break;
+                }
+            }
+        }
+        if (overrideJson == null) {
+            // We need to create a new override because none with the desired predicate existed
+            overrideJson = new JsonObject();
+            overrideJson.add(KeyConstants.overridePredicate, predicateJson);
+            overridesJson.add(overrideJson);
+        }
+        overrideJson.addProperty(KeyConstants.model, overridingModel.getKeyWithIntention().toString());
+        this.setDirty();
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/model/MutableResourcePackModel.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/model/MutableResourcePackModel.java
new file mode 100644
index 0000000000000000000000000000000000000000..52fe7370738d0ca3bb937a172052d1d436a538a6
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/model/MutableResourcePackModel.java
@@ -0,0 +1,38 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.model;
+
+import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
+import nl.martijnmuijsers.paper.blockanditemdata.texture.Texture;
+import nl.martijnmuijsers.paper.resourcepack.MutableResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.json.MutableJsonResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A mutable {@link ResourcePackModel}
+ */
+public interface MutableResourcePackModel extends MutableJsonResourcePackAsset, ResourcePackModel {
+
+    @Override
+    @NotNull MutableResourcePackModel merge(@NotNull ResourcePackAsset other);
+
+    void setParent(@NotNull Model parent);
+
+    void setAllTextures(@NotNull Texture texture);
+
+    /**
+     * @param pack Because this instance is not aware of the resource pack it is in, this pack must be provided to automatically add the given overriding model to the resource pack
+     * @param overwriteExistingOverridingModel Whether to overwrite an existing model in the resource pack (this has to do with the overriding model, not with this model instance: this instance's overrides property is always modified by this method)
+     */
+    default void addModelOverride(int customModelData, @NotNull Model overridingModel, @NotNull MutableResourcePack pack, boolean overwriteExistingOverridingModel) {
+        this.addModelOverride(customModelData, overridingModel);
+        overridingModel.addToResourcePack(pack, overwriteExistingOverridingModel);
+    }
+
+    /**
+     * This does not automatically add the overriding model to the resource pack
+     */
+    void addModelOverride(int customModelData, @NotNull Model overridingModel);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/model/ResourcePackModel.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/model/ResourcePackModel.java
new file mode 100644
index 0000000000000000000000000000000000000000..319b778d805a9ab124fe0ca37dda5b9c2564c36c
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/model/ResourcePackModel.java
@@ -0,0 +1,18 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.model;
+
+import nl.martijnmuijsers.paper.resourcepack.ResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.json.JsonResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An element of 'models' in a {@link ResourcePack}
+ */
+public interface ResourcePackModel extends JsonResourcePackAsset {
+
+    @Override
+    @NotNull ResourcePackModel merge(@NotNull ResourcePackAsset other);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/texture/ConcreteResourcePackTexture.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/texture/ConcreteResourcePackTexture.java
new file mode 100644
index 0000000000000000000000000000000000000000..742d4558b13e1360a0617322681f599567b6f4cc
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/texture/ConcreteResourcePackTexture.java
@@ -0,0 +1,41 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.texture;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAssetType;
+import nl.martijnmuijsers.paper.resourcepack.asset.image.SimpleImageFileResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.ResourcePackModel;
+import org.apache.commons.lang3.Validate;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Concrete implementation of {@link MutableResourcePackTexture}
+ */
+public class ConcreteResourcePackTexture extends SimpleImageFileResourcePackAsset implements MutableResourcePackTexture {
+
+    public ConcreteResourcePackTexture(boolean existsInIncludedResourcePack, @Nullable String imageFilePath, @NotNull NamespacedKeyWithIntention key, boolean dirty) {
+        super(existsInIncludedResourcePack, imageFilePath, key, dirty);
+    }
+
+    public ConcreteResourcePackTexture(boolean existsInIncludedResourcePack, @Nullable String imageFilePath, @NotNull NamespacedKeyWithIntention key) {
+        super(existsInIncludedResourcePack, imageFilePath, key);
+    }
+
+    @Override
+    public @NotNull ResourcePackAssetType getType() {
+        return ResourcePackAssetType.TEXTURE;
+    }
+
+    public @NotNull ConcreteResourcePackTexture merge(@NotNull ResourcePackAsset other) {
+        Validate.isInstanceOf(ConcreteResourcePackTexture.class, other);
+        return (ConcreteResourcePackTexture) super.merge(other);
+    }
+
+    public void setBasedOnFileToImport(@NotNull String fileToImport) {
+        this.setImageFilePath(fileToImport);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/texture/MutableResourcePackTexture.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/texture/MutableResourcePackTexture.java
new file mode 100644
index 0000000000000000000000000000000000000000..3b18ece5e503170a02ee7f6b6a967064f1533fb8
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/texture/MutableResourcePackTexture.java
@@ -0,0 +1,19 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.texture;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.image.MutableImageResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A mutable {@link ResourcePackTexture}
+ */
+public interface MutableResourcePackTexture extends MutableImageResourcePackAsset, ResourcePackTexture {
+
+    @Override
+    @NotNull MutableResourcePackTexture merge(@NotNull ResourcePackAsset other);
+
+    void setBasedOnFileToImport(@NotNull String filePath);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/texture/ResourcePackTexture.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/texture/ResourcePackTexture.java
new file mode 100644
index 0000000000000000000000000000000000000000..52b2cda69eb3dc8f4754e439ee64483878bc34b2
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/texture/ResourcePackTexture.java
@@ -0,0 +1,18 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.texture;
+
+import nl.martijnmuijsers.paper.resourcepack.ResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.image.ImageResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An element of 'textures' in a {@link ResourcePack}
+ */
+public interface ResourcePackTexture extends ImageResourcePackAsset {
+
+    @Override
+    @NotNull ResourcePackTexture merge(@NotNull ResourcePackAsset other);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/memory/MemoryResourcePack.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/memory/MemoryResourcePack.java
new file mode 100644
index 0000000000000000000000000000000000000000..79884eccff1994db247ee495048635a16d54495a
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/memory/MemoryResourcePack.java
@@ -0,0 +1,222 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.memory;
+
+import com.google.common.base.Charsets;
+import com.google.common.collect.ImmutableList;
+import com.google.gson.JsonObject;
+import it.unimi.dsi.fastutil.Pair;
+import nl.martijnmuijsers.paper.resourcepack.PathConstants;
+import nl.martijnmuijsers.paper.resourcepack.asset.blockstates.ConcreteResourcePackBlockStates;
+import nl.martijnmuijsers.paper.resourcepack.asset.image.MutableImageResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.ConcreteResourcePackModel;
+import nl.martijnmuijsers.paper.resourcepack.asset.InitializableResourcePackAssetType;
+import nl.martijnmuijsers.paper.resourcepack.MutableResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.MutableResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.ResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAssetType;
+import nl.martijnmuijsers.paper.resourcepack.asset.blockstates.ResourcePackBlockStates;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.ResourcePackModel;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.texture.ConcreteResourcePackTexture;
+import nl.martijnmuijsers.paper.resourcepack.asset.texture.ResourcePackTexture;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.stream.Stream;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
+
+/**
+ * A resource pack available in memory. Can be written to a file. May be backed by a default resource pack (such as the Minecraft default resource pack), and may be based on (and always fully include) a list of other resource packs.
+ */
+public class MemoryResourcePack implements MutableResourcePack {
+
+    /**
+     * The resource pack to pull defaults from (that will be included in this resource pack only if they are modified)
+     * <br>
+     * The resource packs with the lowest index are polled for the requested asset first
+     */
+    private final @NotNull List<@NotNull ResourcePack> defaultResourcePacks = new ArrayList<>();
+
+    /**
+     * The resource pack to inherit values from, that will be always be included in this resource pack
+     * <br>
+     * On a merge conflict, the resource pack with the lowest index determines the used value
+     * (of course, unless also overwritten by this resource pack itself, in which case that value becomes the used value)
+     */
+    private final @NotNull List<@NotNull ResourcePack> includedResourcePacks = new ArrayList<>();
+
+    private final @NotNull MemoryResourcePackSettings settings = new MemoryResourcePackSettings(this);
+
+    private final @NotNull Map<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>, @NotNull MutableResourcePackAsset> assets = new HashMap<>(0);
+
+    public MemoryResourcePack() {}
+
+    @Override
+    public @NotNull Stream<@NotNull Pair<@NotNull String, @NotNull Callable<@NotNull InputStream>>> getAllFilesStream() throws IOException {
+        throw new UnsupportedOperationException("Cannot stream over all files for a resource pack being constructed in memory");
+    }
+
+    public @NotNull List<@NotNull ResourcePack> getDefaultResourcePacks() {
+        return ImmutableList.copyOf(this.defaultResourcePacks);
+    }
+
+    public void addDefaultResourcePack(@NotNull ResourcePack resourcePack) {
+        if (!this.defaultResourcePacks.contains(resourcePack)) {
+            this.defaultResourcePacks.add(resourcePack);
+        }
+    }
+
+    public @NotNull List<@NotNull ResourcePack> getIncludedResourcePacks() {
+        return ImmutableList.copyOf(this.includedResourcePacks);
+    }
+
+    public void addIncludedResourcePack(@NotNull ResourcePack resourcePack) {
+        if (!this.includedResourcePacks.contains(resourcePack)) {
+            this.includedResourcePacks.add(resourcePack);
+        }
+    }
+
+    @Override
+    public @NotNull MemoryResourcePackSettings getSettings() {
+        return this.settings;
+    }
+
+    private @NotNull MutableResourcePackAsset getMutable(@NotNull ResourcePackAssetType type, @NotNull ResourcePackAsset asset) {
+        if (asset instanceof MutableResourcePackAsset mutableAsset) {
+            return mutableAsset;
+        }
+        if (type.equals(ResourcePackAssetType.BLOCK_STATES)) {
+            return new ConcreteResourcePackBlockStates((ResourcePackBlockStates) asset);
+        } else if (type.equals(ResourcePackAssetType.MODEL)) {
+            return new ConcreteResourcePackModel((ResourcePackModel) asset);
+        } else if (type.equals(ResourcePackAssetType.TEXTURE)) {
+            // We assume all ResourcePackTexture to have been MutableResourcePackAsset already (as the current only implementation is ConcreteResourcePackTexture)
+            // since there is immediate obvious way to implement a ConcreteResourcePackTexture(ResourcePackTexture reference) constructor
+            throw new UnsupportedOperationException("Not implemented yet: could implement by adding existsInIncludedResourcePack() and getImageFilePath() methods to ResourcePackTexture interface, but that feels wrong for now");
+        } else {
+            throw new IllegalArgumentException("Attempted to create mutable asset for memory resource pack by cloning a given asset, but the type (" + type.getFolderPathInNamespaceFolder() + ") is not a known copiable type");
+        }
+    }
+
+    @Override
+    public @NotNull MutableResourcePackAsset getAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException {
+        @Nullable MutableResourcePackAsset foundOrDerivedAsset = this.assets.computeIfAbsent(Pair.of(type, key), namespacedKey -> {
+            // Try creating a merged asset from the included resource packs
+            @Nullable MutableResourcePackAsset derivedAsset = null;
+            for (@NotNull ResourcePack includedResourcePack : this.getIncludedResourcePacks()) {
+                @Nullable ResourcePackAsset includedAsset = includedResourcePack.getOptionalAsset(type, key);
+                if (includedAsset != null) {
+                    if (derivedAsset == null) {
+                        derivedAsset = this.getMutable(type, includedAsset);
+                    } else {
+                        derivedAsset = derivedAsset.merge(includedAsset);
+                    }
+                }
+            }
+            if (derivedAsset != null) {
+                derivedAsset.setDirty();
+                return derivedAsset;
+            }
+            // Try finding the default form of the asset in the default resource packs
+            for (@NotNull ResourcePack defaultResourcePack : this.getDefaultResourcePacks()) {
+                @Nullable ResourcePackAsset defaultAsset = defaultResourcePack.getOptionalAsset(type, key);
+                if (defaultAsset != null) {
+                    return this.getMutable(type, defaultAsset);
+                }
+            }
+            // We can't initially derive this asset from any inherited resource packs
+            return null;
+        });
+        if (foundOrDerivedAsset != null) {
+            return foundOrDerivedAsset;
+        }
+        throw new IllegalArgumentException("Attempted to load required asset from memory resource pack, but none was already created or present in inherited resource packs");
+    }
+
+    @Override
+    public @NotNull MutableResourcePackAsset getOrCreateAsset(@NotNull InitializableResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException {
+        @Nullable MutableResourcePackAsset existingAsset = this.getOptionalAsset(type, key);
+        if (existingAsset != null) {
+            return existingAsset;
+        }
+        @NotNull MutableResourcePackAsset newAsset;
+        if (type.equals(ResourcePackAssetType.BLOCK_STATES)) {
+            newAsset = new ConcreteResourcePackBlockStates(new JsonObject(), key);
+        } else if (type.equals(ResourcePackAssetType.MODEL)) {
+            newAsset = new ConcreteResourcePackModel(new JsonObject(), key);
+        } else if (type.equals(ResourcePackAssetType.TEXTURE)) {
+            newAsset = new ConcreteResourcePackTexture(false, null, key);
+        } else {
+            throw new IllegalArgumentException("Attempted to create asset for memory resource pack, but the type (" + type.getFolderPathInNamespaceFolder() + ") is not a known initializable type");
+        }
+        this.assets.put(Pair.of(type, key), newAsset);
+        return newAsset;
+    }
+
+    public void writeToFolder(String folderPath) throws IOException {
+        @NotNull File folder = new File(folderPath);
+        if (!folder.isDirectory()) {
+            throw new IOException("MemoryResourcePack.writeToFolder received a path that does not point to a folder");
+        }
+        try (@NotNull FileOutputStream fileOutputStream = new FileOutputStream(Path.of(folderPath, this.getSettings().getName() + ".zip").toFile())) {
+            try (@NotNull ZipOutputStream zipOutputStream = new ZipOutputStream(fileOutputStream)) {
+                @NotNull Set<@NotNull String> zippedFilePaths = new HashSet<>();
+                // Add the settings
+                {
+                    zippedFilePaths.add(PathConstants.PackMeta.pathFromRoot);
+                    @NotNull ZipEntry zipEntry = new ZipEntry(PathConstants.PackMeta.pathFromRoot);
+                    zipOutputStream.putNextEntry(zipEntry);
+                    zipOutputStream.write(this.getSettings().createJson().toString().getBytes(Charsets.UTF_8));
+                }
+                // Add the cached assets
+                for (@NotNull MutableResourcePackAsset assetInMemory : this.assets.values()) {
+                    // Don't write assets just because we have them cached: only write those that are dirty (the ones that need to be included even if not dirty will be added later)
+                    if (!assetInMemory.isDirty()) {
+                        continue;
+                    }
+                    @NotNull String path = assetInMemory.getPathInResourcePack();
+                    zippedFilePaths.add(path);
+                    @NotNull ZipEntry zipEntry = new ZipEntry(path);
+                    zipOutputStream.putNextEntry(zipEntry);
+                    assetInMemory.writeTo(zipOutputStream);
+                }
+                // Add all files from included resource packs that we haven't added yet
+                for (@NotNull ResourcePack includedResourcePack : this.includedResourcePacks) {
+                    @NotNull Stream<@NotNull Pair<@NotNull String, @NotNull Callable<@NotNull InputStream>>> allFilesStream = includedResourcePack.getAllFilesStream();
+                    @NotNull Iterable<@NotNull Pair<@NotNull String, @NotNull Callable<@NotNull InputStream>>> allFilesIterable = () -> allFilesStream.iterator();
+                    for (@NotNull Pair<@NotNull String, @NotNull Callable<@NotNull InputStream>> includedResourcePackFile : allFilesIterable) {
+                        @NotNull String includedFilePath = includedResourcePackFile.left();
+                        if (zippedFilePaths.add(includedFilePath)) {
+                            try (@NotNull InputStream includedFileInputStream = includedResourcePackFile.right().call()) {
+                                zipOutputStream.putNextEntry(new ZipEntry(includedFilePath));
+                                zipOutputStream.write(includedFileInputStream.readAllBytes());
+                            } catch (Exception e) {
+                                if (e instanceof IOException ioE) {
+                                    throw ioE;
+                                }
+                                throw new IOException("An exception occurred while getting input stream for included resource pack file", e);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        // TODO write to file and make sure to include everything from the included resource packs for sure
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/memory/MemoryResourcePackSettings.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/memory/MemoryResourcePackSettings.java
new file mode 100644
index 0000000000000000000000000000000000000000..504f1da6c1018950ef154b461c5e1e6abfa38603
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/memory/MemoryResourcePackSettings.java
@@ -0,0 +1,80 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.memory;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonParser;
+import nl.martijnmuijsers.paper.resourcepack.ResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.ResourcePackSettings;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+/**
+ * The top-level settings of a {@link MemoryResourcePack}
+ */
+public class MemoryResourcePackSettings implements ResourcePackSettings {
+
+    private static final @NotNull String DEFAULT_NAME = "Resource pack";
+    private static final @NotNull JsonElement DEFAULT_DESCRIPTION = JsonParser.parseString("[\"A resource pack\"]");
+
+    private final @NotNull MemoryResourcePack pack;
+
+    /**
+     * The name of the resource pack, which is not defined within the resource pack anywhere, but is defined by its filename without the extension
+     * <br>
+     * Note: because the filename of downloaded server resource packs is changed, this value is not relevant for resource packs used as a server resource pack
+     */
+    private @Nullable String name;
+
+    /**
+     * The description of the resource pack, displayed in the resource pack GUI
+     */
+    private @Nullable JsonElement description;
+
+    MemoryResourcePackSettings(@NotNull MemoryResourcePack pack) {
+        this.pack = pack;
+    }
+
+    @Override
+    public @NotNull String getName() {
+        if (this.name == null) {
+            // Get the name from the first included resource pack
+            List<@NotNull ResourcePack> includedResourcePacks = this.pack.getDefaultResourcePacks();
+            if (!includedResourcePacks.isEmpty()) {
+                this.name = includedResourcePacks.get(0).getSettings().getName();
+            }
+            if (this.name == null) {
+                // Use the default name
+                this.name = DEFAULT_NAME;
+            }
+        }
+        return this.name;
+    }
+
+    public void setName(@NotNull String name) {
+        this.name = name;
+    }
+
+    @Override
+    public @NotNull JsonElement getDescription() {
+        if (this.description == null) {
+            // Get the description from the first included resource pack
+            List<@NotNull ResourcePack> includedResourcePacks = this.pack.getDefaultResourcePacks();
+            if (!includedResourcePacks.isEmpty()) {
+                this.description = includedResourcePacks.get(0).getSettings().getDescription();
+            }
+            if (this.description == null) {
+                // Use the default description
+                this.description = DEFAULT_DESCRIPTION;
+            }
+        }
+        return this.description;
+    }
+
+    public void setDescription(@NotNull JsonElement description) {
+        this.description = description;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/readfromarchive/ReadFromArchiveResourcePack.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/readfromarchive/ReadFromArchiveResourcePack.java
new file mode 100644
index 0000000000000000000000000000000000000000..3ea678d446c2c9d445c3564fa8a0ea3577ce9d9a
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/readfromarchive/ReadFromArchiveResourcePack.java
@@ -0,0 +1,126 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.readfromarchive;
+
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+import it.unimi.dsi.fastutil.Pair;
+import nl.martijnmuijsers.paper.resourcepack.asset.blockstates.ConcreteResourcePackBlockStates;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.ConcreteResourcePackModel;
+import nl.martijnmuijsers.paper.resourcepack.ResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAssetType;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.texture.ConcreteResourcePackTexture;
+import org.apache.commons.lang3.Validate;
+import org.apache.commons.lang3.tuple.ImmutablePair;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.file.Path;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.Callable;
+import java.util.stream.Stream;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
+/**
+ * Implementation of {@link ResourcePack} based on existing ZIP archive file
+ */
+public class ReadFromArchiveResourcePack implements ResourcePack, Closeable {
+
+    private final @NotNull Path path;
+
+    private @Nullable ZipFile zipFile;
+
+    private final ReadFromArchiveResourcePackSettings settings = new ReadFromArchiveResourcePackSettings(this);
+
+    private final @NotNull Map<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>, @NotNull ResourcePackAsset> assets = new HashMap<>(0);
+
+    public ReadFromArchiveResourcePack(@NotNull Path path) {
+        this.path = path;
+    }
+
+    public ReadFromArchiveResourcePack(@NotNull String path) {
+        this(Path.of(path));
+    }
+
+    @NotNull Path getPath() {
+        return this.path;
+    }
+
+    private @NotNull ZipFile getZipFile() throws IOException {
+        if (this.zipFile == null) {
+            this.zipFile = new ZipFile(this.path.toFile());
+        }
+        return this.zipFile;
+    }
+
+    public void close() throws IOException {
+        if (this.zipFile != null) {
+            this.zipFile.close();
+            this.zipFile = null;
+        }
+    }
+
+    private @NotNull Stream<@NotNull ZipEntry> getZipFileEntriesStream() throws IOException, NullPointerException {
+        return Validate.notNull(this.getZipFile().stream().map(it -> Validate.notNull(it)));
+    }
+
+    private @NotNull ZipEntry getZipFileEntry(@NotNull String path) throws IOException, NullPointerException {
+        return Validate.notNull(this.getZipFile().getEntry(path));
+    }
+
+    private @NotNull InputStream getZipFileEntryInputStream(@NotNull String path) throws IOException, NullPointerException {
+        return Validate.notNull(this.getZipFile().getInputStream(this.getZipFileEntry(path)));
+    }
+
+    @Override
+    public @NotNull Stream<@NotNull Pair<@NotNull String, @NotNull Callable<@NotNull InputStream>>> getAllFilesStream() throws IOException {
+        return this.getZipFileEntriesStream().map(it -> Pair.of(it.getName(), () -> this.getZipFile().getInputStream(it)));
+    }
+
+    @NotNull JsonObject readJsonAsset(@NotNull String path) throws IllegalArgumentException {
+        try {
+            @NotNull InputStream inputStream = this.getZipFileEntryInputStream(path);
+            return Validate.notNull(JsonParser.parseReader(new InputStreamReader(inputStream)).getAsJsonObject());
+        } catch (Exception e) {
+            throw new IllegalArgumentException("Attempted to load required JSON asset at internal path '" + path + "' from resource pack with path '" + this.path + "' but it did not exist", e);
+        }
+    }
+
+    @Nullable JsonObject readOptionalJsonAsset(@NotNull String path) {
+        try {
+            return readJsonAsset(path);
+        } catch (Exception e) {
+            return null;
+        }
+    }
+
+    @Override
+    public @NotNull ReadFromArchiveResourcePackSettings getSettings() {
+        return this.settings;
+    }
+
+    @Override
+    public @NotNull ResourcePackAsset getAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException {
+        @Nullable ResourcePackAsset foundAsset = this.assets.computeIfAbsent(Pair.of(type, key), namespacedKey -> {
+            if (type.equals(ResourcePackAssetType.BLOCK_STATES)) {
+                return new ConcreteResourcePackBlockStates(readJsonAsset(type.getPathInResourcePack(key)), key);
+            } else if (type.equals(ResourcePackAssetType.MODEL)) {
+                return new ConcreteResourcePackModel(readJsonAsset(type.getPathInResourcePack(key)), key);
+            } else if (type.equals(ResourcePackAssetType.TEXTURE)) {
+                return new ConcreteResourcePackTexture(true, null, key);
+            } else {
+                throw new IllegalArgumentException("Attempted to read asset from archive resource pack, but the type (" + type.getFolderPathInNamespaceFolder() + ") is not a known readable type");
+            }
+        });
+        return foundAsset;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/readfromarchive/ReadFromArchiveResourcePackSettings.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/readfromarchive/ReadFromArchiveResourcePackSettings.java
new file mode 100644
index 0000000000000000000000000000000000000000..3d9a586c9ca60ea8797d586a54d5233e9c2f3cb3
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/readfromarchive/ReadFromArchiveResourcePackSettings.java
@@ -0,0 +1,69 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.readfromarchive;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import nl.martijnmuijsers.paper.resourcepack.KeyConstants;
+import nl.martijnmuijsers.paper.resourcepack.PathConstants;
+import nl.martijnmuijsers.paper.resourcepack.ResourcePackSettings;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Implementation of {@link ResourcePackSettings} for a {@link ReadFromArchiveResourcePack}
+ */
+public class ReadFromArchiveResourcePackSettings implements ResourcePackSettings {
+
+    private final @NotNull ReadFromArchiveResourcePack pack;
+
+    private @Nullable JsonObject packMetaJson;
+
+    private @Nullable String name;
+
+    private @Nullable JsonElement description;
+
+    ReadFromArchiveResourcePackSettings(@NotNull ReadFromArchiveResourcePack pack) {
+        this.pack = pack;
+    }
+
+    private @NotNull JsonObject getPackMetaJson() {
+        if (this.packMetaJson == null) {
+            this.packMetaJson = this.pack.readJsonAsset(PathConstants.PackMeta.pathFromRoot);
+        }
+        return this.packMetaJson;
+    }
+
+    @Override
+    public @NotNull String getName() {
+        if (this.name == null) {
+            // Read the name from the pack path
+            String filename = this.pack.getPath().getFileName().toString();
+            int dotIndex = filename.lastIndexOf('.');
+            if (dotIndex != -1) {
+                if (dotIndex == 0) {
+                    this.name = "";
+                } else {
+                    this.name = filename.substring(0, dotIndex);
+                }
+            } else {
+                this.name = filename;
+            }
+        }
+        return this.name;
+    }
+
+    @Override
+    public @NotNull JsonElement getDescription() {
+        if (this.description == null) {
+            // Read the description from the archive
+            this.description = this.getPackMetaJson().getAsJsonObject(KeyConstants.pack).get(KeyConstants.packDescription);
+        }
+        return this.description;
+    }
+
+    public void setDescription(@NotNull JsonElement description) {
+        this.description = description;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/sucraft/CreateSuCraftResourcePack.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/sucraft/CreateSuCraftResourcePack.java
new file mode 100644
index 0000000000000000000000000000000000000000..20aed5bfadc83bc58841e1a55ad1a41ed80ba9c4
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/sucraft/CreateSuCraftResourcePack.java
@@ -0,0 +1,96 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.sucraft;
+
+import com.google.common.collect.Iterables;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonParser;
+import net.minecraft.core.Registry;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.Block;
+import nl.martijnmuijsers.paper.block.BlockReplacementRule;
+import nl.martijnmuijsers.paper.item.ItemReplacementRule;
+import nl.martijnmuijsers.paper.resourcepack.ResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.memory.MemoryResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.memory.MemoryResourcePackSettings;
+import nl.martijnmuijsers.paper.resourcepack.readfromarchive.ReadFromArchiveResourcePack;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Utility class to create and write the server resource pack.
+ */
+public final class CreateSuCraftResourcePack {
+
+    private CreateSuCraftResourcePack() {}
+
+    public static final int RESOURCE_PACK_FORMAT = 9;
+
+    public static final String INPUT_TEXTURES_FOLDER_PATH = "resourcepack/input/textures";
+
+    private static final String VANILLA_RESOURCE_PACK_ARCHIVE_PATH = "resourcepack/input/inheritedpacks/vanilla_client_1.19_only_assets_minecraft.zip";
+
+    private static final String NAME = "SuCraft";
+    private static final JsonElement DESCRIPTION = JsonParser.parseString("[{\"text\":\"\\u2764 Made with love\",\"color\":\"gray\"},{\"text\":\"\\n\"},{\"text\":\"~SuCraft\",\"color\":\"gold\"}]");
+
+    private static final String OUTPUT_FOLDER_PATH = "resourcepack/output";
+
+    public static void createAndWrite() {
+        MinecraftServer.LOGGER.info("Creating server resource pack...");
+        try {
+
+            // Construct the resource pack
+            @NotNull MemoryResourcePack resourcePack = new MemoryResourcePack();
+
+            try {
+
+                // Add the vanilla JAR as default resource pack
+                resourcePack.addDefaultResourcePack(new ReadFromArchiveResourcePack(VANILLA_RESOURCE_PACK_ARCHIVE_PATH));
+
+                // Set the settings
+                @NotNull MemoryResourcePackSettings settings = resourcePack.getSettings();
+                settings.setName(NAME);
+                settings.setDescription(DESCRIPTION);
+
+                // Add all custom blocks
+                for (Block block : Registry.BLOCK) {
+                    @Nullable BlockReplacementRule replacementRule = block.replacementRule;
+                    if (replacementRule != null) {
+                        replacementRule.addToResourcePack(resourcePack);
+                    }
+                }
+
+                // Add all custom items
+                for (Item item : Registry.ITEM) {
+                    @Nullable ItemReplacementRule replacementRule = item.replacementRule;
+                    if (replacementRule != null) {
+                        replacementRule.addToResourcePack(resourcePack);
+                    }
+                }
+
+                // Write the resource pack to the output file
+                resourcePack.writeToFolder(OUTPUT_FOLDER_PATH);
+
+            } finally {
+
+                // Close all opened inherited resource packs
+                for (@NotNull ResourcePack inheritedResourcePack : Iterables.concat(resourcePack.getDefaultResourcePacks(), resourcePack.getIncludedResourcePacks())) {
+                    if (inheritedResourcePack instanceof ReadFromArchiveResourcePack readInheritedResourcePack) {
+                        try {
+                            readInheritedResourcePack.close();
+                        } catch (Exception e) {
+                            MinecraftServer.LOGGER.warn("Exception occurred while closing inherited resource pack read from archive:");
+                            e.printStackTrace();
+                        }
+                    }
+                }
+
+            }
+
+        } catch (Exception e) {
+            throw new RuntimeException("Exception occurred while creating server resource pack", e);
+        }
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/structure/CraftWorldStructurePiece.java b/src/main/java/nl/martijnmuijsers/paper/structure/CraftWorldStructurePiece.java
index c5e428bbb05f801da88449307e7c75b00f7e7cfd..60158b10b5258016a89eb879f22661463e539d47 100644
--- a/src/main/java/nl/martijnmuijsers/paper/structure/CraftWorldStructurePiece.java
+++ b/src/main/java/nl/martijnmuijsers/paper/structure/CraftWorldStructurePiece.java
@@ -66,8 +66,8 @@ public class CraftWorldStructurePiece implements WorldStructurePiece {
             if (tag == null) {
                 this.cachedFullStructureTemplateName = Optional.empty();
             } else {
-                @Nullable String name = tag.getString("Template");
-                if (name != null && name.isBlank()) {
+                @NotNull String name = tag.getString("Template");
+                if (name.isBlank()) {
                     this.cachedFullStructureTemplateName = Optional.empty();
                 } else {
                     this.cachedFullStructureTemplateName = Optional.ofNullable(name);
@@ -115,8 +115,8 @@ public class CraftWorldStructurePiece implements WorldStructurePiece {
                     this.cachedFullPoolElementName = Optional.empty();
                 } else {
                     @NotNull CompoundTag poolElementTag = tag.getCompound("pool_element");
-                    @Nullable String name = poolElementTag.getString("location");
-                    if (name != null && name.isBlank()) {
+                    @NotNull String name = poolElementTag.getString("location");
+                    if (name.isBlank()) {
                         this.cachedFullPoolElementName = Optional.empty();
                     } else {
                         this.cachedFullPoolElementName = Optional.ofNullable(name);
@@ -140,8 +140,8 @@ public class CraftWorldStructurePiece implements WorldStructurePiece {
             if (colonIndex == -1) {
                 this.cachedShortPoolElementName = Optional.of(fullPoolElementName);
             } else {
-                @Nullable String name = fullPoolElementName.substring(colonIndex + 1);
-                if (name != null && name.isBlank()) {
+                @NotNull String name = fullPoolElementName.substring(colonIndex + 1);
+                if (name.isBlank()) {
                     this.cachedShortPoolElementName = Optional.empty();
                 } else {
                     this.cachedShortPoolElementName = Optional.ofNullable(name);
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 50d8c6d75e3ab4d1109e591091438f01e7ae64af..9bb7fc289e4992d0f7f44f4992b179f321eee3db 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -6,6 +6,7 @@ import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import io.papermc.paper.configuration.GlobalConfiguration;
 import io.papermc.paper.world.structure.ConfiguredStructure;
+import it.unimi.dsi.fastutil.Pair;
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
@@ -67,6 +68,7 @@ import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
 import nl.martijnmuijsers.paper.structure.WorldStructure;
 import org.apache.commons.lang.Validate;
+import org.apache.commons.lang3.tuple.ImmutablePair;
 import org.bukkit.BlockChangeDelegate;
 import org.bukkit.Bukkit;
 import org.bukkit.Chunk;
@@ -539,13 +541,16 @@ public class CraftWorld extends CraftRegionAccessor implements World {
                 if (playersInRange.isEmpty()) return;
 
                 // Paper start - Anti-Xray - Bypass
-                Map<Object, ClientboundLevelChunkWithLightPacket> refreshPackets = new HashMap<>();
+                Map<ImmutablePair<Boolean, Boolean>, ClientboundLevelChunkWithLightPacket> refreshPackets = new HashMap<>(); // Martijn - custom blocks and items
                 for (ServerPlayer player : playersInRange) {
                     if (player.connection == null) continue;
 
                     Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
-                    player.connection.send(refreshPackets.computeIfAbsent(shouldModify, s -> { // Use connection to prevent creating firing event
-                        return new ClientboundLevelChunkWithLightPacket(chunk, this.world.getLightEngine(), null, null, true, (Boolean) s);
+                    // Martijn start - custom blocks and items
+                    boolean hasResourcePack = player.hasSuCraftResourcePack();
+                    player.connection.send(refreshPackets.computeIfAbsent(new ImmutablePair<>(shouldModify, hasResourcePack), s -> { // Use connection to prevent creating firing event
+                        return new ClientboundLevelChunkWithLightPacket(chunk, this.world.getLightEngine(), null, null, true, s.left, s.right);
+                        // Martijn end - custom blocks and items
                     }));
                     // Paper end
                 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 2a7c9a82e5b5797f9a49889ae6fc251870258d49..3353fc3eabb08a80fcd817906eaf0062fea55045 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -2429,6 +2429,17 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public void setResourcePackStatus(org.bukkit.event.player.PlayerResourcePackStatusEvent.Status status) {
         this.resourcePackStatus = status;
     }
+
+    // Martijn start - custom blocks and items
+
+    @Override
+    public boolean hasSuCraftResourcePack() {
+        // Currently we simply assume that if any resource pack was successfully loaded, it includes at least the SuCraft resource pack
+        return this.hasResourcePack();
+    }
+
+    // Martijn end - custom blocks and items
+
     // Paper end
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
index 3c4dadd0012c11191c873fe25a7625193563915d..b3bc3e8ef51dfdcb264962ecf9a6267adc72ea42 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
@@ -112,9 +112,9 @@ import java.util.Collections;
  * <li> SerializableMeta.Deserializers deserializer()
  */
 @DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
-class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
+public class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta { // Martijn - custom blocks and items
 
-    static class ItemMetaKey {
+    public static class ItemMetaKey { // Martijn - custom blocks and items
 
         @Retention(RetentionPolicy.SOURCE)
         @Target(ElementType.FIELD)
@@ -128,7 +128,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         }
 
         final String BUKKIT;
-        final String NBT;
+        public final String NBT; // Martijn - custom blocks and items
 
         ItemMetaKey(final String both) {
             this(both, both);
@@ -238,12 +238,12 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         }
     }
 
-    static final ItemMetaKey NAME = new ItemMetaKey("Name", "display-name");
+    public static final ItemMetaKey NAME = new ItemMetaKey("Name", "display-name"); // Martijn - custom blocks and items
     static final ItemMetaKey LOCNAME = new ItemMetaKey("LocName", "loc-name");
     @Specific(Specific.To.NBT)
-    static final ItemMetaKey DISPLAY = new ItemMetaKey("display");
-    static final ItemMetaKey LORE = new ItemMetaKey("Lore", "lore");
-    static final ItemMetaKey CUSTOM_MODEL_DATA = new ItemMetaKey("CustomModelData", "custom-model-data");
+    public static final ItemMetaKey DISPLAY = new ItemMetaKey("display"); // Martijn - custom blocks and items
+    public static final ItemMetaKey LORE = new ItemMetaKey("Lore", "lore"); // Martijn - custom blocks and items
+    public static final ItemMetaKey CUSTOM_MODEL_DATA = new ItemMetaKey("CustomModelData", "custom-model-data"); // Martijn - custom blocks and items
     static final ItemMetaKey ENCHANTMENTS = new ItemMetaKey("Enchantments", "enchants");
     @Specific(Specific.To.NBT)
     static final ItemMetaKey ENCHANTMENTS_ID = new ItemMetaKey("id");
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index 7c1e510a0ad4b69c1fedc3367a8216046efb228e..0a0ea287897b4cbe15ca18bda99d6115f3aea31c 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -144,11 +144,25 @@ public final class CraftMagicNumbers implements UnsafeValues {
         }
         // Paper end
         for (Block block : net.minecraft.core.Registry.BLOCK) {
-            BLOCK_MATERIAL.put(block, Material.getMaterial(net.minecraft.core.Registry.BLOCK.getKey(block).getPath().toUpperCase(Locale.ROOT)));
+            // Martijn start - custom blocks and items
+            var key = net.minecraft.core.Registry.BLOCK.getKey(block);
+            String materialName = key.getPath().toUpperCase(Locale.ROOT);
+            if (key.getNamespace().equals(ResourceLocation.SUCRAFT_NAMESPACE)) {
+                materialName = "SUCRAFT_" + materialName;
+            }
+            BLOCK_MATERIAL.put(block, Material.getMaterial(materialName));
+            // Martijn end - custom blocks and items
         }
 
         for (Item item : net.minecraft.core.Registry.ITEM) {
-            ITEM_MATERIAL.put(item, Material.getMaterial(net.minecraft.core.Registry.ITEM.getKey(item).getPath().toUpperCase(Locale.ROOT)));
+            // Martijn start - custom blocks and items
+            var key = net.minecraft.core.Registry.ITEM.getKey(item);
+            String materialName = key.getPath().toUpperCase(Locale.ROOT);
+            if (key.getNamespace().equals(ResourceLocation.SUCRAFT_NAMESPACE)) {
+                materialName = "SUCRAFT_" + materialName;
+            }
+            ITEM_MATERIAL.put(item, Material.getMaterial(materialName));
+            // Martijn end - custom blocks and items
         }
 
         for (net.minecraft.world.level.material.Fluid fluid : net.minecraft.core.Registry.FLUID) {
