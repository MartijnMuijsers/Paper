From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Mon, 27 Jun 2022 01:04:35 +0200
Subject: [PATCH] Add custom blocks and items


diff --git a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java
index aabad39d13ead83042ec2e4dd7f4ed4966af650d..3cda0b29f3b56188d7b671ed55e9d52bfff1a1f2 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java
@@ -13,7 +13,7 @@ import net.minecraft.world.level.chunk.LevelChunk;
 
 public class ChunkPacketBlockController {
 
-    public static final ChunkPacketBlockController NO_OPERATION_INSTANCE = new ChunkPacketBlockController();
+    //public static final ChunkPacketBlockController NO_OPERATION_INSTANCE = new ChunkPacketBlockController(); // Martijn - custom blocks and items
 
     protected ChunkPacketBlockController() {
 
@@ -27,7 +27,7 @@ public class ChunkPacketBlockController {
         return false;
     }
 
-    public ChunkPacketInfo<BlockState> getChunkPacketInfo(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk) {
+    public ChunkPacketInfo<BlockState> getChunkPacketInfo(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk, boolean doesPlayerHaveResourcePack) { // Martijn - custom blocks and items
         return null;
     }
 
diff --git a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java
index a5d43901595f864c8a5dd5d013aa42d7f294e489..0fec5b98077ce888362870e5bc33b9d20bb093d2 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java
@@ -19,6 +19,8 @@ import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.EntityBlock;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.*;
+import nl.martijnmuijsers.paper.antixray.ChunkPacketBlockControllerModifier;
+import nl.martijnmuijsers.paper.antixray.ChunkPacketBlockControllerModifierBase;
 import org.bukkit.Bukkit;
 import org.spongepowered.configurate.serialize.ScalarSerializer;
 import org.spongepowered.configurate.serialize.SerializationException;
@@ -30,11 +32,9 @@ import java.util.concurrent.ThreadLocalRandom;
 import java.util.function.IntSupplier;
 import java.util.function.Predicate;
 
-public final class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockController {
+// Martijn start - custom blocks and items
+public class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockControllerModifierBase { // Martijn - custom blocks and items
 
-    private static final Palette<BlockState> GLOBAL_BLOCKSTATE_PALETTE = new GlobalPalette<>(Block.BLOCK_STATE_REGISTRY);
-    private static final LevelChunkSection EMPTY_SECTION = null;
-    private final Executor executor;
     private final EngineMode engineMode;
     private final int maxBlockHeight;
     private final int updateRadius;
@@ -56,7 +56,7 @@ public final class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockCo
     private final int maxBlockHeightUpdatePosition;
 
     public ChunkPacketBlockControllerAntiXray(Level level, Executor executor) {
-        this.executor = executor;
+        super(level, executor);
         WorldConfiguration.AntiCheat.AntiXRay paperWorldConfig = level.paperConfig().anticheat.antiXray;
         engineMode = paperWorldConfig.engineMode;
         maxBlockHeight = paperWorldConfig.maxBlockHeight >> 4 << 4;
@@ -168,44 +168,24 @@ public final class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockCo
         return !usePermission || !player.getBukkitEntity().hasPermission("paper.antixray.bypass");
     }
 
-    @Override
-    public ChunkPacketInfoAntiXray getChunkPacketInfo(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk) {
-        // Return a new instance to collect data and objects in the right state while creating the chunk packet for thread safe access later
-        return new ChunkPacketInfoAntiXray(chunkPacket, chunk, this);
-    }
-
-    @Override
-    public void modifyBlocks(ClientboundLevelChunkWithLightPacket chunkPacket, ChunkPacketInfo<BlockState> chunkPacketInfo) {
-        if (!(chunkPacketInfo instanceof ChunkPacketInfoAntiXray)) {
-            chunkPacket.setReady(true);
-            return;
-        }
-
-        if (!Bukkit.isPrimaryThread()) {
-            // Plugins?
-            MinecraftServer.getServer().scheduleOnMain(() -> modifyBlocks(chunkPacket, chunkPacketInfo));
-            return;
-        }
-
-        LevelChunk chunk = chunkPacketInfo.getChunk();
-        int x = chunk.getPos().x;
-        int z = chunk.getPos().z;
-        Level level = chunk.getLevel();
-        ((ChunkPacketInfoAntiXray) chunkPacketInfo).setNearbyChunks(level.getChunkIfLoaded(x - 1, z), level.getChunkIfLoaded(x + 1, z), level.getChunkIfLoaded(x, z - 1), level.getChunkIfLoaded(x, z + 1));
-        executor.execute((Runnable) chunkPacketInfo);
-    }
-
     // Actually these fields should be variables inside the obfuscate method but in sync mode or with SingleThreadExecutor in async mode it's okay (even without ThreadLocal)
     // If an ExecutorService with multiple threads is used, ThreadLocal must be used here
     private final ThreadLocal<int[]> presetBlockStateBits = ThreadLocal.withInitial(() -> new int[getPresetBlockStatesFullLength()]);
-    private static final ThreadLocal<boolean[]> SOLID = ThreadLocal.withInitial(() -> new boolean[Block.BLOCK_STATE_REGISTRY.size()]);
-    private static final ThreadLocal<boolean[]> OBFUSCATE = ThreadLocal.withInitial(() -> new boolean[Block.BLOCK_STATE_REGISTRY.size()]);
+    protected static final ThreadLocal<boolean[]> SOLID = ThreadLocal.withInitial(() -> new boolean[Block.BLOCK_STATE_REGISTRY.size()]);
+    protected static final ThreadLocal<boolean[]> OBFUSCATE = ThreadLocal.withInitial(() -> new boolean[Block.BLOCK_STATE_REGISTRY.size()]);
     // These boolean arrays represent chunk layers, true means don't obfuscate, false means obfuscate
-    private static final ThreadLocal<boolean[][]> CURRENT = ThreadLocal.withInitial(() -> new boolean[16][16]);
-    private static final ThreadLocal<boolean[][]> NEXT = ThreadLocal.withInitial(() -> new boolean[16][16]);
-    private static final ThreadLocal<boolean[][]> NEXT_NEXT = ThreadLocal.withInitial(() -> new boolean[16][16]);
+    protected static final ThreadLocal<boolean[][]> CURRENT = ThreadLocal.withInitial(() -> new boolean[16][16]);
+    protected static final ThreadLocal<boolean[][]> NEXT = ThreadLocal.withInitial(() -> new boolean[16][16]);
+    protected static final ThreadLocal<boolean[][]> NEXT_NEXT = ThreadLocal.withInitial(() -> new boolean[16][16]);
 
-    public void obfuscate(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+    // Martijn start- custom blocks and items
+    @Override
+    public void obfuscateInternal(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        this.obfuscateXray(chunkPacketInfoAntiXray);
+    }
+
+    public void obfuscateXray(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        // Martijn end - custom blocks and items
         int[] presetBlockStateBits = this.presetBlockStateBits.get();
         boolean[] solid = SOLID.get();
         boolean[] obfuscate = OBFUSCATE.get();
@@ -349,8 +329,6 @@ public final class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockCo
                 bitStorageWriter.flush();
             }
         }
-
-        chunkPacketInfoAntiXray.getChunkPacket().setReady(true);
     }
 
     private void obfuscateLayer(int y, BitStorageReader bitStorageReader, BitStorageWriter bitStorageWriter, boolean[] solid, boolean[] obfuscate, int[] presetBlockStateBits, boolean[][] current, boolean[][] next, boolean[][] nextNext, LevelChunkSection[] nearbyChunkSections, IntSupplier random) {
@@ -690,3 +668,4 @@ public final class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockCo
         }
     }
 }
+// Martijn end - custom blocks and items
diff --git a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfo.java b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfo.java
index d98a3f5c54c67a673eb7dc456dd039cd78f9c34d..7e9b89c8d18df38831f0e5a4945c65b1285fc7a0 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfo.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfo.java
@@ -13,6 +13,7 @@ public class ChunkPacketInfo<T> {
     private final int[] indexes;
     private final Object[][] presetValues;
     private byte[] buffer;
+    private final int[] paletteIndexes; // Martijn - custom blocks and items
 
     public ChunkPacketInfo(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk) {
         this.chunkPacket = chunkPacket;
@@ -22,6 +23,7 @@ public class ChunkPacketInfo<T> {
         palettes = new Object[sections];
         indexes = new int[sections];
         presetValues = new Object[sections][];
+        paletteIndexes = new int[sections]; // Martijn - custom blocks and items
     }
 
     public ClientboundLevelChunkWithLightPacket getChunkPacket() {
@@ -74,6 +76,18 @@ public class ChunkPacketInfo<T> {
         this.presetValues[chunkSectionIndex] = presetValues;
     }
 
+    // Martijn start - custom blocks and items
+
+    public int getPaletteIndex(int chunkSectionIndex) {
+        return paletteIndexes[chunkSectionIndex];
+    }
+
+    public void setPaletteIndex(int chunkSectionIndex, int paletteIndex) {
+        paletteIndexes[chunkSectionIndex] = paletteIndex;
+    }
+
+    // Martijn end - custom blocks and items
+
     public boolean isWritten(int chunkSectionIndex) {
         return bits[chunkSectionIndex] != 0;
     }
diff --git a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfoAntiXray.java b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfoAntiXray.java
index 80a2dfb266ae1221680a7b24fee2f7e2a8330b7d..48bc2e20e45183733ec5b1e545ce0d371b3e1ad0 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfoAntiXray.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfoAntiXray.java
@@ -3,15 +3,21 @@ package com.destroystokyo.paper.antixray;
 import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.LevelChunk;
+import nl.martijnmuijsers.paper.antixray.ChunkPacketBlockControllerAntiXrayCustom;
+import nl.martijnmuijsers.paper.antixray.ChunkPacketBlockControllerModifier;
 
 public final class ChunkPacketInfoAntiXray extends ChunkPacketInfo<BlockState> implements Runnable {
 
-    private final ChunkPacketBlockControllerAntiXray chunkPacketBlockControllerAntiXray;
+    // Martijn start - custom blocks and items
+    private final ChunkPacketBlockControllerModifier chunkPacketBlockControllerAntiXray;
+    public final boolean doesPlayerHaveResourcePack;
+    // Martijn end - custom blocks and items
     private LevelChunk[] nearbyChunks;
 
-    public ChunkPacketInfoAntiXray(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk, ChunkPacketBlockControllerAntiXray chunkPacketBlockControllerAntiXray) {
+    public ChunkPacketInfoAntiXray(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk, ChunkPacketBlockControllerModifier chunkPacketBlockControllerAntiXray, boolean doesPlayerHaveResourcePack) { // Martijn - custom blocks and items
         super(chunkPacket, chunk);
         this.chunkPacketBlockControllerAntiXray = chunkPacketBlockControllerAntiXray;
+        this.doesPlayerHaveResourcePack = doesPlayerHaveResourcePack;
     }
 
     public LevelChunk[] getNearbyChunks() {
diff --git a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
index 89f86e52ff8b85a48e28ff60ca23853105df2f31..80e4cf626351901b96132627483749aefa117f9f 100644
--- a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
@@ -925,7 +925,7 @@ public final class PlayerChunkLoader {
         protected final TreeSet<ChunkPriorityHolder> sendQueueForTracking = createSendQueue();
         protected final TreeSet<ChunkPriorityHolder> sendQueueForSeeing = createSendQueue();
 
-        protected LongOpenHashSet getSentChunks(final boolean concernsTracking) {
+        public LongOpenHashSet getSentChunks(final boolean concernsTracking) { // Martijn - custom blocks and items
             return concernsTracking ? this.sentChunksForTracking : this.sentChunksForSeeing;
         }
         protected LongOpenHashSet getChunksToBeSent(final boolean concernsTracking) {
diff --git a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
index 5b079540a777db3f88cb356ee735d498fe6b5ed0..b40fd89ebe9c69fdc490c845d539172701853cc4 100644
--- a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
@@ -34,6 +34,18 @@ public class GlobalConfiguration extends ConfigurationPart {
     @Setting(Configuration.VERSION_FIELD)
     public int version = CURRENT_VERSION;
 
+    // Martijn start - custom blocks and items
+
+    public CustomBlocksAndItems customBlocksAndItems;
+
+    public class CustomBlocksAndItems extends ConfigurationPart {
+
+        public int maxPingThatCountsAsLowForCustomBlocks = 300;
+
+    }
+
+    // Martijn end - custom blocks and items
+
     // Martijn start - custom strongholds
 
     public CustomStrongholds customStrongholds;
diff --git a/src/main/java/net/minecraft/commands/Commands.java b/src/main/java/net/minecraft/commands/Commands.java
index b9be353c61e14d8a231b9ccc827d36b4777ddb65..b2ad92339a76dad0df0f263b866d25b523cf1d9a 100644
--- a/src/main/java/net/minecraft/commands/Commands.java
+++ b/src/main/java/net/minecraft/commands/Commands.java
@@ -12,6 +12,7 @@ import com.mojang.brigadier.tree.CommandNode;
 import com.mojang.brigadier.tree.RootCommandNode;
 import com.mojang.logging.LogUtils;
 import java.util.Iterator;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.function.Predicate;
@@ -23,6 +24,7 @@ import net.minecraft.Util;
 import net.minecraft.commands.synchronization.ArgumentTypeInfos;
 import net.minecraft.commands.synchronization.ArgumentUtils;
 import net.minecraft.commands.synchronization.SuggestionProviders;
+import net.minecraft.core.Registry;
 import net.minecraft.core.RegistryAccess;
 import net.minecraft.gametest.framework.TestCommand;
 import net.minecraft.network.chat.ClickEvent;
diff --git a/src/main/java/net/minecraft/commands/arguments/item/ItemParser.java b/src/main/java/net/minecraft/commands/arguments/item/ItemParser.java
index d36518504d6524e551abb2ee424b7133508934b2..0a15552af53d89ffae76e8ece84d6e001405d7cd 100644
--- a/src/main/java/net/minecraft/commands/arguments/item/ItemParser.java
+++ b/src/main/java/net/minecraft/commands/arguments/item/ItemParser.java
@@ -26,7 +26,7 @@ import net.minecraft.world.item.Item;
 
 public class ItemParser {
     private static final SimpleCommandExceptionType ERROR_NO_TAGS_ALLOWED = new SimpleCommandExceptionType(Component.translatable("argument.item.tag.disallowed"));
-    private static final DynamicCommandExceptionType ERROR_UNKNOWN_ITEM = new DynamicCommandExceptionType((id) -> {
+    public static final DynamicCommandExceptionType ERROR_UNKNOWN_ITEM = new DynamicCommandExceptionType((id) -> { // Martijn - custom blocks and items
         return Component.translatable("argument.item.id.invalid", id);
     });
     private static final DynamicCommandExceptionType ERROR_UNKNOWN_TAG = new DynamicCommandExceptionType((tag) -> {
diff --git a/src/main/java/net/minecraft/commands/synchronization/ArgumentTypeInfos.java b/src/main/java/net/minecraft/commands/synchronization/ArgumentTypeInfos.java
index f7c856535cc6a1f010d82f0a0b31a34978854310..69bb527caa960df890e3dee9910f95432622319b 100644
--- a/src/main/java/net/minecraft/commands/synchronization/ArgumentTypeInfos.java
+++ b/src/main/java/net/minecraft/commands/synchronization/ArgumentTypeInfos.java
@@ -59,6 +59,7 @@ import net.minecraft.commands.synchronization.brigadier.StringArgumentSerializer
 import net.minecraft.core.Registry;
 import net.minecraft.gametest.framework.TestClassNameArgument;
 import net.minecraft.gametest.framework.TestFunctionArgument;
+import nl.martijnmuijsers.paper.command.CustomItemArgument;
 
 public class ArgumentTypeInfos {
     private static final Map<Class<?>, ArgumentTypeInfo<?, ?>> BY_CLASS = Maps.newHashMap();
@@ -112,8 +113,8 @@ public class ArgumentTypeInfos {
         register(registry, "entity_summon", EntitySummonArgument.class, SingletonArgumentInfo.contextFree(EntitySummonArgument::id));
         register(registry, "dimension", DimensionArgument.class, SingletonArgumentInfo.contextFree(DimensionArgument::dimension));
         register(registry, "time", TimeArgument.class, SingletonArgumentInfo.contextFree(TimeArgument::time));
-        register(registry, "resource_or_tag", fixClassType(ResourceOrTagLocationArgument.class), new ResourceOrTagLocationArgument.Info());
-        register(registry, "resource", fixClassType(ResourceKeyArgument.class), new ResourceKeyArgument.Info());
+        register(registry, "resource_or_tag", fixClassType(ResourceOrTagLocationArgument.class), new ResourceOrTagLocationArgument.Info<>());
+        register(registry, "resource", fixClassType(ResourceKeyArgument.class), new ResourceKeyArgument.Info<>());
         register(registry, "template_mirror", TemplateMirrorArgument.class, SingletonArgumentInfo.contextFree(TemplateMirrorArgument::templateMirror));
         register(registry, "template_rotation", TemplateRotationArgument.class, SingletonArgumentInfo.contextFree(TemplateRotationArgument::templateRotation));
         if (SharedConstants.IS_RUNNING_IN_IDE) {
@@ -125,7 +126,7 @@ public class ArgumentTypeInfos {
     }
 
     private static <T extends ArgumentType<?>> Class<T> fixClassType(Class<? super T> clazz) {
-        return clazz;
+        return (Class<T>) clazz;
     }
 
     public static boolean isClassRecognized(Class<?> clazz) {
@@ -137,7 +138,7 @@ public class ArgumentTypeInfos {
         if (argumentTypeInfo == null) {
             throw new IllegalArgumentException("Unrecognized argument type %s (%s)".formatted(argumentType, argumentType.getClass()));
         } else {
-            return argumentTypeInfo;
+            return (ArgumentTypeInfo<A, ?>) argumentTypeInfo;
         }
     }
 
diff --git a/src/main/java/net/minecraft/core/MappedRegistry.java b/src/main/java/net/minecraft/core/MappedRegistry.java
index 16c37e5f8af31c366286254b210439082cc418dc..9fd30fd735bed9fee236fb17126653d47060541e 100644
--- a/src/main/java/net/minecraft/core/MappedRegistry.java
+++ b/src/main/java/net/minecraft/core/MappedRegistry.java
@@ -35,9 +35,12 @@ import net.minecraft.tags.TagKey;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.level.biome.Biome;
 import net.minecraft.world.level.biome.Biomes;
+import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.levelgen.structure.Structure;
 import nl.martijnmuijsers.paper.biome.SuCraftBiomeTags;
 import nl.martijnmuijsers.paper.biome.SuCraftBiomeTagsProvider;
+import nl.martijnmuijsers.paper.block.SuCraftBlockTagsProvider;
+import nl.martijnmuijsers.paper.block.SuCraftObservableBlockTagsSpreader;
 import nl.martijnmuijsers.paper.data.SuCraftTagsProvider;
 import nl.martijnmuijsers.paper.structure.SuCraftBuiltinStructures;
 import nl.martijnmuijsers.paper.structure.SuCraftStructureTagsProvider;
@@ -394,6 +397,10 @@ public class MappedRegistry<T> extends WritableRegistry<T> {
             tagEntries = ((SuCraftTagsProvider<T>) new SuCraftStructureTagsProvider((Registry<Structure>) this)).run(tagEntries);
         } else if (this.key().equals(BIOME_REGISTRY)) {
             tagEntries = ((SuCraftTagsProvider<T>) new SuCraftBiomeTagsProvider((Registry<Biome>) this)).run(tagEntries);
+        } else if (this.key().equals(BLOCK_REGISTRY)) {
+            tagEntries = ((SuCraftTagsProvider<T>) new SuCraftBlockTagsProvider((Registry<Block>) this)).run(tagEntries);
+            var spreader = (SuCraftTagsProvider<T>) new SuCraftObservableBlockTagsSpreader((Registry<Block>) this);
+            tagEntries = spreader.run(tagEntries);
         }
         // Martijn end - custom resource
         tagEntries.forEach((tag, entries) -> {
diff --git a/src/main/java/net/minecraft/core/Rotations.java b/src/main/java/net/minecraft/core/Rotations.java
index 152b1a2cb88c6456282b537611c18975d6da5f57..a353f9b9e20c0f23b04eee5885893d81f52a860d 100644
--- a/src/main/java/net/minecraft/core/Rotations.java
+++ b/src/main/java/net/minecraft/core/Rotations.java
@@ -3,12 +3,15 @@ package net.minecraft.core;
 import net.minecraft.nbt.FloatTag;
 import net.minecraft.nbt.ListTag;
 import net.minecraft.util.Mth;
+import org.jetbrains.annotations.NotNull;
 
 public class Rotations {
     protected final float x;
     protected final float y;
     protected final float z;
 
+    public static final @NotNull Rotations ZERO = new Rotations(0, 0, 0); // Martijn - custom blocks and items
+
     public Rotations(float pitch, float yaw, float roll) {
         this.x = !Float.isInfinite(pitch) && !Float.isNaN(pitch) ? pitch % 360.0F : 0.0F;
         this.y = !Float.isInfinite(yaw) && !Float.isNaN(yaw) ? yaw % 360.0F : 0.0F;
diff --git a/src/main/java/net/minecraft/data/loot/BlockLoot.java b/src/main/java/net/minecraft/data/loot/BlockLoot.java
index 2ae3cf188ed5ab1266b1aae796fecce02f517908..412ae3d0a634cbe183ee2ebeefb35dbec3f87fdf 100644
--- a/src/main/java/net/minecraft/data/loot/BlockLoot.java
+++ b/src/main/java/net/minecraft/data/loot/BlockLoot.java
@@ -96,7 +96,7 @@ public class BlockLoot implements Consumer<BiConsumer<ResourceLocation, LootTabl
     private static final LootItemCondition.Builder HAS_SHEARS_OR_SILK_TOUCH = HAS_SHEARS.or(HAS_SILK_TOUCH);
     private static final LootItemCondition.Builder HAS_NO_SHEARS_OR_SILK_TOUCH = HAS_SHEARS_OR_SILK_TOUCH.invert();
     private static final Set<Item> EXPLOSION_RESISTANT = Stream.of(Blocks.DRAGON_EGG, Blocks.BEACON, Blocks.CONDUIT, Blocks.SKELETON_SKULL, Blocks.WITHER_SKELETON_SKULL, Blocks.PLAYER_HEAD, Blocks.ZOMBIE_HEAD, Blocks.CREEPER_HEAD, Blocks.DRAGON_HEAD, Blocks.SHULKER_BOX, Blocks.BLACK_SHULKER_BOX, Blocks.BLUE_SHULKER_BOX, Blocks.BROWN_SHULKER_BOX, Blocks.CYAN_SHULKER_BOX, Blocks.GRAY_SHULKER_BOX, Blocks.GREEN_SHULKER_BOX, Blocks.LIGHT_BLUE_SHULKER_BOX, Blocks.LIGHT_GRAY_SHULKER_BOX, Blocks.LIME_SHULKER_BOX, Blocks.MAGENTA_SHULKER_BOX, Blocks.ORANGE_SHULKER_BOX, Blocks.PINK_SHULKER_BOX, Blocks.PURPLE_SHULKER_BOX, Blocks.RED_SHULKER_BOX, Blocks.WHITE_SHULKER_BOX, Blocks.YELLOW_SHULKER_BOX).map(ItemLike::asItem).collect(ImmutableSet.toImmutableSet());
-    private static final float[] NORMAL_LEAVES_SAPLING_CHANCES = new float[]{0.05F, 0.0625F, 0.083333336F, 0.1F};
+    public static final float[] NORMAL_LEAVES_SAPLING_CHANCES = new float[]{0.05F, 0.0625F, 0.083333336F, 0.1F}; // Martijn - custom blocks and items
     private static final float[] JUNGLE_LEAVES_SAPLING_CHANGES = new float[]{0.025F, 0.027777778F, 0.03125F, 0.041666668F, 0.1F};
     private static final float[] NORMAL_LEAVES_STICK_CHANCES = new float[]{0.02F, 0.022222223F, 0.025F, 0.033333335F, 0.1F};
     private final Map<ResourceLocation, LootTable.Builder> map = Maps.newHashMap();
@@ -109,7 +109,7 @@ public class BlockLoot implements Consumer<BiConsumer<ResourceLocation, LootTabl
         return (T)(!EXPLOSION_RESISTANT.contains(drop.asItem()) ? builder.when(ExplosionCondition.survivesExplosion()) : builder.unwrap());
     }
 
-    private static LootTable.Builder createSingleItemTable(ItemLike drop) {
+    public static LootTable.Builder createSingleItemTable(ItemLike drop) { // Martijn - custom blocks and items
         return LootTable.lootTable().withPool(applyExplosionCondition(drop, LootPool.lootPool().setRolls(ConstantValue.exactly(1.0F)).add(LootItem.lootTableItem(drop))));
     }
 
@@ -129,7 +129,7 @@ public class BlockLoot implements Consumer<BiConsumer<ResourceLocation, LootTabl
         return createSelfDropDispatchTable(drop, HAS_SHEARS_OR_SILK_TOUCH, child);
     }
 
-    private static LootTable.Builder createSingleItemTableWithSilkTouch(Block dropWithSilkTouch, ItemLike drop) {
+    public static LootTable.Builder createSingleItemTableWithSilkTouch(Block dropWithSilkTouch, ItemLike drop) { // Martijn - custom blocks and items
         return createSilkTouchDispatchTable(dropWithSilkTouch, applyExplosionCondition(dropWithSilkTouch, LootItem.lootTableItem(drop)));
     }
 
@@ -137,11 +137,11 @@ public class BlockLoot implements Consumer<BiConsumer<ResourceLocation, LootTabl
         return LootTable.lootTable().withPool(LootPool.lootPool().setRolls(ConstantValue.exactly(1.0F)).add(applyExplosionDecay(drop, LootItem.lootTableItem(drop).apply(SetItemCountFunction.setCount(count)))));
     }
 
-    private static LootTable.Builder createSingleItemTableWithSilkTouch(Block dropWithSilkTouch, ItemLike drop, NumberProvider count) {
+    public static LootTable.Builder createSingleItemTableWithSilkTouch(Block dropWithSilkTouch, ItemLike drop, NumberProvider count) { // Martijn - custom blocks and items
         return createSilkTouchDispatchTable(dropWithSilkTouch, applyExplosionDecay(dropWithSilkTouch, LootItem.lootTableItem(drop).apply(SetItemCountFunction.setCount(count))));
     }
 
-    private static LootTable.Builder createSilkTouchOnlyTable(ItemLike drop) {
+    public static LootTable.Builder createSilkTouchOnlyTable(ItemLike drop) { // Martijn - custom blocks and items
         return LootTable.lootTable().withPool(LootPool.lootPool().when(HAS_SILK_TOUCH).setRolls(ConstantValue.exactly(1.0F)).add(LootItem.lootTableItem(drop)));
     }
 
@@ -149,7 +149,7 @@ public class BlockLoot implements Consumer<BiConsumer<ResourceLocation, LootTabl
         return LootTable.lootTable().withPool(applyExplosionCondition(Blocks.FLOWER_POT, LootPool.lootPool().setRolls(ConstantValue.exactly(1.0F)).add(LootItem.lootTableItem(Blocks.FLOWER_POT)))).withPool(applyExplosionCondition(plant, LootPool.lootPool().setRolls(ConstantValue.exactly(1.0F)).add(LootItem.lootTableItem(plant))));
     }
 
-    private static LootTable.Builder createSlabItemTable(Block drop) {
+    public static LootTable.Builder createSlabItemTable(Block drop) { // Martijn - custom blocks and items
         return LootTable.lootTable().withPool(LootPool.lootPool().setRolls(ConstantValue.exactly(1.0F)).add(applyExplosionDecay(drop, LootItem.lootTableItem(drop).apply(SetItemCountFunction.setCount(ConstantValue.exactly(2.0F)).when(LootItemBlockStatePropertyCondition.hasBlockStateProperties(drop).setProperties(StatePropertiesPredicate.Builder.properties().hasProperty(SlabBlock.TYPE, SlabType.DOUBLE)))))));
     }
 
@@ -225,7 +225,7 @@ public class BlockLoot implements Consumer<BiConsumer<ResourceLocation, LootTabl
         }).apply(SetItemCountFunction.setCount(ConstantValue.exactly(-1.0F), true)))));
     }
 
-    private static LootTable.Builder createLeavesDrops(Block leaves, Block drop, float... chance) {
+    public static LootTable.Builder createLeavesDrops(Block leaves, Block drop, float... chance) { // Martijn - custom blocks and items
         return createSilkTouchOrShearsDispatchTable(leaves, applyExplosionCondition(leaves, LootItem.lootTableItem(drop)).when(BonusLevelTableCondition.bonusLevelFlatChance(Enchantments.BLOCK_FORTUNE, chance))).withPool(LootPool.lootPool().setRolls(ConstantValue.exactly(1.0F)).when(HAS_NO_SHEARS_OR_SILK_TOUCH).add(applyExplosionDecay(leaves, LootItem.lootTableItem(Items.STICK).apply(SetItemCountFunction.setCount(UniformGenerator.between(1.0F, 2.0F)))).when(BonusLevelTableCondition.bonusLevelFlatChance(Enchantments.BLOCK_FORTUNE, NORMAL_LEAVES_STICK_CHANCES))));
     }
 
@@ -1312,6 +1312,7 @@ public class BlockLoot implements Consumer<BiConsumer<ResourceLocation, LootTabl
         this.add(Blocks.POWDER_SNOW, noDrop());
         this.add(Blocks.FROGSPAWN, noDrop());
         this.add(Blocks.REINFORCED_DEEPSLATE, noDrop());
+
         Set<ResourceLocation> set = Sets.newHashSet();
 
         for(Block block : Registry.BLOCK) {
diff --git a/src/main/java/net/minecraft/network/Connection.java b/src/main/java/net/minecraft/network/Connection.java
index aca0dc4ce75b25409b057fe94362276c682cdc21..92e5b636dcaa4450d220185d4c68d7770c3d98e8 100644
--- a/src/main/java/net/minecraft/network/Connection.java
+++ b/src/main/java/net/minecraft/network/Connection.java
@@ -2,6 +2,7 @@ package net.minecraft.network;
 
 import com.google.common.collect.Queues;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.Channel;
@@ -20,7 +21,6 @@ import io.netty.channel.epoll.EpollSocketChannel;
 import io.netty.channel.local.LocalChannel;
 import io.netty.channel.local.LocalServerChannel;
 import io.netty.channel.nio.NioEventLoopGroup;
-import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.handler.timeout.ReadTimeoutHandler;
 import io.netty.handler.timeout.TimeoutException;
@@ -29,24 +29,62 @@ import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
+import java.util.BitSet;
+import java.util.Collections;
 import java.util.Queue;
+import java.util.UUID;
 import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.locks.ReentrantLock;
 import javax.annotation.Nullable;
-import javax.crypto.Cipher;
+
+import io.papermc.paper.util.CoordinateUtils;
+import it.unimi.dsi.fastutil.longs.Long2BooleanMap;
+import it.unimi.dsi.fastutil.longs.Long2BooleanOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2IntMap;
+import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongArrayFIFOQueue;
+import it.unimi.dsi.fastutil.longs.LongArrayList;
+import it.unimi.dsi.fastutil.longs.LongList;
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongSet;
 import net.minecraft.Util;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.core.Rotations;
+import net.minecraft.core.SectionPos;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.game.ClientboundAddEntityPacket;
 import net.minecraft.network.protocol.game.ClientboundDisconnectPacket;
+import net.minecraft.network.protocol.game.ClientboundRemoveEntitiesPacket;
+import net.minecraft.network.protocol.game.ClientboundSetEntityDataPacket;
+import net.minecraft.network.protocol.game.ClientboundSetEquipmentPacket;
 import net.minecraft.network.protocol.login.ClientboundLoginDisconnectPacket;
+import net.minecraft.network.syncher.SynchedEntityData;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.RunningOnDifferentThreadException;
 import net.minecraft.server.network.ServerGamePacketListenerImpl;
 import net.minecraft.server.network.ServerLoginPacketListenerImpl;
 import net.minecraft.util.LazyLoadedValue;
 import net.minecraft.util.Mth;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.decoration.ArmorStand;
+import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.phys.Vec3;
+import nl.martijnmuijsers.paper.blockanditemdata.model.BlockEntityModelPosition;
+import nl.martijnmuijsers.paper.blockanditemdata.model.BlockEntityModelProximity;
+import nl.martijnmuijsers.paper.blockanditemdata.model.BlockEntityModelVisualProperties;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.ResourcePackModel;
 import org.apache.commons.lang3.Validate;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 import org.slf4j.Marker;
 import org.slf4j.MarkerFactory;
@@ -96,6 +134,455 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     private float averageSentPackets;
     private int tickCount;
     private boolean handlingFault;
+
+    // Martijn start - custom blocks and items
+
+    // Keeping track of the Entity.getEntityId() of the fake entities that are sent to this connection's player as block entities
+
+    /**
+     * Stores the entity id (@{link org.bukkit.entity.Entity#getEntityId}) of the block entity (sent or to send) at the given block position (represented by a block key ({@link CoordinateUtils#getBlockKey}))
+     */
+    private final @NotNull Long2IntMap blockEntityEntityIdByBlockPosKey = new Long2IntOpenHashMap();
+
+    /**
+     * Stores the information of the block entity that was last sent at the given block position (represented by a block key ({@link CoordinateUtils#getBlockKey}))
+     */
+    private final @NotNull Long2ObjectMap<SentBlockEntityInformation> sentBlockEntityInformationByBlockPosKey = new Long2ObjectOpenHashMap<>(0);
+
+    private record SentBlockEntityInformation(@NotNull BlockState blockState, @NotNull BlockEntityModelVisualProperties properties) {}
+
+    /**
+     * Stores the block positions (represented by a block key ({@link CoordinateUtils#getBlockKey})) at the given chunk section position (represented by a chunk section key ({@link CoordinateUtils#getChunkSectionKey}))
+     */
+    private final @NotNull Long2ObjectMap<LongSet> blockEntityBlockPosKeysPerChunkSectionKey = new Long2ObjectOpenHashMap<>(0);
+
+    public @Nullable LongSet getBlockEntityBlockPosKeysForChunkSectionKey(long chunkSectionKey) {
+        return this.blockEntityBlockPosKeysPerChunkSectionKey.get(chunkSectionKey);
+    }
+
+    /**
+     * Utility function used in {@link #spawnBlockEntity}
+     */
+    private static void writeMetadataSharedFlags(@NotNull FriendlyByteBuf buf, int index, int byteValue) {
+        buf.writeByte(index);
+        buf.writeVarInt(0);
+        buf.writeByte(byteValue);
+    }
+
+    private static void writeMetadataRotation(@NotNull FriendlyByteBuf buf, int index, float x, float y, float z) {
+        buf.writeByte(index);
+        buf.writeVarInt(8);
+        buf.writeFloat(x);
+        buf.writeFloat(y);
+        buf.writeFloat(z);
+    }
+
+    /**
+     * Utility function used in {@link #spawnBlockEntity}
+     */
+    private static int bitsetToInt(@NotNull BitSet bitset) {
+        long[] longArray = bitset.toLongArray();
+        if (longArray.length == 0) {
+            return 0;
+        }
+        return (int) longArray[0];
+    }
+
+    private void sendSetEquipmentPacket(int entityId, @NotNull SentBlockEntityInformation blockEntityInformationToSend) {
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Sending " + entityId + " equipment: " + blockEntityInformationToSend.blockState + " , " + blockEntityInformationToSend.properties.position() + " , " + blockEntityInformationToSend.properties.proximity() + " = " + blockEntityInformationToSend.blockState().getBlock().replacementRule.getBlockEntityItemStack(blockEntityInformationToSend.blockState(), blockEntityInformationToSend.properties).getTag().getInt(CraftMetaItem.CUSTOM_MODEL_DATA.NBT) + " ( " + blockEntityInformationToSend.blockState().getBlock().replacementRule.getBlockEntityItemModel(blockEntityInformationToSend.blockState(), blockEntityInformationToSend.properties).getKeyWithIntention() + " using custom model data " + blockEntityInformationToSend.blockState().getBlock().replacementRule.getBlockEntityItemCustomModelData(blockEntityInformationToSend.blockState(), blockEntityInformationToSend.properties) + " )");
+        this.send(new ClientboundSetEquipmentPacket(entityId, Collections.singletonList(new Pair<>(EquipmentSlot.HEAD, blockEntityInformationToSend.blockState().getBlock().replacementRule.getBlockEntityItemStack(blockEntityInformationToSend.blockState(), blockEntityInformationToSend.properties)))));
+    }
+
+    private void spawnBlockEntity(@NotNull BlockPos blockPos, @NotNull SentBlockEntityInformation blockEntityInformationToSend) {
+
+        long blockKey = blockPos.asLong();
+        int entityId = this.blockEntityEntityIdByBlockPosKey.computeIfAbsent(blockKey, $ -> Entity.ENTITY_COUNTER.incrementAndGet());
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Spawning " + entityId + " at " + blockPos.getX() + ", " + blockPos.getY() + ", " + blockPos.getZ());
+        this.sentBlockEntityInformationByBlockPosKey.put(blockKey, blockEntityInformationToSend);
+        long chunkSectionKey = SectionPos.of(blockPos).asLong();
+        this.blockEntityBlockPosKeysPerChunkSectionKey.computeIfAbsent(chunkSectionKey, $ -> new LongOpenHashSet(1)).add(blockKey);
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Added block key " + BlockPos.of(blockKey).getX() + ", " + BlockPos.of(blockKey).getY() + ", " + BlockPos.of(blockKey).getZ());
+        UUID entityUUID = UUID.randomUUID();
+
+        // Send the add entity packet
+        this.send(new ClientboundAddEntityPacket(
+            entityId,
+            entityUUID,
+            blockPos.getX() + 0.5F + blockEntityInformationToSend.properties.position().armorStandPhysicalTranslationX,
+            blockPos.getY() + ResourcePackModel.BLOCK_ENTITY_ARMOR_STAND_DY,
+            blockPos.getZ() + 0.5F + blockEntityInformationToSend.properties.position().armorStandPhysicalTranslationZ,
+            0F,
+            0F,
+            EntityType.ARMOR_STAND,
+            0,
+            Vec3.ZERO,
+            0
+        ));
+
+        // Send the set equipment packet
+        this.sendSetEquipmentPacket(entityId, blockEntityInformationToSend);
+
+        // Send the set entity data packet
+        @NotNull ClientboundSetEntityDataPacket setEntityDataPacket = new ClientboundSetEntityDataPacket(entityId);
+        var setEntityDataUnpackedData = setEntityDataPacket.getUnpackedData();
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(Entity.DATA_SHARED_FLAGS_ID, (byte) (1 << Entity.FLAG_INVISIBLE)));
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(Entity.DATA_NO_GRAVITY, true));
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(Entity.DATA_SILENT, true));
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(Entity.DATA_AIR_SUPPLY_ID, Integer.MAX_VALUE));
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(ArmorStand.DATA_CLIENT_FLAGS, (byte) (ArmorStand.CLIENT_FLAG_NO_BASEPLATE | ArmorStand.CLIENT_FLAG_MARKER)));
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(ArmorStand.DATA_HEAD_POSE, Rotations.ZERO));
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(ArmorStand.DATA_BODY_POSE, Rotations.ZERO));
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(ArmorStand.DATA_LEFT_ARM_POSE, Rotations.ZERO));
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(ArmorStand.DATA_RIGHT_ARM_POSE, Rotations.ZERO));
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(ArmorStand.DATA_LEFT_LEG_POSE, Rotations.ZERO));
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(ArmorStand.DATA_RIGHT_LEG_POSE, Rotations.ZERO));
+        this.send(setEntityDataPacket);
+
+    }
+
+    private void despawnBlockEntity(@NotNull BlockPos blockPos, boolean needToRemoveFromPerChunkSectionKey) {
+        long blockKey = blockPos.asLong();
+        if (!this.blockEntityEntityIdByBlockPosKey.containsKey(blockKey)) {
+//            MinecraftServer.LOGGER.info("TEMP DEBUG - Tried to despawn at " + blockPos.getX() + ", " + blockPos.getY() + ", " + blockPos.getZ() + " but is no longer there?");
+            return;
+        }
+        int entityId = this.blockEntityEntityIdByBlockPosKey.remove(blockKey);
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Despawning " + entityId + " at " + blockPos.getX() + ", " + blockPos.getY() + ", " + blockPos.getZ());
+        this.sentBlockEntityInformationByBlockPosKey.remove(blockKey);
+        if (needToRemoveFromPerChunkSectionKey) {
+            long chunkSectionKey = SectionPos.of(blockPos).asLong();
+            this.blockEntityBlockPosKeysPerChunkSectionKey.computeIfPresent(chunkSectionKey, ($, blockPosKeys) -> {
+                blockPosKeys.remove(blockKey);
+                if (blockPosKeys.isEmpty()) {
+                    return null;
+                }
+                return blockPosKeys;
+            });
+        }
+        this.send(new ClientboundRemoveEntitiesPacket(entityId));
+    }
+
+    /**
+     * Updates any existing sent block entity at the position that had different information,
+     * and spawns a new block entity if no such existing sent block entity exists
+     */
+    private void updateBlockEntityOrSpawnIfNotSent(@NotNull BlockPos blockPos, @NotNull SentBlockEntityInformation blockEntityInformationToSend) {
+        long blockKey = blockPos.asLong();
+        @Nullable SentBlockEntityInformation existingSentBlockEntityInformation = this.sentBlockEntityInformationByBlockPosKey.get(blockKey);
+        tryUpdateExistingBlockEntity: if (existingSentBlockEntityInformation != null) {
+            if (existingSentBlockEntityInformation.properties.position() != blockEntityInformationToSend.properties.position()) {
+                this.despawnBlockEntity(blockPos, true);
+                break tryUpdateExistingBlockEntity;
+            }
+            boolean updated = false;
+            if (!existingSentBlockEntityInformation.blockState.equals(blockEntityInformationToSend.blockState) || existingSentBlockEntityInformation.properties.proximity() != blockEntityInformationToSend.properties.proximity()) {
+                int entityId = this.blockEntityEntityIdByBlockPosKey.get(blockKey);
+                // Send a set equipment packet to change the observed block state
+                sendSetEquipmentPacket(entityId, blockEntityInformationToSend);
+                updated = true;
+            }
+            if (updated) {
+                sentBlockEntityInformationByBlockPosKey.put(blockKey, blockEntityInformationToSend);
+            }
+            return;
+        }
+        this.spawnBlockEntity(blockPos, blockEntityInformationToSend);
+    }
+
+    /**
+     * Completely updates this player correctly as per the current potential block entity at the given position
+     * <br>
+     * To be called when a block update for the block is sent to the player
+     *
+     * @param sentBlockEntityBlockPosKeys Will be used to determine if a block entity at the given block position (represented by the block key) was sent to the player before - if null, will be assumed to be an empty set
+     */
+    public void updatePotentialBlockEntityAtPosition(@NotNull BlockPos blockPos, boolean useGivenSentBlockEntityBlockPosKeys, @Nullable LongSet sentBlockEntityBlockPosKeys, boolean doDespawns) {
+        long blockKey = blockPos.asLong();
+        var player = this.getPlayer();
+        var level = player.getLevel();
+        @NotNull BlockState state = level.getBlockState(blockPos);
+        @Nullable var replacementRule = state.getBlock().replacementRule;
+        if (replacementRule == null || !replacementRule.hasAsReal(state.getBlock()) || !replacementRule.rendersAsEntity()) {
+            if (doDespawns && (useGivenSentBlockEntityBlockPosKeys ? (sentBlockEntityBlockPosKeys != null && sentBlockEntityBlockPosKeys.contains(blockKey)) : this.blockEntityEntityIdByBlockPosKey.containsKey(blockKey))) {
+                this.despawnBlockEntity(blockPos, true);
+            }
+            return;
+        }
+        @NotNull BlockEntityModelPosition position;
+        // Check if one of the block, the block above and the block below is transparent: because then we can just use the center
+        if (!state.isOpaque() || !level.getBlockState(blockPos.above()).isOpaque() || !level.getBlockState(blockPos.below()).isOpaque()) {
+            position = BlockEntityModelPosition.CENTER;
+        } else {
+            // If all three vertical blocks on the positive X, positive Z and positive XZ side are opaque, only then do we assume the negative XZ is a better position
+            BlockPos positiveXRelative = blockPos.relative(Direction.Axis.X, 1);
+            BlockPos positiveZRelative = blockPos.relative(Direction.Axis.Z, 1);
+            BlockPos positiveXZRelative = positiveXRelative.relative(Direction.Axis.Z, 1);
+            if (level.getBlockState(positiveXRelative).isOpaque() && level.getBlockState(positiveXRelative.above()).isOpaque() && level.getBlockState(positiveXRelative.below()).isOpaque() && level.getBlockState(positiveZRelative).isOpaque() && level.getBlockState(positiveZRelative.above()).isOpaque() && level.getBlockState(positiveZRelative.below()).isOpaque() && level.getBlockState(positiveXZRelative).isOpaque() && level.getBlockState(positiveXZRelative.above()).isOpaque() && level.getBlockState(positiveXZRelative.below()).isOpaque()) {
+                position = BlockEntityModelPosition.NEGATIVE_XZ;
+            } else {
+                position = BlockEntityModelPosition.POSITIVE_XZ;
+            }
+        }
+        @NotNull BlockEntityModelProximity proximity = this.computeNewProximity(blockKey, SectionPos.of(player), player.blockPosition);
+        this.updateBlockEntityOrSpawnIfNotSent(blockPos, new SentBlockEntityInformation(state, new BlockEntityModelVisualProperties(position, proximity)));
+    }
+
+    private ReentrantLock scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock = new ReentrantLock();
+    private boolean executedUpdatePotentialBlockEntitiesInSectionSpawnNewThisTick = false;
+
+    private @NotNull Long2BooleanMap sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewAndWhetherToUpdateOutsideSectionBounds = new Long2BooleanOpenHashMap(1);
+    private @NotNull LongArrayFIFOQueue sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewList= new LongArrayFIFOQueue(1);
+
+    private void tickUpdatePotentialBlockEntitiesInSectionSpawnNew() {
+        long sectionKey;
+        boolean updateOutsideSectionBounds;
+        boolean needToUnlock = true;
+        try {
+            scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.lock();
+            if (sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewAndWhetherToUpdateOutsideSectionBounds.isEmpty()) {
+                executedUpdatePotentialBlockEntitiesInSectionSpawnNewThisTick = false;
+                scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.unlock();
+                needToUnlock = false;
+                return;
+            }
+            executedUpdatePotentialBlockEntitiesInSectionSpawnNewThisTick = true;
+            sectionKey = sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewList.dequeueLong();
+            updateOutsideSectionBounds = sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewAndWhetherToUpdateOutsideSectionBounds.remove(sectionKey);
+        } finally {
+            if (needToUnlock) {
+                scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.unlock();
+            }
+        }
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Section update new during tick: " + SectionPos.of(sectionKey).x() + ", " + SectionPos.of(sectionKey).y() + ", " + SectionPos.of(sectionKey).z());
+        this.updatePotentialBlockEntitiesInSectionSpawnNew(SectionPos.of(sectionKey), updateOutsideSectionBounds, null);
+    }
+
+    private void scheduleUpdatePotentialBlockEntitiesInSectionSpawnNew(@NotNull SectionPos sectionPos, boolean updateOutsideSectionBounds, @Nullable LevelChunk precomputedChunk) {
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Schedule section update new: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
+        boolean needToUnlock = true;
+        try {
+            scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.lock();
+//            boolean executeRightNow = !executedUpdatePotentialBlockEntitiesInSectionSpawnNewThisTick && sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewList.isEmpty();
+//            if (executeRightNow) {
+//                executedUpdatePotentialBlockEntitiesInSectionSpawnNewThisTick = true;
+//                scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.unlock();
+//                needToUnlock = false;
+//                MinecraftServer.LOGGER.info("TEMP DEBUG - Section update new right now: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
+//                this.updatePotentialBlockEntitiesInSectionSpawnNew(sectionPos, updateOutsideSectionBounds, precomputedChunk);
+//                return;
+//            }
+            long sectionKey = sectionPos.asLong();
+            sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewAndWhetherToUpdateOutsideSectionBounds.compute(sectionKey, ($, existingUpdateOutsideSectionBounds) -> {
+                if (existingUpdateOutsideSectionBounds == null) {
+                    sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewList.enqueue(sectionKey);
+                    return updateOutsideSectionBounds;
+                }
+                return existingUpdateOutsideSectionBounds || updateOutsideSectionBounds;
+            });
+        } finally {
+            if (needToUnlock) {
+                scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.unlock();
+            }
+        }
+    }
+
+    /**
+     * The part of {@link #updatePotentialBlockEntitiesInSection} that spawns new block entities
+     */
+    private void updatePotentialBlockEntitiesInSectionSpawnNew(@NotNull SectionPos sectionPos, boolean updateOutsideSectionBounds, @Nullable LevelChunk precomputedChunk) {
+        var player = this.getPlayer();
+        var level = player.getLevel();
+        @Nullable LevelChunk chunk = precomputedChunk != null ? precomputedChunk : level.getChunkIfLoaded(sectionPos.x(), sectionPos.z());
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Section update new: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
+        if (chunk != null) {
+            var section = chunk.getSection(chunk.getSectionIndexFromSectionY(sectionPos.y()));
+            if (section.potentiallyContainsBlockEntity()) {
+                int minYInSection;
+                int maxYInSection;
+                int minXInSection;
+                int minZInSection;
+                int maxXInSection;
+                int maxZInSection;
+                if (updateOutsideSectionBounds) {
+                    boolean isBottomSection = sectionPos.y() == level.getMinSection();
+                    boolean isTopSection = sectionPos.y() == level.getMaxSection();
+                    boolean isMinXChunkLoaded = chunk.isNeighbourLoaded(-1, 0);
+                    boolean isMinXZChunkLoaded = chunk.isNeighbourLoaded(-1, -1);
+                    boolean isMinZChunkLoaded = chunk.isNeighbourLoaded(0, -1);
+                    boolean isPlusXChunkLoaded = chunk.isNeighbourLoaded(1, 0);
+                    boolean isPlusXZChunkLoaded = chunk.isNeighbourLoaded(1, 1);
+                    boolean isPlusZChunkLoaded = chunk.isNeighbourLoaded(0, 1);
+                    boolean isMinXPlusZChunkLoaded = chunk.isNeighbourLoaded(-1, 1);
+                    boolean isPlusXMinZChunkLoaded = chunk.isNeighbourLoaded(1, -1);
+                    minYInSection = isBottomSection ? 0 : -1;
+                    maxYInSection = isTopSection ? 15 : 16;
+                    minXInSection = isMinXChunkLoaded && isMinXZChunkLoaded && isMinXPlusZChunkLoaded ? -1 : 0;
+                    minZInSection = isMinZChunkLoaded && isMinXZChunkLoaded && isPlusXMinZChunkLoaded ? -1 : 0;
+                    maxXInSection = isPlusXChunkLoaded && isPlusXZChunkLoaded && isPlusXMinZChunkLoaded ? 16 : 15;
+                    maxZInSection = isPlusZChunkLoaded && isPlusXZChunkLoaded && isMinXPlusZChunkLoaded ? 16 : 15;
+                } else {
+                    minYInSection = 0;
+                    maxYInSection = 15;
+                    minXInSection = 0;
+                    minZInSection = 0;
+                    maxXInSection = 15;
+                    maxZInSection = 15;
+                }
+                //                MinecraftServer.LOGGER.info("TEMP DEBUG - Section update loop: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
+                for (int xInSection = minXInSection; xInSection <= maxXInSection; xInSection++) {
+                    for (int yInSection = minYInSection; yInSection <= maxYInSection; yInSection++) {
+                        for (int zInSection = minZInSection; zInSection <= maxZInSection; zInSection++) {
+                            int blockX = sectionPos.minBlockX() + xInSection;
+                            int blockY = sectionPos.minBlockY() + yInSection;
+                            int blockZ = sectionPos.minBlockZ() + zInSection;
+                            this.updatePotentialBlockEntityAtPosition(new BlockPos(blockX, blockY, blockZ), true, null, false);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    public void updatePotentialBlockEntitiesInSection(@NotNull SectionPos sectionPos, boolean updateOutsideSectionBounds, @Nullable LevelChunk precomputedChunk) {
+        var player = this.getPlayer();
+        var level = player.getLevel();
+        @Nullable LevelChunk chunk = precomputedChunk != null ? precomputedChunk : level.getChunkIfLoaded(sectionPos.x(), sectionPos.z());
+        if (chunk != null) {
+//            MinecraftServer.LOGGER.info("TEMP DEBUG - Section update start: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
+            var sectionKey = sectionPos.asLong();
+            // Attempt to despawn any sent block entities where one no longer exists
+            @Nullable LongSet sectionSentBlockKeys = this.getBlockEntityBlockPosKeysForChunkSectionKey(sectionKey);
+            if (sectionSentBlockKeys != null) {
+//                MinecraftServer.LOGGER.info("TEMP DEBUG - Section update old: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
+                @Nullable LongList toRemoveBlockKeys = null;
+                for (long sentBlockKey : sectionSentBlockKeys) {
+                    @NotNull BlockPos blockPos = BlockPos.of(sentBlockKey);
+                    @NotNull BlockState state = level.getBlockState(blockPos);
+                    @Nullable var replacementRule = state.getBlock().replacementRule;
+                    if (replacementRule == null || !replacementRule.hasAsReal(state.getBlock()) || !replacementRule.rendersAsEntity()) {
+                        if (toRemoveBlockKeys == null) {
+                            toRemoveBlockKeys = new LongArrayList(1);
+                        }
+                        toRemoveBlockKeys.add(sentBlockKey);
+                        despawnBlockEntity(blockPos, false);
+                    }
+                }
+//                MinecraftServer.LOGGER.info("TEMP DEBUG - Section update old to remove size is " + (toRemoveBlockKeys == null ? 0 : toRemoveBlockKeys.size()));
+                if (toRemoveBlockKeys != null) {
+                    for (long sentBlockKey : toRemoveBlockKeys) {
+                        sectionSentBlockKeys.remove(sentBlockKey);
+                        if (sectionSentBlockKeys.isEmpty()) {
+                            this.blockEntityBlockPosKeysPerChunkSectionKey.remove(sectionKey);
+                        }
+                    }
+                }
+            }
+            // Attempt to update any block entities derived from the actual world block states
+            var section = chunk.getSection(chunk.getSectionIndexFromSectionY(sectionPos.y()));
+            if (section.potentiallyContainsBlockEntity()) {
+                this.scheduleUpdatePotentialBlockEntitiesInSectionSpawnNew(sectionPos, updateOutsideSectionBounds, chunk);
+//                MinecraftServer.LOGGER.info("TEMP DEBUG - Section update done: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
+            }
+        }
+    }
+
+    /**
+     * To be called for every chunk section of a chunk when it is being unloaded from the player
+     */
+    public void despawnBlockEntitiesInChunkSection(long chunkSectionKey) {
+        this.blockEntityBlockPosKeysPerChunkSectionKey.computeIfPresent(chunkSectionKey, ($, blockPosKeys) -> {
+            blockPosKeys.forEach(blockPosKey -> this.despawnBlockEntity(BlockPos.of(blockPosKey), false));
+            return null;
+        });
+    }
+
+    public boolean hasUpdatedBlockEntitiesClosebyModelForSections = false;
+
+    private static @NotNull BlockEntityModelProximity getProximityForSections(@NotNull SectionPos sectionPos, @NotNull SectionPos playerSectionPos) {
+        int sectionDX = sectionPos.x() - playerSectionPos.x();
+        int sectionDY = sectionPos.y() - playerSectionPos.y();
+        int sectionDZ = sectionPos.z() - playerSectionPos.z();
+        if (sectionDX == 0 && sectionDY == 0 && sectionDZ == 0) {
+            return BlockEntityModelProximity.SAME_CHUNK;
+        } else if (sectionDX >= -BlockEntityModelProximity.maxSectionDistanceForNeighbors && sectionDX <= BlockEntityModelProximity.maxSectionDistanceForNeighbors && sectionDY >= -BlockEntityModelProximity.maxSectionDistanceForNeighbors && sectionDY <= BlockEntityModelProximity.maxSectionDistanceForNeighbors && sectionDZ >= -BlockEntityModelProximity.maxSectionDistanceForNeighbors && sectionDZ <= BlockEntityModelProximity.maxSectionDistanceForNeighbors) {
+            return BlockEntityModelProximity.NEIGHBOR_CHUNK;
+        } else {
+            return BlockEntityModelProximity.FAR;
+        }
+    }
+
+    private static @Nullable BlockEntityModelProximity getProximityForBlocks(@NotNull BlockPos blockPos, @NotNull BlockPos playerBlockPos, @Nullable BlockEntityModelProximity defaultValue) {
+        int dx = blockPos.getX() - playerBlockPos.getX();
+        if (dx >= -BlockEntityModelProximity.maxBlockDistanceForNeighbors && dx <= BlockEntityModelProximity.maxBlockDistanceForNeighbors) {
+            int dy = blockPos.getY() - playerBlockPos.getY();
+            if (dy >= -BlockEntityModelProximity.maxBlockDistanceForNeighbors && dy <= BlockEntityModelProximity.maxBlockDistanceForNeighbors) {
+                int dz = blockPos.getZ() - playerBlockPos.getZ();
+                if (dz >= -BlockEntityModelProximity.maxBlockDistanceForNeighbors && dz <= BlockEntityModelProximity.maxBlockDistanceForNeighbors) {
+                    return BlockEntityModelProximity.NEIGHBOR_BLOCK;
+                }
+            }
+        }
+        return defaultValue;
+    }
+
+    private @NotNull SentBlockEntityInformation sendUpdateBlockEntityClosebyModelIfNeeded(long blockKey, @NotNull SentBlockEntityInformation existingSentBlockEntityInformation, @NotNull BlockEntityModelProximity newProximity) {
+        if (existingSentBlockEntityInformation.properties.proximity() == newProximity) {
+            return existingSentBlockEntityInformation;
+        }
+        int entityId = this.blockEntityEntityIdByBlockPosKey.get(blockKey);
+        var newBlockEntityInformation = new SentBlockEntityInformation(existingSentBlockEntityInformation.blockState, new BlockEntityModelVisualProperties(existingSentBlockEntityInformation.properties.position(), newProximity));
+        this.sendSetEquipmentPacket(entityId, newBlockEntityInformation);
+        return newBlockEntityInformation;
+    }
+
+    /**
+     * To be called for every chunk section that the player enters or leaves, or any chunk section right next to a chunk section (at most chunk section chessboard distance 1) the player enters or leaves
+     */
+    public void updateBlockEntitiesClosebyModelInChunkSection(long chunkSectionKey, @NotNull SectionPos upToDatePlayerSectionPos, @NotNull BlockPos upToDatePlayerBlockPos) {
+        LongSet blockKeys = this.blockEntityBlockPosKeysPerChunkSectionKey.get(chunkSectionKey);
+        if (blockKeys == null) {
+            return;
+        }
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Updating closeby model for all in section " + SectionPos.x(chunkSectionKey) + ", " + SectionPos.y(chunkSectionKey) + ", " + SectionPos.z(chunkSectionKey));
+        SectionPos sectionPos = SectionPos.of(chunkSectionKey);
+        @NotNull BlockEntityModelProximity globalSectionProximity = getProximityForSections(sectionPos, upToDatePlayerSectionPos);
+        boolean needToCheckForBlockProximity;
+        if (upToDatePlayerSectionPos.asLong() == chunkSectionKey) {
+            needToCheckForBlockProximity = true;
+        } else {
+            needToCheckForBlockProximity = upToDatePlayerBlockPos.getX() >= sectionPos.minBlockX() - 1 && upToDatePlayerBlockPos.getX() <= sectionPos.maxBlockX() + 1 && upToDatePlayerBlockPos.getY() >= sectionPos.minBlockY() - 1 && upToDatePlayerBlockPos.getY() <= sectionPos.maxBlockY() + 1 && upToDatePlayerBlockPos.getZ() >= sectionPos.minBlockZ() - 1 && upToDatePlayerBlockPos.getZ() <= sectionPos.maxBlockZ() + 1;
+        }
+        for (long blockKey : blockKeys) {
+            this.sentBlockEntityInformationByBlockPosKey.computeIfPresent(blockKey, ($, existingSentBlockEntityInformation) -> {
+                @NotNull BlockEntityModelProximity newProximity = globalSectionProximity;
+                if (needToCheckForBlockProximity) {
+                    BlockPos blockPos = BlockPos.of(blockKey);
+                    newProximity = getProximityForBlocks(blockPos, upToDatePlayerBlockPos, newProximity);
+                }
+                return sendUpdateBlockEntityClosebyModelIfNeeded(blockKey, existingSentBlockEntityInformation, newProximity);
+            });
+        }
+    }
+
+    private @NotNull BlockEntityModelProximity computeNewProximity(long blockKey, @NotNull SectionPos upToDatePlayerSectionPos, @NotNull BlockPos upToDatePlayerBlockPos) {
+        BlockPos blockPos = BlockPos.of(blockKey);
+        @Nullable BlockEntityModelProximity newProximity = getProximityForBlocks(blockPos, upToDatePlayerBlockPos, null);
+        if (newProximity == null) {
+            SectionPos sectionPos = SectionPos.of(blockPos);
+            newProximity = getProximityForSections(sectionPos, upToDatePlayerSectionPos);
+        }
+        return newProximity;
+    }
+
+    public void updateBlockEntitiesClosebyModelForBlock(long blockKey, @NotNull SectionPos upToDatePlayerSectionPos, @NotNull BlockPos upToDatePlayerBlockPos) {
+        this.sentBlockEntityInformationByBlockPosKey.computeIfPresent(blockKey, ($, existingSentBlockEntityInformation) -> {
+            @Nullable BlockEntityModelProximity newProximity = computeNewProximity(blockKey, upToDatePlayerSectionPos, upToDatePlayerBlockPos);
+            return sendUpdateBlockEntityClosebyModelIfNeeded(blockKey, existingSentBlockEntityInformation, newProximity);
+        });
+    }
+
+    // Martijn end - custom blocks and items
+
     // Paper start - NetworkClient implementation
     public int protocolVersion;
     public java.net.InetSocketAddress virtualHost;
@@ -327,6 +814,21 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             return null;
         }
     }
+
+    // Martijn start - custom blocks and items
+
+    public boolean doesPlayerHaveSuCraftResourcePack() {
+        var player = getPlayer();
+        return player != null ? player.hasSuCraftResourcePack() : false;
+    }
+
+    public boolean doesPlayerHaveHighPingForCustomBlocks() {
+        var player = getPlayer();
+        return player != null ? player.hasHighPingForCustomBlocks() : false;
+    }
+
+    // Martijn end - custom blocks and items
+
     private static class InnerUtil { // Attempt to hide these methods from ProtocolLib so it doesn't accidently pick them up.
         private static java.util.List<Packet> buildExtraPackets(Packet packet) {
             java.util.List<Packet> extra = packet.getExtraPackets();
@@ -363,7 +865,15 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
                 packet instanceof net.minecraft.network.protocol.game.ClientboundClearTitlesPacket ||
                 packet instanceof net.minecraft.network.protocol.game.ClientboundBossEventPacket ||
                 packet instanceof net.minecraft.network.protocol.game.ClientboundPlayerInfoPacket ||
-                packet instanceof net.minecraft.network.protocol.game.ClientboundMapItemDataPacket;
+                // Martijn start - custom blocks and items - even more packets that can be sent immediately
+                packet instanceof net.minecraft.network.protocol.game.ClientboundMapItemDataPacket ||
+                packet instanceof net.minecraft.network.protocol.game.ClientboundUpdateAdvancementsPacket ||
+                packet instanceof net.minecraft.network.protocol.game.ClientboundUpdateRecipesPacket ||
+                packet instanceof net.minecraft.network.protocol.game.ClientboundResourcePackPacket ||
+                packet instanceof net.minecraft.network.protocol.game.ClientboundInitializeBorderPacket ||
+                packet instanceof net.minecraft.network.protocol.game.ClientboundLoginPacket ||
+                packet instanceof net.minecraft.network.protocol.game.ClientboundServerDataPacket;
+                // Martijn end - custom blocks and items - even more packets that can be sent immediately
             // Martijn end - more packets that can be sent immediately
         }
         // Paper end
@@ -380,6 +890,11 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         if (!connected && !preparing) {
             return; // Do nothing
         }
+        // Martijn start - custom blocks and items
+        if (this.doesPlayerHaveSuCraftResourcePack()) {
+            callback = packet.updateCallbackWithBlockEntityPacketSends(callback, this);
+        }
+        // Martijn end - custom blocks and items
         packet.onPacketDispatch(getPlayer());
         if (connected && (InnerUtil.canSendImmediate(this, packet) || (
             net.minecraft.server.MCUtil.isMainThread() && packet.isReady() && this.queue.isEmpty() &&
@@ -421,6 +936,14 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             || packet instanceof net.minecraft.network.protocol.game.ClientboundForgetLevelChunkPacket
             || packet instanceof net.minecraft.network.protocol.game.ClientboundPlayerInfoPacket
             || packet instanceof net.minecraft.network.protocol.game.ClientboundMapItemDataPacket
+            // Martijn start - custom blocks and items - even more packets without delay
+            || packet instanceof net.minecraft.network.protocol.game.ClientboundUpdateAdvancementsPacket
+            || packet instanceof net.minecraft.network.protocol.game.ClientboundUpdateRecipesPacket
+            || packet instanceof net.minecraft.network.protocol.game.ClientboundResourcePackPacket
+            || packet instanceof net.minecraft.network.protocol.game.ClientboundInitializeBorderPacket
+            || packet instanceof net.minecraft.network.protocol.game.ClientboundLoginPacket
+            || packet instanceof net.minecraft.network.protocol.game.ClientboundServerDataPacket
+            // Martijn end - custom blocks and items - even more packets without delay
             ; // no delay for certain packets
         // Martijn end - more packets without delay
         // Paper end - add flush parameter
@@ -433,20 +956,22 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             this.channel.config().setAutoRead(false);
         }
 
+        Packet<?> modifiedPacket = packet.replaceCustomContent(this.doesPlayerHaveSuCraftResourcePack(), this.doesPlayerHaveHighPingForCustomBlocks()); // Martijn - custom blocks and items
+
         if (this.channel.eventLoop().inEventLoop()) {
-            this.doSendPacket(packet, callback, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter
+            this.doSendPacket(modifiedPacket, callback, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter // Martijn - custom blocks and items
         } else {
             // Paper start - optimise packets that are not flushed
             // note: since the type is not dynamic here, we need to actually copy the old executor code
             // into two branches. On conflict, just re-copy - no changes were made inside the executor code.
             if (!flush) {
                 AbstractEventExecutor.LazyRunnable run = () -> {
-                    this.doSendPacket(packet, callback, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter
+                    this.doSendPacket(modifiedPacket, callback, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter // Martijn - custom blocks and items
                 };
                 this.channel.eventLoop().execute(run);
             } else { // Paper end - optimise packets that are not flushed
             this.channel.eventLoop().execute(() -> {
-                this.doSendPacket(packet, callback, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter // Paper - diff on change
+                this.doSendPacket(modifiedPacket, callback, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter // Paper - diff on change // Martijn - custom blocks and items
             });
             } // Paper
         }
@@ -558,6 +1083,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     private static int joinAttemptsThisTick; // Paper
     private static int currTick; // Paper
     public void tick() {
+        this.tickUpdatePotentialBlockEntitiesInSectionSpawnNew(); // Martijn - custom blocks and items
         this.flushQueue();
         // Paper start
         if (currTick != net.minecraft.server.MinecraftServer.currentTick) {
diff --git a/src/main/java/net/minecraft/network/FriendlyByteBuf.java b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
index 35377576ed182814051c11f902e02e8e921e84e3..52642ec2abf26b20fcfd353732326d26a39ef335 100644
--- a/src/main/java/net/minecraft/network/FriendlyByteBuf.java
+++ b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
@@ -60,6 +60,7 @@ import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.util.Crypt;
 import net.minecraft.util.CryptException;
 import net.minecraft.world.item.Item;
@@ -68,7 +69,10 @@ import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.Vec3;
+import nl.martijnmuijsers.paper.item.ItemReplacementRule;
+import nl.martijnmuijsers.paper.item.SuCraftItems;
 import org.bukkit.craftbukkit.inventory.CraftItemStack; // CraftBukkit
+import org.jetbrains.annotations.NotNull;
 
 public class FriendlyByteBuf extends ByteBuf {
 
@@ -83,6 +87,11 @@ public class FriendlyByteBuf extends ByteBuf {
     private static final int MAX_PUBLIC_KEY_HEADER_SIZE = 256;
     private static final int MAX_PUBLIC_KEY_LENGTH = 512;
 
+    // Martijn start - custom blocks and items
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack = null;
+    public @Nullable Boolean doesNetworkTargetHaveHighPing = null;
+    // Martijn end - custom blocks and items
+
     public FriendlyByteBuf(ByteBuf parent) {
         this.source = parent;
     }
@@ -513,6 +522,28 @@ public class FriendlyByteBuf extends ByteBuf {
         return this;
     }
 
+    // Martijn start - custom blocks and items
+
+    /**
+     * We may want to change the palette of chunk packets on the fly, but we can't do that if the palette values are already written to the buffer with a VarInt type (since then, if they are no longer the same length in bytes as a VarInt, we would have to move up all following data in the buffer)
+     * <br>
+     * Therefore, we introduce this method: it will write exactly 3 bytes (which is the minimum needed to encode all possible block states using a VarInt), but still in the VarInt format so that the client can read it properly
+     *
+     * @see #writeVarInt
+     */
+    public FriendlyByteBuf writeVarIntThreeBytes(int value) {
+        // First write two bytes
+        this.writeByte(value & 127 | 128);
+        value >>>= 7;
+        this.writeByte(value & 127 | 128);
+        value >>>= 7;
+        // Then write the last byte
+        this.writeByte(value);
+        return this;
+    }
+
+    // Martijn end - custom blocks and items
+
     public FriendlyByteBuf writeVarLong(long value) {
         while ((value & -128L) != 0L) {
             this.writeByte((int) (value & 127L) | 128);
@@ -566,12 +597,37 @@ public class FriendlyByteBuf extends ByteBuf {
     }
 
     public FriendlyByteBuf writeItem(ItemStack stack) {
+        // Martijn start - custom blocks and items
+        return this.writeItem(stack, false);
+    }
+
+    public FriendlyByteBuf writeItem(ItemStack stack, boolean isStonecutterRecipeResult) {
+        // Martijn end - custom blocks and items
         if (stack.isEmpty() || stack.getItem() == null) { // CraftBukkit - NPE fix itemstack.getItem()
             this.writeBoolean(false);
         } else {
             this.writeBoolean(true);
             Item item = stack.getItem();
 
+            // Martijn start - custom blocks and items
+            boolean tryRename = true;
+            if (item.replacementRule != null) {
+                @Nullable ItemStack replacedStack = item.replacementRule.replace(stack, doesNetworkTargetHaveResourcePack != null ? doesNetworkTargetHaveResourcePack : false, doesNetworkTargetHaveHighPing != null ? doesNetworkTargetHaveHighPing : false, isStonecutterRecipeResult);
+                if (replacedStack != null) {
+                    tryRename = false;
+                    stack = replacedStack;
+                    item = replacedStack.getItem();
+                }
+            }
+            if (tryRename && item.customDisplayName != null) {
+                @NotNull ItemStack replacedStack = stack.copy();
+                CompoundTag tag = replacedStack.getOrCreateTag();
+                ItemReplacementRule.SimpleItemReplacementRule.replaceItemStackDisplayName(replacedStack, tag, null, item.customDisplayNameJSON, item.customDisplayNameInLoreJSON);
+                ItemReplacementRule.storeOriginalItemInfoInItemStackNBT(replacedStack, tag, stack);
+                stack = replacedStack;
+            }
+            // Martijn end - custom blocks and items
+
             this.writeId(Registry.ITEM, item);
             this.writeByte(stack.getCount());
             CompoundTag nbttagcompound = null;
diff --git a/src/main/java/net/minecraft/network/PacketEncoder.java b/src/main/java/net/minecraft/network/PacketEncoder.java
index 5fce1177e7198d791d4ab1c64b394c5b1c145782..78bcdcb62d52ceaac6dd6b76b25d53630c79c6f1 100644
--- a/src/main/java/net/minecraft/network/PacketEncoder.java
+++ b/src/main/java/net/minecraft/network/PacketEncoder.java
@@ -38,6 +38,10 @@ public class PacketEncoder extends MessageToByteEncoder<Packet<?>> {
 
                 try {
                     int i = friendlyByteBuf.writerIndex();
+                    // Martijn start - custom blocks and items
+                    friendlyByteBuf.doesNetworkTargetHaveResourcePack = packet.doesNetworkTargetHaveResourcePack();
+                    friendlyByteBuf.doesNetworkTargetHaveHighPing = packet.doesNetworkTargetHaveHighPing();
+                    // Martijn end - custom blocks and items
                     packet.write(friendlyByteBuf);
                     int j = friendlyByteBuf.writerIndex() - i;
                     if (j > 8388608) {
diff --git a/src/main/java/net/minecraft/network/protocol/Packet.java b/src/main/java/net/minecraft/network/protocol/Packet.java
index e8fcd56906d26f6dc87959e32c4c7c78cfea9658..5fdb104e8df5539f13d05ba35c602c778f71331d 100644
--- a/src/main/java/net/minecraft/network/protocol/Packet.java
+++ b/src/main/java/net/minecraft/network/protocol/Packet.java
@@ -1,7 +1,13 @@
 package net.minecraft.network.protocol;
 
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
+import net.minecraft.network.Connection;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.PacketListener;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
 public interface Packet<T extends PacketListener> {
     void write(FriendlyByteBuf buf);
@@ -30,4 +36,33 @@ public interface Packet<T extends PacketListener> {
     default boolean isSkippable() {
         return false;
     }
+
+    // Martijn start - custom blocks and items
+
+    /**
+     * Replaces any custom blocks or items in this packet will their intended replacement, based
+     * on whether a player has accepted the resource pack.
+     *
+     * This will usually replace the custom content in-place, returning this instance itself. However, when there is
+     * a real risk of a single packet instance with custom content to be replaced being sent to multiple players with
+     * differing resource pack statuses, this method may return a different instance.
+     */
+    default @NotNull Packet<T> replaceCustomContent(boolean hasResourcePack, boolean hasHighPing) {
+        return this;
+    }
+
+    default @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return null;
+    }
+
+    default @Nullable Boolean doesNetworkTargetHaveHighPing() {
+        return null;
+    }
+
+    default <F extends Future<? super Void>> GenericFutureListener<F> updateCallbackWithBlockEntityPacketSends(@Nullable GenericFutureListener<F> callback, @NotNull Connection connection) {
+        return callback;
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockUpdatePacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockUpdatePacket.java
index 7b4947aa2cdd7f359184689bf348560bde1016dd..ee4b4d93c1814b327a8786829e1b3bcea4fccdfd 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockUpdatePacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockUpdatePacket.java
@@ -1,15 +1,24 @@
 package net.minecraft.network.protocol.game;
 
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
 import net.minecraft.core.BlockPos;
+import net.minecraft.network.Connection;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.state.BlockState;
+import nl.martijnmuijsers.paper.protocol.CachableCustomContentReplaceable;
+import nl.martijnmuijsers.paper.protocol.ReplacedCustomContentCache;
+import org.jetbrains.annotations.NotNull;
 
-public class ClientboundBlockUpdatePacket implements Packet<ClientGamePacketListener> {
+import javax.annotation.Nullable;
+import java.util.Arrays;
+
+public class ClientboundBlockUpdatePacket implements Packet<ClientGamePacketListener>, CachableCustomContentReplaceable<ClientboundBlockUpdatePacket> { // Martijn - custom blocks and items
     private final BlockPos pos;
-    public final BlockState blockState;
+    public BlockState blockState; // Martijn - custom blocks and items
 
     public ClientboundBlockUpdatePacket(BlockPos pos, BlockState state) {
         this.pos = pos;
@@ -43,4 +52,61 @@ public class ClientboundBlockUpdatePacket implements Packet<ClientGamePacketList
     public BlockPos getPos() {
         return this.pos;
     }
+
+    // Martijn start - custom blocks and items
+
+    private final ReplacedCustomContentCache<ClientboundBlockUpdatePacket> replacedCustomContentCache = new ReplacedCustomContentCache<>(this);
+
+    @Override
+    public @NotNull ClientboundBlockUpdatePacket replaceCustomContent(boolean hasResourcePack, boolean hasHighPing) {
+        return this.replacedCustomContentCache.get(hasResourcePack);
+    }
+
+    @Override
+    public @NotNull ClientboundBlockUpdatePacket copy() {
+        return new ClientboundBlockUpdatePacket(
+            this.pos,
+            this.blockState
+        );
+    }
+
+    @Override
+    public void replaceCustomContentInPlace(boolean hasResourcePack) {
+        var stateIdReplacementArray = hasResourcePack ? Block.stateIdReplacementArrayWithResourcePack : Block.stateIdReplacementArrayWithoutResourcePack;
+        int oldId = Block.BLOCK_STATE_REGISTRY.getId(this.blockState);
+        int newId = stateIdReplacementArray[oldId];
+        if (oldId != newId) {
+            this.blockState = Block.BLOCK_STATE_REGISTRY.byId(newId);
+        }
+    }
+
+    @Override
+    public <F extends Future<? super Void>> GenericFutureListener<F> updateCallbackWithBlockEntityPacketSends(@Nullable GenericFutureListener<F> callback, @NotNull Connection connection) {
+        return future -> {
+            if (callback != null) {
+                callback.operationComplete(future);
+            }
+            if (!future.isCancelled() && future.isSuccess() && connection.isConnected()) {
+                var level = connection.getPlayer().getLevel();
+                if (level != null) {
+                    for (int dx = -1; dx <= 1; dx++) {
+                        for (int dy = -1; dy <= 1; dy++) {
+                            for (int dz = -1; dz <= 1; dz++) {
+                                int nx = this.pos.getX() + dx;
+                                int ny = this.pos.getY() + dy;
+                                int nz = this.pos.getZ() + dz;
+                                BlockPos npos = new BlockPos(nx, ny, nz);
+                                if (level.isLoadedAndInBounds(npos)) {
+                                    connection.updatePotentialBlockEntityAtPosition(npos, false, null, true);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        };
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetContentPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetContentPacket.java
index dbd8b9b09b82c1b75e8be9dc7416d9f0863c8c87..ccf0485d73aeef0be2078adbafe75994d06bcda3 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetContentPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetContentPacket.java
@@ -5,12 +5,19 @@ import net.minecraft.core.NonNullList;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.item.ItemStack;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
 public class ClientboundContainerSetContentPacket implements Packet<ClientGamePacketListener> {
     private final int containerId;
     private final int stateId;
     private final List<ItemStack> items;
     private final ItemStack carriedItem;
+    // Martijn start - custom blocks and items
+    private @Nullable Boolean doesNetworkTargetHaveResourcePack = null;
+    private @Nullable Boolean doesNetworkTargetHaveHighPing = null;
+    // Martijn end - custom blocks and items
 
     public ClientboundContainerSetContentPacket(int syncId, int revision, NonNullList<ItemStack> contents, ItemStack cursorStack) {
         this.containerId = syncId;
@@ -69,4 +76,26 @@ public class ClientboundContainerSetContentPacket implements Packet<ClientGamePa
     public int getStateId() {
         return this.stateId;
     }
+
+    // Martijn start - custom blocks and items
+
+    @Override
+    public @NotNull ClientboundContainerSetContentPacket replaceCustomContent(boolean hasResourcePack, boolean hasHighPing) {
+        this.doesNetworkTargetHaveResourcePack = hasResourcePack;
+        this.doesNetworkTargetHaveHighPing = hasHighPing;
+        return this;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return this.doesNetworkTargetHaveResourcePack;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveHighPing() {
+        return this.doesNetworkTargetHaveHighPing;
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetSlotPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetSlotPacket.java
index 13ee7ad9c9415cd785b5487de7131c932c2198a0..0d5bfd1c6c10361059d281ab3f4b43c62d241b4c 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetSlotPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetSlotPacket.java
@@ -3,6 +3,9 @@ package net.minecraft.network.protocol.game;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.item.ItemStack;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
 public class ClientboundContainerSetSlotPacket implements Packet<ClientGamePacketListener> {
     public static final int CARRIED_ITEM = -1;
@@ -11,6 +14,10 @@ public class ClientboundContainerSetSlotPacket implements Packet<ClientGamePacke
     private final int stateId;
     private final int slot;
     private final ItemStack itemStack;
+    // Martijn start - custom blocks and items
+    private @Nullable Boolean doesNetworkTargetHaveResourcePack = null;
+    private @Nullable Boolean doesNetworkTargetHaveHighPing = null;
+    // Martijn end - custom blocks and items
 
     public ClientboundContainerSetSlotPacket(int syncId, int revision, int slot, ItemStack stack) {
         this.containerId = syncId;
@@ -54,4 +61,26 @@ public class ClientboundContainerSetSlotPacket implements Packet<ClientGamePacke
     public int getStateId() {
         return this.stateId;
     }
+
+    // Martijn start - custom blocks and items
+
+    @Override
+    public @NotNull ClientboundContainerSetSlotPacket replaceCustomContent(boolean hasResourcePack, boolean hasHighPing) {
+        this.doesNetworkTargetHaveResourcePack = hasResourcePack;
+        this.doesNetworkTargetHaveHighPing = hasHighPing;
+        return this;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return this.doesNetworkTargetHaveResourcePack;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveHighPing() {
+        return this.doesNetworkTargetHaveHighPing;
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundForgetLevelChunkPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundForgetLevelChunkPacket.java
index 578600a56f9461fbf3a6c1abf1d5aad614a93eb6..f6bbfbda350086176bf810bf71bbb3887d17bc33 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundForgetLevelChunkPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundForgetLevelChunkPacket.java
@@ -1,7 +1,15 @@
 package net.minecraft.network.protocol.game;
 
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
+import io.papermc.paper.util.CoordinateUtils;
+import net.minecraft.core.SectionPos;
+import net.minecraft.network.Connection;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.world.level.ChunkPos;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
 public class ClientboundForgetLevelChunkPacket implements Packet<ClientGamePacketListener> {
     private final int x;
@@ -35,4 +43,24 @@ public class ClientboundForgetLevelChunkPacket implements Packet<ClientGamePacke
     public int getZ() {
         return this.z;
     }
+
+    // Martijn start - custom blocks and items
+
+    @Override
+    public <F extends Future<? super Void>> GenericFutureListener<F> updateCallbackWithBlockEntityPacketSends(@Nullable GenericFutureListener<F> callback, @NotNull Connection connection) {
+        return future -> {
+            if (callback != null) {
+                callback.operationComplete(future);
+            }
+            if (!future.isCancelled() && future.isSuccess() && connection.isConnected()) {
+                ChunkPos chunkPos = new ChunkPos(x, z);
+                for (int y = connection.getPlayer().getLevel().getMinSection(); y <= connection.getPlayer().getLevel().getMaxSection(); y++) {
+                    connection.despawnBlockEntitiesInChunkSection(SectionPos.of(chunkPos, y).asLong());
+                }
+            }
+        };
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
index 6c30f3bf85ec0e0dfbae1b5ed192b43b1dbd48be..721840c7e1280be5cb79add9f0da76c424573975 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
@@ -191,4 +191,19 @@ public class ClientboundLevelChunkPacketData {
     public interface BlockEntityTagOutput {
         void accept(BlockPos pos, BlockEntityType<?> type, @Nullable CompoundTag nbt);
     }
+
+    // Martijn start - custom blocks and items
+
+//    /**
+//     * Replaces any custom blocks or items in this packet will their intended replacement, based
+//     * on whether a player has accepted the resource pack.
+//     *
+//     * The replacement is performed in-place.
+//     */
+//    default void replaceCustomContent(boolean hasResourcePack) {
+//
+//    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
index 2072aa8710f6e285f7c8f76c63b7bcf85cc11030..20b3c5a8d163db354acfc63072c2b680c56988ea 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
@@ -2,11 +2,21 @@ package net.minecraft.network.protocol.game;
 
 import java.util.BitSet;
 import javax.annotation.Nullable;
+
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
+import io.papermc.paper.util.CoordinateUtils;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.SectionPos;
+import net.minecraft.network.Connection;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.lighting.LevelLightEngine;
+import org.jetbrains.annotations.NotNull;
 
 public class ClientboundLevelChunkWithLightPacket implements Packet<ClientGamePacketListener> {
     private final int x;
@@ -27,9 +37,11 @@ public class ClientboundLevelChunkWithLightPacket implements Packet<ClientGamePa
     // Paper end
 
     // Paper start - Anti-Xray - Add chunk packet info
-    @Deprecated public ClientboundLevelChunkWithLightPacket(LevelChunk chunk, LevelLightEngine lightProvider, @Nullable BitSet skyBits, @Nullable BitSet blockBits, boolean nonEdge) { this(chunk, lightProvider, skyBits, blockBits, nonEdge, true); } // Notice for updates: Please make sure this constructor isn't used anywhere
-    public ClientboundLevelChunkWithLightPacket(LevelChunk chunk, LevelLightEngine lightProvider, @Nullable BitSet skyBits, @Nullable BitSet blockBits, boolean nonEdge, boolean modifyBlocks) {
-        com.destroystokyo.paper.antixray.ChunkPacketInfo<net.minecraft.world.level.block.state.BlockState> chunkPacketInfo = modifyBlocks ? chunk.getLevel().chunkPacketBlockController.getChunkPacketInfo(this, chunk) : null;
+    // Martijn start - custom blocks and items
+    @Deprecated public ClientboundLevelChunkWithLightPacket(LevelChunk chunk, LevelLightEngine lightProvider, @Nullable BitSet skyBits, @Nullable BitSet blockBits, boolean nonEdge, boolean doesPlayerHaveResourcePack) { this(chunk, lightProvider, skyBits, blockBits, nonEdge, true, doesPlayerHaveResourcePack); } // Notice for updates: Please make sure this constructor isn't used anywhere
+    public ClientboundLevelChunkWithLightPacket(LevelChunk chunk, LevelLightEngine lightProvider, @Nullable BitSet skyBits, @Nullable BitSet blockBits, boolean nonEdge, boolean modifyBlocks, boolean doesPlayerHaveResourcePack) {
+        com.destroystokyo.paper.antixray.ChunkPacketInfo<net.minecraft.world.level.block.state.BlockState> chunkPacketInfo = modifyBlocks ? chunk.getLevel().chunkPacketBlockController.getChunkPacketInfo(this, chunk, doesPlayerHaveResourcePack) : null;
+        // Martijn end - custom blocks and items
         ChunkPos chunkPos = chunk.getPos();
         this.x = chunkPos.x;
         this.z = chunkPos.z;
@@ -81,4 +93,51 @@ public class ClientboundLevelChunkWithLightPacket implements Packet<ClientGamePa
         return this.chunkData.getExtraPackets();
     }
     // Paper end
+
+    // Martijn start - custom blocks and items
+
+//    @Override
+//    public @NotNull ClientboundLevelChunkWithLightPacket replaceCustomContent(boolean hasResourcePack) {
+//        chunkData.replaceCustomContent(hasResourcePack);
+//        return this;
+//    }
+
+    @Override
+    public <F extends Future<? super Void>> GenericFutureListener<F> updateCallbackWithBlockEntityPacketSends(@Nullable GenericFutureListener<F> callback, @NotNull Connection connection) {
+        return future -> {
+            if (callback != null) {
+                callback.operationComplete(future);
+            }
+            if (!future.isCancelled() && future.isSuccess() && connection.isConnected()) {
+                try {
+                    @Nullable LevelChunk chunk = connection.getPlayer().getLevel().getChunkIfLoaded(this.x, this.z);
+                    if (chunk != null) {
+                        int sectionsCount = chunk.getSectionsCount();
+//                        int chunkMinBlockX = chunk.getPos().getMinBlockX();
+//                        int chunkMinBlockZ = chunk.getPos().getMinBlockZ();
+                        for (int sectionYIndex = 0; sectionYIndex < sectionsCount; sectionYIndex++) {
+                            SectionPos sectionPos = SectionPos.of(this.x, chunk.getSectionYFromSectionIndex(sectionYIndex), this.z);
+                            connection.updatePotentialBlockEntitiesInSection(sectionPos, false, chunk);
+//                            var section = chunk.getSection(sectionYIndex);
+//                            var sectionKey = CoordinateUtils.getChunkSectionKey();
+//                            @Nullable LongSet sectionSentBlockKeys = connection.getBlockEntityBlockPosKeysForChunkSectionKey(sectionKey);
+//                            if (section.potentiallyContainsBlockEntity()) {
+//                                var sectionMinBlockY = section.bottomBlockY();
+//                                for (int xInSection = 0; xInSection < 16; xInSection++) {
+//                                    for (int yInSection = 0; yInSection < 16; yInSection++) {
+//                                        for (int zInSection = 0; zInSection < 16; zInSection++) {
+//                                            connection.updatePotentialBlockEntityAtPosition(new BlockPos(xInSection + chunkMinBlockX, yInSection + sectionMinBlockY, zInSection + chunkMinBlockZ), true, sectionSentBlockKeys);
+//                                        }
+//                                    }
+//                                }
+//                            }
+                        }
+                    }
+                } catch (Exception ignored) {}
+            }
+        };
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundMerchantOffersPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundMerchantOffersPacket.java
index dc31aa80ead5765e0b8cc63aa890966ab0bf94a4..d79da37b82063505ecd2dda57a728a4fc8aa284f 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundMerchantOffersPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundMerchantOffersPacket.java
@@ -3,6 +3,9 @@ package net.minecraft.network.protocol.game;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.item.trading.MerchantOffers;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
 public class ClientboundMerchantOffersPacket implements Packet<ClientGamePacketListener> {
     private final int containerId;
@@ -11,6 +14,10 @@ public class ClientboundMerchantOffersPacket implements Packet<ClientGamePacketL
     private final int villagerXp;
     private final boolean showProgress;
     private final boolean canRestock;
+    // Martijn start - custom blocks and items
+    private @Nullable Boolean doesNetworkTargetHaveResourcePack = null;
+    private @Nullable Boolean doesNetworkTargetHaveHighPing = null;
+    // Martijn end - custom blocks and items
 
     public ClientboundMerchantOffersPacket(int syncId, MerchantOffers recipes, int levelProgress, int experience, boolean leveled, boolean refreshable) {
         this.containerId = syncId;
@@ -68,4 +75,26 @@ public class ClientboundMerchantOffersPacket implements Packet<ClientGamePacketL
     public boolean canRestock() {
         return this.canRestock;
     }
+
+    // Martijn start - custom blocks and items
+
+    @Override
+    public @NotNull ClientboundMerchantOffersPacket replaceCustomContent(boolean hasResourcePack, boolean hasHighPing) {
+        this.doesNetworkTargetHaveResourcePack = hasResourcePack;
+        this.doesNetworkTargetHaveHighPing = hasHighPing;
+        return this;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return this.doesNetworkTargetHaveResourcePack;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveHighPing() {
+        return this.doesNetworkTargetHaveHighPing;
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
index 652bea6868a03a5315965f79c76172fb9dbb93fb..3decb05ab0a4eb8ada98ad8dc852b7278fd910e7 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
@@ -1,17 +1,32 @@
 package net.minecraft.network.protocol.game;
 
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
+import io.papermc.paper.util.CoordinateUtils;
+import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.shorts.ShortIterator;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
+
+import java.util.Arrays;
 import java.util.function.BiConsumer;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
+import net.minecraft.network.Connection;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.chunk.LevelChunkSection;
+import nl.martijnmuijsers.paper.protocol.CachableCustomContentReplaceable;
+import nl.martijnmuijsers.paper.protocol.ReplacedCustomContentCache;
+import org.bukkit.Chunk;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
-public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePacketListener> {
+public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePacketListener>, CachableCustomContentReplaceable<ClientboundSectionBlocksUpdatePacket> { // Martijn - custom blocks and items
 
     private static final int POS_IN_SECTION_BITS = 12;
     private final SectionPos sectionPos;
@@ -19,6 +34,17 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
     private final BlockState[] states;
     private final boolean suppressLightUpdates;
 
+    // Martijn start - custom blocks and items
+
+    public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, short[] positions, BlockState[] states, boolean suppressLightUpdates) {
+        this.sectionPos = sectionPos;
+        this.positions = positions;
+        this.states = states;
+        this.suppressLightUpdates = suppressLightUpdates;
+    }
+
+    // Martijn end - custom blocks and items
+
     public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, ShortSet positions, LevelChunkSection section, boolean noLightingUpdates) {
         this.sectionPos = sectionPos;
         this.suppressLightUpdates = noLightingUpdates;
@@ -94,4 +120,50 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
     public boolean shouldSuppressLightUpdates() {
         return this.suppressLightUpdates;
     }
+
+    // Martijn start - custom blocks and items
+
+    private final ReplacedCustomContentCache<ClientboundSectionBlocksUpdatePacket> replacedCustomContentCache = new ReplacedCustomContentCache<>(this);
+
+    @Override
+    public @NotNull ClientboundSectionBlocksUpdatePacket replaceCustomContent(boolean hasResourcePack, boolean hasHighPing) {
+       return this.replacedCustomContentCache.get(hasResourcePack);
+    }
+
+    @Override
+    public @NotNull ClientboundSectionBlocksUpdatePacket copy() {
+        return new ClientboundSectionBlocksUpdatePacket(
+            this.sectionPos,
+            this.positions,
+            Arrays.copyOf(this.states, this.states.length),
+            this.suppressLightUpdates
+        );
+    }
+
+    @Override
+    public void replaceCustomContentInPlace(boolean hasResourcePack) {
+        var stateIdReplacementArray = hasResourcePack ? Block.stateIdReplacementArrayWithResourcePack : Block.stateIdReplacementArrayWithoutResourcePack;
+        for (int i = 0; i < this.states.length; i++) {
+            int oldId = Block.BLOCK_STATE_REGISTRY.getId(states[i]);
+            int newId = stateIdReplacementArray[oldId];
+            if (oldId != newId) {
+                this.states[i] = Block.BLOCK_STATE_REGISTRY.byId(newId);
+            }
+        }
+    }
+
+    @Override
+    public <F extends Future<? super Void>> GenericFutureListener<F> updateCallbackWithBlockEntityPacketSends(@Nullable GenericFutureListener<F> callback, @NotNull Connection connection) {
+        return future -> {
+            if (callback != null) {
+                callback.operationComplete(future);
+            }
+            if (!future.isCancelled() && future.isSuccess() && connection.isConnected()) {
+                connection.updatePotentialBlockEntitiesInSection(this.sectionPos, true, null);
+            }
+        };
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityDataPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityDataPacket.java
index 3e17f6131bf590d7c4a16b79c1c145cb4f565bc9..5aef3b156d56615427a469c4ba3b2f59148a7bfd 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityDataPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityDataPacket.java
@@ -1,15 +1,21 @@
 package net.minecraft.network.protocol.game;
 
+import java.util.ArrayList;
 import java.util.List;
 import javax.annotation.Nullable;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.syncher.SynchedEntityData;
+import org.jetbrains.annotations.NotNull;
 
 public class ClientboundSetEntityDataPacket implements Packet<ClientGamePacketListener> {
     private final int id;
     @Nullable
     private final List<SynchedEntityData.DataItem<?>> packedItems;
+    // Martijn start - custom blocks and items
+    private @Nullable Boolean doesNetworkTargetHaveResourcePack = null;
+    private @Nullable Boolean doesNetworkTargetHaveHighPing = null;
+    // Martijn end - custom blocks and items
 
     public ClientboundSetEntityDataPacket(int id, SynchedEntityData tracker, boolean forceUpdateAll) {
         this.id = id;
@@ -22,6 +28,15 @@ public class ClientboundSetEntityDataPacket implements Packet<ClientGamePacketLi
 
     }
 
+    // Martijn start - custom blocks and items
+
+    public ClientboundSetEntityDataPacket(int id) {
+        this.id = id;
+        this.packedItems = new ArrayList<>();
+    }
+
+    // Martijn end - custom blocks and items
+
     public ClientboundSetEntityDataPacket(FriendlyByteBuf buf) {
         this.id = buf.readVarInt();
         this.packedItems = SynchedEntityData.unpack(buf);
@@ -46,4 +61,26 @@ public class ClientboundSetEntityDataPacket implements Packet<ClientGamePacketLi
     public int getId() {
         return this.id;
     }
+
+    // Martijn start - custom blocks and items
+
+    @Override
+    public @NotNull ClientboundSetEntityDataPacket replaceCustomContent(boolean hasResourcePack, boolean hasHighPing) {
+        this.doesNetworkTargetHaveResourcePack = hasResourcePack;
+        this.doesNetworkTargetHaveHighPing = hasHighPing;
+        return this;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return this.doesNetworkTargetHaveResourcePack;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveHighPing() {
+        return this.doesNetworkTargetHaveHighPing;
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEquipmentPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEquipmentPacket.java
index 5a8f850b447fc3a4bd0eb0c505bbdfc8be7115e8..cda0879d6a2eaae947d0411cc5e9f758d7a1c97d 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEquipmentPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEquipmentPacket.java
@@ -7,11 +7,18 @@ import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.entity.EquipmentSlot;
 import net.minecraft.world.item.ItemStack;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
 public class ClientboundSetEquipmentPacket implements Packet<ClientGamePacketListener> {
     private static final byte CONTINUE_MASK = -128;
     private final int entity;
     private final List<Pair<EquipmentSlot, ItemStack>> slots;
+    // Martijn start - custom blocks and items
+    private @Nullable Boolean doesNetworkTargetHaveResourcePack = null;
+    private @Nullable Boolean doesNetworkTargetHaveHighPing = null;
+    // Martijn end - custom blocks and items
 
     public ClientboundSetEquipmentPacket(int id, List<Pair<EquipmentSlot, ItemStack>> equipmentList) {
         this.entity = id;
@@ -61,4 +68,26 @@ public class ClientboundSetEquipmentPacket implements Packet<ClientGamePacketLis
     public List<Pair<EquipmentSlot, ItemStack>> getSlots() {
         return this.slots;
     }
+
+    // Martijn start - custom blocks and items
+
+    @Override
+    public @NotNull ClientboundSetEquipmentPacket replaceCustomContent(boolean hasResourcePack, boolean hasHighPing) {
+        this.doesNetworkTargetHaveResourcePack = hasResourcePack;
+        this.doesNetworkTargetHaveHighPing = hasHighPing;
+        return this;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return this.doesNetworkTargetHaveResourcePack;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveHighPing() {
+        return this.doesNetworkTargetHaveHighPing;
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateAdvancementsPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateAdvancementsPacket.java
index 053a66d714168f5e8a7cc5ff532190e80de887ca..42e6324a53a1168f3bc0012d901621c085104432 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateAdvancementsPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateAdvancementsPacket.java
@@ -11,12 +11,19 @@ import net.minecraft.advancements.AdvancementProgress;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.resources.ResourceLocation;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
 public class ClientboundUpdateAdvancementsPacket implements Packet<ClientGamePacketListener> {
     private final boolean reset;
     private final Map<ResourceLocation, Advancement.Builder> added;
     private final Set<ResourceLocation> removed;
     private final Map<ResourceLocation, AdvancementProgress> progress;
+    // Martijn start - custom blocks and items
+    private @Nullable Boolean doesNetworkTargetHaveResourcePack = null;
+    private @Nullable Boolean doesNetworkTargetHaveHighPing = null;
+    // Martijn end - custom blocks and items
 
     public ClientboundUpdateAdvancementsPacket(boolean clearCurrent, Collection<Advancement> toEarn, Set<ResourceLocation> toRemove, Map<ResourceLocation, AdvancementProgress> toSetProgress) {
         this.reset = clearCurrent;
@@ -70,4 +77,26 @@ public class ClientboundUpdateAdvancementsPacket implements Packet<ClientGamePac
     public boolean shouldReset() {
         return this.reset;
     }
+
+    // Martijn start - custom blocks and items
+
+    @Override
+    public @NotNull ClientboundUpdateAdvancementsPacket replaceCustomContent(boolean hasResourcePack, boolean hasHighPing) {
+        this.doesNetworkTargetHaveResourcePack = hasResourcePack;
+        this.doesNetworkTargetHaveHighPing = hasHighPing;
+        return this;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return this.doesNetworkTargetHaveResourcePack;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveHighPing() {
+        return this.doesNetworkTargetHaveHighPing;
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateRecipesPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateRecipesPacket.java
index 07d96cca04c9658291eea91e7b0a7f5a3fc9882e..31104e2195dd79dca0f223bcec1deb88de09ca15 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateRecipesPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateRecipesPacket.java
@@ -8,9 +8,17 @@ import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.world.item.crafting.Recipe;
+import net.minecraft.world.item.crafting.RecipeSerializer;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
 public class ClientboundUpdateRecipesPacket implements Packet<ClientGamePacketListener> {
     private final List<Recipe<?>> recipes;
+    // Martijn start - custom blocks and items
+    private @Nullable Boolean doesNetworkTargetHaveResourcePack = null;
+    private @Nullable Boolean doesNetworkTargetHaveHighPing = null;
+    // Martijn end - custom blocks and items
 
     public ClientboundUpdateRecipesPacket(Collection<Recipe<?>> recipes) {
         this.recipes = Lists.newArrayList(recipes);
@@ -45,6 +53,28 @@ public class ClientboundUpdateRecipesPacket implements Packet<ClientGamePacketLi
     public static <T extends Recipe<?>> void toNetwork(FriendlyByteBuf buf, T recipe) {
         buf.writeResourceLocation(Registry.RECIPE_SERIALIZER.getKey(recipe.getSerializer()));
         buf.writeResourceLocation(recipe.getId());
-        recipe.getSerializer().toNetwork(buf, recipe);
+        ((RecipeSerializer<T>) recipe.getSerializer()).toNetwork(buf, recipe);
     }
+
+    // Martijn start - custom blocks and items
+
+    @Override
+    public @NotNull ClientboundUpdateRecipesPacket replaceCustomContent(boolean hasResourcePack, boolean hasHighPing) {
+        this.doesNetworkTargetHaveResourcePack = hasResourcePack;
+        this.doesNetworkTargetHaveHighPing = hasHighPing;
+        return this;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return this.doesNetworkTargetHaveResourcePack;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveHighPing() {
+        return this.doesNetworkTargetHaveHighPing;
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/resources/ResourceKey.java b/src/main/java/net/minecraft/resources/ResourceKey.java
index b8cd7177d82c08604bc3654cc2098e78484551d2..092f99ab1f169932f8bfe8a629a131fb97438a58 100644
--- a/src/main/java/net/minecraft/resources/ResourceKey.java
+++ b/src/main/java/net/minecraft/resources/ResourceKey.java
@@ -6,6 +6,8 @@ import java.util.Collections;
 import java.util.Map;
 import java.util.Optional;
 import net.minecraft.core.Registry;
+import org.bukkit.NamespacedKey;
+import org.jetbrains.annotations.NotNull;
 
 public class ResourceKey<T> {
 
@@ -56,6 +58,14 @@ public class ResourceKey<T> {
         return this.location;
     }
 
+    // Martijn start - custom resources
+
+    public @NotNull NamespacedKey asBukkit() {
+        return location().asBukkit();
+    }
+
+    // Martijn end - custom resources
+
     public ResourceLocation registry() {
         return this.registryName;
     }
diff --git a/src/main/java/net/minecraft/resources/ResourceLocation.java b/src/main/java/net/minecraft/resources/ResourceLocation.java
index bb92ba63e91a637b18154a154672acc413acf5ca..8a353de5309ca6496332cdd1559a3c14c06d0ee6 100644
--- a/src/main/java/net/minecraft/resources/ResourceLocation.java
+++ b/src/main/java/net/minecraft/resources/ResourceLocation.java
@@ -17,7 +17,10 @@ import javax.annotation.Nullable;
 import net.minecraft.ResourceLocationException;
 import net.minecraft.network.chat.Component;
 import net.minecraft.util.GsonHelper;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
 import org.apache.commons.lang3.StringUtils;
+import org.bukkit.NamespacedKey;
+import org.jetbrains.annotations.NotNull;
 
 public class ResourceLocation implements Comparable<ResourceLocation> {
     public static final Codec<ResourceLocation> CODEC = Codec.STRING.comapFlatMap(ResourceLocation::read, ResourceLocation::toString).stable();
@@ -53,6 +56,18 @@ public class ResourceLocation implements Comparable<ResourceLocation> {
         return new ResourceLocation(SUCRAFT_NAMESPACE, id);
     }
 
+    public @NotNull NamespacedKey asBukkit() {
+        return new NamespacedKey(this.namespace, this.path);
+    }
+
+    public @NotNull ResourceLocation withPathSuffix(@NotNull String suffix) {
+        return new ResourceLocation(namespace, this.path + suffix);
+    }
+
+    public @NotNull ResourceLocation withPathPrefix(@NotNull String prefix) {
+        return new ResourceLocation(namespace, prefix + this.path);
+    }
+
     // Martijn end - custom resources
 
     public static ResourceLocation of(String id, char delimiter) {
diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index 5aaeb05cf3f3a86530e929499dfb98a659c714b7..9b01d7633b07ef0f4636abcafb889957ee449f1e 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -59,6 +59,7 @@ import net.minecraft.world.level.storage.LevelStorageSource;
 import net.minecraft.world.level.storage.LevelSummary;
 import nl.martijnmuijsers.paper.biome.SuCraftBiomeTagsProvider;
 import nl.martijnmuijsers.paper.data.BlackHoleCachedOutput;
+import nl.martijnmuijsers.paper.resourcepack.httpserver.ResourcePackHTTPServer;
 import nl.martijnmuijsers.paper.structure.SuCraftStructureTagsProvider;
 import org.slf4j.Logger;
 
@@ -287,6 +288,7 @@ public class Main {
 
                 return dedicatedserver1;
             });
+
             /* CraftBukkit start
             Thread thread = new Thread("Server Shutdown Thread") {
                 public void run() {
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 1d452417c83f4a4053faf3bb6b86d357a6403203..1a0721e864bb7e0c92df4e9e63c8161a007df365 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -96,6 +96,7 @@ import net.minecraft.server.players.GameProfileCache;
 import net.minecraft.server.players.PlayerList;
 import net.minecraft.server.players.ServerOpListEntry;
 import net.minecraft.server.players.UserWhiteList;
+import net.minecraft.tags.BlockTags;
 import net.minecraft.util.Crypt;
 import net.minecraft.util.CryptException;
 import net.minecraft.util.FrameTimer;
@@ -136,6 +137,7 @@ import net.minecraft.world.level.GameType;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelSettings;
 import net.minecraft.world.level.biome.BiomeManager;
+import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.border.WorldBorder;
 import net.minecraft.world.level.dimension.LevelStem;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
@@ -153,7 +155,10 @@ import net.minecraft.world.level.storage.loot.LootTables;
 import net.minecraft.world.level.storage.loot.PredicateManager;
 import net.minecraft.world.phys.Vec2;
 import net.minecraft.world.phys.Vec3;
+import nl.martijnmuijsers.paper.block.SuCraftBlocks;
+import nl.martijnmuijsers.paper.item.SuCraftCraftingRecipeProvider;
 import org.apache.commons.lang3.Validate;
+import org.bukkit.Material;
 import org.slf4j.Logger;
 
 // CraftBukkit start
diff --git a/src/main/java/net/minecraft/server/PlayerAdvancements.java b/src/main/java/net/minecraft/server/PlayerAdvancements.java
index de0513b38e5fa0138f1cee6bb633561be12449fc..cc4f0e64ca476435aed1e8b5dcf5300014fabdcb 100644
--- a/src/main/java/net/minecraft/server/PlayerAdvancements.java
+++ b/src/main/java/net/minecraft/server/PlayerAdvancements.java
@@ -63,7 +63,7 @@ public class PlayerAdvancements {
     private final File file;
     public final Map<Advancement, AdvancementProgress> advancements = Maps.newLinkedHashMap();
     private final Set<Advancement> visible = Sets.newLinkedHashSet();
-    private final Set<Advancement> visibilityChanged = Sets.newLinkedHashSet();
+    public final Set<Advancement> visibilityChanged = Sets.newLinkedHashSet(); // Martijn - custom blocks and items // We use this to mark advancements as dirty to resend them when the resource pack status changes
     private final Set<Advancement> progressChanged = Sets.newLinkedHashSet();
     private ServerPlayer player;
     @Nullable
diff --git a/src/main/java/net/minecraft/server/commands/GiveCommand.java b/src/main/java/net/minecraft/server/commands/GiveCommand.java
index 06e3a868e922f1b7a586d0ca28f64a67ae463b68..0feab0105d15be1847d0064aeb1186ed8a2b117a 100644
--- a/src/main/java/net/minecraft/server/commands/GiveCommand.java
+++ b/src/main/java/net/minecraft/server/commands/GiveCommand.java
@@ -2,6 +2,7 @@ package net.minecraft.server.commands;
 
 import com.mojang.brigadier.CommandDispatcher;
 import com.mojang.brigadier.arguments.IntegerArgumentType;
+import com.mojang.brigadier.builder.ArgumentBuilder;
 import com.mojang.brigadier.builder.LiteralArgumentBuilder;
 import com.mojang.brigadier.builder.RequiredArgumentBuilder;
 import com.mojang.brigadier.exceptions.CommandSyntaxException;
@@ -10,6 +11,7 @@ import java.util.Iterator;
 import net.minecraft.commands.CommandBuildContext;
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.commands.arguments.ResourceLocationArgument;
 import net.minecraft.commands.arguments.item.ItemArgument;
 import net.minecraft.commands.arguments.item.ItemInput;
 import net.minecraft.network.chat.Component;
@@ -19,6 +21,7 @@ import net.minecraft.sounds.SoundSource;
 import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
+import nl.martijnmuijsers.paper.command.CustomItemArgument;
 
 public class GiveCommand {
 
@@ -26,16 +29,31 @@ public class GiveCommand {
 
     public GiveCommand() {}
 
+    // Martijn start - custom blocks and items
+
+    @SuppressWarnings("unchecked")
     public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext commandRegistryAccess) {
-        dispatcher.register((LiteralArgumentBuilder) ((LiteralArgumentBuilder) net.minecraft.commands.Commands.literal("give").requires((commandlistenerwrapper) -> {
+        // This is not working, stopped working on this while in progress
+        var targetsArgument =
+            net.minecraft.commands.Commands.argument("targets", EntityArgument.players())
+                .then(((RequiredArgumentBuilder) net.minecraft.commands.Commands.argument("item", ItemArgument.item(commandRegistryAccess)).executes((commandcontext) -> {
+                    return GiveCommand.giveItem((CommandSourceStack) commandcontext.getSource(), ItemArgument.getItem(commandcontext, "item"), EntityArgument.getPlayers(commandcontext, "targets"), 1);
+                })).then(net.minecraft.commands.Commands.argument("count", IntegerArgumentType.integer(1)).executes((commandcontext) -> {
+                    return GiveCommand.giveItem((CommandSourceStack) commandcontext.getSource(), ItemArgument.getItem(commandcontext, "item"), EntityArgument.getPlayers(commandcontext, "targets"), IntegerArgumentType.getInteger(commandcontext, "count"));
+                })))
+                .then(((RequiredArgumentBuilder) net.minecraft.commands.Commands.argument("sucraft item", ResourceLocationArgument.id())).executes((commandcontext) -> {
+                    return GiveCommand.giveItem((CommandSourceStack) commandcontext.getSource(), CustomItemArgument.getItem(commandcontext, "sucraft item"), EntityArgument.getPlayers(commandcontext, "targets"), 1);
+                }).then(net.minecraft.commands.Commands.argument("count", IntegerArgumentType.integer(1)).executes((commandcontext) -> {
+                    return GiveCommand.giveItem((CommandSourceStack) commandcontext.getSource(), CustomItemArgument.getItem(commandcontext, "sucraft item"), EntityArgument.getPlayers(commandcontext, "targets"), IntegerArgumentType.getInteger(commandcontext, "count"));
+                })));
+        var giveCommand = (LiteralArgumentBuilder) net.minecraft.commands.Commands.literal("give").requires((commandlistenerwrapper) -> {
             return commandlistenerwrapper.hasPermission(2);
-        })).then(net.minecraft.commands.Commands.argument("targets", EntityArgument.players()).then(((RequiredArgumentBuilder) net.minecraft.commands.Commands.argument("item", ItemArgument.item(commandRegistryAccess)).executes((commandcontext) -> {
-            return GiveCommand.giveItem((CommandSourceStack) commandcontext.getSource(), ItemArgument.getItem(commandcontext, "item"), EntityArgument.getPlayers(commandcontext, "targets"), 1);
-        })).then(net.minecraft.commands.Commands.argument("count", IntegerArgumentType.integer(1)).executes((commandcontext) -> {
-            return GiveCommand.giveItem((CommandSourceStack) commandcontext.getSource(), ItemArgument.getItem(commandcontext, "item"), EntityArgument.getPlayers(commandcontext, "targets"), IntegerArgumentType.getInteger(commandcontext, "count"));
-        })))));
+        }).then(targetsArgument);
+        dispatcher.register(giveCommand);
     }
 
+    // Martijn end - custom blocks and items
+
     private static int giveItem(CommandSourceStack source, ItemInput item, Collection<ServerPlayer> targets, int count) throws CommandSyntaxException {
         int j = item.getItem().getMaxStackSize();
         int k = j * 100;
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index 5d6ceeecfbb55a1bfe77a1f1ac39b02993e714e3..dc3150370198220b54af06979cbbf45c461886c5 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -13,11 +13,16 @@ import java.net.Proxy;
 import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
+import java.util.ArrayList;
 import java.util.Collections;
+import java.util.Comparator;
+import java.util.IdentityHashMap;
 import java.util.List;
 import java.util.Locale;
+import java.util.Map;
 import java.util.Optional;
 import java.util.function.BooleanSupplier;
+import java.util.stream.StreamSupport;
 import javax.annotation.Nullable;
 import net.minecraft.DefaultUncaughtExceptionHandler;
 import net.minecraft.DefaultUncaughtExceptionHandlerWithName;
@@ -27,6 +32,7 @@ import net.minecraft.Util;
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.NonNullList;
+import net.minecraft.core.Registry;
 import net.minecraft.nbt.Tag;
 import net.minecraft.server.ConsoleInput;
 import net.minecraft.server.MinecraftServer;
@@ -49,12 +55,19 @@ import net.minecraft.util.Mth;
 import net.minecraft.util.monitoring.jmx.MinecraftServerStatistics;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.CreativeModeTab;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
+import net.minecraft.world.item.crafting.RecipeType;
 import net.minecraft.world.level.DataPackConfig;
 import net.minecraft.world.level.GameRules;
 import net.minecraft.world.level.GameType;
 import net.minecraft.world.level.block.entity.SkullBlockEntity;
 import net.minecraft.world.level.storage.LevelStorageSource;
+import nl.martijnmuijsers.paper.item.ItemReplacementRule;
+import nl.martijnmuijsers.paper.item.SuCraftCraftingRecipeProvider;
+import nl.martijnmuijsers.paper.resourcepack.httpserver.ResourcePackHTTPServer;
+import nl.martijnmuijsers.paper.resourcepack.sucraft.CreateSuCraftResourcePack;
 import org.slf4j.Logger;
 
 // CraftBukkit start
@@ -275,6 +288,58 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
             return false;
         }
 
+        // Martijn start - custom blocks and items
+
+        SuCraftCraftingRecipeProvider.run();
+
+        // Now that we have all the recipes added, we should set some stonecutter hosts for those items that require it
+        Map<Item, List<Item>> ingredientToResult = new IdentityHashMap<>();
+        Map<Item, List<Item>> resultToIngredient = new IdentityHashMap<>();
+        MinecraftServer.getServer().getRecipeManager().getAllRecipesFor(RecipeType.STONECUTTING).forEach(recipe -> {
+            recipe.getIngredients().forEach(ingredient -> {
+                if (ingredient.getItems() != null) {
+                    for (ItemStack itemStack : ingredient.getItems()) {
+                        ingredientToResult.computeIfAbsent(itemStack.getItem(), $ -> new ArrayList<>(1)).add(recipe.getResultItem().getItem());
+                        resultToIngredient.computeIfAbsent(recipe.getResultItem().getItem(), $ -> new ArrayList<>(1)).add(itemStack.getItem());
+                    }
+                }
+            });
+        });
+        Map<Item, Integer> ingredientToIngredientGroupIndex = new IdentityHashMap<>();
+        int nextGroupIndex = 0;
+        for (Map.Entry<Item, List<Item>> resultToIngredientEntry : resultToIngredient.entrySet()) {
+            final int finalNextGroupIndex = nextGroupIndex;
+            for (Item ingredient : resultToIngredientEntry.getValue()) {
+                Integer existingGroupIndex = ingredientToIngredientGroupIndex.get(ingredient);
+                if (existingGroupIndex != null) {
+                    ingredientToIngredientGroupIndex.replaceAll((item, index) -> index.equals(existingGroupIndex) ? finalNextGroupIndex : index);
+                } else {
+                    ingredientToIngredientGroupIndex.put(ingredient, nextGroupIndex);
+                }
+            }
+            nextGroupIndex++;
+        }
+        ingredientToIngredientGroupIndex.values().stream().toList().stream().map(index -> ingredientToIngredientGroupIndex.entrySet().stream().filter(entry -> entry.getValue() == index).map(entry -> entry.getKey()).toList()).forEach(groupIngredients -> {
+            var groupResults = groupIngredients.stream().flatMap(ingredient -> ingredientToResult.get(ingredient).stream()).distinct().toList();
+//            System.out.println("TEMP DEBUG - group results: " + groupResults);
+            List<Item> potentialHosts = StreamSupport.stream(Registry.ITEM.spliterator(), false).filter(item -> item.isVanilla && Registry.BLOCK.containsKey(item.id) && !groupResults.contains(item)).sorted(Comparator.comparing(item -> item.getDescriptionId())).toList();
+            var customGroupResults = groupResults.stream().filter(result -> !result.isVanilla).toList();
+            for (int i = 0; i < customGroupResults.size(); i++) {
+                var replacementRule = customGroupResults.get(i).replacementRule;
+                replacementRule.setStonecutterRecipeHost(potentialHosts.get(potentialHosts.size() - customGroupResults.size() + i));
+            }
+        });
+
+        // This is a reasonable time to create the resource pack
+        CreateSuCraftResourcePack.createAndWrite();
+        // Start the HTTP server that serves the resource pack
+        ResourcePackHTTPServer.getInstance().startIfNotStarted();
+
+        // Update the server properties in memory to match the resource pack and HTTP server
+        ResourcePackHTTPServer.getInstance().updateServerPropertiesInMemory(false);
+
+        // Martijn end - custom blocks and items
+
         // CraftBukkit start
         // this.setPlayerList(new DedicatedPlayerList(this, this.registryHolder, this.playerDataStorage)); // Spigot - moved up
         server.loadPlugins();
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 94a96e5f85334b46261e2960ca2fec6c8c4bdd43..f8d72c63974ceb7d886c9077a4d35f077acaf040 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -59,6 +59,7 @@ import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
 import net.minecraft.Util;
+import net.minecraft.core.BlockPos;
 import net.minecraft.core.Registry;
 import net.minecraft.core.SectionPos;
 import net.minecraft.nbt.CompoundTag;
@@ -105,11 +106,12 @@ import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemp
 import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelStorageSource;
 import it.unimi.dsi.fastutil.objects.ObjectRBTreeSet; // Paper
+import nl.martijnmuijsers.paper.blockanditemdata.model.BlockEntityModelProximity;
 import org.apache.commons.lang3.mutable.MutableBoolean;
 import org.apache.commons.lang3.mutable.MutableObject;
+import org.apache.commons.lang3.tuple.ImmutablePair;
 import org.slf4j.Logger;
 import org.bukkit.craftbukkit.generator.CustomChunkGenerator;
-import org.bukkit.entity.Player;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
 
@@ -1699,7 +1701,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
     // Paper end - replace player loader system
 
-    public void updateChunkTracking(ServerPlayer player, ChunkPos pos, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> packet, boolean oldWithinViewDistance, boolean newWithinViewDistance, boolean concernsTracking) { // Paper - Anti-Xray - Bypass // Paper - public // Martijn - per-player track and see view distance
+    public void updateChunkTracking(ServerPlayer player, ChunkPos pos, MutableObject<java.util.Map<ImmutablePair<Boolean, Boolean>, ClientboundLevelChunkWithLightPacket>> packet, boolean oldWithinViewDistance, boolean newWithinViewDistance, boolean concernsTracking) { // Paper - Anti-Xray - Bypass // Paper - public // Martijn - per-player track and see view distance // Martijn - custom blocks and items
         if (player.level == this.level) {
             if (newWithinViewDistance && !oldWithinViewDistance) {
                 ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos.toLong());
@@ -2007,6 +2009,66 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         int j = SectionPos.blockToSectionCoord(player.getBlockZ());
         SectionPos sectionposition = player.getLastSectionPos();
         SectionPos sectionposition1 = SectionPos.of((EntityAccess) player);
+        // Martijn start - custom blocks and items
+        BlockPos newBlockPos = player.blockPosition;
+        var connection = player.connection;
+        if (connection != null) {
+            if (!connection.isDisconnected()) {
+                var connection2 = connection.connection;
+                if (connection2 != null && connection2.isConnected()) {
+                    if (!sectionposition.equals(sectionposition1) || !connection2.hasUpdatedBlockEntitiesClosebyModelForSections) {
+                        connection2.hasUpdatedBlockEntitiesClosebyModelForSections = true;
+                        LongSet fromAndToSectionsAndChessboardNeighbors = new LongOpenHashSet((BlockEntityModelProximity.maxSectionDistanceForNeighbors * 2 + 1) * (BlockEntityModelProximity.maxSectionDistanceForNeighbors * 2 + 1) * (BlockEntityModelProximity.maxSectionDistanceForNeighbors * 2 + 1) * 2 * 2);
+                        for (SectionPos oldOrNewSectionPos : new SectionPos[]{sectionposition, sectionposition1}) {
+                            for (int dx = -BlockEntityModelProximity.maxSectionDistanceForNeighbors; dx <= BlockEntityModelProximity.maxSectionDistanceForNeighbors; dx++) {
+                                for (int dy = -BlockEntityModelProximity.maxSectionDistanceForNeighbors; dy <= BlockEntityModelProximity.maxSectionDistanceForNeighbors; dy++) {
+                                    for (int dz = -BlockEntityModelProximity.maxSectionDistanceForNeighbors; dz <= BlockEntityModelProximity.maxSectionDistanceForNeighbors; dz++) {
+                                        int nx = oldOrNewSectionPos.x() + dx;
+                                        int ny = oldOrNewSectionPos.y() + dy;
+                                        int nz = oldOrNewSectionPos.z() + dz;
+                                        if (ny >= level.getMinSection() && ny <= level.getMaxSection()) {
+                                            SectionPos neighbor = SectionPos.of(nx, ny, nz);
+                                            if (level.isLoadedAndInBounds(new BlockPos(neighbor.minBlockX(), neighbor.minBlockY(), neighbor.minBlockZ()))) {
+                                                long neighborKey = neighbor.asLong();
+                                                if (fromAndToSectionsAndChessboardNeighbors.add(neighborKey)) {
+                                                    connection2.updateBlockEntitiesClosebyModelInChunkSection(neighborKey, sectionposition1, newBlockPos);
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    } else if (player.lastBlockPos == null || !player.lastBlockPos.equals(newBlockPos)) {
+                        LongSet fromAndToBlocksAndChessboardNeighbors = new LongOpenHashSet((BlockEntityModelProximity.maxBlockDistanceForNeighbors * 2 + 1) * (BlockEntityModelProximity.maxBlockDistanceForNeighbors * 2 + 1) * (BlockEntityModelProximity.maxBlockDistanceForNeighbors * 2 + 1) * 2 * 2);
+                        for (BlockPos oldOrNewBlockPos : new BlockPos[]{player.lastBlockPos, newBlockPos}) {
+                            if (oldOrNewBlockPos != null) {
+                                for (int dx = -BlockEntityModelProximity.maxBlockDistanceForNeighbors; dx <= BlockEntityModelProximity.maxBlockDistanceForNeighbors; dx++) {
+                                    for (int dy = -BlockEntityModelProximity.maxBlockDistanceForNeighbors; dy <= BlockEntityModelProximity.maxBlockDistanceForNeighbors; dy++) {
+                                        for (int dz = -BlockEntityModelProximity.maxBlockDistanceForNeighbors; dz <= BlockEntityModelProximity.maxBlockDistanceForNeighbors; dz++) {
+                                            int nx = oldOrNewBlockPos.getX() + dx;
+                                            int ny = oldOrNewBlockPos.getY() + dy;
+                                            int nz = oldOrNewBlockPos.getZ() + dz;
+                                            if (ny >= level.getMinBuildHeight() && ny <= level.getMaxBuildHeight()) {
+                                                BlockPos neighbor = new BlockPos(nx, ny, nz);
+                                                if (level.isLoadedAndInBounds(neighbor)) {
+                                                    long neighborKey = neighbor.asLong();
+                                                    if (fromAndToBlocksAndChessboardNeighbors.add(neighborKey)) {
+                                                        connection2.updateBlockEntitiesClosebyModelForBlock(neighborKey, sectionposition1, newBlockPos);
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        player.lastBlockPos = newBlockPos;
+        // Martijn end - custom blocks and items
         long k = sectionposition.chunk().toLong();
         long l = sectionposition1.chunk().toLong();
         boolean flag = this.playerMap.ignored(player);
@@ -2250,14 +2312,17 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     // Paper start - Anti-Xray - Bypass
-    private void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk, boolean concernsTracking) { // Martijn - per-player track and see view distance
+    public void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<ImmutablePair<Boolean, Boolean>, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk, boolean concernsTracking) { // Martijn - per-player track and see view distance // Martijn - custom blocks and items
         if (cachedDataPackets.getValue() == null) {
             cachedDataPackets.setValue(new java.util.HashMap<>());
         }
 
         Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
-        player.trackChunk(chunk.getPos(), cachedDataPackets.getValue().computeIfAbsent(shouldModify, (s) -> {
-            return new ClientboundLevelChunkWithLightPacket(chunk, this.lightEngine, (BitSet) null, (BitSet) null, true, (Boolean) s);
+        // Martijn start - custom blocks and items
+        boolean hasResourcePack = player.hasSuCraftResourcePack();
+        player.trackChunk(chunk.getPos(), cachedDataPackets.getValue().computeIfAbsent(new ImmutablePair<>(shouldModify, hasResourcePack), (s) -> {
+            return new ClientboundLevelChunkWithLightPacket(chunk, this.lightEngine, (BitSet) null, (BitSet) null, true, s.left, s.right);
+            // Martijn end - custom blocks and items
         }), concernsTracking);
         // Paper end
         DebugPackets.sendPoiPacketsForChunk(this.level, chunk.getPos());
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 5aae519912830ffb67c5c3d9fbe9f7f07ac2ab9d..eb875d1464ee4018513cfb4cf2127fc5bff1b444 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -8,6 +8,7 @@ import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2IntArrayMap;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.longs.LongSets;
 import it.unimi.dsi.fastutil.objects.Object2IntMap.Entry;
@@ -154,6 +155,7 @@ import net.minecraft.world.phys.shapes.BooleanOp;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
 import net.minecraft.world.ticks.LevelTicks;
+import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 import org.bukkit.Bukkit;
 import org.bukkit.Location;
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index cebf8782b35bdaadae3d7feef1ffd8faf169b23a..db471f9b5e8f1e2858ee68f789b2fc12ace08ec3 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -9,14 +9,18 @@ import com.mojang.logging.LogUtils;
 import com.mojang.serialization.DataResult;
 
 import java.util.ArrayDeque;
+import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.OptionalInt;
+import java.util.Set;
 import java.util.UUID;
+import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 
@@ -24,6 +28,9 @@ import io.papermc.paper.chunk.PlayerChunkLoader;
 import io.papermc.paper.configuration.GlobalConfiguration;
 import it.unimi.dsi.fastutil.Pair;
 import it.unimi.dsi.fastutil.ints.IntIntPair;
+import it.unimi.dsi.fastutil.longs.LongArrayList;
+import it.unimi.dsi.fastutil.longs.LongList;
+import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.objects.ObjectObjectImmutablePair;
 import net.minecraft.BlockUtil;
 import net.minecraft.ChatFormatting;
@@ -85,6 +92,7 @@ import net.minecraft.network.protocol.game.ClientboundSetHealthPacket;
 import net.minecraft.network.protocol.game.ClientboundSoundPacket;
 import net.minecraft.network.protocol.game.ClientboundSystemChatPacket;
 import net.minecraft.network.protocol.game.ClientboundUpdateMobEffectPacket;
+import net.minecraft.network.protocol.game.ClientboundUpdateRecipesPacket;
 import net.minecraft.network.protocol.game.ServerboundClientInformationPacket;
 import net.minecraft.network.protocol.status.ServerStatus;
 import net.minecraft.resources.ResourceKey;
@@ -128,6 +136,7 @@ import net.minecraft.world.inventory.ContainerSynchronizer;
 import net.minecraft.world.inventory.HorseInventoryMenu;
 import net.minecraft.world.inventory.ResultSlot;
 import net.minecraft.world.inventory.Slot;
+import net.minecraft.world.inventory.StonecutterMenu;
 import net.minecraft.world.item.ComplexItem;
 import net.minecraft.world.item.ItemCooldowns;
 import net.minecraft.world.item.ItemStack;
@@ -151,11 +160,13 @@ import net.minecraft.world.level.block.entity.CommandBlockEntity;
 import net.minecraft.world.level.block.entity.SignBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.border.WorldBorder;
+import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.dimension.LevelStem;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.portal.PortalInfo;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
+import org.apache.commons.lang3.mutable.MutableObject;
 import org.slf4j.Logger;
 import net.minecraft.world.Container;
 import net.minecraft.world.InteractionHand;
@@ -504,6 +515,7 @@ public class ServerPlayer extends Player {
     @Nullable
     private Vec3 enteredLavaOnVehiclePosition;
     private SectionPos lastSectionPos;
+    public @Nullable BlockPos lastBlockPos; // Martijn - custom blocks and items
     private ResourceKey<Level> respawnDimension;
     @Nullable
     private BlockPos respawnPosition;
@@ -548,7 +560,7 @@ public class ServerPlayer extends Player {
 
     private int maxNumberOfChunkPacketsInTransitBasedOnConnection = GlobalConfiguration.get().networkConstrainedChunkSending.maxChunkPacketsInTransit.initial;
     // Keep track of chunk packets in transit
-    private final ArrayDeque<ChunkPacketInTransit> chunkInitializationPacketsInTransitKeepaliveIds = new ArrayDeque<>();
+    public final ArrayDeque<ChunkPacketInTransit> chunkInitializationPacketsInTransitKeepaliveIds = new ArrayDeque<>(); // Martijn - custom blocks and items
 
     public int getMaxNumberOfChunkPacketsInTransitBasedOnConnection() {
         synchronized (this.networkConstrainedSendingLock) {
@@ -604,6 +616,11 @@ public class ServerPlayer extends Player {
     }
 
     public boolean canSendChunkInitializationPacketNow(ChunkPos chunk) {
+        // Martijn start - custom blocks and items
+        if (getBukkitEntity().getResourcePackStatus() == null) {
+            return false;
+        }
+        // Martijn end - custom blocks and items
         if (getChessboardDistanceToChunk(chunk) <= GlobalConfiguration.get().networkConstrainedChunkSending.ignoreNetworkConditionsForChunksWithinChessboardDistance) return true;
         synchronized (this.networkConstrainedSendingLock) {
             return this.chunkInitializationPacketsInTransitKeepaliveIds.size() < this.maxNumberOfChunkPacketsInTransitBasedOnConnection;
@@ -2914,4 +2931,132 @@ public class ServerPlayer extends Player {
     // CraftBukkit end
 
     public final int getViewDistance() { throw new UnsupportedOperationException("Use PlayerChunkLoader"); } // Paper - placeholder
+
+    // Martijn start - custom blocks and items
+
+    public boolean hasSuCraftResourcePack() {
+        var bukkitPlayer = getBukkitEntity();
+        if (bukkitPlayer == null) {
+            return false;
+        }
+        return bukkitPlayer.hasSuCraftResourcePack();
+    }
+
+    public boolean hasHighPingForCustomBlocks() {
+        var bukkitPlayer = getBukkitEntity();
+        if (bukkitPlayer == null) {
+            return false;
+        }
+        return bukkitPlayer.hasHighPingForCustomBlocks();
+    }
+
+    public void resendInventory() {
+        this.getBukkitEntity().updateInventory();
+    }
+
+    private @Nullable Set<ResourceLocation> lastSentSpecificRecipeIds = null;
+
+    public final @NotNull Comparator<Recipe<?>> RECIPE_ORDER = (recipe1, recipe2) -> {
+        // Martijn start - custom blocks and items
+        var descriptionId1 = recipe1.getReplacedResultItemDescriptionId(this);
+        var descriptionId2 = recipe2.getReplacedResultItemDescriptionId(this);
+        int descriptionIdCompare = descriptionId1.compareTo(descriptionId2);
+        if (descriptionIdCompare != 0) {
+            return descriptionIdCompare;
+        }
+        return Integer.compare(descriptionId1.hashCode(), descriptionId2.hashCode());
+        // Martijn end - custom blocks and items
+    };
+
+    public void resendCraftingRecipes(@Nullable ItemStack stonecutterInput, int iteration) {
+
+        Collection<Recipe<?>> allRecipes = this.server.getRecipeManager().getRecipes();
+
+        if (!this.hasSuCraftResourcePack()) {
+            if (this.lastSentSpecificRecipeIds != null && lastSentSpecificRecipeIds.isEmpty()) {
+                return;
+            }
+            var recipesToSend = allRecipes.stream().filter(recipe -> recipe.shouldAlwaysSend()).toList();
+            this.lastSentSpecificRecipeIds = Collections.emptySet();
+            this.connection.send(new ClientboundUpdateRecipesPacket(recipesToSend));
+            this.getRecipeBook().sendInitialRecipeBook(this);
+            return;
+        }
+
+        if (stonecutterInput == null) {
+            if (this.containerMenu instanceof StonecutterMenu stonecutterMenu) {
+                stonecutterInput = stonecutterMenu.container.getItem(StonecutterMenu.INPUT_SLOT);
+            }
+        }
+
+        final @Nullable ItemStack finalStonecutterInput = stonecutterInput;
+        List<Recipe<?>> alwaysRecipesToSend = new ArrayList<>(allRecipes.size());
+        List<Recipe<?>> specificRecipesToSend = new ArrayList<>(4);
+        List<Recipe<?>> allRecipesToSend = new ArrayList<>(allRecipes.size());
+        allRecipes.forEach(recipe -> {
+            if (recipe.shouldAlwaysSend()) {
+                alwaysRecipesToSend.add(recipe);
+                allRecipesToSend.add(recipe);
+            } else if (recipe.shouldSpecificallySend(this, finalStonecutterInput)) {
+                specificRecipesToSend.add(recipe);
+                allRecipesToSend.add(recipe);
+            }
+        });
+        Set<ResourceLocation> willSendSpecificRecipeIds = specificRecipesToSend.stream().map(recipe -> recipe.getId()).collect(Collectors.toSet());
+
+        if (this.lastSentSpecificRecipeIds == null || !this.lastSentSpecificRecipeIds.equals(willSendSpecificRecipeIds)) {
+            allRecipesToSend.sort(RECIPE_ORDER);
+//            MinecraftServer.LOGGER.info("TEMP DEBUG - all: " + allRecipesToSend.stream().map(recipe -> recipe.getResultItem().getItem()).toList());
+//            Collections.shuffle(allRecipesToSend);
+            this.lastSentSpecificRecipeIds = willSendSpecificRecipeIds;
+            this.connection.send(new ClientboundUpdateRecipesPacket(allRecipesToSend));
+            this.getRecipeBook().sendInitialRecipeBook(this);
+//            MinecraftServer.LOGGER.info("TEMP DEBUG - specific: " + specificRecipesToSend.stream().sorted(RECIPE_ORDER).map(recipe -> recipe.getResultItem().getItem()).toList());
+        }
+
+        if (iteration < 3 && iteration >= 0) {
+            if (this.containerMenu instanceof StonecutterMenu stonecutterMenu) {
+                this.connection.send(new ClientboundContainerSetSlotPacket(containerMenu.containerId, containerMenu.getStateId(), StonecutterMenu.INPUT_SLOT, new ItemStack(Items.AIR, 0)));
+            }
+            this.resendInventory();
+            Bukkit.getScheduler().runTaskLater(Bukkit.getPluginManager().getPlugins()[0], () -> this.resendCraftingRecipes(null, iteration + 1), 1);
+        }
+
+    }
+
+    public void resendAdvancements() {
+        this.advancements.visibilityChanged.addAll(this.advancements.advancements.keySet());
+        this.advancements.flushDirty(this);
+    }
+
+    public void resendAllSentChunks() {
+        if (!this.isAlive()) {
+            // Chunks cannot be untracked or tracked while dead
+            return;
+        }
+        net.minecraft.server.level.ChunkMap chunkMap = this.getLevel().getChunkSource().chunkMap;
+        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this);
+        LongSet sentTrackChunks = data.getSentChunks(true);
+        LongSet sentSeeChunks = data.getSentChunks(false);
+        // For all chunk keys, we will naively untrack and track the chunks all at once (bypassing the entire network-constrained chunk sending system, which would normally also call the untrackand track methods at the right times)
+        for (long chunkKey : sentSeeChunks) {
+            ChunkPos chunkPos = new ChunkPos(chunkKey);
+            int chunkX = chunkPos.x;
+            int chunkZ = chunkPos.z;
+            boolean concernsTracking = sentTrackChunks.contains(chunkKey);
+            // Untrack the chunk
+            this.untrackChunk(chunkPos, concernsTracking);
+            // Track the chunk (note that this will send a network-constrained chunk sending fake keep-alive packet too, and thereby increase the number of packets in transit according to that system, which should cause the network-constrained chunk sending system to wait appropriately for enough of these packets to arrive before sending any more)
+            // ChunkMap.playerLoadedChunk is basically ServerPlayer.trackChunk in this scenario, but it re-computes the chunk data to send based on the resource pack status
+            LevelChunk chunk = chunkMap.level.getChunkIfLoaded(chunkX, chunkZ);
+            // We don't want to suddenly load a chunk here, so we simply ignore this chunk if it is somehow not loaded anymore - too bad, but this should never happen or be so rare it is not significant
+            if (chunk == null) {
+                continue;
+            }
+            chunkMap.playerLoadedChunk(this, new MutableObject<>(), chunk, concernsTracking);
+        }
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
index 7123b7a821e2b3b75701976ed5382f4f3aaecfda..1a34ef9e4c242a8048b3d21ab73126a1da70dee2 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
@@ -59,6 +59,7 @@ public class ServerPlayerGameMode {
     private boolean isDestroyingBlock;
     private int destroyProgressStart;
     private BlockPos destroyPos;
+    private int destroySequence; // Martijn - custom blocks and items
     private int gameTicks;
     private boolean hasDelayedDestroy;
     private BlockPos delayedDestroyPos;
@@ -151,7 +152,16 @@ public class ServerPlayerGameMode {
                 this.lastSentState = -1;
                 this.isDestroyingBlock = false;
             } else {
-                this.incrementDestroyProgress(iblockdata, this.destroyPos, this.destroyProgressStart);
+                // Martijn start - custom blocks and items
+                float f = this.incrementDestroyProgress(iblockdata, this.destroyPos, this.destroyProgressStart);
+                // Arbitrary choices: 1.5f is about double the usual check amount when a player sends a block break finish packet (0.7f), and it seems to work very well
+                // The minimum ticks of 7 is because otherwise it seems that for good tools, it breaks way too quickly
+                if (iblockdata.getBlock().breakBeforeClientKnowsToBreak && f >= 1.5f && this.gameTicks - this.destroyProgressStart >= 7) {
+                    this.isDestroyingBlock = false;
+                    this.level.destroyBlockProgress(this.player.getId(), this.destroyPos, -1);
+                    this.destroyAndAck(this.destroyPos, this.destroySequence, "destroyed");
+                }
+                // Martijn end - custom blocks and items
             }
         }
 
@@ -308,6 +318,7 @@ public class ServerPlayerGameMode {
 
                     this.isDestroyingBlock = true;
                     this.destroyPos = pos.immutable();
+                    this.destroySequence = sequence; // Martijn - custom blocks and items
                     int k = (int) (f * 10.0F);
 
                     this.level.destroyBlockProgress(this.player.getId(), pos, k);
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 40712b51b84a812737f6c5f58eefece1e11608a3..323ffabfc90b27e612d7f4df758e8898fef8a0f1 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -30,6 +30,7 @@ import java.util.function.BiFunction;
 import java.util.function.Consumer;
 import java.util.function.UnaryOperator;
 import java.util.stream.Collectors;
+import java.util.stream.IntStream;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 import net.minecraft.ChatFormatting;
@@ -142,6 +143,7 @@ import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.entity.Mob;
 import net.minecraft.world.entity.MoverType;
 import net.minecraft.world.entity.PlayerRideableJumping;
+import net.minecraft.world.inventory.StonecutterMenu;
 import net.minecraft.world.item.BlockItem;
 import net.minecraft.world.item.BucketItem;
 import net.minecraft.world.item.Item;
@@ -170,6 +172,7 @@ import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.phys.shapes.BooleanOp;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
+import nl.martijnmuijsers.paper.item.ItemReplacementRule;
 import org.apache.commons.lang3.StringUtils;
 import org.slf4j.Logger;
 
@@ -1990,7 +1993,30 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
         }
         // Paper start
         PlayerResourcePackStatusEvent.Status packStatus = PlayerResourcePackStatusEvent.Status.values()[packet.action.ordinal()];
+
+        // Martijn start - custom blocks and items
+
+        @Nullable PlayerResourcePackStatusEvent.Status oldPackStatus = this.player.getBukkitEntity().getResourcePackStatus();
+
+        // Update the player's packet status before resending anything, so that it can be used by for example ChunkMap.playerLoadedChunk to correctly compute the chunk data to send
         player.getBukkitEntity().setResourcePackStatus(packStatus);
+
+        if ((oldPackStatus == PlayerResourcePackStatusEvent.Status.ACCEPTED || oldPackStatus == PlayerResourcePackStatusEvent.Status.SUCCESSFULLY_LOADED) && (packStatus == PlayerResourcePackStatusEvent.Status.DECLINED || packStatus == PlayerResourcePackStatusEvent.Status.FAILED_DOWNLOAD)) {
+            // Resend most of the potentially already sent data if we previously thought the player had accepted the resource pack, but now they no longer do
+            this.player.resendInventory();
+            this.player.resendAllSentChunks();
+            this.player.resendCraftingRecipes(null, -1);
+            this.player.resendAdvancements();
+            this.player.chunkInitializationPacketsInTransitKeepaliveIds.clear(); // Don't delay starting sending chunks even if some are already in transit
+        } else if (oldPackStatus == null && (packStatus == PlayerResourcePackStatusEvent.Status.ACCEPTED || packStatus == PlayerResourcePackStatusEvent.Status.SUCCESSFULLY_LOADED)) {
+            // Resend their inventory (we have not sent any chunks yet if this is true, so we do not need to resend any)
+            this.player.resendInventory();
+            this.player.resendCraftingRecipes(null, -1);
+            this.player.resendAdvancements();
+            this.player.chunkInitializationPacketsInTransitKeepaliveIds.clear(); // Don't delay starting sending chunks even if some are already in transit
+        }
+        // Martijn end - custom blocks and items
+
         this.cserver.getPluginManager().callEvent(new PlayerResourcePackStatusEvent(this.getCraftPlayer(), packStatus)); // CraftBukkit
         // Paper end
     }
@@ -3064,6 +3090,17 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
                             return;
                         }
 
+                        // Martijn start - custom blocks and items
+
+                        if (this.player.containerMenu instanceof StonecutterMenu stonecutterMenu) {
+                            ItemStack intoInputStack = ItemReplacementRule.reverseReplacement(packet.getChangedSlots().get(StonecutterMenu.INPUT_SLOT));
+                            if (intoInputStack != null) {
+                                this.player.resendCraftingRecipes(intoInputStack, 0);
+                            }
+                        }
+
+                        // Martijn end - custom blocks and items
+
                         switch (event.getResult()) {
                             case ALLOW:
                             case DEFAULT:
@@ -3131,10 +3168,10 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
                     while (objectiterator.hasNext()) {
                         Entry<ItemStack> entry = (Entry) objectiterator.next();
 
-                        this.player.containerMenu.setRemoteSlotNoCopy(entry.getIntKey(), (ItemStack) entry.getValue());
+                        this.player.containerMenu.setRemoteSlotNoCopy(entry.getIntKey(), ItemReplacementRule.reverseReplacement((ItemStack) entry.getValue())); // Martijn - custom blocks and items
                     }
 
-                    this.player.containerMenu.setRemoteCarried(packet.getCarriedItem());
+                    this.player.containerMenu.setRemoteCarried(ItemReplacementRule.reverseReplacement(packet.getCarriedItem())); // Martijn - custom blocks and items
                     this.player.containerMenu.resumeRemoteUpdates();
                     if (flag) {
                         this.player.containerMenu.broadcastFullState();
@@ -3191,7 +3228,10 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.getLevel());
         if (this.player.gameMode.isCreative()) {
             boolean flag = packet.getSlotNum() < 0;
-            ItemStack itemstack = packet.getItem();
+            // Martijn start - custom blocks and items
+            ItemStack requestedItemStack = ItemReplacementRule.reverseReplacement(packet.getItem());
+            ItemStack itemstack = requestedItemStack;
+            // Martijn end - custom blocks and items
             CompoundTag nbttagcompound = BlockItem.getBlockEntityData(itemstack);
 
             if (!itemstack.isEmpty() && nbttagcompound != null && nbttagcompound.contains("x") && nbttagcompound.contains("y") && nbttagcompound.contains("z") && this.player.getBukkitEntity().hasPermission("minecraft.nbt.copy")) { // Spigot
@@ -3210,10 +3250,10 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
 
             boolean flag1 = packet.getSlotNum() >= 1 && packet.getSlotNum() <= 45;
             boolean flag2 = itemstack.isEmpty() || itemstack.getDamageValue() >= 0 && itemstack.getCount() <= 64 && !itemstack.isEmpty();
-            if (flag || (flag1 && !ItemStack.matches(this.player.inventoryMenu.getSlot(packet.getSlotNum()).getItem(), packet.getItem()))) { // Insist on valid slot
+            if (flag || (flag1 && !ItemStack.matches(this.player.inventoryMenu.getSlot(packet.getSlotNum()).getItem(), requestedItemStack))) { // Insist on valid slot // Martijn - custom blocks and items
                 // CraftBukkit start - Call click event
                 InventoryView inventory = this.player.inventoryMenu.getBukkitView();
-                org.bukkit.inventory.ItemStack item = CraftItemStack.asBukkitCopy(packet.getItem());
+                org.bukkit.inventory.ItemStack item = CraftItemStack.asBukkitCopy(requestedItemStack); // Martijn - custom blocks and items
 
                 SlotType type = SlotType.QUICKBAR;
                 if (flag) {
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index def57a2f44bf20c06b161f144e1122ad0ba4b705..8554b85ba84e4b5ed15d15049dd17f2a617870de 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -275,14 +275,21 @@ public abstract class PlayerList {
 
         player.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         playerconnection.send(new ClientboundCustomPayloadPacket(ClientboundCustomPayloadPacket.BRAND, (new FriendlyByteBuf(Unpooled.buffer())).writeUtf(this.getServer().getServerModName())));
+
+        // Martijn start - custom blocks and items
+        this.server.getServerResourcePack().ifPresent((minecraftserver_serverresourcepackinfo) -> {
+            player.sendTexturePack(minecraftserver_serverresourcepackinfo.url(), minecraftserver_serverresourcepackinfo.hash(), minecraftserver_serverresourcepackinfo.isRequired(), minecraftserver_serverresourcepackinfo.prompt());
+        });
+        // Martijn end - custom blocks and items
+
         playerconnection.send(new ClientboundChangeDifficultyPacket(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
         playerconnection.send(new ClientboundPlayerAbilitiesPacket(player.getAbilities()));
         playerconnection.send(new ClientboundSetCarriedItemPacket(player.getInventory().selected));
-        playerconnection.send(new ClientboundUpdateRecipesPacket(this.server.getRecipeManager().getRecipes()));
+//        playerconnection.send(new ClientboundUpdateRecipesPacket(this.server.getRecipeManager().getRecipes())); // Martijn - custom blocks and items
         playerconnection.send(new ClientboundUpdateTagsPacket(TagNetworkSerialization.serializeTagsToNetwork(this.registryHolder)));
         this.sendPlayerPermissionLevel(player);
         player.getStats().markAllDirty();
-        player.getRecipeBook().sendInitialRecipeBook(player);
+//        player.getRecipeBook().sendInitialRecipeBook(player); // Martijn - custom blocks and items
         this.updateEntireScoreboard(worldserver1.getScoreboard(), player);
         this.server.invalidateStatus();
         // Paper start - async load spawn in chunk
@@ -407,9 +414,11 @@ public abstract class PlayerList {
         worldserver1 = player.getLevel(); // CraftBukkit - Update in case join event changed it
         // CraftBukkit end
         this.sendLevelInfo(player, worldserver1);
-        this.server.getServerResourcePack().ifPresent((minecraftserver_serverresourcepackinfo) -> {
-            player.sendTexturePack(minecraftserver_serverresourcepackinfo.url(), minecraftserver_serverresourcepackinfo.hash(), minecraftserver_serverresourcepackinfo.isRequired(), minecraftserver_serverresourcepackinfo.prompt());
-        });
+        // Martijn start - custom blocks and items
+//        this.server.getServerResourcePack().ifPresent((minecraftserver_serverresourcepackinfo) -> {
+//            player.sendTexturePack(minecraftserver_serverresourcepackinfo.url(), minecraftserver_serverresourcepackinfo.hash(), minecraftserver_serverresourcepackinfo.isRequired(), minecraftserver_serverresourcepackinfo.prompt());
+//        });
+        // Martijn end - custom blocks and items
         player.sendServerStatus(this.server.getStatus());
         Iterator iterator = player.getActiveEffects().iterator();
 
@@ -427,7 +436,7 @@ public abstract class PlayerList {
                 .getHolderOrThrow(net.minecraft.world.level.biome.Biomes.PLAINS);
             player.connection.send(new net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket(
                 new net.minecraft.world.level.chunk.EmptyLevelChunk(worldserver1, player.chunkPosition(), plains),
-                worldserver1.getLightEngine(), null, null, true, false)
+                worldserver1.getLightEngine(), null, null, true, false, player.hasSuCraftResourcePack()) // Martijn - custom blocks and items
             );
         }
         // Paper end
diff --git a/src/main/java/net/minecraft/stats/ServerRecipeBook.java b/src/main/java/net/minecraft/stats/ServerRecipeBook.java
index b7ebaf8c17b5075989ae04224f837c7932ec6cdd..5637ab33538d61aef40c68f92ff6e6a818989ecd 100644
--- a/src/main/java/net/minecraft/stats/ServerRecipeBook.java
+++ b/src/main/java/net/minecraft/stats/ServerRecipeBook.java
@@ -143,4 +143,5 @@ public class ServerRecipeBook extends RecipeBook {
     public void sendInitialRecipeBook(ServerPlayer player) {
         player.connection.send(new ClientboundRecipePacket(ClientboundRecipePacket.State.INIT, this.known, this.highlight, this.getBookSettings()));
     }
+
 }
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 1b9b58557ff48b87794d66238dbf64b81c087c86..695ed363c7e783d696cc2e02956fb7cfbb067d08 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -264,7 +264,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     private static final Logger LOGGER = LogUtils.getLogger();
     public static final String ID_TAG = "id";
     public static final String PASSENGERS_TAG = "Passengers";
-    private static final AtomicInteger ENTITY_COUNTER = new AtomicInteger();
+    public static final AtomicInteger ENTITY_COUNTER = new AtomicInteger(); // Martijn - custom blocks and items
     private static final List<ItemStack> EMPTY_LIST = Collections.emptyList();
     public static final int BOARDING_COOLDOWN = 60;
     public static final int TOTAL_AIR_SUPPLY = 300;
@@ -331,21 +331,23 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     public int invulnerableTime;
     protected boolean firstTick;
     protected final SynchedEntityData entityData;
-    protected static final EntityDataAccessor<Byte> DATA_SHARED_FLAGS_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BYTE);
-    protected static final int FLAG_ONFIRE = 0;
+    // Martijn start - custom blocks and item
+    public static final EntityDataAccessor<Byte> DATA_SHARED_FLAGS_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BYTE);
+    private static final int FLAG_ONFIRE = 0;
     private static final int FLAG_SHIFT_KEY_DOWN = 1;
     private static final int FLAG_SPRINTING = 3;
     private static final int FLAG_SWIMMING = 4;
-    private static final int FLAG_INVISIBLE = 5;
+    public static final int FLAG_INVISIBLE = 5;
     protected static final int FLAG_GLOWING = 6;
     protected static final int FLAG_FALL_FLYING = 7;
-    private static final EntityDataAccessor<Integer> DATA_AIR_SUPPLY_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
+    public static final EntityDataAccessor<Integer> DATA_AIR_SUPPLY_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
     private static final EntityDataAccessor<Optional<Component>> DATA_CUSTOM_NAME = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.OPTIONAL_COMPONENT);
     private static final EntityDataAccessor<Boolean> DATA_CUSTOM_NAME_VISIBLE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
-    private static final EntityDataAccessor<Boolean> DATA_SILENT = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
-    private static final EntityDataAccessor<Boolean> DATA_NO_GRAVITY = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
+    public static final EntityDataAccessor<Boolean> DATA_SILENT = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
+    public static final EntityDataAccessor<Boolean> DATA_NO_GRAVITY = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
     protected static final EntityDataAccessor<net.minecraft.world.entity.Pose> DATA_POSE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.POSE);
     private static final EntityDataAccessor<Integer> DATA_TICKS_FROZEN = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
+    // Martijn end - custom blocks and item
     private EntityInLevelCallback levelCallback;
     private final VecDeltaCodec packetPositionCodec;
     public boolean noCulling;
diff --git a/src/main/java/net/minecraft/world/entity/monster/Silverfish.java b/src/main/java/net/minecraft/world/entity/monster/Silverfish.java
index 2dcda3b03796655da443e1b3dd68c6f6bca20d21..75f071fbeea888d2f37e3fa9f8801d6faa2e2951 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Silverfish.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Silverfish.java
@@ -4,6 +4,7 @@ import java.util.EnumSet;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.util.RandomSource;
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index 16f74e2a118803e64a3156fb6a894c558c6adde7..6a15bc2c981236104a6aa25c6610a59942057639 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -39,6 +39,7 @@ import net.minecraft.network.syncher.EntityDataAccessor;
 import net.minecraft.network.syncher.EntityDataSerializers;
 import net.minecraft.network.syncher.SynchedEntityData;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.sounds.SoundEvent;
@@ -852,6 +853,14 @@ public abstract class Player extends LivingEntity {
         return !state.requiresCorrectToolForDrops() || this.inventory.getSelected().isCorrectToolForDrops(state);
     }
 
+    // Martijn start - custom blocks and items
+
+    public boolean hasCorrectToolForFasterBreaking(BlockState state) {
+        return hasCorrectToolForDrops(state) || !state.requiresCorrectToolForFasterBreaking(true) || this.inventory.getSelected().isCorrectToolForFasterBreaking(state, true);
+    }
+
+    // Martijn end - custom blocks and items
+
     @Override
     public void readAdditionalSaveData(CompoundTag nbt) {
         super.readAdditionalSaveData(nbt);
diff --git a/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java b/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
index 79d8bcf3f9b0fe4a65ad7899f858efefac6feaa7..64066022cf8b56939096c3a66cb5e26f9edba6e9 100644
--- a/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
+++ b/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
@@ -425,6 +425,7 @@ public abstract class AbstractContainerMenu {
                 itemstack = this.getCarried();
                 if (AbstractContainerMenu.canItemQuickReplace(slot, itemstack, true) && slot.mayPlace(itemstack) && (this.quickcraftType == 2 || itemstack.getCount() > this.quickcraftSlots.size()) && this.canDragTo(slot)) {
                     this.quickcraftSlots.add(slot);
+
                 }
             } else if (this.quickcraftStatus == 2) {
                 if (!this.quickcraftSlots.isEmpty()) {
@@ -451,6 +452,7 @@ public abstract class AbstractContainerMenu {
                             AbstractContainerMenu.getQuickCraftSlotCount(this.quickcraftSlots, this.quickcraftType, itemstack3, j1);
                             int k1 = Math.min(itemstack3.getMaxStackSize(), slot1.getMaxStackSize(itemstack3));
 
+
                             if (itemstack3.getCount() > k1) {
                                 itemstack3.setCount(k1);
                             }
diff --git a/src/main/java/net/minecraft/world/inventory/StonecutterMenu.java b/src/main/java/net/minecraft/world/inventory/StonecutterMenu.java
index d4f71422b25f70abfe50481d6071abea6ad147c0..a5063cc97aee67887944fa9c337cc47295dd6feb 100644
--- a/src/main/java/net/minecraft/world/inventory/StonecutterMenu.java
+++ b/src/main/java/net/minecraft/world/inventory/StonecutterMenu.java
@@ -2,6 +2,8 @@ package net.minecraft.world.inventory;
 
 import com.google.common.collect.Lists;
 import java.util.List;
+
+import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.sounds.SoundSource;
 import net.minecraft.world.Container;
@@ -15,7 +17,9 @@ import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Blocks;
 
 // CraftBukkit start
+import org.bukkit.Bukkit;
 import org.bukkit.Location;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.inventory.CraftInventoryStonecutter;
 import org.bukkit.craftbukkit.inventory.CraftInventoryView;
 import org.bukkit.entity.Player;
@@ -73,6 +77,12 @@ public class StonecutterMenu extends AbstractContainerMenu {
                 super.setChanged();
                 StonecutterMenu.this.slotsChanged(this);
                 StonecutterMenu.this.slotUpdateListener.run();
+                // Martijn start - custom blocks and items
+                ((CraftPlayer) StonecutterMenu.this.player).getHandle().resendCraftingRecipes(null, 0);
+//                Bukkit.getScheduler().runTaskLater(Bukkit.getPluginManager().getPlugins()[0], () ->
+//                    ((CraftPlayer) StonecutterMenu.this.player).getHandle().resendCraftingRecipes(), 1
+//                );
+                // Martijn end - custom blocks and items
             }
 
             // CraftBukkit start
diff --git a/src/main/java/net/minecraft/world/item/Item.java b/src/main/java/net/minecraft/world/item/Item.java
index 8b250dab8f3cb788ae1cfad43737afda31b72c0f..1cd8d8e596f0a62cde63d5966952ad0fe5ec19f1 100644
--- a/src/main/java/net/minecraft/world/item/Item.java
+++ b/src/main/java/net/minecraft/world/item/Item.java
@@ -4,11 +4,20 @@ import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimap;
 import com.mojang.logging.LogUtils;
+
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.UUID;
+import java.util.function.Supplier;
+import java.util.stream.Stream;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.adventure.PaperAdventure;
+import it.unimi.dsi.fastutil.Pair;
+import net.kyori.adventure.text.format.TextDecoration;
+import net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;
 import net.minecraft.SharedConstants;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
@@ -17,6 +26,7 @@ import net.minecraft.core.NonNullList;
 import net.minecraft.core.Registry;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceLocation;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.util.Mth;
@@ -37,6 +47,8 @@ import net.minecraft.world.inventory.ClickAction;
 import net.minecraft.world.inventory.Slot;
 import net.minecraft.world.inventory.tooltip.TooltipComponent;
 import net.minecraft.world.item.context.UseOnContext;
+import net.minecraft.world.item.crafting.Ingredient;
+import net.minecraft.world.item.crafting.StonecutterRecipe;
 import net.minecraft.world.level.ClipContext;
 import net.minecraft.world.level.ItemLike;
 import net.minecraft.world.level.Level;
@@ -44,8 +56,14 @@ import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.Vec3;
+import nl.martijnmuijsers.paper.item.ItemReplacementRule;
+import org.bukkit.craftbukkit.generator.CustomChunkGenerator;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 
+import static nl.martijnmuijsers.paper.item.SuCraftItems.CUSTOM_DISPLAY_NAME_IN_LORE_DEFAULT_COLOR;
+
 public class Item implements ItemLike {
     private static final Logger LOGGER = LogUtils.getLogger();
     public static final Map<Block, Item> BY_BLOCK = Maps.newHashMap();
@@ -68,6 +86,83 @@ public class Item implements ItemLike {
     @Nullable
     private final FoodProperties foodProperties;
 
+    // Martijn start - custom blocks and items
+
+    public boolean isVanilla = true;
+
+    /**
+     * This is the {@link ResourceLocation} for this item
+     * <br>
+     * Must be non-null for SuCraft items
+     */
+    public @Nullable ResourceLocation customKey;
+
+    /**
+     * This is the {@link ResourceLocation} for this item
+     * <br>
+     * Will always be non-null after it has been registered
+     */
+    public @Nullable ResourceLocation id;
+
+    /**
+     * Must be non-null for SuCraft items
+     */
+    public @Nullable ItemReplacementRule replacementRule = null;
+
+    public void setRename(@NotNull net.kyori.adventure.text.Component kyoriDisplayName, @NotNull String displayNameJSON, @NotNull net.kyori.adventure.text.Component kyoriDisplayNameInLore, @NotNull String displayNameInLoreJSON) {
+        this.customDisplayName = kyoriDisplayName;
+        this.customDisplayNameJSON = displayNameJSON;
+        this.customDisplayNameInLore = kyoriDisplayNameInLore;
+        this.customDisplayNameInLoreJSON = displayNameInLoreJSON;
+    }
+
+    public void setRename(@NotNull String displayName) {
+        var kyoriDisplayName = net.kyori.adventure.text.Component.text(displayName, PaperAdventure.asAdventure(rarity.color)).decoration(TextDecoration.ITALIC, false);
+        var displayNameJSON = GsonComponentSerializer.gson().serialize(kyoriDisplayName);
+        var kyoriDisplayNameInLore = net.kyori.adventure.text.Component.text(displayName, PaperAdventure.asAdventure(CUSTOM_DISPLAY_NAME_IN_LORE_DEFAULT_COLOR)).decoration(TextDecoration.ITALIC, false);
+        var displayNameInLoreJSON = GsonComponentSerializer.gson().serialize(kyoriDisplayNameInLore);
+        this.setRename(kyoriDisplayName, displayNameJSON, kyoriDisplayNameInLore, displayNameInLoreJSON);
+    }
+
+    /**
+     * Must be non-null for SuCraft items
+     */
+    public @Nullable net.kyori.adventure.text.Component customDisplayName = null;
+
+    /**
+     * Must be non-null for SuCraft items
+     */
+    public @Nullable String customDisplayNameJSON = null;
+
+    /**
+     * Must be non-null for SuCraft items
+     */
+    public @Nullable net.kyori.adventure.text.Component customDisplayNameInLore = null;
+
+    /**
+     * Must be non-null for SuCraft items
+     */
+    public @Nullable String customDisplayNameInLoreJSON = null;
+
+    public record CustomStonecutterRecipe(@NotNull ResourceLocation key, @Nullable String group, @NotNull Item ingredient, int resultAmount) {
+
+        public @NotNull StonecutterRecipe build(@NotNull Item result) {
+            var recipeIngredient = new Ingredient(Stream.of(new Ingredient.ItemValue(new ItemStack(ingredient))));
+//            recipeIngredient.exact = true;
+            return new StonecutterRecipe(key, group == null ? key.getPath() : group, recipeIngredient, new ItemStack(result, resultAmount), true);
+        }
+
+    }
+
+    public @NotNull List<@NotNull CustomStonecutterRecipe> customStonecutterRecipes = new ArrayList<>(0);
+
+    public @NotNull Item withCustomStonecutterRecipe(@NotNull CustomStonecutterRecipe recipe) {
+        this.customStonecutterRecipes.add(recipe);
+        return this;
+    }
+
+    // Martijn end - custom blocks and items
+
     public static int getId(Item item) {
         return item == null ? 0 : Registry.ITEM.getId(item);
     }
diff --git a/src/main/java/net/minecraft/world/item/ItemStack.java b/src/main/java/net/minecraft/world/item/ItemStack.java
index 6b3cfc19c4fd1382ddf534265a1114995a4f6b55..fb83a6fabe65bcc57b959e3e355951f9416c6f71 100644
--- a/src/main/java/net/minecraft/world/item/ItemStack.java
+++ b/src/main/java/net/minecraft/world/item/ItemStack.java
@@ -669,6 +669,25 @@ public final class ItemStack {
         return this.getItem().isCorrectToolForDrops(state);
     }
 
+    // Martijn start - custom blocks and items
+
+    public boolean isCorrectToolForFasterBreaking(net.minecraft.world.level.block.state.BlockState state, boolean doPlayerObservableLookups) {
+        if (this.isCorrectToolForDrops(state)) {
+            return true;
+        }
+        if (doPlayerObservableLookups) {
+            for (int playerObservableStateId : Block.realStateToPlayerObservableStates[Block.BLOCK_STATE_REGISTRY.getId(state)]) {
+                net.minecraft.world.level.block.state.BlockState playerObservableState = Block.BLOCK_STATE_REGISTRY.byId(playerObservableStateId);
+                if (this.isCorrectToolForFasterBreaking(playerObservableState, false)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    // Martijn end - custom blocks and items
+
     public InteractionResult interactLivingEntity(net.minecraft.world.entity.player.Player user, LivingEntity entity, InteractionHand hand) {
         return this.getItem().interactLivingEntity(this, user, entity, hand);
     }
diff --git a/src/main/java/net/minecraft/world/item/Items.java b/src/main/java/net/minecraft/world/item/Items.java
index d9ba3ae228791ebf6ea29353fb88c1765fa4d20c..8b9caf6fc03e392277ce2ea73b10f42c6ad8b454 100644
--- a/src/main/java/net/minecraft/world/item/Items.java
+++ b/src/main/java/net/minecraft/world/item/Items.java
@@ -14,6 +14,9 @@ import net.minecraft.world.food.Foods;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.material.Fluids;
+import nl.martijnmuijsers.paper.item.SuCraftItems;
+import nl.martijnmuijsers.paper.resourcepack.httpserver.ResourcePackHTTPServer;
+import nl.martijnmuijsers.paper.resourcepack.sucraft.CreateSuCraftResourcePack;
 
 public class Items {
     public static final Item AIR = registerBlock(Blocks.AIR, new AirItem(Blocks.AIR, new Item.Properties()));
@@ -1173,15 +1176,15 @@ public class Items {
         return Optional.empty();
     }
 
-    private static Item registerBlock(Block block) {
+    public static Item registerBlock(Block block) { // Martijn - custom blocks and items
         return registerBlock(new BlockItem(block, new Item.Properties()));
     }
 
-    private static Item registerBlock(Block block, CreativeModeTab group) {
+    public static Item registerBlock(Block block, CreativeModeTab group) { // Martijn - custom blocks and items
         return registerBlock(new BlockItem(block, (new Item.Properties()).tab(group)));
     }
 
-    private static Item registerBlock(Block block, Optional<CreativeModeTab> group) {
+    public static Item registerBlock(Block block, Optional<CreativeModeTab> group) { // Martijn - custom blocks and items
         return group.map((groupx) -> {
             return registerBlock(block, groupx);
         }).orElseGet(() -> {
@@ -1189,7 +1192,7 @@ public class Items {
         });
     }
 
-    private static Item registerBlock(Block block, CreativeModeTab group, Block... blocks) {
+    public static Item registerBlock(Block block, CreativeModeTab group, Block... blocks) { // Martijn - custom blocks and items
         BlockItem blockItem = new BlockItem(block, (new Item.Properties()).tab(group));
 
         for(Block block2 : blocks) {
@@ -1199,23 +1202,37 @@ public class Items {
         return registerBlock(blockItem);
     }
 
-    private static Item registerBlock(BlockItem item) {
+    public static Item registerBlock(BlockItem item) { // Martijn - custom blocks and items
         return registerBlock(item.getBlock(), item);
     }
 
-    protected static Item registerBlock(Block block, Item item) {
+    public static Item registerBlock(Block block, Item item) { // Martijn - custom blocks and items
         return registerItem(Registry.BLOCK.getKey(block), item);
     }
 
-    private static Item registerItem(String id, Item item) {
+    public static Item registerItem(String id, Item item) { // Martijn - custom blocks and items
         return registerItem(new ResourceLocation(id), item);
     }
 
-    private static Item registerItem(ResourceLocation id, Item item) {
+    public static Item registerItem(ResourceLocation id, Item item) { // Martijn - custom blocks and items
         if (item instanceof BlockItem) {
             ((BlockItem)item).registerBlocks(Item.BY_BLOCK, item);
         }
-
+        item.id = id; // Martijn - custom blocks and items
         return Registry.register(Registry.ITEM, id, item);
     }
+
+    // Martijn start - custom blocks and items
+    static {
+        // Evaluate the last element to bootstrap Items
+        ECHO_SHARD.asItem();
+        // Set some custom name replacements
+        BOOKSHELF.setRename("Oak Bookshelf");
+        STONECUTTER.setRename("Blockcutter");
+        // Then bootstrap SuCraftItems
+        SuCraftItems.bootstrap();
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/world/item/crafting/Recipe.java b/src/main/java/net/minecraft/world/item/crafting/Recipe.java
index 6d50c7ae912a36c8d3caaf26e2fc2dc20731b279..deb9c8a453f007d8c692662a8750ecd984db390b 100644
--- a/src/main/java/net/minecraft/world/item/crafting/Recipe.java
+++ b/src/main/java/net/minecraft/world/item/crafting/Recipe.java
@@ -2,11 +2,15 @@ package net.minecraft.world.item.crafting;
 
 import net.minecraft.core.NonNullList;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.Container;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Blocks;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
 public interface Recipe<C extends Container> {
 
@@ -18,6 +22,51 @@ public interface Recipe<C extends Container> {
 
     ItemStack getResultItem();
 
+    // Martijn start - custom blocks and items
+
+    default @NotNull ItemStack getReplacedResultItem(@NotNull Player player) {
+        return this.getReplacedResultItem(player.hasSuCraftResourcePack(), player.hasHighPingForCustomBlocks());
+    }
+
+    default @NotNull ItemStack getReplacedResultItem(@NotNull ServerPlayer player) {
+        return this.getReplacedResultItem(player.hasSuCraftResourcePack(), player.hasHighPingForCustomBlocks());
+    }
+
+    default @NotNull ItemStack getReplacedResultItem(boolean hasSuCraftResourcePack, boolean hasHighPingForCustomBlocks) {
+        ItemStack result = this.getResultItem();
+        var replacementRule1 = result.getItem().replacementRule;
+        if (replacementRule1 != null) {
+            result = replacementRule1.replace(result, hasSuCraftResourcePack, hasHighPingForCustomBlocks, true);
+        };
+        return result;
+    }
+
+    default @NotNull String getReplacedResultItemDescriptionId(@NotNull Player player) {
+        return this.getReplacedResultItemDescriptionId(player.hasSuCraftResourcePack(), player.hasHighPingForCustomBlocks());
+    }
+
+    default @NotNull String getReplacedResultItemDescriptionId(@NotNull ServerPlayer player) {
+        return this.getReplacedResultItemDescriptionId(player.hasSuCraftResourcePack(), player.hasHighPingForCustomBlocks());
+    }
+
+    default @NotNull String getReplacedResultItemDescriptionId(boolean hasSuCraftResourcePack, boolean hasHighPingForCustomBlocks) {
+        return this.getReplacedResultItem(hasSuCraftResourcePack, hasHighPingForCustomBlocks).getDescriptionId();
+    }
+
+    default boolean shouldAlwaysSend() {
+        return true;
+    }
+
+    default boolean shouldSpecificallySend(@NotNull ServerPlayer player, @Nullable ItemStack stonecutterInput) {
+        return false;
+    }
+
+    default boolean shouldSendRightNow(@NotNull ServerPlayer player, @Nullable ItemStack stonecutterInput) {
+        return this.shouldAlwaysSend() || this.shouldSpecificallySend(player, stonecutterInput);
+    }
+
+    // Martijn end - custom blocks and items
+
     default NonNullList<ItemStack> getRemainingItems(C inventory) {
         NonNullList<ItemStack> nonnulllist = NonNullList.withSize(inventory.getContainerSize(), ItemStack.EMPTY);
 
diff --git a/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java b/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java
index 4872f70977e73c889fe6e2339d00ebc64459613d..3a86d2b3b44e198ec84be4b535c545c8a9b1e45d 100644
--- a/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java
+++ b/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java
@@ -32,6 +32,7 @@ import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.Container;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.Level;
+import org.bukkit.entity.Player;
 import org.slf4j.Logger;
 
 import it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenHashMap; // CraftBukkit
@@ -92,7 +93,13 @@ public class RecipeManager extends SimpleJsonResourceReloadListener {
         if (this.byName.containsKey(irecipe.getId()) || map.containsKey(irecipe.getId())) {
             throw new IllegalStateException("Duplicate recipe ignored with ID " + irecipe.getId());
         } else {
-            map.putAndMoveToFirst(irecipe.getId(), irecipe); // CraftBukkit - SPIGOT-4638: last recipe gets priority
+            // Martijn start - custom blocks and items
+            if (irecipe.shouldAlwaysSend()) {
+                map.putAndMoveToFirst(irecipe.getId(), irecipe); // CraftBukkit - SPIGOT-4638: last recipe gets priority
+            } else {
+                map.putAndMoveToLast(irecipe.getId(), irecipe);
+            }
+            // Martijn end - custom blocks and items
             this.byName.put(irecipe.getId(), irecipe);
         }
     }
@@ -135,11 +142,40 @@ public class RecipeManager extends SimpleJsonResourceReloadListener {
     }
 
     public <C extends Container, T extends Recipe<C>> List<T> getRecipesFor(RecipeType<T> type, C inventory, Level world) {
+        @Nullable Player player = null;
+        var viewers = inventory.getViewers();
+        if (!viewers.isEmpty()) {
+            var viewer = viewers.get(0);
+            if (viewer instanceof Player) {
+                player = (Player) viewer;
+            }
+        }
+        final @Nullable Player finalPlayer = player;
         return (List) this.byType(type).values().stream().filter((irecipe) -> {
             return irecipe.matches(inventory, world);
-        }).sorted(Comparator.comparing((irecipe) -> {
-            return irecipe.getResultItem().getDescriptionId();
-        })).collect(Collectors.toList());
+            // Martijn start - custom blocks and items
+//        }).filter()
+        }).filter(
+            recipe -> (finalPlayer != null && finalPlayer.hasSuCraftResourcePack()) || recipe.shouldAlwaysSend()
+        ).sorted((recipe1, recipe2) -> {
+            ItemStack result1;
+            ItemStack result2;
+            if (finalPlayer != null) {
+                result1 = recipe1.getReplacedResultItem(finalPlayer);
+                result2 = recipe2.getReplacedResultItem(finalPlayer);
+            } else {
+                result1 = recipe1.getResultItem();
+                result2 = recipe2.getResultItem();
+            }
+            String descriptionId1 = result1.getDescriptionId();
+            String descriptionId2 = result2.getDescriptionId();
+            int descriptionIdCompare = descriptionId1.compareTo(descriptionId2);
+            if (descriptionIdCompare != 0) {
+                return descriptionIdCompare;
+            }
+            return Integer.compare(descriptionId1.hashCode(), descriptionId2.hashCode());
+        }).collect(Collectors.toList());
+        // Martijn end - custom blocks and items
     }
 
     private <C extends Container, T extends Recipe<C>> Map<ResourceLocation, T> byType(RecipeType<T> type) {
diff --git a/src/main/java/net/minecraft/world/item/crafting/RecipeSerializer.java b/src/main/java/net/minecraft/world/item/crafting/RecipeSerializer.java
index 71d491172b73fa5f428e3cab39240349dd715b6d..5b9b8fdae3a078e154490905e37c7aa18993ae45 100644
--- a/src/main/java/net/minecraft/world/item/crafting/RecipeSerializer.java
+++ b/src/main/java/net/minecraft/world/item/crafting/RecipeSerializer.java
@@ -25,7 +25,7 @@ public interface RecipeSerializer<T extends Recipe<?>> {
     SimpleCookingSerializer<BlastingRecipe> BLASTING_RECIPE = register("blasting", new SimpleCookingSerializer<>(BlastingRecipe::new, 100));
     SimpleCookingSerializer<SmokingRecipe> SMOKING_RECIPE = register("smoking", new SimpleCookingSerializer<>(SmokingRecipe::new, 100));
     SimpleCookingSerializer<CampfireCookingRecipe> CAMPFIRE_COOKING_RECIPE = register("campfire_cooking", new SimpleCookingSerializer<>(CampfireCookingRecipe::new, 100));
-    RecipeSerializer<StonecutterRecipe> STONECUTTER = register("stonecutting", new SingleItemRecipe.Serializer<>(StonecutterRecipe::new));
+    RecipeSerializer<StonecutterRecipe> STONECUTTER = register("stonecutting", new StonecutterRecipe.Serializer()); // Martijn - custom blocks and items
     RecipeSerializer<UpgradeRecipe> SMITHING = register("smithing", new UpgradeRecipe.Serializer());
 
     T fromJson(ResourceLocation id, JsonObject json);
diff --git a/src/main/java/net/minecraft/world/item/crafting/StonecutterRecipe.java b/src/main/java/net/minecraft/world/item/crafting/StonecutterRecipe.java
index 6d5803fcdd0a0b2d106745e9e6b859693b2aade2..2b90878913cbd3a5934cde6aaa4d3f0141f1028d 100644
--- a/src/main/java/net/minecraft/world/item/crafting/StonecutterRecipe.java
+++ b/src/main/java/net/minecraft/world/item/crafting/StonecutterRecipe.java
@@ -1,7 +1,14 @@
 package net.minecraft.world.item.crafting;
 
+import com.google.gson.JsonObject;
+import net.minecraft.core.Registry;
+import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.util.GsonHelper;
 import net.minecraft.world.Container;
+import net.minecraft.world.inventory.StonecutterMenu;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Blocks;
@@ -12,12 +19,23 @@ import org.bukkit.craftbukkit.inventory.CraftRecipe;
 import org.bukkit.craftbukkit.inventory.CraftStonecuttingRecipe;
 import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.inventory.Recipe;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 // CraftBukkit end
 
 public class StonecutterRecipe extends SingleItemRecipe {
 
+    private final boolean isCustom; // Martijn - custom blocks and items
+
     public StonecutterRecipe(ResourceLocation id, String group, Ingredient input, ItemStack output) {
+        // Martijn start - custom blocks and items
+        this(id, group, input, output, false);
+    }
+
+    public StonecutterRecipe(ResourceLocation id, String group, Ingredient input, ItemStack output, boolean isCustom) {
         super(RecipeType.STONECUTTING, RecipeSerializer.STONECUTTER, id, group, input, output);
+        this.isCustom = isCustom;
+        // Martijn end - custom blocks and items
     }
 
     @Override
@@ -41,4 +59,40 @@ public class StonecutterRecipe extends SingleItemRecipe {
         return recipe;
     }
     // CraftBukkit end
+
+    // Martijn start - custom blocks and items
+
+    @Override
+    public boolean shouldAlwaysSend() {
+        return !isCustom;
+    }
+
+    @Override
+    public boolean shouldSpecificallySend(@NotNull ServerPlayer player, @Nullable ItemStack stonecutterInput) {
+        if (!isCustom) {
+            return super.shouldSpecificallySend(player, stonecutterInput);
+        }
+        if (stonecutterInput == null) {
+            return false;
+        }
+        return player.containerMenu instanceof StonecutterMenu stonecutterMenu && this.ingredient.test(stonecutterInput);
+    }
+
+    public static class Serializer extends SingleItemRecipe.Serializer<StonecutterRecipe> {
+
+        protected Serializer() {
+            super(StonecutterRecipe::new);
+        }
+
+        @Override
+        public void toNetwork(FriendlyByteBuf buf, StonecutterRecipe recipe) {
+            buf.writeUtf(recipe.group);
+            recipe.ingredient.toNetwork(buf);
+            buf.writeItem(recipe.result, true);
+        }
+
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 94dd87584de8cf23ff8fc4396400ff39730709f0..d5cae13c0cdf4171541d43e512970ea2cdca34b1 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -1,10 +1,7 @@
 package net.minecraft.world.level;
 
-import co.aikar.timings.Timing;
-import co.aikar.timings.Timings;
 import com.destroystokyo.paper.event.server.ServerExceptionEvent;
 import com.destroystokyo.paper.exception.ServerInternalException;
-import com.google.common.base.MoreObjects;
 import com.google.common.collect.Lists;
 import com.mojang.serialization.Codec;
 import java.io.IOException;
@@ -17,7 +14,6 @@ import java.util.function.Supplier;
 import javax.annotation.Nullable;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
-import net.minecraft.ReportedException;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Holder;
@@ -40,8 +36,6 @@ import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.DifficultyInstance;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.boss.EnderDragonPart;
-import net.minecraft.world.entity.boss.enderdragon.EnderDragon;
 import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
@@ -89,18 +83,17 @@ import net.minecraft.network.protocol.game.ClientboundSetBorderLerpSizePacket;
 import net.minecraft.network.protocol.game.ClientboundSetBorderSizePacket;
 import net.minecraft.network.protocol.game.ClientboundSetBorderWarningDelayPacket;
 import net.minecraft.network.protocol.game.ClientboundSetBorderWarningDistancePacket;
+import nl.martijnmuijsers.paper.antixray.ChunkPacketBlockControllerAntiXrayCustom;
+import nl.martijnmuijsers.paper.antixray.ChunkPacketBlockControllerCustom;
 import org.bukkit.Bukkit;
-import org.bukkit.Location;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.block.CapturedBlockState;
 import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.craftbukkit.util.CraftSpawnCategory;
-import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.entity.SpawnCategory;
 import org.bukkit.event.block.BlockPhysicsEvent;
-import org.bukkit.event.world.GenericGameEvent;
 // CraftBukkit end
 
 public abstract class Level implements LevelAccessor, AutoCloseable {
@@ -374,7 +367,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         this.keepSpawnInMemory = this.paperConfig().spawn.keepSpawnLoaded; // Paper
         this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
         this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
-        this.chunkPacketBlockController = this.paperConfig().anticheat.antiXray.enabled ? new com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray(this, executor) : com.destroystokyo.paper.antixray.ChunkPacketBlockController.NO_OPERATION_INSTANCE; // Paper - Anti-Xray
+        this.chunkPacketBlockController = this.paperConfig().anticheat.antiXray.enabled ? new ChunkPacketBlockControllerAntiXrayCustom(this, executor) : new ChunkPacketBlockControllerCustom(this, executor); // Paper - Anti-Xray // Martijn - custom blocks and items
         this.entitySliceManager = new io.papermc.paper.world.EntitySliceManager((ServerLevel)this); // Paper
     }
 
diff --git a/src/main/java/net/minecraft/world/level/block/Block.java b/src/main/java/net/minecraft/world/level/block/Block.java
index 224ce424b9a22548212ac157ec273c6dd80d6cfb..4a6e1e7a8915f48edff111c3028fda68ac106cd8 100644
--- a/src/main/java/net/minecraft/world/level/block/Block.java
+++ b/src/main/java/net/minecraft/world/level/block/Block.java
@@ -6,10 +6,13 @@ import com.google.common.cache.LoadingCache;
 import com.google.common.collect.ImmutableMap;
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap;
+
+import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.function.Function;
 import java.util.function.Supplier;
+import java.util.stream.Stream;
 import javax.annotation.Nullable;
 import net.minecraft.SharedConstants;
 import net.minecraft.Util;
@@ -21,9 +24,11 @@ import net.minecraft.core.NonNullList;
 import net.minecraft.core.Registry;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.stats.Stats;
 import net.minecraft.tags.BlockTags;
+import net.minecraft.tags.TagKey;
 import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
 import net.minecraft.util.valueproviders.IntProvider;
@@ -41,6 +46,8 @@ import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.TooltipFlag;
 import net.minecraft.world.item.context.BlockPlaceContext;
+import net.minecraft.world.item.crafting.Ingredient;
+import net.minecraft.world.item.crafting.StonecutterRecipe;
 import net.minecraft.world.item.enchantment.EnchantmentHelper;
 import net.minecraft.world.item.enchantment.Enchantments;
 import net.minecraft.world.level.BlockGetter;
@@ -58,11 +65,15 @@ import net.minecraft.world.level.block.state.StateDefinition;
 import net.minecraft.world.level.block.state.properties.Property;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.storage.loot.LootContext;
+import net.minecraft.world.level.storage.loot.LootTable;
 import net.minecraft.world.level.storage.loot.parameters.LootContextParams;
 import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.phys.shapes.BooleanOp;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
+import nl.martijnmuijsers.paper.block.replacementrule.BlockReplacementRule;
+import org.bukkit.Tag;
+import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 
 public class Block extends BlockBehaviour implements ItemLike {
@@ -70,6 +81,25 @@ public class Block extends BlockBehaviour implements ItemLike {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Holder.Reference<Block> builtInRegistryHolder;
     public static final IdMapper<BlockState> BLOCK_STATE_REGISTRY = new IdMapper<>();
+    // Martijn start - custom blocks and items
+    public static final IdMapper<BlockState> BLOCK_STATE_REGISTRY_VANILLA = new IdMapper<>();
+    public static int[] stateIdReplacementArrayWithResourcePack;
+    public static int[] stateIdReplacementArrayWithoutResourcePack;
+    public static int[][] realStateToPlayerObservableStates;
+    public static void addRealStateToPlayerObservableStates(int realState, int playerObservableState) {
+        int[] existingPlayerObservableStates = realStateToPlayerObservableStates[realState];
+        for (int i = 0; i < existingPlayerObservableStates.length; i++) {
+            if (existingPlayerObservableStates[i] == playerObservableState) {
+                // Already present in the array
+                return;
+            }
+        }
+        int[] newPlayerObservableStates = new int[existingPlayerObservableStates.length + 1];
+        System.arraycopy(existingPlayerObservableStates, 0, newPlayerObservableStates, 0, existingPlayerObservableStates.length);
+        newPlayerObservableStates[existingPlayerObservableStates.length] = playerObservableState;
+        realStateToPlayerObservableStates[realState] = newPlayerObservableStates;
+    }
+    // Martijn end - custom blocks and items
     private static final LoadingCache<VoxelShape, Boolean> SHAPE_FULL_BLOCK_CACHE = CacheBuilder.newBuilder().maximumSize(512L).weakKeys().build(new CacheLoader<VoxelShape, Boolean>() {
         public Boolean load(VoxelShape voxelshape) {
             return !Shapes.joinIsNotEmpty(Shapes.block(), voxelshape, BooleanOp.NOT_SAME);
@@ -127,6 +157,171 @@ public class Block extends BlockBehaviour implements ItemLike {
         return object2bytelinkedopenhashmap;
     });
 
+    // Martijn start - custom blocks and items
+
+    public boolean isVanilla = true;
+
+    /**
+     * This is the {@link ResourceLocation} for this block
+     * <br>
+     * Must be non-null for SuCraft blocks
+     */
+    public @Nullable ResourceLocation customKey;
+
+    /**
+     * This is the {@link ResourceLocation} for this item
+     * <br>
+     * Will always be non-null after it has been registered
+     */
+    public @Nullable ResourceLocation id;
+
+    public @Nullable Item customItemForBlock = null;
+
+    /**
+     * Must be non-null for SuCraft blocks
+     */
+    public @Nullable BlockReplacementRule replacementRule = null;
+
+    public @Nullable String customFireType;
+
+    public @Nullable Supplier<@org.jetbrains.annotations.Nullable LootTable> customLootTableSupplier = null;
+
+    public @Nullable LootTable createCustomLootTable() {
+        if (this.customLootTableSupplier == null) {
+            return null;
+        }
+        return this.customLootTableSupplier.get();
+    }
+
+    public @NotNull List<@NotNull Supplier<@NotNull TagKey<Block>>> tagsToAddSuppliers = new ArrayList<>();
+
+    public @NotNull Block withTag(@NotNull Supplier<@NotNull TagKey<Block>> tagToAddSupplier) {
+        this.tagsToAddSuppliers.add(tagToAddSupplier);
+        return this;
+    }
+
+    // Tags that influence block breaking
+
+    public @NotNull Block mineableWithAxe() {
+        return this.withTag(() -> BlockTags.MINEABLE_WITH_AXE);
+    }
+
+    public @NotNull Block mineableWithHoe() {
+        return this.withTag(() -> BlockTags.MINEABLE_WITH_HOE);
+    }
+
+    public @NotNull Block mineableWithPickaxe() {
+        return this.withTag(() -> BlockTags.MINEABLE_WITH_PICKAXE);
+    }
+
+    public @NotNull Block mineableWithShovel() {
+        return this.withTag(() -> BlockTags.MINEABLE_WITH_SHOVEL);
+    }
+
+    public @NotNull Block leaves() {
+        return this.withTag(() -> BlockTags.LEAVES);
+    }
+
+    public @NotNull Block wool() {
+        return this.withTag(() -> BlockTags.WOOL);
+    }
+
+    // Other tags
+
+    public @NotNull Block planks() {
+        return this.withTag(() -> BlockTags.PLANKS);
+    }
+
+    public @NotNull Block stoneBricks() {
+        return this.withTag(() -> BlockTags.STONE_BRICKS);
+    }
+
+    public @NotNull Block slab() {
+        return this.withTag(() -> BlockTags.SLABS);
+    }
+
+    public @NotNull Block stairs() {
+        return this.withTag(() -> BlockTags.STAIRS);
+    }
+
+    public @NotNull Block woodenSlab() {
+        return this.withTag(() -> BlockTags.WOODEN_SLABS).slab();
+    }
+
+    public @NotNull Block woodenStairs() {
+        return this.withTag(() -> BlockTags.WOODEN_STAIRS).stairs();
+    }
+
+    public @NotNull Block dirt() {
+        return this.withTag(() -> BlockTags.DIRT);
+    }
+
+    public @NotNull Block soulSpeed() {
+        return this.withTag(() -> BlockTags.SOUL_SPEED_BLOCKS);
+    }
+
+    public @NotNull Block soulFireBase() {
+        return this.withTag(() -> BlockTags.SOUL_FIRE_BASE_BLOCKS);
+    }
+
+    public @NotNull Block guardedByPiglins() {
+        return this.withTag(() -> BlockTags.GUARDED_BY_PIGLINS);
+    }
+
+    public @NotNull Block withAddedTagsLike(@NotNull Block block) {
+        this.tagsToAddSuppliers.addAll(block.tagsToAddSuppliers);
+        return this;
+    }
+
+    public boolean breakBeforeClientKnowsToBreak = false;
+
+    public @NotNull Block breakBeforeClientKnowsToBreak() {
+        this.breakBeforeClientKnowsToBreak = true;
+        return this;
+    }
+
+    // Crafting recipes
+
+    public record CustomStonecutterRecipe(@NotNull ResourceLocation key, @Nullable String group, @NotNull Block ingredient, int resultAmount) {}
+
+    public @NotNull List<@NotNull CustomStonecutterRecipe> customStonecutterRecipes = new ArrayList<>(0);
+
+    public @NotNull Block withCustomStonecutterRecipe(@NotNull CustomStonecutterRecipe recipe) {
+        if (!this.customStonecutterRecipes.stream().anyMatch(existingRecipe -> existingRecipe.ingredient.equals(recipe.ingredient))) {
+            this.customStonecutterRecipes.add(recipe);
+        }
+        return this;
+    }
+
+    public @NotNull Block withCustomStonecutterRecipe(@NotNull Block ingredient, @Nullable String group, int resultAmount, boolean transitive) {
+        @NotNull String uniqueRecipeDescription = id.getPath() + "_from_" + ingredient.id.getPath() + "_stonecutting";
+        this.withCustomStonecutterRecipe(new CustomStonecutterRecipe(ResourceLocation.sucraft(uniqueRecipeDescription), group, ingredient, resultAmount));
+        if (transitive) {
+            for (CustomStonecutterRecipe transitiveRecipe : ingredient.customStonecutterRecipes) {
+                this.withCustomStonecutterRecipe(transitiveRecipe.ingredient(), null, resultAmount * transitiveRecipe.resultAmount(), true);
+            }
+        }
+        return this;
+    }
+
+    public @NotNull Block withCustomSlabStonecutterRecipe(@NotNull Block ingredient, @Nullable String group, boolean transitive) {
+        return this.withCustomStonecutterRecipe(ingredient, group, 2, transitive);
+    }
+
+    public @NotNull Block withCustomSlabStonecutterRecipe(@NotNull Block ingredient) {
+        return this.withCustomSlabStonecutterRecipe(ingredient, null, true);
+    }
+
+    public @NotNull Block withCustomOneToOneStonecutterRecipe(@NotNull Block ingredient, @Nullable String group, boolean transitive) {
+        return this.withCustomStonecutterRecipe(ingredient, group, 1, transitive);
+    }
+
+    public @NotNull Block withCustomOneToOneStonecutterRecipe(@NotNull Block ingredient) {
+        return this.withCustomOneToOneStonecutterRecipe(ingredient, null, true);
+    }
+
+    // Martijn end - custom blocks and items
+
     public static int getId(@Nullable BlockState state) {
         if (state == null) {
             return 0;
@@ -639,4 +834,14 @@ public class Block extends BlockBehaviour implements ItemLike {
             return i;
         }
     }
+
+    // Martijn start - custom blocks and items
+
+    public void updateDestroyTime(float destroyTime) {
+        this.properties.destroyTime(destroyTime);
+        this.getStateDefinition().getPossibleStates().forEach(state -> state.destroySpeed = destroyTime);
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/world/level/block/Blocks.java b/src/main/java/net/minecraft/world/level/block/Blocks.java
index 5b5086f4016fc9015ac53bafd2c80bc724d575e4..1a95ca57cf674e1e07d4ccafcdc695543d0500c8 100644
--- a/src/main/java/net/minecraft/world/level/block/Blocks.java
+++ b/src/main/java/net/minecraft/world/level/block/Blocks.java
@@ -7,6 +7,7 @@ import net.minecraft.core.Registry;
 import net.minecraft.core.cauldron.CauldronInteraction;
 import net.minecraft.core.particles.ParticleTypes;
 import net.minecraft.data.worldgen.features.TreeFeatures;
+import net.minecraft.resources.ResourceLocation;
 import net.minecraft.util.valueproviders.UniformInt;
 import net.minecraft.world.effect.MobEffects;
 import net.minecraft.world.entity.EntityType;
@@ -34,6 +35,7 @@ import net.minecraft.world.level.block.state.properties.WoodType;
 import net.minecraft.world.level.material.Fluids;
 import net.minecraft.world.level.material.Material;
 import net.minecraft.world.level.material.MaterialColor;
+import nl.martijnmuijsers.paper.block.SuCraftBlocks;
 import org.jetbrains.annotations.NotNull;
 
 public class Blocks {
@@ -1095,7 +1097,7 @@ public class Blocks {
         return (boolean)true;
     }
 
-    private static Boolean ocelotOrParrot(BlockState state, BlockGetter world, BlockPos pos, EntityType<?> type) {
+    public static Boolean ocelotOrParrot(BlockState state, BlockGetter world, BlockPos pos, EntityType<?> type) { // Martijn - custom blocks and items
         return type == EntityType.OCELOT || type == EntityType.PARROT;
     }
 
@@ -1142,7 +1144,7 @@ public class Blocks {
         return true;
     }
 
-    private static boolean never(BlockState state, BlockGetter world, BlockPos pos) {
+    public static boolean never(BlockState state, BlockGetter world, BlockPos pos) { // Martijn - custom blocks and items
         return false;
     }
 
@@ -1150,7 +1152,7 @@ public class Blocks {
         return new StainedGlassBlock(color, BlockBehaviour.Properties.of(Material.GLASS, color).strength(0.3F).sound(SoundType.GLASS).noOcclusion().isValidSpawn(Blocks::never).isRedstoneConductor(Blocks::never).isSuffocating(Blocks::never).isViewBlocking(Blocks::never));
     }
 
-    private static LeavesBlock leaves(SoundType soundGroup) {
+    public static LeavesBlock leaves(SoundType soundGroup) {
         return new LeavesBlock(BlockBehaviour.Properties.of(Material.LEAVES).strength(0.2F).randomTicks().sound(soundGroup).noOcclusion().isValidSpawn(Blocks::ocelotOrParrot).isSuffocating(Blocks::never).isViewBlocking(Blocks::never));
     }
 
@@ -1174,6 +1176,7 @@ public class Blocks {
     }
 
     private static Block register(String id, Block block) {
+        block.id = new ResourceLocation(id); // Martijn - custom blocks and items
         return Registry.register(Registry.BLOCK, id, block);
     }
 
@@ -1182,13 +1185,60 @@ public class Blocks {
     }
 
     static {
+        // Martijn start - custom blocks and items
+        // Evaluate the last element to bootstrap Blocks
+        REINFORCED_DEEPSLATE.asBlock();
+        // Then bootstrap SuCraftBlocks
+        SuCraftBlocks.bootstrap();
+        // Martijn end - custom blocks and items
         for(Block block : Registry.BLOCK) {
             for(BlockState blockState : block.getStateDefinition().getPossibleStates()) {
                 Block.BLOCK_STATE_REGISTRY.add(blockState);
+                // Martijn start - custom blocks and items
+                if (block.isVanilla) {
+                    Block.BLOCK_STATE_REGISTRY_VANILLA.add(blockState);
+                }
+                // Martijn end - custom blocks and items
             }
 
             block.getLootTable();
         }
 
+        // Martijn start - custom blocks and items
+
+        // Initialize the global state replacement arrays so we can populate them
+        Block.stateIdReplacementArrayWithResourcePack = new int[Block.BLOCK_STATE_REGISTRY.size()];
+        Block.stateIdReplacementArrayWithoutResourcePack = new int[Block.BLOCK_STATE_REGISTRY.size()];
+        // Initialize the global state replacement arrays with identities (aka no replacement is done)
+        for (int id = 0; id < Block.BLOCK_STATE_REGISTRY.size(); id++) {
+            Block.stateIdReplacementArrayWithResourcePack[id] = id;
+            Block.stateIdReplacementArrayWithoutResourcePack[id] = id;
+        }
+        // Initialize the global real state to observable states arrays with empty arrays
+        Block.realStateToPlayerObservableStates = new int[Block.BLOCK_STATE_REGISTRY.size()][];
+        for (int id = 0; id < Block.BLOCK_STATE_REGISTRY.size(); id++) {
+            Block.realStateToPlayerObservableStates[id] = new int[0];
+        }
+        // Then overwrite them where necessary with all the needed replacements
+        for (Block block : Registry.BLOCK) {
+            if (block.replacementRule != null) {
+                block.replacementRule.writeToStateIdReplacementArrays();
+            }
+        }
+        // Special case: we want to make sure we replace (for players with the resource pack) all fire states with age greater than 0 to age 0 (due to the way we write the fire blockstates asset)
+        for (BlockState fireBlockState : Blocks.FIRE.getStateDefinition().getPossibleStates()) {
+            int id = Block.BLOCK_STATE_REGISTRY.getId(fireBlockState);
+            if (Block.stateIdReplacementArrayWithResourcePack[id] == id && fireBlockState.getValue(BlockStateProperties.AGE_15) > 0) { // If not replaced yet before and with age greater than 0
+                Block.stateIdReplacementArrayWithResourcePack[id] = Block.BLOCK_STATE_REGISTRY.getId(Blocks.FIRE.withPropertiesOf(fireBlockState).setValue(BlockStateProperties.AGE_15, 0));
+            }
+        }
+        // TEMP TODO REMOVE
+//        for (BlockState state : Blocks.NOTE_BLOCK.getStateDefinition().getPossibleStates()) {
+//            if (!state.equals(Blocks.NOTE_BLOCK.defaultBlockState())) {
+//                Block.stateIdReplacementArrayWithResourcePack[Block.BLOCK_STATE_REGISTRY.getId(state)] = Block.BLOCK_STATE_REGISTRY.getId(Blocks.NOTE_BLOCK.defaultBlockState());
+//            }
+//        }
+
+        // Martijn end - custom blocks and items
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/block/InfestedBlock.java b/src/main/java/net/minecraft/world/level/block/InfestedBlock.java
index f33033c99ac52e2c64adeb8c58ae87625e92b299..423e5bcd3ea481f20abac1ddc5d2aaad730da4d4 100644
--- a/src/main/java/net/minecraft/world/level/block/InfestedBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/InfestedBlock.java
@@ -5,6 +5,7 @@ import java.util.Iterator;
 import java.util.Map;
 import java.util.function.Supplier;
 import net.minecraft.core.BlockPos;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.monster.Silverfish;
@@ -25,7 +26,13 @@ public class InfestedBlock extends Block {
     private static final Map<BlockState, BlockState> INFESTED_TO_HOST_STATES = Maps.newIdentityHashMap();
 
     public InfestedBlock(Block regularBlock, BlockBehaviour.Properties settings) {
-        super(settings.destroyTime(regularBlock.defaultDestroyTime() / 2.0F).explosionResistance(0.75F));
+        // Martijn start - custom block and items
+        this(regularBlock, settings, true);
+    }
+
+    public InfestedBlock(Block regularBlock, BlockBehaviour.Properties settings, boolean halveDestroyTime) { // If we create infested blocks from custom blocks, it may be that their destroy time was already halved (due to being observable as an infested block by players) in which case we can set the halveDestroyTime flag to false, to prevent repeated halving
+        super(settings.destroyTime(halveDestroyTime ? regularBlock.defaultDestroyTime() / 2.0F : regularBlock.defaultDestroyTime()).explosionResistance(0.75F));
+        // Martijn end - custom block and items
         this.hostBlock = regularBlock;
         InfestedBlock.BLOCK_BY_HOST_BLOCK.put(regularBlock, this);
     }
diff --git a/src/main/java/net/minecraft/world/level/block/NoteBlock.java b/src/main/java/net/minecraft/world/level/block/NoteBlock.java
index c14eb4f7decdbcd6176d3bff95d595a947d4ec95..67c14254c1fca29290437c0335a113119ca7140e 100644
--- a/src/main/java/net/minecraft/world/level/block/NoteBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/NoteBlock.java
@@ -70,7 +70,7 @@ public class NoteBlock extends Block {
             // CraftBukkit end
             // Paper - TODO any way to cancel the game event?
             world.blockEvent(blockposition, this, 0, 0);
-            world.gameEvent(entity, GameEvent.NOTE_BLOCK_PLAY, blockposition);
+            //world.gameEvent(entity, GameEvent.NOTE_BLOCK_PLAY, blockposition); // Martijn - custom blocks and items
         }
 
     }
diff --git a/src/main/java/net/minecraft/world/level/block/StairBlock.java b/src/main/java/net/minecraft/world/level/block/StairBlock.java
index 827713a332baa6d280cd61d40faf8f6243b3b08c..d0a0b1f696441c8ebcda8cc96a33fae3764e89cc 100644
--- a/src/main/java/net/minecraft/world/level/block/StairBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/StairBlock.java
@@ -81,7 +81,7 @@ public class StairBlock extends Block implements SimpleWaterloggedBlock {
         return voxelShape;
     }
 
-    protected StairBlock(BlockState baseBlockState, BlockBehaviour.Properties settings) {
+    public StairBlock(BlockState baseBlockState, BlockBehaviour.Properties settings) { // Martijn - custom blocks and items
         super(settings);
         this.registerDefaultState(this.stateDefinition.any().setValue(FACING, Direction.NORTH).setValue(HALF, Half.BOTTOM).setValue(SHAPE, StairsShape.STRAIGHT).setValue(WATERLOGGED, Boolean.valueOf(false)));
         this.base = baseBlockState.getBlock();
diff --git a/src/main/java/net/minecraft/world/level/block/StonecutterBlock.java b/src/main/java/net/minecraft/world/level/block/StonecutterBlock.java
index 0a95842c53a9d0286c57bcb42db97e468e30fb7d..52e1e78adc7c3fe69edb9eec0242a4e3819e074b 100644
--- a/src/main/java/net/minecraft/world/level/block/StonecutterBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/StonecutterBlock.java
@@ -25,7 +25,7 @@ import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.VoxelShape;
 
 public class StonecutterBlock extends Block {
-    private static final Component CONTAINER_TITLE = Component.translatable("container.stonecutter");
+    private static final Component CONTAINER_TITLE = Component.literal("Blockcutter")/*Component.translatable("container.stonecutter")*/; // Martijn - custom blocks and items
     public static final DirectionProperty FACING = HorizontalDirectionalBlock.FACING;
     protected static final VoxelShape SHAPE = Block.box(0.0D, 0.0D, 0.0D, 16.0D, 9.0D, 16.0D);
 
diff --git a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
index e8eb061181e9b5e6bde99253079864626bc8ad4b..23b6f79c868484421b8ee80dd2ec0e09b1b18183 100644
--- a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
+++ b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
@@ -18,6 +18,7 @@ import net.minecraft.core.HolderSet;
 import net.minecraft.core.Registry;
 import net.minecraft.network.protocol.game.DebugPackets;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.tags.FluidTags;
 import net.minecraft.tags.TagKey;
@@ -83,7 +84,7 @@ public abstract class BlockBehaviour {
     protected final float speedFactor;
     protected final float jumpFactor;
     protected final boolean dynamicShape;
-    protected final BlockBehaviour.Properties properties;
+    public final BlockBehaviour.Properties properties; // Martijn - custom blocks and items
     @Nullable
     protected ResourceLocation drops;
 
@@ -370,7 +371,7 @@ public abstract class BlockBehaviour {
         if (f == -1.0F) {
             return 0.0F;
         } else {
-            int i = player.hasCorrectToolForDrops(state) ? 30 : 100;
+            int i = player.hasCorrectToolForFasterBreaking(state) ? 30 : 100; // Martijn - custom blocks and items
 
             return player.getDestroySpeed(state) / f / (float) i;
         }
@@ -434,7 +435,7 @@ public abstract class BlockBehaviour {
         SoundType soundType;
         ToIntFunction<BlockState> lightEmission;
         float explosionResistance;
-        float destroyTime;
+        public float destroyTime; // Martijn - custom blocks and items
         boolean requiresCorrectToolForDrops;
         boolean isRandomlyTicking;
         float friction;
@@ -637,6 +638,15 @@ public abstract class BlockBehaviour {
             return this;
         }
 
+        // Martijn start - custom blocks and items
+
+        public BlockBehaviour.Properties doesNotRequireCorrectToolForDrops() {
+            this.requiresCorrectToolForDrops = false;
+            return this;
+        }
+
+        // Martijn end - custom blocks and items
+
         public BlockBehaviour.Properties color(MaterialColor color) {
             this.materialColor = (iblockdata) -> {
                 return color;
@@ -693,7 +703,7 @@ public abstract class BlockBehaviour {
         private final boolean isAir;
         private final Material material;
         private final MaterialColor materialColor;
-        public final float destroySpeed;
+        public float destroySpeed; // Martijn - custom blocks and items
         private final boolean requiresCorrectToolForDrops;
         private final boolean canOcclude;
 
@@ -1185,6 +1195,25 @@ public abstract class BlockBehaviour {
             return this.requiresCorrectToolForDrops;
         }
 
+        // Martijn start - custom blocks and items
+
+        public boolean requiresCorrectToolForFasterBreaking(boolean doPlayerObservableLookups) {
+            if (!this.requiresCorrectToolForDrops()) {
+                return false;
+            }
+            if (doPlayerObservableLookups) {
+                for (int playerObservableStateId : Block.realStateToPlayerObservableStates[Block.BLOCK_STATE_REGISTRY.getId(this.asState())]) {
+                    net.minecraft.world.level.block.state.BlockState playerObservableState = Block.BLOCK_STATE_REGISTRY.byId(playerObservableStateId);
+                    if (!playerObservableState.requiresCorrectToolForFasterBreaking(false)) {
+                        return false;
+                    }
+                }
+            }
+            return true;
+        }
+
+        // Martijn end - custom blocks and items
+
         public BlockBehaviour.OffsetType getOffsetType() {
             return this.offsetType;
         }
diff --git a/src/main/java/net/minecraft/world/level/block/state/StateHolder.java b/src/main/java/net/minecraft/world/level/block/state/StateHolder.java
index 340d0648fcf9b9749c4daa1c25a226b947707c3d..d3033f13b92966d6b40853e64f096ab03efcc567 100644
--- a/src/main/java/net/minecraft/world/level/block/state/StateHolder.java
+++ b/src/main/java/net/minecraft/world/level/block/state/StateHolder.java
@@ -81,6 +81,19 @@ public abstract class StateHolder<O, S> {
         return stringBuilder.toString();
     }
 
+    // Martijn start - custom blocks and items
+
+    public String toVariantString() {
+        // Based on StateHolder.toString
+        StringBuilder stringBuilder = new StringBuilder();
+        if (!this.getValues().isEmpty()) {
+            stringBuilder.append(this.getValues().entrySet().stream().map(PROPERTY_ENTRY_TO_STRING_FUNCTION).collect(Collectors.joining(",")));
+        }
+        return stringBuilder.toString();
+    }
+
+    // Martijn end - custom blocks and items
+
     public Collection<Property<?>> getProperties() {
         return Collections.unmodifiableCollection(this.values.keySet());
     }
diff --git a/src/main/java/net/minecraft/world/level/chunk/HashMapPalette.java b/src/main/java/net/minecraft/world/level/chunk/HashMapPalette.java
index ba9b0f419b0785a0b1e3bc57f18bfe5edaa192bd..b21d11d08f7b69240e416bee1a7a2f0be49d627a 100644
--- a/src/main/java/net/minecraft/world/level/chunk/HashMapPalette.java
+++ b/src/main/java/net/minecraft/world/level/chunk/HashMapPalette.java
@@ -11,7 +11,7 @@ public class HashMapPalette<T> implements Palette<T> {
     private final IdMap<T> registry;
     private final CrudeIncrementalIntIdentityHashBiMap<T> values;
     private final PaletteResize<T> resizeHandler;
-    private final int bits;
+    public final int bits; // Martijn - custom blocks and items
 
     public HashMapPalette(IdMap<T> idList, int bits, PaletteResize<T> listener, List<T> entries) {
         this(idList, bits, listener);
@@ -90,7 +90,7 @@ public class HashMapPalette<T> implements Palette<T> {
         buf.writeVarInt(i);
 
         for(int j = 0; j < i; ++j) {
-            buf.writeVarInt(this.registry.getId(this.values.byId(j)));
+            buf.writeVarIntThreeBytes(this.registry.getId(this.values.byId(j))); // Martijn - custom blocks and items
         }
 
     }
@@ -99,9 +99,7 @@ public class HashMapPalette<T> implements Palette<T> {
     public int getSerializedSize() {
         int i = FriendlyByteBuf.getVarIntSize(this.getSize());
 
-        for(int j = 0; j < this.getSize(); ++j) {
-            i += FriendlyByteBuf.getVarIntSize(this.registry.getId(this.values.byId(j)));
-        }
+        i += this.getSize() * 3; // Martijn - custom blocks and items
 
         return i;
     }
@@ -121,4 +119,13 @@ public class HashMapPalette<T> implements Palette<T> {
     public Palette<T> copy() {
         return new HashMapPalette<>(this.registry, this.bits, this.resizeHandler, this.values.copy());
     }
+
+    // Martijn start - custom blocks and items
+
+    public HashMapPalette<T> copyBlank(List<T> entries) {
+        return new HashMapPalette<>(this.registry, this.bits, (newSize, added) -> 0, entries);
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
index 9465b2ab698362824f837abfd824e8f48fe3235c..8b6f2fa03098e3b26d40c8baa6af66ce40347ec1 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
@@ -330,4 +330,27 @@ public class LevelChunkSection {
 
         this.biomes = datapaletteblock;
     }
+
+    // Martijn start - custom blocks and entities
+
+    public boolean potentiallyContainsBlockEntity() {
+        boolean[] potentiallyContainsBlockEntity = { false };
+        this.getStates().getAllEarlyStop(stateInSection -> {
+            Block block = stateInSection.getBlock();
+            var replacementRule = block.replacementRule;
+            if (replacementRule != null) {
+                if (replacementRule.hasAsReal(block)) {
+                    if (replacementRule.rendersAsEntity()) {
+                        potentiallyContainsBlockEntity[0] = true;
+                        return true;
+                    }
+                }
+            }
+            return false;
+        });
+        return potentiallyContainsBlockEntity[0];
+    }
+
+    // Martijn end - custom blocks and entities
+
 }
diff --git a/src/main/java/net/minecraft/world/level/chunk/LinearPalette.java b/src/main/java/net/minecraft/world/level/chunk/LinearPalette.java
index fb65457bc03a24b5f67e8eef538da8d6c2aabd6e..1732975254176f19f80d3563488b7f30959dbbff 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LinearPalette.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LinearPalette.java
@@ -10,7 +10,7 @@ public class LinearPalette<T> implements Palette<T> {
     private final IdMap<T> registry;
     private final T[] values;
     private final PaletteResize<T> resizeHandler;
-    private final int bits;
+    public final int bits; // Martijn start - custom blocks and items
     private int size;
 
     private LinearPalette(IdMap<T> idList, int bits, PaletteResize<T> listener, List<T> list) {
@@ -92,7 +92,7 @@ public class LinearPalette<T> implements Palette<T> {
         buf.writeVarInt(this.size);
 
         for(int i = 0; i < this.size; ++i) {
-            buf.writeVarInt(this.registry.getId(this.values[i]));
+            buf.writeVarIntThreeBytes(this.registry.getId(this.values[i])); // Martijn - custom blocks and items
         }
 
     }
@@ -101,9 +101,7 @@ public class LinearPalette<T> implements Palette<T> {
     public int getSerializedSize() {
         int i = FriendlyByteBuf.getVarIntSize(this.getSize());
 
-        for(int j = 0; j < this.getSize(); ++j) {
-            i += FriendlyByteBuf.getVarIntSize(this.registry.getId(this.values[j]));
-        }
+        i += this.getSize() * 3; // Martijn - custom blocks and items
 
         return i;
     }
@@ -117,4 +115,13 @@ public class LinearPalette<T> implements Palette<T> {
     public Palette<T> copy() {
         return new LinearPalette<>(this.registry, (T[])((Object[])this.values.clone()), this.resizeHandler, this.bits, this.size);
     }
+
+    // Martijn start - custom blocks and items
+
+    public LinearPalette<T> copyBlank(List<T> entries) {
+        return new LinearPalette<>(this.registry, this.bits, (newSize, added) -> 0, entries);
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
index 08e1309e618377d170c446a1568c21b7bf4e5683..52e0c97ca4e83ecab61b4c1a5247c325e1f5f550 100644
--- a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
+++ b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
@@ -219,6 +219,21 @@ public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainer
         });
     }
 
+    // Martijn start - custom blocks and items
+
+    public void getAllEarlyStop(Predicate<T> whetherToStop) {
+        Palette<T> palette = this.data.palette();
+        IntSet intSet = new IntArraySet();
+        this.data.storage.getAll(intSet::add);
+        for (int id : intSet) {
+            if (whetherToStop.test(palette.valueFor(id))) {
+                break;
+            }
+        }
+    }
+
+    // Martijn end - custom blocks and items
+
     public synchronized void read(FriendlyByteBuf buf) { // Paper - synchronize
         this.acquire();
 
@@ -374,7 +389,7 @@ public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainer
         }
     }
 
-    static record Configuration<T>(Palette.Factory factory, int bits) {
+    public static record Configuration<T>(Palette.Factory factory, int bits) { // Martijn - custom blocks and items
         public PalettedContainer.Data<T> createData(IdMap<T> idList, PaletteResize<T> listener, int size) {
             BitStorage bitStorage = (BitStorage)(this.bits == 0 ? new ZeroBitStorage(size) : new SimpleBitStorage(this.bits, size));
             Palette<T> palette = this.factory.create(this.bits, idList, listener, List.of());
@@ -411,6 +426,12 @@ public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainer
         // Paper start - Anti-Xray - Add chunk packet info
         public void write(FriendlyByteBuf buf, @Nullable com.destroystokyo.paper.antixray.ChunkPacketInfo<T> chunkPacketInfo, int bottomBlockY) {
             buf.writeByte(this.storage.getBits());
+            // Martijn start - custom blocks and items
+            if (chunkPacketInfo != null) {
+                int chunkSectionIndex = (bottomBlockY >> 4) - chunkPacketInfo.getChunk().getMinSection();
+                chunkPacketInfo.setPaletteIndex(chunkSectionIndex, buf.writerIndex());
+            }
+            // Martijn end - custom blocks and items
             this.palette.write(buf);
 
             if (chunkPacketInfo != null) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/SingleValuePalette.java b/src/main/java/net/minecraft/world/level/chunk/SingleValuePalette.java
index 76cfa5797a71df34c7b933798815863f437debcd..f7b8bcbc27c52176b68dcd558531ec8349f06bec 100644
--- a/src/main/java/net/minecraft/world/level/chunk/SingleValuePalette.java
+++ b/src/main/java/net/minecraft/world/level/chunk/SingleValuePalette.java
@@ -8,12 +8,12 @@ import net.minecraft.network.FriendlyByteBuf;
 import org.apache.commons.lang3.Validate;
 
 public class SingleValuePalette<T> implements Palette<T> {
-    private final IdMap<T> registry;
+    public final IdMap<T> registry; // Martijn - custom blocks and items
     @Nullable
     private T value;
-    private final PaletteResize<T> resizeHandler;
+    private final @Nullable PaletteResize<T> resizeHandler; // Martijn - custom blocks and items
 
-    public SingleValuePalette(IdMap<T> idList, PaletteResize<T> listener, List<T> entries) {
+    public SingleValuePalette(IdMap<T> idList, @Nullable PaletteResize<T> listener, List<T> entries) { // Martijn - custom blocks and items
         this.registry = idList;
         this.resizeHandler = listener;
         if (entries.size() > 0) {
@@ -23,13 +23,18 @@ public class SingleValuePalette<T> implements Palette<T> {
 
     }
 
-    public static <A> Palette<A> create(int bitSize, IdMap<A> idList, PaletteResize<A> listener, List<A> entries) {
+    public static <A> Palette<A> create(int bitSize, IdMap<A> idList, @Nullable PaletteResize<A> listener, List<A> entries) { // Martijn - custom blocks and items
         return new SingleValuePalette<>(idList, listener, entries);
     }
 
     @Override
     public int idFor(T object) {
         if (this.value != null && this.value != object) {
+            // Martijn start - custom blocks and items
+            if (this.resizeHandler == null) {
+                throw new IllegalStateException("Tried to expand SingleValuePalette without a resizeHandler");
+            }
+            // Martijn end - custom blocks and items
             return this.resizeHandler.onResize(1, object);
         } else {
             this.value = object;
@@ -65,7 +70,7 @@ public class SingleValuePalette<T> implements Palette<T> {
         if (this.value == null) {
             throw new IllegalStateException("Use of an uninitialized palette");
         } else {
-            buf.writeVarInt(this.registry.getId(this.value));
+            buf.writeVarIntThreeBytes(this.registry.getId(this.value)); // Martijn - custom blocks and items
         }
     }
 
@@ -74,7 +79,7 @@ public class SingleValuePalette<T> implements Palette<T> {
         if (this.value == null) {
             throw new IllegalStateException("Use of an uninitialized palette");
         } else {
-            return FriendlyByteBuf.getVarIntSize(this.registry.getId(this.value));
+            return 3; // Martijn - custom blocks and items
         }
     }
 
@@ -91,4 +96,13 @@ public class SingleValuePalette<T> implements Palette<T> {
             return this;
         }
     }
+
+    // Martijn start - custom blocks and items
+
+    public SingleValuePalette<T> copyBlank(List<T> entries) {
+        return new SingleValuePalette<>(this.registry, (newSize, added) -> 0, entries);
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/world/level/storage/loot/LootTables.java b/src/main/java/net/minecraft/world/level/storage/loot/LootTables.java
index aef7198ca8b781d02204098811086b25050ab262..c51bd7abafdb609c9e4086b33e6210f1f1f9ba74 100644
--- a/src/main/java/net/minecraft/world/level/storage/loot/LootTables.java
+++ b/src/main/java/net/minecraft/world/level/storage/loot/LootTables.java
@@ -9,12 +9,17 @@ import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
 import java.util.function.Function;
+
+import net.minecraft.core.Registry;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.packs.resources.ResourceManager;
 import net.minecraft.server.packs.resources.SimpleJsonResourceReloadListener;
 import net.minecraft.util.profiling.ProfilerFiller;
+import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.storage.loot.parameters.LootContextParamSet;
 import net.minecraft.world.level.storage.loot.parameters.LootContextParamSets;
+import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
 
 public class LootTables extends SimpleJsonResourceReloadListener {
@@ -52,6 +57,16 @@ public class LootTables extends SimpleJsonResourceReloadListener {
             }
 
         });
+        // Martijn start - custom blocks and items
+        for (Block block : Registry.BLOCK) {
+            @Nullable LootTable customLootTable = block.createCustomLootTable();
+            if (customLootTable != null) {
+                // The below is taken from
+                var lootTableKey = block.getLootTable();
+                builder.put(lootTableKey, customLootTable);
+            }
+        }
+        // Martijn end - custom blocks and items
         builder.put(BuiltInLootTables.EMPTY, LootTable.EMPTY);
         ImmutableMap<ResourceLocation, LootTable> immutablemap = builder.build();
         LootContextParamSet lootcontextparameterset = LootContextParamSets.ALL_PARAMS;
diff --git a/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerAntiXrayCustom.java b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerAntiXrayCustom.java
new file mode 100644
index 0000000000000000000000000000000000000000..8437ad716fc469e43579c7197aad7b541162a48e
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerAntiXrayCustom.java
@@ -0,0 +1,29 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.antixray;
+
+import com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray;
+import com.destroystokyo.paper.antixray.ChunkPacketInfoAntiXray;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.chunk.LevelChunk;
+import java.util.concurrent.Executor;
+
+public final class ChunkPacketBlockControllerAntiXrayCustom extends ChunkPacketBlockControllerAntiXray {
+
+    public ChunkPacketBlockControllerAntiXrayCustom(Level level, Executor executor) {
+        super(level, executor);
+    }
+
+    @Override
+    public boolean shouldModify(ServerPlayer player, LevelChunk chunk) {
+        return true;
+    }
+
+    @Override
+    public void obfuscateInternal(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        obfuscateXray(chunkPacketInfoAntiXray);
+        ChunkPacketBlockControllerCustom.replaceCustom(chunkPacketInfoAntiXray);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerCustom.java b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerCustom.java
new file mode 100644
index 0000000000000000000000000000000000000000..d2ffa53275aee4a582e88f3560244b5a2e7da901
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerCustom.java
@@ -0,0 +1,205 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.antixray;
+
+import com.destroystokyo.paper.antixray.BitStorageReader;
+import com.destroystokyo.paper.antixray.BitStorageWriter;
+import com.destroystokyo.paper.antixray.ChunkPacketInfoAntiXray;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import it.unimi.dsi.fastutil.ints.Int2IntArrayMap;
+import it.unimi.dsi.fastutil.ints.Int2IntMap;
+import it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap;
+import it.unimi.dsi.fastutil.ints.IntArraySet;
+import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.GlobalPalette;
+import net.minecraft.world.level.chunk.HashMapPalette;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.LinearPalette;
+import net.minecraft.world.level.chunk.Palette;
+import net.minecraft.world.level.chunk.SingleValuePalette;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.Executor;
+
+public final class ChunkPacketBlockControllerCustom extends ChunkPacketBlockControllerModifierBase {
+
+    public ChunkPacketBlockControllerCustom(Level level, Executor executor) {
+        super(level, executor);
+    }
+
+    @Override
+    public boolean shouldModify(ServerPlayer player, LevelChunk chunk) {
+        return true;
+    }
+
+    @Override
+    public void obfuscateInternal(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        replaceCustom(chunkPacketInfoAntiXray);
+    }
+
+    public static void replaceCustom(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+
+        // bitStorageReader, bitStorageWriter and nearbyChunkSections could also be reused (with ThreadLocal if necessary) but it's not worth it
+        BitStorageReader bitStorageReader = new BitStorageReader();
+        BitStorageWriter bitStorageWriter = new BitStorageWriter();
+        LevelChunk chunk = chunkPacketInfoAntiXray.getChunk();
+        int sectionsCount = chunk.getSectionsCount();
+        Level level = chunk.getLevel();
+        boolean[] obfuscateTemp = null;
+        bitStorageReader.setBuffer(chunkPacketInfoAntiXray.getBuffer());
+        bitStorageWriter.setBuffer(chunkPacketInfoAntiXray.getBuffer());
+
+        for (int chunkSectionIndex = 0; chunkSectionIndex < sectionsCount; chunkSectionIndex++) {
+            if (chunkPacketInfoAntiXray.isWritten(chunkSectionIndex)) {
+
+                // Get the current (potentially to be replaced) palette
+                var oldPalette = chunkPacketInfoAntiXray.getPalette(chunkSectionIndex);
+                int oldPaletteSize = oldPalette.getSize();
+
+                // Get the appropriate global replacements
+                int[] globalBlockStateReplacementsForResourcePackStatus = chunkPacketInfoAntiXray.doesPlayerHaveResourcePack ? Block.stateIdReplacementArrayWithResourcePack : Block.stateIdReplacementArrayWithoutResourcePack;
+
+                // First we store the old and new global ids, and flag if there will be any replacements
+                int[] oldStateRegistryIdsByOldPaletteId = new int[oldPaletteSize];
+                int[] newStateRegistryIdsByOldPaletteId = new int[oldPaletteSize];
+                boolean anyReplacements = false;
+                for (int oldPaletteId = 0; oldPaletteId < oldPaletteSize; oldPaletteId++) {
+                    BlockState oldValue = oldPalette.valueFor(oldPaletteId);
+                    int oldStateRegistryId = Block.BLOCK_STATE_REGISTRY.getId(oldValue);
+                    oldStateRegistryIdsByOldPaletteId[oldPaletteId] = oldStateRegistryId;
+                    int newStateRegistryId = globalBlockStateReplacementsForResourcePackStatus[oldStateRegistryId];
+                    newStateRegistryIdsByOldPaletteId[oldPaletteId] = newStateRegistryId;
+                    anyReplacements |= oldStateRegistryId != newStateRegistryId;
+                }
+
+                // If no replacements are necessary, we are done with this section (this will always be false in the case of a global palette that contains some non-vanilla block states)
+                if (!anyReplacements) {
+                    continue;
+                }
+
+                // Prepare for potential block replacements later
+                int[] blockStateReplacements = null;
+
+                // Special case for the global palette, where we don't have to find a new list of which global ids are needed in the new palette: we can just use the palette containing all vanilla blocks
+                // But the palette isn't written at all to the packet in this case (the client simply expects the vanilla global palette), so we simply need to compute the needed block replacements
+                if (oldPalette instanceof GlobalPalette<BlockState>) {
+
+                    // We can just straight up use the appropriate precomputed array over all block states
+                    blockStateReplacements = globalBlockStateReplacementsForResourcePackStatus;
+
+                } else {
+                    // If not a global palette, we must figure out what will go into the new palette
+
+                    // We create sets of the old and new global ids so that we can for example check for old global ids whether they will be still present
+                    IntSet newStateRegistryIds = (oldPaletteSize <= 16) ? new IntArraySet(oldPaletteSize) : new IntOpenHashSet(oldPaletteSize * 2);
+                    Arrays.stream(newStateRegistryIdsByOldPaletteId).forEach(newStateRegistryIds::add);
+                    int newPaletteSize = newStateRegistryIds.size();
+
+                    // Create the global ids that will be in the new palette
+                    int[] newStateRegistryIdsByNewPaletteId = new int[newStateRegistryIds.size()];
+                    Arrays.fill(newStateRegistryIdsByNewPaletteId, -1); // -1 marks we have not decided which new palette state registry id to put at this palette id yet
+
+                    // Put the new global ids in the same position as the old global id they replace, if possible
+                    Int2IntMap newPaletteIdByNewStateRegistryId = newStateRegistryIds.size() <= 16 ? new Int2IntArrayMap(newStateRegistryIds.size()) : new Int2IntOpenHashMap(newStateRegistryIds.size() * 2);
+                    for (int oldPaletteId = 0; oldPaletteId < oldPaletteSize && oldPaletteId < newPaletteSize /* We cannot store them in the same palette id beyond the new palette size */; oldPaletteId++) {
+                        int newStateRegistryId = newStateRegistryIdsByOldPaletteId[oldPaletteId];
+                        // Get the existing new palette id, or use the current old palette id
+                        final int finalOldPaletteId = oldPaletteId;
+                        int newPaletteId = newPaletteIdByNewStateRegistryId.computeIfAbsent(newStateRegistryId, key -> finalOldPaletteId);
+                        newStateRegistryIdsByNewPaletteId[newPaletteId] = newStateRegistryId;
+                    }
+
+                    // Go over all new global ids and assign any of them that still need it a new palette id
+                    int[] nextNewPaletteId = {0};
+                    while (nextNewPaletteId[0] < newStateRegistryIdsByNewPaletteId.length && newStateRegistryIdsByNewPaletteId[nextNewPaletteId[0]] != -1) {
+                        nextNewPaletteId[0]++;
+                    }
+                    for (int newStateRegistryId : newStateRegistryIds) {
+                        newPaletteIdByNewStateRegistryId.computeIfAbsent(newStateRegistryId, key -> {
+                            int newPaletteId = nextNewPaletteId[0];
+                            do {
+                                nextNewPaletteId[0]++;
+                            } while (nextNewPaletteId[0] < newStateRegistryIdsByNewPaletteId.length && newStateRegistryIdsByNewPaletteId[nextNewPaletteId[0]] != -1);
+                            newStateRegistryIdsByNewPaletteId[newPaletteId] = key;
+                            return newPaletteId;
+                        });
+                    }
+
+                    // Create the necessary entries for the new palette
+                    List<BlockState> newPaletteBlockStateList = new ArrayList<>(Arrays.stream(newStateRegistryIdsByNewPaletteId).mapToObj(stateRegistryId -> Block.BLOCK_STATE_REGISTRY.byId(stateRegistryId)).toList());
+
+                    // Make sure we fit into the protocol by keeping the exact same number of bits and such, so we add some unused block states to the palette to get the same size as before
+                    for (BlockState paddingBlockState : Block.BLOCK_STATE_REGISTRY) {
+                        if (newPaletteBlockStateList.size() == oldPaletteSize) {
+                            break;
+                        }
+                        if (!newPaletteBlockStateList.contains(paddingBlockState)) {
+                            newPaletteBlockStateList.add(paddingBlockState);
+                        }
+                    }
+
+                    // We clone the palette with the new entries, so that we can then write it to the buffer
+                    Palette<BlockState> newPalette = null; // Will be initialized in one of the cases below for sure
+                    if (oldPalette instanceof SingleValuePalette<BlockState> oldSingleValuePalette) {
+                        newPalette = oldSingleValuePalette.copyBlank(newPaletteBlockStateList);
+                    } else if (oldPalette instanceof LinearPalette<BlockState> oldLinearPalette) {
+                        newPalette = oldLinearPalette.copyBlank(newPaletteBlockStateList);
+                    } else if (oldPalette instanceof HashMapPalette<BlockState> oldHashMapPalette) {
+                        newPalette = oldHashMapPalette.copyBlank(newPaletteBlockStateList);
+                    }
+
+                    // Write the new palette to the buffer
+                    FriendlyByteBuf paletteWriter;
+                    {
+                        ByteBuf byteBuf = Unpooled.wrappedBuffer(chunkPacketInfoAntiXray.getBuffer());
+                        byteBuf.writerIndex(chunkPacketInfoAntiXray.getPaletteIndex(chunkSectionIndex));
+                        paletteWriter = new FriendlyByteBuf(byteBuf);
+                    }
+                    newPalette.write(paletteWriter);
+
+                    // For any palette id where the global id at that index in the new palette is not the replacement for the global id at that index in the old palette, we must replace the palette id of all block occurrences to the palette id where the replacement is in fact stored in the new palette
+                    for (int oldPaletteId = 0; oldPaletteId < oldPaletteSize; oldPaletteId++) {
+                        // If the replacement is no longer in the right position
+                        int newStateRegistryId = newStateRegistryIdsByOldPaletteId[oldPaletteId];
+                        int newPaletteIdOfNewStateRegistryId = newPaletteIdByNewStateRegistryId.get(newStateRegistryId);
+                        if (newPaletteIdOfNewStateRegistryId != oldPaletteId) {
+                            if (blockStateReplacements == null) {
+                                blockStateReplacements = new int[oldPaletteSize];
+                                for (int i = 0; i < oldPaletteSize; i++) {
+                                    blockStateReplacements[i] = i;
+                                }
+                            }
+                            blockStateReplacements[oldPaletteId] = newPaletteIdOfNewStateRegistryId;
+                        }
+                    }
+
+                }
+
+                if (blockStateReplacements != null) {
+                    bitStorageReader.setBits(chunkPacketInfoAntiXray.getBits(chunkSectionIndex));
+                    bitStorageReader.setIndex(chunkPacketInfoAntiXray.getIndex(chunkSectionIndex));
+                    bitStorageWriter.setBits(chunkPacketInfoAntiXray.getBits(chunkSectionIndex));
+                    bitStorageWriter.setIndex(chunkPacketInfoAntiXray.getIndex(chunkSectionIndex));
+
+                    // Modify all layers of the current chunk section
+                    for (int xyz = 0; xyz < 4096/* = 16*16*16 */; xyz++) {
+                        int bits = bitStorageReader.read();
+                        bitStorageWriter.write(blockStateReplacements[bits]);
+                    }
+                    bitStorageWriter.flush();
+                }
+            }
+        }
+
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerModifier.java b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerModifier.java
new file mode 100644
index 0000000000000000000000000000000000000000..5657efde50d31c1661b9c47a596f0df58c137803
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerModifier.java
@@ -0,0 +1,15 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.antixray;
+
+import com.destroystokyo.paper.antixray.ChunkPacketInfoAntiXray;
+
+public interface ChunkPacketBlockControllerModifier {
+
+    /**
+     * This method represents modifying the blocks, which can be obfuscation, but doesn't have to be
+     * (naming based on existing method in ChunkPacketBlockControllerAntiXray)
+     */
+    void obfuscate(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerModifierBase.java b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerModifierBase.java
new file mode 100644
index 0000000000000000000000000000000000000000..a50c702b7e653d74a1f8f7d0f472c6ae5ac624e2
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerModifierBase.java
@@ -0,0 +1,66 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.antixray;
+
+import com.destroystokyo.paper.antixray.ChunkPacketBlockController;
+import com.destroystokyo.paper.antixray.ChunkPacketInfo;
+import com.destroystokyo.paper.antixray.ChunkPacketInfoAntiXray;
+import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.GlobalPalette;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.LevelChunkSection;
+import net.minecraft.world.level.chunk.Palette;
+import org.bukkit.Bukkit;
+
+import java.util.concurrent.Executor;
+
+public abstract class ChunkPacketBlockControllerModifierBase extends ChunkPacketBlockController implements ChunkPacketBlockControllerModifier { // Martijn - custom blocks and items
+
+    public static final Palette<BlockState> GLOBAL_BLOCKSTATE_PALETTE = new GlobalPalette<>(Block.BLOCK_STATE_REGISTRY);
+    public static final LevelChunkSection EMPTY_SECTION = null;
+    protected final Executor executor;
+
+    public ChunkPacketBlockControllerModifierBase(Level level, Executor executor) {
+        this.executor = executor;
+    }
+
+    @Override
+    public void obfuscate(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        this.obfuscateInternal(chunkPacketInfoAntiXray);
+        chunkPacketInfoAntiXray.getChunkPacket().setReady(true);
+    }
+
+    public abstract void obfuscateInternal(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray);
+
+    @Override
+    public ChunkPacketInfoAntiXray getChunkPacketInfo(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk, boolean doesPlayerHaveResourcePack) {
+        // Return a new instance to collect data and objects in the right state while creating the chunk packet for thread safe access later
+        return new ChunkPacketInfoAntiXray(chunkPacket, chunk, this, doesPlayerHaveResourcePack);
+    }
+
+    @Override
+    public void modifyBlocks(ClientboundLevelChunkWithLightPacket chunkPacket, ChunkPacketInfo<BlockState> chunkPacketInfo) {
+        if (!(chunkPacketInfo instanceof ChunkPacketInfoAntiXray)) {
+            chunkPacket.setReady(true);
+            return;
+        }
+
+        if (!Bukkit.isPrimaryThread()) {
+            // Plugins?
+            MinecraftServer.getServer().scheduleOnMain(() -> modifyBlocks(chunkPacket, chunkPacketInfo));
+            return;
+        }
+
+        LevelChunk chunk = chunkPacketInfo.getChunk();
+        int x = chunk.getPos().x;
+        int z = chunk.getPos().z;
+        Level level = chunk.getLevel();
+        ((ChunkPacketInfoAntiXray) chunkPacketInfo).setNearbyChunks(level.getChunkIfLoaded(x - 1, z), level.getChunkIfLoaded(x + 1, z), level.getChunkIfLoaded(x, z - 1), level.getChunkIfLoaded(x, z + 1));
+        executor.execute((Runnable) chunkPacketInfo);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/biome/SuCraftBiomeTagsProvider.java b/src/main/java/nl/martijnmuijsers/paper/biome/SuCraftBiomeTagsProvider.java
index 347f0b29fbe89eaab83692e3991aa19752c0e8fd..01c9d12bc884e60a69ade60cfa8be985c7964b72 100644
--- a/src/main/java/nl/martijnmuijsers/paper/biome/SuCraftBiomeTagsProvider.java
+++ b/src/main/java/nl/martijnmuijsers/paper/biome/SuCraftBiomeTagsProvider.java
@@ -2,12 +2,17 @@
 
 package nl.martijnmuijsers.paper.biome;
 
+import net.minecraft.core.Holder;
 import net.minecraft.core.Registry;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.tags.TagKey;
 import net.minecraft.world.level.biome.Biome;
 import nl.martijnmuijsers.paper.data.SuCraftTagsProvider;
 import net.minecraft.world.level.biome.Biomes;
 
+import java.util.List;
+import java.util.Map;
+
 /**
  * Based on {@link net.minecraft.data.tags.BiomeTagsProvider}
  */
@@ -18,7 +23,7 @@ public class SuCraftBiomeTagsProvider extends SuCraftTagsProvider<Biome> {
     }
 
     @Override
-    protected void addTags() {
+    protected void addTags(Map<TagKey<Biome>, List<Holder<Biome>>> existingRegistryTagEntries) {
         MinecraftServer.LOGGER.info("Adding custom biome tags...");
         this.tag(SuCraftBiomeTags.HAS_STRONGHOLD_SURFACE).add(Biomes.PLAINS).add(Biomes.SUNFLOWER_PLAINS).add(Biomes.SNOWY_PLAINS).add(Biomes.ICE_SPIKES).add(Biomes.DESERT).add(Biomes.FOREST).add(Biomes.FLOWER_FOREST).add(Biomes.BIRCH_FOREST).add(Biomes.DARK_FOREST).add(Biomes.OLD_GROWTH_BIRCH_FOREST).add(Biomes.OLD_GROWTH_PINE_TAIGA).add(Biomes.OLD_GROWTH_SPRUCE_TAIGA).add(Biomes.TAIGA).add(Biomes.SNOWY_TAIGA).add(Biomes.SAVANNA).add(Biomes.SAVANNA_PLATEAU).add(Biomes.WINDSWEPT_HILLS).add(Biomes.WINDSWEPT_GRAVELLY_HILLS).add(Biomes.WINDSWEPT_FOREST).add(Biomes.WINDSWEPT_SAVANNA).add(Biomes.JUNGLE).add(Biomes.SPARSE_JUNGLE).add(Biomes.BAMBOO_JUNGLE).add(Biomes.BADLANDS).add(Biomes.ERODED_BADLANDS).add(Biomes.WOODED_BADLANDS).add(Biomes.MEADOW).add(Biomes.GROVE).add(Biomes.SNOWY_SLOPES).add(Biomes.FROZEN_PEAKS).add(Biomes.JAGGED_PEAKS).add(Biomes.STONY_PEAKS).add(Biomes.MUSHROOM_FIELDS); // Martijn - custom strongholds - surface strongholds
     }
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/ConcreteDirectionalBlock.java b/src/main/java/nl/martijnmuijsers/paper/block/ConcreteDirectionalBlock.java
new file mode 100644
index 0000000000000000000000000000000000000000..ea2f292f7d26674b1bb834211af7a3997b21fee0
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/block/ConcreteDirectionalBlock.java
@@ -0,0 +1,36 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.block;
+
+import net.minecraft.core.Direction;
+import net.minecraft.world.item.context.BlockPlaceContext;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.DirectionalBlock;
+import net.minecraft.world.level.block.Rotation;
+import net.minecraft.world.level.block.state.BlockBehaviour;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.StateDefinition;
+
+public class ConcreteDirectionalBlock extends DirectionalBlock {
+
+    public ConcreteDirectionalBlock(BlockBehaviour.Properties settings) {
+        super(settings);
+        this.registerDefaultState(this.defaultBlockState().setValue(FACING, Direction.SOUTH));
+    }
+
+    @Override
+    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
+        builder.add(FACING);
+    }
+
+    @Override
+    public BlockState rotate(BlockState state, Rotation rotation) {
+        return state.setValue(FACING, rotation.rotate(state.getValue(FACING)));
+    }
+
+    @Override
+    public BlockState getStateForPlacement(BlockPlaceContext ctx) {
+        return this.defaultBlockState().setValue(FACING, ctx.getNearestLookingDirection().getOpposite().getOpposite());
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlockLoot.java b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlockLoot.java
new file mode 100644
index 0000000000000000000000000000000000000000..5a2e8c0c52ee2e6109d85445f1e4242fe6a1b851
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlockLoot.java
@@ -0,0 +1,49 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.block;
+
+import net.minecraft.data.loot.BlockLoot;
+import net.minecraft.world.level.ItemLike;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.storage.loot.LootTable;
+import net.minecraft.world.level.storage.loot.providers.number.NumberProvider;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Partially based on {@link net.minecraft.data.loot.BlockLoot}
+ */
+public final class SuCraftBlockLoot {
+
+    private SuCraftBlockLoot() {}
+
+    private static final @NotNull BlockLoot blockLoot = new BlockLoot();
+
+    public static @NotNull LootTable dropSelf(@NotNull Block block) {
+        return dropSingleItem(block);
+    }
+
+    public static @NotNull LootTable dropSingleOrDoubleSlabSelf(@NotNull Block slabBlock) {
+        return blockLoot.createSlabItemTable(slabBlock).build();
+    }
+
+    public static @NotNull LootTable dropSingleItem(@NotNull ItemLike drop) {
+        return blockLoot.createSingleItemTable(drop).build();
+    }
+
+    public static @NotNull LootTable dropSingleItemWhenSilkTouch(@NotNull ItemLike drop) {
+        return blockLoot.createSilkTouchOnlyTable(drop).build();
+    }
+
+    public static @NotNull LootTable dropSingleItemAndSingleItemWhenSilkTouch(@NotNull ItemLike withoutSilkTouch, @NotNull Block withSilkTouch) {
+        return blockLoot.createSingleItemTableWithSilkTouch(withSilkTouch, withoutSilkTouch).build();
+    }
+
+    public static @NotNull LootTable dropSingleItemAndSingleItemWhenSilkTouch(@NotNull ItemLike withoutSilkTouch, @NotNull NumberProvider withoutSilkTouchAmount, @NotNull Block withSilkTouch) {
+        return blockLoot.createSingleItemTableWithSilkTouch(withSilkTouch, withoutSilkTouch, withoutSilkTouchAmount).build();
+    }
+
+    public static @NotNull LootTable dropLeaves(@NotNull Block block, @NotNull Block saplingBlock) {
+        return blockLoot.createLeavesDrops(block, saplingBlock, blockLoot.NORMAL_LEAVES_SAPLING_CHANCES).build();
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlockTagsProvider.java b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlockTagsProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..b084f203a96c68a5c443b8ad9ae965882adcf906
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlockTagsProvider.java
@@ -0,0 +1,204 @@
+// Martijn - custom resources
+
+package nl.martijnmuijsers.paper.block;
+
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.core.Holder;
+import net.minecraft.core.Registry;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.tags.TagKey;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import nl.martijnmuijsers.paper.data.SuCraftTagsProvider;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.function.Supplier;
+
+/**
+ * Based on {@link net.minecraft.data.tags.BlockTagsProvider}
+ */
+public class SuCraftBlockTagsProvider extends SuCraftTagsProvider<Block> {
+
+    public SuCraftBlockTagsProvider(Registry<Block> registry) {
+        super(registry);
+    }
+
+    @Override
+    protected void addTags(Map<TagKey<Block>, List<Holder<Block>>> existingRegistryTagEntries) {
+        MinecraftServer.LOGGER.info("Adding onto existing block tags...");
+        // Martijn start - custom blocks and items
+//        final List<TagKey<Block>> mineableTags = List.of(BlockTags.MINEABLE_WITH_AXE, BlockTags.MINEABLE_WITH_HOE, BlockTags.MINEABLE_WITH_PICKAXE, BlockTags.MINEABLE_WITH_SHOVEL);
+//        for (TagKey<Block> tag : mineableTags) {
+//            this.tag(tag).add();
+//        }
+        for (@NotNull Block block : Registry.BLOCK) {
+            block.tagsToAddSuppliers.stream().map(Supplier::get).distinct().forEach(tagToAdd -> {
+                // Some tags may not be valid to transfer, but such a check is not implemented yet
+                this.tag(tagToAdd).add(block);
+            });
+        }
+        // Martijn end - custom blocks and items
+
+        // The below is a literal copy from BlockTagsProvider.addTags, which adds the tags transitively (for instance adding DEAD_BUSH_MAY_PLACE_ON to all blocks with the tag DIRT) after we have added more of some of those tags
+        this.tag(BlockTags.WOOL).add(Blocks.WHITE_WOOL, Blocks.ORANGE_WOOL, Blocks.MAGENTA_WOOL, Blocks.LIGHT_BLUE_WOOL, Blocks.YELLOW_WOOL, Blocks.LIME_WOOL, Blocks.PINK_WOOL, Blocks.GRAY_WOOL, Blocks.LIGHT_GRAY_WOOL, Blocks.CYAN_WOOL, Blocks.PURPLE_WOOL, Blocks.BLUE_WOOL, Blocks.BROWN_WOOL, Blocks.GREEN_WOOL, Blocks.RED_WOOL, Blocks.BLACK_WOOL);
+        this.tag(BlockTags.PLANKS).add(Blocks.OAK_PLANKS, Blocks.SPRUCE_PLANKS, Blocks.BIRCH_PLANKS, Blocks.JUNGLE_PLANKS, Blocks.ACACIA_PLANKS, Blocks.DARK_OAK_PLANKS, Blocks.CRIMSON_PLANKS, Blocks.WARPED_PLANKS, Blocks.MANGROVE_PLANKS);
+        this.tag(BlockTags.STONE_BRICKS).add(Blocks.STONE_BRICKS, Blocks.MOSSY_STONE_BRICKS, Blocks.CRACKED_STONE_BRICKS, Blocks.CHISELED_STONE_BRICKS);
+        this.tag(BlockTags.WOODEN_BUTTONS).add(Blocks.OAK_BUTTON, Blocks.SPRUCE_BUTTON, Blocks.BIRCH_BUTTON, Blocks.JUNGLE_BUTTON, Blocks.ACACIA_BUTTON, Blocks.DARK_OAK_BUTTON, Blocks.CRIMSON_BUTTON, Blocks.WARPED_BUTTON, Blocks.MANGROVE_BUTTON);
+        this.tag(BlockTags.BUTTONS).addTag(BlockTags.WOODEN_BUTTONS).add(Blocks.STONE_BUTTON).add(Blocks.POLISHED_BLACKSTONE_BUTTON);
+        this.tag(BlockTags.WOOL_CARPETS).add(Blocks.WHITE_CARPET, Blocks.ORANGE_CARPET, Blocks.MAGENTA_CARPET, Blocks.LIGHT_BLUE_CARPET, Blocks.YELLOW_CARPET, Blocks.LIME_CARPET, Blocks.PINK_CARPET, Blocks.GRAY_CARPET, Blocks.LIGHT_GRAY_CARPET, Blocks.CYAN_CARPET, Blocks.PURPLE_CARPET, Blocks.BLUE_CARPET, Blocks.BROWN_CARPET, Blocks.GREEN_CARPET, Blocks.RED_CARPET, Blocks.BLACK_CARPET);
+        this.tag(BlockTags.WOODEN_DOORS).add(Blocks.OAK_DOOR, Blocks.SPRUCE_DOOR, Blocks.BIRCH_DOOR, Blocks.JUNGLE_DOOR, Blocks.ACACIA_DOOR, Blocks.DARK_OAK_DOOR, Blocks.CRIMSON_DOOR, Blocks.WARPED_DOOR, Blocks.MANGROVE_DOOR);
+        this.tag(BlockTags.WOODEN_STAIRS).add(Blocks.OAK_STAIRS, Blocks.SPRUCE_STAIRS, Blocks.BIRCH_STAIRS, Blocks.JUNGLE_STAIRS, Blocks.ACACIA_STAIRS, Blocks.DARK_OAK_STAIRS, Blocks.CRIMSON_STAIRS, Blocks.WARPED_STAIRS, Blocks.MANGROVE_STAIRS);
+        this.tag(BlockTags.WOODEN_SLABS).add(Blocks.OAK_SLAB, Blocks.SPRUCE_SLAB, Blocks.BIRCH_SLAB, Blocks.JUNGLE_SLAB, Blocks.ACACIA_SLAB, Blocks.DARK_OAK_SLAB, Blocks.CRIMSON_SLAB, Blocks.WARPED_SLAB, Blocks.MANGROVE_SLAB);
+        this.tag(BlockTags.WOODEN_FENCES).add(Blocks.OAK_FENCE, Blocks.ACACIA_FENCE, Blocks.DARK_OAK_FENCE, Blocks.SPRUCE_FENCE, Blocks.BIRCH_FENCE, Blocks.JUNGLE_FENCE, Blocks.CRIMSON_FENCE, Blocks.WARPED_FENCE, Blocks.MANGROVE_FENCE);
+        this.tag(BlockTags.DOORS).addTag(BlockTags.WOODEN_DOORS).add(Blocks.IRON_DOOR);
+        this.tag(BlockTags.SAPLINGS).add(Blocks.OAK_SAPLING, Blocks.SPRUCE_SAPLING, Blocks.BIRCH_SAPLING, Blocks.JUNGLE_SAPLING, Blocks.ACACIA_SAPLING, Blocks.DARK_OAK_SAPLING, Blocks.AZALEA, Blocks.FLOWERING_AZALEA, Blocks.MANGROVE_PROPAGULE);
+        this.tag(BlockTags.DARK_OAK_LOGS).add(Blocks.DARK_OAK_LOG, Blocks.DARK_OAK_WOOD, Blocks.STRIPPED_DARK_OAK_LOG, Blocks.STRIPPED_DARK_OAK_WOOD);
+        this.tag(BlockTags.OAK_LOGS).add(Blocks.OAK_LOG, Blocks.OAK_WOOD, Blocks.STRIPPED_OAK_LOG, Blocks.STRIPPED_OAK_WOOD);
+        this.tag(BlockTags.ACACIA_LOGS).add(Blocks.ACACIA_LOG, Blocks.ACACIA_WOOD, Blocks.STRIPPED_ACACIA_LOG, Blocks.STRIPPED_ACACIA_WOOD);
+        this.tag(BlockTags.BIRCH_LOGS).add(Blocks.BIRCH_LOG, Blocks.BIRCH_WOOD, Blocks.STRIPPED_BIRCH_LOG, Blocks.STRIPPED_BIRCH_WOOD);
+        this.tag(BlockTags.JUNGLE_LOGS).add(Blocks.JUNGLE_LOG, Blocks.JUNGLE_WOOD, Blocks.STRIPPED_JUNGLE_LOG, Blocks.STRIPPED_JUNGLE_WOOD);
+        this.tag(BlockTags.SPRUCE_LOGS).add(Blocks.SPRUCE_LOG, Blocks.SPRUCE_WOOD, Blocks.STRIPPED_SPRUCE_LOG, Blocks.STRIPPED_SPRUCE_WOOD);
+        this.tag(BlockTags.CRIMSON_STEMS).add(Blocks.CRIMSON_STEM, Blocks.STRIPPED_CRIMSON_STEM, Blocks.CRIMSON_HYPHAE, Blocks.STRIPPED_CRIMSON_HYPHAE);
+        this.tag(BlockTags.WARPED_STEMS).add(Blocks.WARPED_STEM, Blocks.STRIPPED_WARPED_STEM, Blocks.WARPED_HYPHAE, Blocks.STRIPPED_WARPED_HYPHAE);
+        this.tag(BlockTags.MANGROVE_LOGS).add(Blocks.MANGROVE_LOG, Blocks.MANGROVE_WOOD, Blocks.STRIPPED_MANGROVE_LOG, Blocks.STRIPPED_MANGROVE_WOOD);
+        this.tag(BlockTags.LOGS_THAT_BURN).addTag(BlockTags.DARK_OAK_LOGS).addTag(BlockTags.OAK_LOGS).addTag(BlockTags.ACACIA_LOGS).addTag(BlockTags.BIRCH_LOGS).addTag(BlockTags.JUNGLE_LOGS).addTag(BlockTags.SPRUCE_LOGS).addTag(BlockTags.MANGROVE_LOGS);
+        this.tag(BlockTags.OVERWORLD_NATURAL_LOGS).add(Blocks.ACACIA_LOG).add(Blocks.BIRCH_LOG).add(Blocks.OAK_LOG).add(Blocks.JUNGLE_LOG).add(Blocks.SPRUCE_LOG).add(Blocks.DARK_OAK_LOG).add(Blocks.MANGROVE_LOG);
+        this.tag(BlockTags.LOGS).addTag(BlockTags.LOGS_THAT_BURN).addTag(BlockTags.CRIMSON_STEMS).addTag(BlockTags.WARPED_STEMS);
+        this.tag(BlockTags.ANVIL).add(Blocks.ANVIL, Blocks.CHIPPED_ANVIL, Blocks.DAMAGED_ANVIL);
+        this.tag(BlockTags.SMALL_FLOWERS).add(Blocks.DANDELION, Blocks.POPPY, Blocks.BLUE_ORCHID, Blocks.ALLIUM, Blocks.AZURE_BLUET, Blocks.RED_TULIP, Blocks.ORANGE_TULIP, Blocks.WHITE_TULIP, Blocks.PINK_TULIP, Blocks.OXEYE_DAISY, Blocks.CORNFLOWER, Blocks.LILY_OF_THE_VALLEY, Blocks.WITHER_ROSE);
+        this.tag(BlockTags.DIRT).add(Blocks.DIRT, Blocks.GRASS_BLOCK, Blocks.PODZOL, Blocks.COARSE_DIRT, Blocks.MYCELIUM, Blocks.ROOTED_DIRT, Blocks.MOSS_BLOCK, Blocks.MUD, Blocks.MUDDY_MANGROVE_ROOTS);
+        this.tag(BlockTags.ENDERMAN_HOLDABLE).addTag(BlockTags.SMALL_FLOWERS).addTag(BlockTags.DIRT).add(Blocks.SAND, Blocks.RED_SAND, Blocks.GRAVEL, Blocks.BROWN_MUSHROOM, Blocks.RED_MUSHROOM, Blocks.TNT, Blocks.CACTUS, Blocks.CLAY, Blocks.PUMPKIN, Blocks.CARVED_PUMPKIN, Blocks.MELON, Blocks.CRIMSON_FUNGUS, Blocks.CRIMSON_NYLIUM, Blocks.CRIMSON_ROOTS, Blocks.WARPED_FUNGUS, Blocks.WARPED_NYLIUM, Blocks.WARPED_ROOTS);
+        this.tag(BlockTags.FLOWER_POTS).add(Blocks.FLOWER_POT, Blocks.POTTED_POPPY, Blocks.POTTED_BLUE_ORCHID, Blocks.POTTED_ALLIUM, Blocks.POTTED_AZURE_BLUET, Blocks.POTTED_RED_TULIP, Blocks.POTTED_ORANGE_TULIP, Blocks.POTTED_WHITE_TULIP, Blocks.POTTED_PINK_TULIP, Blocks.POTTED_OXEYE_DAISY, Blocks.POTTED_DANDELION, Blocks.POTTED_OAK_SAPLING, Blocks.POTTED_SPRUCE_SAPLING, Blocks.POTTED_BIRCH_SAPLING, Blocks.POTTED_JUNGLE_SAPLING, Blocks.POTTED_ACACIA_SAPLING, Blocks.POTTED_DARK_OAK_SAPLING, Blocks.POTTED_RED_MUSHROOM, Blocks.POTTED_BROWN_MUSHROOM, Blocks.POTTED_DEAD_BUSH, Blocks.POTTED_FERN, Blocks.POTTED_CACTUS, Blocks.POTTED_CORNFLOWER, Blocks.POTTED_LILY_OF_THE_VALLEY, Blocks.POTTED_WITHER_ROSE, Blocks.POTTED_BAMBOO, Blocks.POTTED_CRIMSON_FUNGUS, Blocks.POTTED_WARPED_FUNGUS, Blocks.POTTED_CRIMSON_ROOTS, Blocks.POTTED_WARPED_ROOTS, Blocks.POTTED_AZALEA, Blocks.POTTED_FLOWERING_AZALEA, Blocks.POTTED_MANGROVE_PROPAGULE);
+        this.tag(BlockTags.BANNERS).add(Blocks.WHITE_BANNER, Blocks.ORANGE_BANNER, Blocks.MAGENTA_BANNER, Blocks.LIGHT_BLUE_BANNER, Blocks.YELLOW_BANNER, Blocks.LIME_BANNER, Blocks.PINK_BANNER, Blocks.GRAY_BANNER, Blocks.LIGHT_GRAY_BANNER, Blocks.CYAN_BANNER, Blocks.PURPLE_BANNER, Blocks.BLUE_BANNER, Blocks.BROWN_BANNER, Blocks.GREEN_BANNER, Blocks.RED_BANNER, Blocks.BLACK_BANNER, Blocks.WHITE_WALL_BANNER, Blocks.ORANGE_WALL_BANNER, Blocks.MAGENTA_WALL_BANNER, Blocks.LIGHT_BLUE_WALL_BANNER, Blocks.YELLOW_WALL_BANNER, Blocks.LIME_WALL_BANNER, Blocks.PINK_WALL_BANNER, Blocks.GRAY_WALL_BANNER, Blocks.LIGHT_GRAY_WALL_BANNER, Blocks.CYAN_WALL_BANNER, Blocks.PURPLE_WALL_BANNER, Blocks.BLUE_WALL_BANNER, Blocks.BROWN_WALL_BANNER, Blocks.GREEN_WALL_BANNER, Blocks.RED_WALL_BANNER, Blocks.BLACK_WALL_BANNER);
+        this.tag(BlockTags.WOODEN_PRESSURE_PLATES).add(Blocks.OAK_PRESSURE_PLATE, Blocks.SPRUCE_PRESSURE_PLATE, Blocks.BIRCH_PRESSURE_PLATE, Blocks.JUNGLE_PRESSURE_PLATE, Blocks.ACACIA_PRESSURE_PLATE, Blocks.DARK_OAK_PRESSURE_PLATE, Blocks.CRIMSON_PRESSURE_PLATE, Blocks.WARPED_PRESSURE_PLATE, Blocks.MANGROVE_PRESSURE_PLATE);
+        this.tag(BlockTags.STONE_PRESSURE_PLATES).add(Blocks.STONE_PRESSURE_PLATE, Blocks.POLISHED_BLACKSTONE_PRESSURE_PLATE);
+        this.tag(BlockTags.PRESSURE_PLATES).add(Blocks.LIGHT_WEIGHTED_PRESSURE_PLATE, Blocks.HEAVY_WEIGHTED_PRESSURE_PLATE).addTag(BlockTags.WOODEN_PRESSURE_PLATES).addTag(BlockTags.STONE_PRESSURE_PLATES);
+        this.tag(BlockTags.STAIRS).addTag(BlockTags.WOODEN_STAIRS).add(Blocks.COBBLESTONE_STAIRS, Blocks.SANDSTONE_STAIRS, Blocks.NETHER_BRICK_STAIRS, Blocks.STONE_BRICK_STAIRS, Blocks.BRICK_STAIRS, Blocks.PURPUR_STAIRS, Blocks.QUARTZ_STAIRS, Blocks.RED_SANDSTONE_STAIRS, Blocks.PRISMARINE_BRICK_STAIRS, Blocks.PRISMARINE_STAIRS, Blocks.DARK_PRISMARINE_STAIRS, Blocks.POLISHED_GRANITE_STAIRS, Blocks.SMOOTH_RED_SANDSTONE_STAIRS, Blocks.MOSSY_STONE_BRICK_STAIRS, Blocks.POLISHED_DIORITE_STAIRS, Blocks.MOSSY_COBBLESTONE_STAIRS, Blocks.END_STONE_BRICK_STAIRS, Blocks.STONE_STAIRS, Blocks.SMOOTH_SANDSTONE_STAIRS, Blocks.SMOOTH_QUARTZ_STAIRS, Blocks.GRANITE_STAIRS, Blocks.ANDESITE_STAIRS, Blocks.RED_NETHER_BRICK_STAIRS, Blocks.POLISHED_ANDESITE_STAIRS, Blocks.DIORITE_STAIRS, Blocks.BLACKSTONE_STAIRS, Blocks.POLISHED_BLACKSTONE_BRICK_STAIRS, Blocks.POLISHED_BLACKSTONE_STAIRS, Blocks.COBBLED_DEEPSLATE_STAIRS, Blocks.POLISHED_DEEPSLATE_STAIRS, Blocks.DEEPSLATE_TILE_STAIRS, Blocks.DEEPSLATE_BRICK_STAIRS, Blocks.OXIDIZED_CUT_COPPER_STAIRS, Blocks.WEATHERED_CUT_COPPER_STAIRS, Blocks.EXPOSED_CUT_COPPER_STAIRS, Blocks.CUT_COPPER_STAIRS, Blocks.WAXED_WEATHERED_CUT_COPPER_STAIRS, Blocks.WAXED_EXPOSED_CUT_COPPER_STAIRS, Blocks.WAXED_CUT_COPPER_STAIRS, Blocks.WAXED_OXIDIZED_CUT_COPPER_STAIRS, Blocks.MUD_BRICK_STAIRS);
+        this.tag(BlockTags.SLABS).addTag(BlockTags.WOODEN_SLABS).add(Blocks.STONE_SLAB, Blocks.SMOOTH_STONE_SLAB, Blocks.STONE_BRICK_SLAB, Blocks.SANDSTONE_SLAB, Blocks.PURPUR_SLAB, Blocks.QUARTZ_SLAB, Blocks.RED_SANDSTONE_SLAB, Blocks.BRICK_SLAB, Blocks.COBBLESTONE_SLAB, Blocks.NETHER_BRICK_SLAB, Blocks.PETRIFIED_OAK_SLAB, Blocks.PRISMARINE_SLAB, Blocks.PRISMARINE_BRICK_SLAB, Blocks.DARK_PRISMARINE_SLAB, Blocks.POLISHED_GRANITE_SLAB, Blocks.SMOOTH_RED_SANDSTONE_SLAB, Blocks.MOSSY_STONE_BRICK_SLAB, Blocks.POLISHED_DIORITE_SLAB, Blocks.MOSSY_COBBLESTONE_SLAB, Blocks.END_STONE_BRICK_SLAB, Blocks.SMOOTH_SANDSTONE_SLAB, Blocks.SMOOTH_QUARTZ_SLAB, Blocks.GRANITE_SLAB, Blocks.ANDESITE_SLAB, Blocks.RED_NETHER_BRICK_SLAB, Blocks.POLISHED_ANDESITE_SLAB, Blocks.DIORITE_SLAB, Blocks.CUT_SANDSTONE_SLAB, Blocks.CUT_RED_SANDSTONE_SLAB, Blocks.BLACKSTONE_SLAB, Blocks.POLISHED_BLACKSTONE_BRICK_SLAB, Blocks.POLISHED_BLACKSTONE_SLAB, Blocks.COBBLED_DEEPSLATE_SLAB, Blocks.POLISHED_DEEPSLATE_SLAB, Blocks.DEEPSLATE_TILE_SLAB, Blocks.DEEPSLATE_BRICK_SLAB, Blocks.WAXED_WEATHERED_CUT_COPPER_SLAB, Blocks.WAXED_EXPOSED_CUT_COPPER_SLAB, Blocks.WAXED_CUT_COPPER_SLAB, Blocks.OXIDIZED_CUT_COPPER_SLAB, Blocks.WEATHERED_CUT_COPPER_SLAB, Blocks.EXPOSED_CUT_COPPER_SLAB, Blocks.CUT_COPPER_SLAB, Blocks.WAXED_OXIDIZED_CUT_COPPER_SLAB, Blocks.MUD_BRICK_SLAB);
+        this.tag(BlockTags.WALLS).add(Blocks.COBBLESTONE_WALL, Blocks.MOSSY_COBBLESTONE_WALL, Blocks.BRICK_WALL, Blocks.PRISMARINE_WALL, Blocks.RED_SANDSTONE_WALL, Blocks.MOSSY_STONE_BRICK_WALL, Blocks.GRANITE_WALL, Blocks.STONE_BRICK_WALL, Blocks.NETHER_BRICK_WALL, Blocks.ANDESITE_WALL, Blocks.RED_NETHER_BRICK_WALL, Blocks.SANDSTONE_WALL, Blocks.END_STONE_BRICK_WALL, Blocks.DIORITE_WALL, Blocks.BLACKSTONE_WALL, Blocks.POLISHED_BLACKSTONE_BRICK_WALL, Blocks.POLISHED_BLACKSTONE_WALL, Blocks.COBBLED_DEEPSLATE_WALL, Blocks.POLISHED_DEEPSLATE_WALL, Blocks.DEEPSLATE_TILE_WALL, Blocks.DEEPSLATE_BRICK_WALL, Blocks.MUD_BRICK_WALL);
+        this.tag(BlockTags.CORAL_PLANTS).add(Blocks.TUBE_CORAL, Blocks.BRAIN_CORAL, Blocks.BUBBLE_CORAL, Blocks.FIRE_CORAL, Blocks.HORN_CORAL);
+        this.tag(BlockTags.CORALS).addTag(BlockTags.CORAL_PLANTS).add(Blocks.TUBE_CORAL_FAN, Blocks.BRAIN_CORAL_FAN, Blocks.BUBBLE_CORAL_FAN, Blocks.FIRE_CORAL_FAN, Blocks.HORN_CORAL_FAN);
+        this.tag(BlockTags.WALL_CORALS).add(Blocks.TUBE_CORAL_WALL_FAN, Blocks.BRAIN_CORAL_WALL_FAN, Blocks.BUBBLE_CORAL_WALL_FAN, Blocks.FIRE_CORAL_WALL_FAN, Blocks.HORN_CORAL_WALL_FAN);
+        this.tag(BlockTags.SAND).add(Blocks.SAND, Blocks.RED_SAND);
+        this.tag(BlockTags.RAILS).add(Blocks.RAIL, Blocks.POWERED_RAIL, Blocks.DETECTOR_RAIL, Blocks.ACTIVATOR_RAIL);
+        this.tag(BlockTags.CORAL_BLOCKS).add(Blocks.TUBE_CORAL_BLOCK, Blocks.BRAIN_CORAL_BLOCK, Blocks.BUBBLE_CORAL_BLOCK, Blocks.FIRE_CORAL_BLOCK, Blocks.HORN_CORAL_BLOCK);
+        this.tag(BlockTags.ICE).add(Blocks.ICE, Blocks.PACKED_ICE, Blocks.BLUE_ICE, Blocks.FROSTED_ICE);
+        this.tag(BlockTags.VALID_SPAWN).add(Blocks.GRASS_BLOCK, Blocks.PODZOL);
+        this.tag(BlockTags.LEAVES).add(Blocks.JUNGLE_LEAVES, Blocks.OAK_LEAVES, Blocks.SPRUCE_LEAVES, Blocks.DARK_OAK_LEAVES, Blocks.ACACIA_LEAVES, Blocks.BIRCH_LEAVES, Blocks.AZALEA_LEAVES, Blocks.FLOWERING_AZALEA_LEAVES, Blocks.MANGROVE_LEAVES);
+        this.tag(BlockTags.IMPERMEABLE).add(Blocks.GLASS, Blocks.WHITE_STAINED_GLASS, Blocks.ORANGE_STAINED_GLASS, Blocks.MAGENTA_STAINED_GLASS, Blocks.LIGHT_BLUE_STAINED_GLASS, Blocks.YELLOW_STAINED_GLASS, Blocks.LIME_STAINED_GLASS, Blocks.PINK_STAINED_GLASS, Blocks.GRAY_STAINED_GLASS, Blocks.LIGHT_GRAY_STAINED_GLASS, Blocks.CYAN_STAINED_GLASS, Blocks.PURPLE_STAINED_GLASS, Blocks.BLUE_STAINED_GLASS, Blocks.BROWN_STAINED_GLASS, Blocks.GREEN_STAINED_GLASS, Blocks.RED_STAINED_GLASS, Blocks.BLACK_STAINED_GLASS, Blocks.TINTED_GLASS);
+        this.tag(BlockTags.WOODEN_TRAPDOORS).add(Blocks.ACACIA_TRAPDOOR, Blocks.BIRCH_TRAPDOOR, Blocks.DARK_OAK_TRAPDOOR, Blocks.JUNGLE_TRAPDOOR, Blocks.OAK_TRAPDOOR, Blocks.SPRUCE_TRAPDOOR, Blocks.CRIMSON_TRAPDOOR, Blocks.WARPED_TRAPDOOR, Blocks.MANGROVE_TRAPDOOR);
+        this.tag(BlockTags.TRAPDOORS).addTag(BlockTags.WOODEN_TRAPDOORS).add(Blocks.IRON_TRAPDOOR);
+        this.tag(BlockTags.UNDERWATER_BONEMEALS).add(Blocks.SEAGRASS).addTag(BlockTags.CORALS).addTag(BlockTags.WALL_CORALS);
+        this.tag(BlockTags.BAMBOO_PLANTABLE_ON).addTag(BlockTags.SAND).addTag(BlockTags.DIRT).add(Blocks.BAMBOO, Blocks.BAMBOO_SAPLING, Blocks.GRAVEL);
+        this.tag(BlockTags.STANDING_SIGNS).add(Blocks.OAK_SIGN, Blocks.SPRUCE_SIGN, Blocks.BIRCH_SIGN, Blocks.ACACIA_SIGN, Blocks.JUNGLE_SIGN, Blocks.DARK_OAK_SIGN, Blocks.CRIMSON_SIGN, Blocks.WARPED_SIGN, Blocks.MANGROVE_SIGN);
+        this.tag(BlockTags.WALL_SIGNS).add(Blocks.OAK_WALL_SIGN, Blocks.SPRUCE_WALL_SIGN, Blocks.BIRCH_WALL_SIGN, Blocks.ACACIA_WALL_SIGN, Blocks.JUNGLE_WALL_SIGN, Blocks.DARK_OAK_WALL_SIGN, Blocks.CRIMSON_WALL_SIGN, Blocks.WARPED_WALL_SIGN, Blocks.MANGROVE_WALL_SIGN);
+        this.tag(BlockTags.SIGNS).addTag(BlockTags.STANDING_SIGNS).addTag(BlockTags.WALL_SIGNS);
+        this.tag(BlockTags.BEDS).add(Blocks.RED_BED, Blocks.BLACK_BED, Blocks.BLUE_BED, Blocks.BROWN_BED, Blocks.CYAN_BED, Blocks.GRAY_BED, Blocks.GREEN_BED, Blocks.LIGHT_BLUE_BED, Blocks.LIGHT_GRAY_BED, Blocks.LIME_BED, Blocks.MAGENTA_BED, Blocks.ORANGE_BED, Blocks.PINK_BED, Blocks.PURPLE_BED, Blocks.WHITE_BED, Blocks.YELLOW_BED);
+        this.tag(BlockTags.FENCES).addTag(BlockTags.WOODEN_FENCES).add(Blocks.NETHER_BRICK_FENCE);
+        this.tag(BlockTags.DRAGON_IMMUNE).add(Blocks.BARRIER, Blocks.BEDROCK, Blocks.END_PORTAL, Blocks.END_PORTAL_FRAME, Blocks.END_GATEWAY, Blocks.COMMAND_BLOCK, Blocks.REPEATING_COMMAND_BLOCK, Blocks.CHAIN_COMMAND_BLOCK, Blocks.STRUCTURE_BLOCK, Blocks.JIGSAW, Blocks.MOVING_PISTON, Blocks.OBSIDIAN, Blocks.CRYING_OBSIDIAN, Blocks.END_STONE, Blocks.IRON_BARS, Blocks.RESPAWN_ANCHOR, Blocks.REINFORCED_DEEPSLATE);
+        this.tag(BlockTags.DRAGON_TRANSPARENT).add(Blocks.LIGHT).addTag(BlockTags.FIRE);
+        this.tag(BlockTags.WITHER_IMMUNE).add(Blocks.BARRIER, Blocks.BEDROCK, Blocks.END_PORTAL, Blocks.END_PORTAL_FRAME, Blocks.END_GATEWAY, Blocks.COMMAND_BLOCK, Blocks.REPEATING_COMMAND_BLOCK, Blocks.CHAIN_COMMAND_BLOCK, Blocks.STRUCTURE_BLOCK, Blocks.JIGSAW, Blocks.MOVING_PISTON, Blocks.LIGHT, Blocks.REINFORCED_DEEPSLATE);
+        this.tag(BlockTags.WITHER_SUMMON_BASE_BLOCKS).add(Blocks.SOUL_SAND, Blocks.SOUL_SOIL);
+        this.tag(BlockTags.TALL_FLOWERS).add(Blocks.SUNFLOWER, Blocks.LILAC, Blocks.PEONY, Blocks.ROSE_BUSH);
+        this.tag(BlockTags.FLOWERS).addTag(BlockTags.SMALL_FLOWERS).addTag(BlockTags.TALL_FLOWERS).add(Blocks.FLOWERING_AZALEA_LEAVES, Blocks.FLOWERING_AZALEA, Blocks.MANGROVE_PROPAGULE);
+        this.tag(BlockTags.BEEHIVES).add(Blocks.BEE_NEST, Blocks.BEEHIVE);
+        this.tag(BlockTags.CROPS).add(Blocks.BEETROOTS, Blocks.CARROTS, Blocks.POTATOES, Blocks.WHEAT, Blocks.MELON_STEM, Blocks.PUMPKIN_STEM);
+        this.tag(BlockTags.BEE_GROWABLES).addTag(BlockTags.CROPS).add(Blocks.SWEET_BERRY_BUSH).add(Blocks.CAVE_VINES).add(Blocks.CAVE_VINES_PLANT);
+        this.tag(BlockTags.SHULKER_BOXES).add(Blocks.SHULKER_BOX, Blocks.BLACK_SHULKER_BOX, Blocks.BLUE_SHULKER_BOX, Blocks.BROWN_SHULKER_BOX, Blocks.CYAN_SHULKER_BOX, Blocks.GRAY_SHULKER_BOX, Blocks.GREEN_SHULKER_BOX, Blocks.LIGHT_BLUE_SHULKER_BOX, Blocks.LIGHT_GRAY_SHULKER_BOX, Blocks.LIME_SHULKER_BOX, Blocks.MAGENTA_SHULKER_BOX, Blocks.ORANGE_SHULKER_BOX, Blocks.PINK_SHULKER_BOX, Blocks.PURPLE_SHULKER_BOX, Blocks.RED_SHULKER_BOX, Blocks.WHITE_SHULKER_BOX, Blocks.YELLOW_SHULKER_BOX);
+        this.tag(BlockTags.PORTALS).add(Blocks.NETHER_PORTAL, Blocks.END_PORTAL, Blocks.END_GATEWAY);
+        this.tag(BlockTags.FIRE).add(Blocks.FIRE, Blocks.SOUL_FIRE);
+        this.tag(BlockTags.NYLIUM).add(Blocks.CRIMSON_NYLIUM, Blocks.WARPED_NYLIUM);
+        this.tag(BlockTags.WART_BLOCKS).add(Blocks.NETHER_WART_BLOCK, Blocks.WARPED_WART_BLOCK);
+        this.tag(BlockTags.BEACON_BASE_BLOCKS).add(Blocks.NETHERITE_BLOCK, Blocks.EMERALD_BLOCK, Blocks.DIAMOND_BLOCK, Blocks.GOLD_BLOCK, Blocks.IRON_BLOCK);
+        this.tag(BlockTags.SOUL_SPEED_BLOCKS).add(Blocks.SOUL_SAND, Blocks.SOUL_SOIL);
+        this.tag(BlockTags.WALL_POST_OVERRIDE).add(Blocks.TORCH, Blocks.SOUL_TORCH, Blocks.REDSTONE_TORCH, Blocks.TRIPWIRE).addTag(BlockTags.SIGNS).addTag(BlockTags.BANNERS).addTag(BlockTags.PRESSURE_PLATES);
+        this.tag(BlockTags.CLIMBABLE).add(Blocks.LADDER, Blocks.VINE, Blocks.SCAFFOLDING, Blocks.WEEPING_VINES, Blocks.WEEPING_VINES_PLANT, Blocks.TWISTING_VINES, Blocks.TWISTING_VINES_PLANT, Blocks.CAVE_VINES, Blocks.CAVE_VINES_PLANT);
+        this.tag(BlockTags.FALL_DAMAGE_RESETTING).addTag(BlockTags.CLIMBABLE).add(Blocks.SWEET_BERRY_BUSH, Blocks.COBWEB);
+        this.tag(BlockTags.PIGLIN_REPELLENTS).add(Blocks.SOUL_FIRE).add(Blocks.SOUL_TORCH).add(Blocks.SOUL_LANTERN).add(Blocks.SOUL_WALL_TORCH).add(Blocks.SOUL_CAMPFIRE);
+        this.tag(BlockTags.HOGLIN_REPELLENTS).add(Blocks.WARPED_FUNGUS).add(Blocks.POTTED_WARPED_FUNGUS).add(Blocks.NETHER_PORTAL).add(Blocks.RESPAWN_ANCHOR);
+        this.tag(BlockTags.GOLD_ORES).add(Blocks.GOLD_ORE, Blocks.NETHER_GOLD_ORE, Blocks.DEEPSLATE_GOLD_ORE);
+        this.tag(BlockTags.IRON_ORES).add(Blocks.IRON_ORE, Blocks.DEEPSLATE_IRON_ORE);
+        this.tag(BlockTags.DIAMOND_ORES).add(Blocks.DIAMOND_ORE, Blocks.DEEPSLATE_DIAMOND_ORE);
+        this.tag(BlockTags.REDSTONE_ORES).add(Blocks.REDSTONE_ORE, Blocks.DEEPSLATE_REDSTONE_ORE);
+        this.tag(BlockTags.COAL_ORES).add(Blocks.COAL_ORE, Blocks.DEEPSLATE_COAL_ORE);
+        this.tag(BlockTags.EMERALD_ORES).add(Blocks.EMERALD_ORE, Blocks.DEEPSLATE_EMERALD_ORE);
+        this.tag(BlockTags.COPPER_ORES).add(Blocks.COPPER_ORE, Blocks.DEEPSLATE_COPPER_ORE);
+        this.tag(BlockTags.LAPIS_ORES).add(Blocks.LAPIS_ORE, Blocks.DEEPSLATE_LAPIS_ORE);
+        this.tag(BlockTags.SOUL_FIRE_BASE_BLOCKS).add(Blocks.SOUL_SAND, Blocks.SOUL_SOIL);
+        this.tag(BlockTags.NON_FLAMMABLE_WOOD).add(Blocks.WARPED_STEM, Blocks.STRIPPED_WARPED_STEM, Blocks.WARPED_HYPHAE, Blocks.STRIPPED_WARPED_HYPHAE, Blocks.CRIMSON_STEM, Blocks.STRIPPED_CRIMSON_STEM, Blocks.CRIMSON_HYPHAE, Blocks.STRIPPED_CRIMSON_HYPHAE, Blocks.CRIMSON_PLANKS, Blocks.WARPED_PLANKS, Blocks.CRIMSON_SLAB, Blocks.WARPED_SLAB, Blocks.CRIMSON_PRESSURE_PLATE, Blocks.WARPED_PRESSURE_PLATE, Blocks.CRIMSON_FENCE, Blocks.WARPED_FENCE, Blocks.CRIMSON_TRAPDOOR, Blocks.WARPED_TRAPDOOR, Blocks.CRIMSON_FENCE_GATE, Blocks.WARPED_FENCE_GATE, Blocks.CRIMSON_STAIRS, Blocks.WARPED_STAIRS, Blocks.CRIMSON_BUTTON, Blocks.WARPED_BUTTON, Blocks.CRIMSON_DOOR, Blocks.WARPED_DOOR, Blocks.CRIMSON_SIGN, Blocks.WARPED_SIGN, Blocks.CRIMSON_WALL_SIGN, Blocks.WARPED_WALL_SIGN);
+        this.tag(BlockTags.STRIDER_WARM_BLOCKS).add(Blocks.LAVA);
+        this.tag(BlockTags.CAMPFIRES).add(Blocks.CAMPFIRE, Blocks.SOUL_CAMPFIRE);
+        this.tag(BlockTags.GUARDED_BY_PIGLINS).add(Blocks.GOLD_BLOCK, Blocks.BARREL, Blocks.CHEST, Blocks.ENDER_CHEST, Blocks.GILDED_BLACKSTONE, Blocks.TRAPPED_CHEST, Blocks.RAW_GOLD_BLOCK).addTag(BlockTags.SHULKER_BOXES).addTag(BlockTags.GOLD_ORES);
+        this.tag(BlockTags.PREVENT_MOB_SPAWNING_INSIDE).addTag(BlockTags.RAILS);
+        this.tag(BlockTags.FENCE_GATES).add(Blocks.ACACIA_FENCE_GATE, Blocks.BIRCH_FENCE_GATE, Blocks.DARK_OAK_FENCE_GATE, Blocks.JUNGLE_FENCE_GATE, Blocks.OAK_FENCE_GATE, Blocks.SPRUCE_FENCE_GATE, Blocks.CRIMSON_FENCE_GATE, Blocks.WARPED_FENCE_GATE, Blocks.MANGROVE_FENCE_GATE);
+        this.tag(BlockTags.UNSTABLE_BOTTOM_CENTER).addTag(BlockTags.FENCE_GATES);
+        this.tag(BlockTags.MUSHROOM_GROW_BLOCK).add(Blocks.MYCELIUM).add(Blocks.PODZOL).add(Blocks.CRIMSON_NYLIUM).add(Blocks.WARPED_NYLIUM);
+        this.tag(BlockTags.INFINIBURN_OVERWORLD).add(Blocks.NETHERRACK, Blocks.MAGMA_BLOCK);
+        this.tag(BlockTags.INFINIBURN_NETHER).addTag(BlockTags.INFINIBURN_OVERWORLD);
+        this.tag(BlockTags.INFINIBURN_END).addTag(BlockTags.INFINIBURN_OVERWORLD).add(Blocks.BEDROCK);
+        this.tag(BlockTags.STONE_ORE_REPLACEABLES).add(Blocks.STONE).add(Blocks.GRANITE).add(Blocks.DIORITE).add(Blocks.ANDESITE);
+        this.tag(BlockTags.DEEPSLATE_ORE_REPLACEABLES).add(Blocks.DEEPSLATE).add(Blocks.TUFF);
+        this.tag(BlockTags.BASE_STONE_OVERWORLD).add(Blocks.STONE).add(Blocks.GRANITE).add(Blocks.DIORITE).add(Blocks.ANDESITE).add(Blocks.TUFF).add(Blocks.DEEPSLATE);
+        this.tag(BlockTags.BASE_STONE_NETHER).add(Blocks.NETHERRACK).add(Blocks.BASALT).add(Blocks.BLACKSTONE);
+        this.tag(BlockTags.OVERWORLD_CARVER_REPLACEABLES).addTag(BlockTags.BASE_STONE_OVERWORLD).addTag(BlockTags.DIRT).addTag(BlockTags.SAND).addTag(BlockTags.TERRACOTTA).addTag(BlockTags.IRON_ORES).addTag(BlockTags.COPPER_ORES).add(Blocks.WATER, Blocks.GRAVEL, Blocks.SANDSTONE, Blocks.RED_SANDSTONE, Blocks.CALCITE, Blocks.SNOW, Blocks.PACKED_ICE, Blocks.RAW_IRON_BLOCK, Blocks.RAW_COPPER_BLOCK);
+        this.tag(BlockTags.NETHER_CARVER_REPLACEABLES).addTag(BlockTags.BASE_STONE_OVERWORLD).addTag(BlockTags.BASE_STONE_NETHER).addTag(BlockTags.DIRT).addTag(BlockTags.NYLIUM).addTag(BlockTags.WART_BLOCKS).add(Blocks.SOUL_SAND, Blocks.SOUL_SOIL);
+        this.tag(BlockTags.CANDLES).add(Blocks.CANDLE, Blocks.WHITE_CANDLE, Blocks.ORANGE_CANDLE, Blocks.MAGENTA_CANDLE, Blocks.LIGHT_BLUE_CANDLE, Blocks.YELLOW_CANDLE, Blocks.LIME_CANDLE, Blocks.PINK_CANDLE, Blocks.GRAY_CANDLE, Blocks.LIGHT_GRAY_CANDLE, Blocks.CYAN_CANDLE, Blocks.PURPLE_CANDLE, Blocks.BLUE_CANDLE, Blocks.BROWN_CANDLE, Blocks.GREEN_CANDLE, Blocks.RED_CANDLE, Blocks.BLACK_CANDLE);
+        this.tag(BlockTags.CANDLE_CAKES).add(Blocks.CANDLE_CAKE, Blocks.WHITE_CANDLE_CAKE, Blocks.ORANGE_CANDLE_CAKE, Blocks.MAGENTA_CANDLE_CAKE, Blocks.LIGHT_BLUE_CANDLE_CAKE, Blocks.YELLOW_CANDLE_CAKE, Blocks.LIME_CANDLE_CAKE, Blocks.PINK_CANDLE_CAKE, Blocks.GRAY_CANDLE_CAKE, Blocks.LIGHT_GRAY_CANDLE_CAKE, Blocks.CYAN_CANDLE_CAKE, Blocks.PURPLE_CANDLE_CAKE, Blocks.BLUE_CANDLE_CAKE, Blocks.BROWN_CANDLE_CAKE, Blocks.GREEN_CANDLE_CAKE, Blocks.RED_CANDLE_CAKE, Blocks.BLACK_CANDLE_CAKE);
+        this.tag(BlockTags.CRYSTAL_SOUND_BLOCKS).add(Blocks.AMETHYST_BLOCK, Blocks.BUDDING_AMETHYST);
+        this.tag(BlockTags.CAULDRONS).add(Blocks.CAULDRON, Blocks.WATER_CAULDRON, Blocks.LAVA_CAULDRON, Blocks.POWDER_SNOW_CAULDRON);
+        this.tag(BlockTags.INSIDE_STEP_SOUND_BLOCKS).add(Blocks.SNOW, Blocks.POWDER_SNOW, Blocks.SCULK_VEIN);
+        this.tag(BlockTags.DRIPSTONE_REPLACEABLE).addTag(BlockTags.BASE_STONE_OVERWORLD);
+        this.tag(BlockTags.CAVE_VINES).add(Blocks.CAVE_VINES_PLANT).add(Blocks.CAVE_VINES);
+        this.tag(BlockTags.MOSS_REPLACEABLE).addTag(BlockTags.BASE_STONE_OVERWORLD).addTag(BlockTags.CAVE_VINES).addTag(BlockTags.DIRT);
+        this.tag(BlockTags.LUSH_GROUND_REPLACEABLE).addTag(BlockTags.MOSS_REPLACEABLE).add(Blocks.CLAY).add(Blocks.GRAVEL).add(Blocks.SAND);
+        this.tag(BlockTags.AZALEA_ROOT_REPLACEABLE).addTag(BlockTags.BASE_STONE_OVERWORLD).addTag(BlockTags.DIRT).addTag(BlockTags.TERRACOTTA).add(Blocks.RED_SAND).add(Blocks.CLAY).add(Blocks.GRAVEL).add(Blocks.SAND).add(Blocks.SNOW_BLOCK).add(Blocks.POWDER_SNOW);
+        this.tag(BlockTags.SMALL_DRIPLEAF_PLACEABLE).add(Blocks.CLAY).add(Blocks.MOSS_BLOCK);
+        this.tag(BlockTags.BIG_DRIPLEAF_PLACEABLE).addTag(BlockTags.SMALL_DRIPLEAF_PLACEABLE).addTag(BlockTags.DIRT).add(Blocks.FARMLAND);
+        this.tag(BlockTags.OCCLUDES_VIBRATION_SIGNALS).addTag(BlockTags.WOOL);
+        this.tag(BlockTags.DAMPENS_VIBRATIONS).addTag(BlockTags.WOOL).addTag(BlockTags.WOOL_CARPETS);
+        this.tag(BlockTags.SNOW).add(Blocks.SNOW, Blocks.SNOW_BLOCK, Blocks.POWDER_SNOW);
+        this.tag(BlockTags.MINEABLE_WITH_AXE).add(Blocks.NOTE_BLOCK, Blocks.ATTACHED_MELON_STEM, Blocks.ATTACHED_PUMPKIN_STEM, Blocks.AZALEA, Blocks.BAMBOO, Blocks.BARREL, Blocks.BEE_NEST, Blocks.BEEHIVE, Blocks.BEETROOTS, Blocks.BIG_DRIPLEAF_STEM, Blocks.BIG_DRIPLEAF, Blocks.BOOKSHELF, Blocks.BROWN_MUSHROOM_BLOCK, Blocks.BROWN_MUSHROOM, Blocks.CAMPFIRE, Blocks.CARROTS, Blocks.CARTOGRAPHY_TABLE, Blocks.CARVED_PUMPKIN, Blocks.CAVE_VINES_PLANT, Blocks.CAVE_VINES, Blocks.CHEST, Blocks.CHORUS_FLOWER, Blocks.CHORUS_PLANT, Blocks.COCOA, Blocks.COMPOSTER, Blocks.CRAFTING_TABLE, Blocks.CRIMSON_FUNGUS, Blocks.DAYLIGHT_DETECTOR, Blocks.DEAD_BUSH, Blocks.FERN, Blocks.FLETCHING_TABLE, Blocks.GLOW_LICHEN, Blocks.GRASS, Blocks.HANGING_ROOTS, Blocks.JACK_O_LANTERN, Blocks.JUKEBOX, Blocks.LADDER, Blocks.LARGE_FERN, Blocks.LECTERN, Blocks.LILY_PAD, Blocks.LOOM, Blocks.MELON_STEM, Blocks.MELON, Blocks.MUSHROOM_STEM, Blocks.NETHER_WART, Blocks.POTATOES, Blocks.PUMPKIN_STEM, Blocks.PUMPKIN, Blocks.RED_MUSHROOM_BLOCK, Blocks.RED_MUSHROOM, Blocks.SCAFFOLDING, Blocks.SMALL_DRIPLEAF, Blocks.SMITHING_TABLE, Blocks.SOUL_CAMPFIRE, Blocks.SPORE_BLOSSOM, Blocks.SUGAR_CANE, Blocks.SWEET_BERRY_BUSH, Blocks.TALL_GRASS, Blocks.TRAPPED_CHEST, Blocks.TWISTING_VINES_PLANT, Blocks.TWISTING_VINES, Blocks.VINE, Blocks.WARPED_FUNGUS, Blocks.WEEPING_VINES_PLANT, Blocks.WEEPING_VINES, Blocks.WHEAT).addTag(BlockTags.BANNERS).addTag(BlockTags.FENCE_GATES).addTag(BlockTags.LOGS).addTag(BlockTags.PLANKS).addTag(BlockTags.SAPLINGS).addTag(BlockTags.SIGNS).addTag(BlockTags.WOODEN_BUTTONS).addTag(BlockTags.WOODEN_DOORS).addTag(BlockTags.WOODEN_FENCES).addTag(BlockTags.WOODEN_PRESSURE_PLATES).addTag(BlockTags.WOODEN_SLABS).addTag(BlockTags.WOODEN_STAIRS).addTag(BlockTags.WOODEN_TRAPDOORS).add(Blocks.MANGROVE_ROOTS);
+        this.tag(BlockTags.MINEABLE_WITH_HOE).add(Blocks.NETHER_WART_BLOCK, Blocks.WARPED_WART_BLOCK, Blocks.HAY_BLOCK, Blocks.DRIED_KELP_BLOCK, Blocks.TARGET, Blocks.SHROOMLIGHT, Blocks.SPONGE, Blocks.WET_SPONGE, Blocks.JUNGLE_LEAVES, Blocks.OAK_LEAVES, Blocks.SPRUCE_LEAVES, Blocks.DARK_OAK_LEAVES, Blocks.ACACIA_LEAVES, Blocks.BIRCH_LEAVES, Blocks.AZALEA_LEAVES, Blocks.FLOWERING_AZALEA_LEAVES, Blocks.MANGROVE_LEAVES, Blocks.SCULK_SENSOR, Blocks.MOSS_BLOCK, Blocks.MOSS_CARPET, Blocks.SCULK, Blocks.SCULK_CATALYST, Blocks.SCULK_VEIN, Blocks.SCULK_SHRIEKER);
+        this.tag(BlockTags.MINEABLE_WITH_PICKAXE).add(Blocks.STONE, Blocks.GRANITE, Blocks.POLISHED_GRANITE, Blocks.DIORITE, Blocks.POLISHED_DIORITE, Blocks.ANDESITE, Blocks.POLISHED_ANDESITE, Blocks.COBBLESTONE, Blocks.GOLD_ORE, Blocks.DEEPSLATE_GOLD_ORE, Blocks.IRON_ORE, Blocks.DEEPSLATE_IRON_ORE, Blocks.COAL_ORE, Blocks.DEEPSLATE_COAL_ORE, Blocks.NETHER_GOLD_ORE, Blocks.LAPIS_ORE, Blocks.DEEPSLATE_LAPIS_ORE, Blocks.LAPIS_BLOCK, Blocks.DISPENSER, Blocks.SANDSTONE, Blocks.CHISELED_SANDSTONE, Blocks.CUT_SANDSTONE, Blocks.GOLD_BLOCK, Blocks.IRON_BLOCK, Blocks.BRICKS, Blocks.MOSSY_COBBLESTONE, Blocks.OBSIDIAN, Blocks.SPAWNER, Blocks.DIAMOND_ORE, Blocks.DEEPSLATE_DIAMOND_ORE, Blocks.DIAMOND_BLOCK, Blocks.FURNACE, Blocks.COBBLESTONE_STAIRS, Blocks.STONE_PRESSURE_PLATE, Blocks.IRON_DOOR, Blocks.REDSTONE_ORE, Blocks.DEEPSLATE_REDSTONE_ORE, Blocks.NETHERRACK, Blocks.BASALT, Blocks.POLISHED_BASALT, Blocks.STONE_BRICKS, Blocks.MOSSY_STONE_BRICKS, Blocks.CRACKED_STONE_BRICKS, Blocks.CHISELED_STONE_BRICKS, Blocks.IRON_BARS, Blocks.CHAIN, Blocks.BRICK_STAIRS, Blocks.STONE_BRICK_STAIRS, Blocks.NETHER_BRICKS, Blocks.NETHER_BRICK_FENCE, Blocks.NETHER_BRICK_STAIRS, Blocks.ENCHANTING_TABLE, Blocks.BREWING_STAND, Blocks.END_STONE, Blocks.SANDSTONE_STAIRS, Blocks.EMERALD_ORE, Blocks.DEEPSLATE_EMERALD_ORE, Blocks.ENDER_CHEST, Blocks.EMERALD_BLOCK, Blocks.LIGHT_WEIGHTED_PRESSURE_PLATE, Blocks.HEAVY_WEIGHTED_PRESSURE_PLATE, Blocks.REDSTONE_BLOCK, Blocks.NETHER_QUARTZ_ORE, Blocks.HOPPER, Blocks.QUARTZ_BLOCK, Blocks.CHISELED_QUARTZ_BLOCK, Blocks.QUARTZ_PILLAR, Blocks.QUARTZ_STAIRS, Blocks.DROPPER, Blocks.WHITE_TERRACOTTA, Blocks.ORANGE_TERRACOTTA, Blocks.MAGENTA_TERRACOTTA, Blocks.LIGHT_BLUE_TERRACOTTA, Blocks.YELLOW_TERRACOTTA, Blocks.LIME_TERRACOTTA, Blocks.PINK_TERRACOTTA, Blocks.GRAY_TERRACOTTA, Blocks.LIGHT_GRAY_TERRACOTTA, Blocks.CYAN_TERRACOTTA, Blocks.PURPLE_TERRACOTTA, Blocks.BLUE_TERRACOTTA, Blocks.BROWN_TERRACOTTA, Blocks.GREEN_TERRACOTTA, Blocks.RED_TERRACOTTA, Blocks.BLACK_TERRACOTTA, Blocks.IRON_TRAPDOOR, Blocks.PRISMARINE, Blocks.PRISMARINE_BRICKS, Blocks.DARK_PRISMARINE, Blocks.PRISMARINE_STAIRS, Blocks.PRISMARINE_BRICK_STAIRS, Blocks.DARK_PRISMARINE_STAIRS, Blocks.PRISMARINE_SLAB, Blocks.PRISMARINE_BRICK_SLAB, Blocks.DARK_PRISMARINE_SLAB, Blocks.TERRACOTTA, Blocks.COAL_BLOCK, Blocks.RED_SANDSTONE, Blocks.CHISELED_RED_SANDSTONE, Blocks.CUT_RED_SANDSTONE, Blocks.RED_SANDSTONE_STAIRS, Blocks.STONE_SLAB, Blocks.SMOOTH_STONE_SLAB, Blocks.SANDSTONE_SLAB, Blocks.CUT_SANDSTONE_SLAB, Blocks.PETRIFIED_OAK_SLAB, Blocks.COBBLESTONE_SLAB, Blocks.BRICK_SLAB, Blocks.STONE_BRICK_SLAB, Blocks.NETHER_BRICK_SLAB, Blocks.QUARTZ_SLAB, Blocks.RED_SANDSTONE_SLAB, Blocks.CUT_RED_SANDSTONE_SLAB, Blocks.PURPUR_SLAB, Blocks.SMOOTH_STONE, Blocks.SMOOTH_SANDSTONE, Blocks.SMOOTH_QUARTZ, Blocks.SMOOTH_RED_SANDSTONE, Blocks.PURPUR_BLOCK, Blocks.PURPUR_PILLAR, Blocks.PURPUR_STAIRS, Blocks.END_STONE_BRICKS, Blocks.MAGMA_BLOCK, Blocks.RED_NETHER_BRICKS, Blocks.BONE_BLOCK, Blocks.OBSERVER, Blocks.WHITE_GLAZED_TERRACOTTA, Blocks.ORANGE_GLAZED_TERRACOTTA, Blocks.MAGENTA_GLAZED_TERRACOTTA, Blocks.LIGHT_BLUE_GLAZED_TERRACOTTA, Blocks.YELLOW_GLAZED_TERRACOTTA, Blocks.LIME_GLAZED_TERRACOTTA, Blocks.PINK_GLAZED_TERRACOTTA, Blocks.GRAY_GLAZED_TERRACOTTA, Blocks.LIGHT_GRAY_GLAZED_TERRACOTTA, Blocks.CYAN_GLAZED_TERRACOTTA, Blocks.PURPLE_GLAZED_TERRACOTTA, Blocks.BLUE_GLAZED_TERRACOTTA, Blocks.BROWN_GLAZED_TERRACOTTA, Blocks.GREEN_GLAZED_TERRACOTTA, Blocks.RED_GLAZED_TERRACOTTA, Blocks.BLACK_GLAZED_TERRACOTTA, Blocks.WHITE_CONCRETE, Blocks.ORANGE_CONCRETE, Blocks.MAGENTA_CONCRETE, Blocks.LIGHT_BLUE_CONCRETE, Blocks.YELLOW_CONCRETE, Blocks.LIME_CONCRETE, Blocks.PINK_CONCRETE, Blocks.GRAY_CONCRETE, Blocks.LIGHT_GRAY_CONCRETE, Blocks.CYAN_CONCRETE, Blocks.PURPLE_CONCRETE, Blocks.BLUE_CONCRETE, Blocks.BROWN_CONCRETE, Blocks.GREEN_CONCRETE, Blocks.RED_CONCRETE, Blocks.BLACK_CONCRETE, Blocks.DEAD_TUBE_CORAL_BLOCK, Blocks.DEAD_BRAIN_CORAL_BLOCK, Blocks.DEAD_BUBBLE_CORAL_BLOCK, Blocks.DEAD_FIRE_CORAL_BLOCK, Blocks.DEAD_HORN_CORAL_BLOCK, Blocks.TUBE_CORAL_BLOCK, Blocks.BRAIN_CORAL_BLOCK, Blocks.BUBBLE_CORAL_BLOCK, Blocks.FIRE_CORAL_BLOCK, Blocks.HORN_CORAL_BLOCK, Blocks.DEAD_TUBE_CORAL, Blocks.DEAD_BRAIN_CORAL, Blocks.DEAD_BUBBLE_CORAL, Blocks.DEAD_FIRE_CORAL, Blocks.DEAD_HORN_CORAL, Blocks.DEAD_TUBE_CORAL_FAN, Blocks.DEAD_BRAIN_CORAL_FAN, Blocks.DEAD_BUBBLE_CORAL_FAN, Blocks.DEAD_FIRE_CORAL_FAN, Blocks.DEAD_HORN_CORAL_FAN, Blocks.DEAD_TUBE_CORAL_WALL_FAN, Blocks.DEAD_BRAIN_CORAL_WALL_FAN, Blocks.DEAD_BUBBLE_CORAL_WALL_FAN, Blocks.DEAD_FIRE_CORAL_WALL_FAN, Blocks.DEAD_HORN_CORAL_WALL_FAN, Blocks.POLISHED_GRANITE_STAIRS, Blocks.SMOOTH_RED_SANDSTONE_STAIRS, Blocks.MOSSY_STONE_BRICK_STAIRS, Blocks.POLISHED_DIORITE_STAIRS, Blocks.MOSSY_COBBLESTONE_STAIRS, Blocks.END_STONE_BRICK_STAIRS, Blocks.STONE_STAIRS, Blocks.SMOOTH_SANDSTONE_STAIRS, Blocks.SMOOTH_QUARTZ_STAIRS, Blocks.GRANITE_STAIRS, Blocks.ANDESITE_STAIRS, Blocks.RED_NETHER_BRICK_STAIRS, Blocks.POLISHED_ANDESITE_STAIRS, Blocks.DIORITE_STAIRS, Blocks.POLISHED_GRANITE_SLAB, Blocks.SMOOTH_RED_SANDSTONE_SLAB, Blocks.MOSSY_STONE_BRICK_SLAB, Blocks.POLISHED_DIORITE_SLAB, Blocks.MOSSY_COBBLESTONE_SLAB, Blocks.END_STONE_BRICK_SLAB, Blocks.SMOOTH_SANDSTONE_SLAB, Blocks.SMOOTH_QUARTZ_SLAB, Blocks.GRANITE_SLAB, Blocks.ANDESITE_SLAB, Blocks.RED_NETHER_BRICK_SLAB, Blocks.POLISHED_ANDESITE_SLAB, Blocks.DIORITE_SLAB, Blocks.SMOKER, Blocks.BLAST_FURNACE, Blocks.GRINDSTONE, Blocks.STONECUTTER, Blocks.BELL, Blocks.LANTERN, Blocks.SOUL_LANTERN, Blocks.WARPED_NYLIUM, Blocks.CRIMSON_NYLIUM, Blocks.NETHERITE_BLOCK, Blocks.ANCIENT_DEBRIS, Blocks.CRYING_OBSIDIAN, Blocks.RESPAWN_ANCHOR, Blocks.LODESTONE, Blocks.BLACKSTONE, Blocks.BLACKSTONE_STAIRS, Blocks.BLACKSTONE_SLAB, Blocks.POLISHED_BLACKSTONE, Blocks.POLISHED_BLACKSTONE_BRICKS, Blocks.CRACKED_POLISHED_BLACKSTONE_BRICKS, Blocks.CHISELED_POLISHED_BLACKSTONE, Blocks.POLISHED_BLACKSTONE_BRICK_SLAB, Blocks.POLISHED_BLACKSTONE_BRICK_STAIRS, Blocks.GILDED_BLACKSTONE, Blocks.POLISHED_BLACKSTONE_STAIRS, Blocks.POLISHED_BLACKSTONE_SLAB, Blocks.POLISHED_BLACKSTONE_PRESSURE_PLATE, Blocks.CHISELED_NETHER_BRICKS, Blocks.CRACKED_NETHER_BRICKS, Blocks.QUARTZ_BRICKS, Blocks.TUFF, Blocks.CALCITE, Blocks.OXIDIZED_COPPER, Blocks.WEATHERED_COPPER, Blocks.EXPOSED_COPPER, Blocks.COPPER_BLOCK, Blocks.COPPER_ORE, Blocks.DEEPSLATE_COPPER_ORE, Blocks.OXIDIZED_CUT_COPPER, Blocks.WEATHERED_CUT_COPPER, Blocks.EXPOSED_CUT_COPPER, Blocks.CUT_COPPER, Blocks.OXIDIZED_CUT_COPPER_STAIRS, Blocks.WEATHERED_CUT_COPPER_STAIRS, Blocks.EXPOSED_CUT_COPPER_STAIRS, Blocks.CUT_COPPER_STAIRS, Blocks.OXIDIZED_CUT_COPPER_SLAB, Blocks.WEATHERED_CUT_COPPER_SLAB, Blocks.EXPOSED_CUT_COPPER_SLAB, Blocks.CUT_COPPER_SLAB, Blocks.WAXED_COPPER_BLOCK, Blocks.WAXED_WEATHERED_COPPER, Blocks.WAXED_EXPOSED_COPPER, Blocks.WAXED_OXIDIZED_COPPER, Blocks.WAXED_OXIDIZED_CUT_COPPER, Blocks.WAXED_WEATHERED_CUT_COPPER, Blocks.WAXED_EXPOSED_CUT_COPPER, Blocks.WAXED_CUT_COPPER, Blocks.WAXED_OXIDIZED_CUT_COPPER_STAIRS, Blocks.WAXED_WEATHERED_CUT_COPPER_STAIRS, Blocks.WAXED_EXPOSED_CUT_COPPER_STAIRS, Blocks.WAXED_CUT_COPPER_STAIRS, Blocks.WAXED_OXIDIZED_CUT_COPPER_SLAB, Blocks.WAXED_WEATHERED_CUT_COPPER_SLAB, Blocks.WAXED_EXPOSED_CUT_COPPER_SLAB, Blocks.WAXED_CUT_COPPER_SLAB, Blocks.LIGHTNING_ROD, Blocks.POINTED_DRIPSTONE, Blocks.DRIPSTONE_BLOCK, Blocks.DEEPSLATE, Blocks.COBBLED_DEEPSLATE, Blocks.COBBLED_DEEPSLATE_STAIRS, Blocks.COBBLED_DEEPSLATE_SLAB, Blocks.POLISHED_DEEPSLATE, Blocks.POLISHED_DEEPSLATE_STAIRS, Blocks.POLISHED_DEEPSLATE_SLAB, Blocks.DEEPSLATE_TILES, Blocks.DEEPSLATE_TILE_STAIRS, Blocks.DEEPSLATE_TILE_SLAB, Blocks.DEEPSLATE_BRICKS, Blocks.DEEPSLATE_BRICK_STAIRS, Blocks.DEEPSLATE_BRICK_SLAB, Blocks.CHISELED_DEEPSLATE, Blocks.CRACKED_DEEPSLATE_BRICKS, Blocks.CRACKED_DEEPSLATE_TILES, Blocks.SMOOTH_BASALT, Blocks.RAW_IRON_BLOCK, Blocks.RAW_COPPER_BLOCK, Blocks.RAW_GOLD_BLOCK, Blocks.ICE, Blocks.PACKED_ICE, Blocks.BLUE_ICE, Blocks.STONE_BUTTON, Blocks.PISTON, Blocks.STICKY_PISTON, Blocks.PISTON_HEAD, Blocks.AMETHYST_CLUSTER, Blocks.SMALL_AMETHYST_BUD, Blocks.MEDIUM_AMETHYST_BUD, Blocks.LARGE_AMETHYST_BUD, Blocks.AMETHYST_BLOCK, Blocks.BUDDING_AMETHYST, Blocks.INFESTED_COBBLESTONE, Blocks.INFESTED_CHISELED_STONE_BRICKS, Blocks.INFESTED_CRACKED_STONE_BRICKS, Blocks.INFESTED_DEEPSLATE, Blocks.INFESTED_STONE, Blocks.INFESTED_MOSSY_STONE_BRICKS, Blocks.INFESTED_STONE_BRICKS).addTag(BlockTags.WALLS).addTag(BlockTags.SHULKER_BOXES).addTag(BlockTags.ANVIL).addTag(BlockTags.CAULDRONS).addTag(BlockTags.RAILS).add(Blocks.CONDUIT).add(Blocks.MUD_BRICKS).add(Blocks.MUD_BRICK_STAIRS).add(Blocks.MUD_BRICK_SLAB).add(Blocks.PACKED_MUD);
+        this.tag(BlockTags.MINEABLE_WITH_SHOVEL).add(Blocks.CLAY, Blocks.DIRT, Blocks.COARSE_DIRT, Blocks.PODZOL, Blocks.FARMLAND, Blocks.GRASS_BLOCK, Blocks.GRAVEL, Blocks.MYCELIUM, Blocks.SAND, Blocks.RED_SAND, Blocks.SNOW_BLOCK, Blocks.SNOW, Blocks.SOUL_SAND, Blocks.DIRT_PATH, Blocks.WHITE_CONCRETE_POWDER, Blocks.ORANGE_CONCRETE_POWDER, Blocks.MAGENTA_CONCRETE_POWDER, Blocks.LIGHT_BLUE_CONCRETE_POWDER, Blocks.YELLOW_CONCRETE_POWDER, Blocks.LIME_CONCRETE_POWDER, Blocks.PINK_CONCRETE_POWDER, Blocks.GRAY_CONCRETE_POWDER, Blocks.LIGHT_GRAY_CONCRETE_POWDER, Blocks.CYAN_CONCRETE_POWDER, Blocks.PURPLE_CONCRETE_POWDER, Blocks.BLUE_CONCRETE_POWDER, Blocks.BROWN_CONCRETE_POWDER, Blocks.GREEN_CONCRETE_POWDER, Blocks.RED_CONCRETE_POWDER, Blocks.BLACK_CONCRETE_POWDER, Blocks.SOUL_SOIL, Blocks.ROOTED_DIRT, Blocks.MUDDY_MANGROVE_ROOTS, Blocks.MUD);
+        this.tag(BlockTags.NEEDS_DIAMOND_TOOL).add(Blocks.OBSIDIAN, Blocks.CRYING_OBSIDIAN, Blocks.NETHERITE_BLOCK, Blocks.RESPAWN_ANCHOR, Blocks.ANCIENT_DEBRIS);
+        this.tag(BlockTags.NEEDS_IRON_TOOL).add(Blocks.DIAMOND_BLOCK, Blocks.DIAMOND_ORE, Blocks.DEEPSLATE_DIAMOND_ORE, Blocks.EMERALD_ORE, Blocks.DEEPSLATE_EMERALD_ORE, Blocks.EMERALD_BLOCK, Blocks.GOLD_BLOCK, Blocks.RAW_GOLD_BLOCK, Blocks.GOLD_ORE, Blocks.DEEPSLATE_GOLD_ORE, Blocks.REDSTONE_ORE, Blocks.DEEPSLATE_REDSTONE_ORE);
+        this.tag(BlockTags.NEEDS_STONE_TOOL).add(Blocks.IRON_BLOCK, Blocks.RAW_IRON_BLOCK, Blocks.IRON_ORE, Blocks.DEEPSLATE_IRON_ORE, Blocks.LAPIS_BLOCK, Blocks.LAPIS_ORE, Blocks.DEEPSLATE_LAPIS_ORE, Blocks.COPPER_BLOCK, Blocks.RAW_COPPER_BLOCK, Blocks.COPPER_ORE, Blocks.DEEPSLATE_COPPER_ORE, Blocks.CUT_COPPER_SLAB, Blocks.CUT_COPPER_STAIRS, Blocks.CUT_COPPER, Blocks.WEATHERED_COPPER, Blocks.WEATHERED_CUT_COPPER_SLAB, Blocks.WEATHERED_CUT_COPPER_STAIRS, Blocks.WEATHERED_CUT_COPPER, Blocks.OXIDIZED_COPPER, Blocks.OXIDIZED_CUT_COPPER_SLAB, Blocks.OXIDIZED_CUT_COPPER_STAIRS, Blocks.OXIDIZED_CUT_COPPER, Blocks.EXPOSED_COPPER, Blocks.EXPOSED_CUT_COPPER_SLAB, Blocks.EXPOSED_CUT_COPPER_STAIRS, Blocks.EXPOSED_CUT_COPPER, Blocks.WAXED_COPPER_BLOCK, Blocks.WAXED_CUT_COPPER_SLAB, Blocks.WAXED_CUT_COPPER_STAIRS, Blocks.WAXED_CUT_COPPER, Blocks.WAXED_WEATHERED_COPPER, Blocks.WAXED_WEATHERED_CUT_COPPER_SLAB, Blocks.WAXED_WEATHERED_CUT_COPPER_STAIRS, Blocks.WAXED_WEATHERED_CUT_COPPER, Blocks.WAXED_EXPOSED_COPPER, Blocks.WAXED_EXPOSED_CUT_COPPER_SLAB, Blocks.WAXED_EXPOSED_CUT_COPPER_STAIRS, Blocks.WAXED_EXPOSED_CUT_COPPER, Blocks.WAXED_OXIDIZED_COPPER, Blocks.WAXED_OXIDIZED_CUT_COPPER_SLAB, Blocks.WAXED_OXIDIZED_CUT_COPPER_STAIRS, Blocks.WAXED_OXIDIZED_CUT_COPPER, Blocks.LIGHTNING_ROD);
+        this.tag(BlockTags.FEATURES_CANNOT_REPLACE).add(Blocks.BEDROCK, Blocks.SPAWNER, Blocks.CHEST, Blocks.END_PORTAL_FRAME, Blocks.REINFORCED_DEEPSLATE);
+        this.tag(BlockTags.LAVA_POOL_STONE_CANNOT_REPLACE).addTag(BlockTags.FEATURES_CANNOT_REPLACE).addTag(BlockTags.LEAVES).addTag(BlockTags.LOGS);
+        this.tag(BlockTags.GEODE_INVALID_BLOCKS).add(Blocks.BEDROCK, Blocks.WATER, Blocks.LAVA, Blocks.ICE, Blocks.PACKED_ICE, Blocks.BLUE_ICE);
+        this.tag(BlockTags.ANIMALS_SPAWNABLE_ON).add(Blocks.GRASS_BLOCK);
+        this.tag(BlockTags.AXOLOTLS_SPAWNABLE_ON).add(Blocks.CLAY);
+        this.tag(BlockTags.GOATS_SPAWNABLE_ON).add(Blocks.STONE, Blocks.SNOW, Blocks.SNOW_BLOCK, Blocks.PACKED_ICE, Blocks.GRAVEL);
+        this.tag(BlockTags.MOOSHROOMS_SPAWNABLE_ON).add(Blocks.MYCELIUM);
+        this.tag(BlockTags.PARROTS_SPAWNABLE_ON).add(Blocks.GRASS_BLOCK, Blocks.AIR).addTag(BlockTags.LEAVES).addTag(BlockTags.LOGS);
+        this.tag(BlockTags.POLAR_BEARS_SPAWNABLE_ON_ALTERNATE).add(Blocks.ICE);
+        this.tag(BlockTags.RABBITS_SPAWNABLE_ON).add(Blocks.GRASS_BLOCK, Blocks.SNOW, Blocks.SNOW_BLOCK, Blocks.SAND);
+        this.tag(BlockTags.FOXES_SPAWNABLE_ON).add(Blocks.GRASS_BLOCK, Blocks.SNOW, Blocks.SNOW_BLOCK, Blocks.PODZOL, Blocks.COARSE_DIRT);
+        this.tag(BlockTags.WOLVES_SPAWNABLE_ON).add(Blocks.GRASS_BLOCK, Blocks.SNOW, Blocks.SNOW_BLOCK);
+        this.tag(BlockTags.FROGS_SPAWNABLE_ON).add(Blocks.GRASS_BLOCK, Blocks.MUD, Blocks.MANGROVE_ROOTS, Blocks.MUDDY_MANGROVE_ROOTS);
+        this.tag(BlockTags.TERRACOTTA).add(Blocks.TERRACOTTA, Blocks.WHITE_TERRACOTTA, Blocks.ORANGE_TERRACOTTA, Blocks.MAGENTA_TERRACOTTA, Blocks.LIGHT_BLUE_TERRACOTTA, Blocks.YELLOW_TERRACOTTA, Blocks.LIME_TERRACOTTA, Blocks.PINK_TERRACOTTA, Blocks.GRAY_TERRACOTTA, Blocks.LIGHT_GRAY_TERRACOTTA, Blocks.CYAN_TERRACOTTA, Blocks.PURPLE_TERRACOTTA, Blocks.BLUE_TERRACOTTA, Blocks.BROWN_TERRACOTTA, Blocks.GREEN_TERRACOTTA, Blocks.RED_TERRACOTTA, Blocks.BLACK_TERRACOTTA);
+        this.tag(BlockTags.AZALEA_GROWS_ON).addTag(BlockTags.DIRT).addTag(BlockTags.SAND).addTag(BlockTags.TERRACOTTA).add(Blocks.SNOW_BLOCK).add(Blocks.POWDER_SNOW);
+        this.tag(BlockTags.REPLACEABLE_PLANTS).add(Blocks.GRASS, Blocks.FERN, Blocks.DEAD_BUSH, Blocks.VINE, Blocks.GLOW_LICHEN, Blocks.SUNFLOWER, Blocks.LILAC, Blocks.ROSE_BUSH, Blocks.PEONY, Blocks.TALL_GRASS, Blocks.LARGE_FERN, Blocks.HANGING_ROOTS);
+        this.tag(BlockTags.FROG_PREFER_JUMP_TO).add(Blocks.LILY_PAD, Blocks.BIG_DRIPLEAF);
+        this.tag(BlockTags.SCULK_REPLACEABLE).addTag(BlockTags.BASE_STONE_OVERWORLD).addTag(BlockTags.DIRT).addTag(BlockTags.TERRACOTTA).addTag(BlockTags.NYLIUM).addTag(BlockTags.BASE_STONE_NETHER).addTag(BlockTags.SAND).add(Blocks.GRAVEL).add(Blocks.SOUL_SAND).add(Blocks.SOUL_SOIL).add(Blocks.CALCITE).add(Blocks.SMOOTH_BASALT).add(Blocks.CLAY).add(Blocks.DRIPSTONE_BLOCK).add(Blocks.END_STONE).add(Blocks.RED_SANDSTONE).add(Blocks.SANDSTONE);
+        this.tag(BlockTags.SCULK_REPLACEABLE_WORLD_GEN).addTag(BlockTags.SCULK_REPLACEABLE).add(Blocks.DEEPSLATE_BRICKS).add(Blocks.DEEPSLATE_TILES).add(Blocks.COBBLED_DEEPSLATE).add(Blocks.CRACKED_DEEPSLATE_BRICKS).add(Blocks.CRACKED_DEEPSLATE_TILES).add(Blocks.POLISHED_DEEPSLATE);
+        this.tag(BlockTags.CONVERTABLE_TO_MUD).add(Blocks.DIRT, Blocks.COARSE_DIRT, Blocks.ROOTED_DIRT);
+        this.tag(BlockTags.ANCIENT_CITY_REPLACEABLE).add(Blocks.DEEPSLATE).add(Blocks.DEEPSLATE_BRICKS).add(Blocks.DEEPSLATE_TILES).add(Blocks.DEEPSLATE_BRICK_SLAB).add(Blocks.DEEPSLATE_TILE_SLAB).add(Blocks.DEEPSLATE_BRICK_STAIRS).add(Blocks.DEEPSLATE_TILE_WALL).add(Blocks.DEEPSLATE_BRICK_WALL).add(Blocks.COBBLED_DEEPSLATE).add(Blocks.CRACKED_DEEPSLATE_BRICKS).add(Blocks.CRACKED_DEEPSLATE_TILES).add(Blocks.GRAY_WOOL);
+        this.tag(BlockTags.MANGROVE_LOGS_CAN_GROW_THROUGH).add(Blocks.MUD, Blocks.MUDDY_MANGROVE_ROOTS, Blocks.MANGROVE_ROOTS, Blocks.MANGROVE_LEAVES, Blocks.MANGROVE_LOG, Blocks.MANGROVE_PROPAGULE, Blocks.MOSS_CARPET, Blocks.VINE);
+        this.tag(BlockTags.MANGROVE_ROOTS_CAN_GROW_THROUGH).add(Blocks.MUD, Blocks.MUDDY_MANGROVE_ROOTS, Blocks.MANGROVE_ROOTS, Blocks.MOSS_CARPET, Blocks.VINE, Blocks.MANGROVE_PROPAGULE, Blocks.SNOW);
+        this.tag(BlockTags.DEAD_BUSH_MAY_PLACE_ON).addTag(BlockTags.SAND).addTag(BlockTags.TERRACOTTA).addTag(BlockTags.DIRT);
+        this.tag(BlockTags.SNOW_LAYER_CANNOT_SURVIVE_ON).add(Blocks.ICE).add(Blocks.PACKED_ICE).add(Blocks.BARRIER);
+        this.tag(BlockTags.SNOW_LAYER_CAN_SURVIVE_ON).add(Blocks.HONEY_BLOCK).add(Blocks.SOUL_SAND).add(Blocks.MUD);
+        this.tag(BlockTags.COMPLETES_FIND_TREE_TUTORIAL).addTag(BlockTags.LOGS).addTag(BlockTags.LEAVES).addTag(BlockTags.WART_BLOCKS);
+        this.tag(BlockTags.SNAPS_GOAT_HORN).addTag(BlockTags.OVERWORLD_NATURAL_LOGS).add(Blocks.STONE).add(Blocks.PACKED_ICE).add(Blocks.IRON_ORE).add(Blocks.COAL_ORE).add(Blocks.COPPER_ORE).add(Blocks.EMERALD_ORE);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlocks.java b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlocks.java
new file mode 100644
index 0000000000000000000000000000000000000000..cdc84463a94ed25312296540f6e7df6b1b1e0d90
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlocks.java
@@ -0,0 +1,992 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.block;
+
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.DyeColor;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.InfestedBlock;
+import net.minecraft.world.level.block.LeavesBlock;
+import net.minecraft.world.level.block.RotatedPillarBlock;
+import net.minecraft.world.level.block.SlabBlock;
+import net.minecraft.world.level.block.SoulFireBlock;
+import net.minecraft.world.level.block.SoundType;
+import net.minecraft.world.level.block.StairBlock;
+import net.minecraft.world.level.block.state.BlockBehaviour;
+import net.minecraft.world.level.material.Material;
+import net.minecraft.world.level.material.MaterialColor;
+import net.minecraft.world.level.storage.loot.LootTable;
+import net.minecraft.world.level.storage.loot.providers.number.ConstantValue;
+import nl.martijnmuijsers.paper.block.replacementrule.BlockReplacementRuleBuilder;
+import nl.martijnmuijsers.paper.block.replacementrule.SingleMultiStateRealBlockReplacementRuleBuilder;
+import nl.martijnmuijsers.paper.block.replacementrule.SingleStateRealBlockReplacementRule;
+import nl.martijnmuijsers.paper.block.replacementrule.BlockReplacementRule;
+import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelContent;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelCreation;
+import nl.martijnmuijsers.paper.blockanditemdata.texture.Texture;
+import nl.martijnmuijsers.paper.blockanditemdata.texture.TextureContent;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.function.Function;
+import java.util.function.Supplier;
+
+/**
+ * Based on {@link net.minecraft.world.level.block.Blocks}
+ */
+public class SuCraftBlocks {
+
+    public static final Block SNOWY_STONE_BRICKS = registerStoneBricks("snowy", Blocks.INFESTED_STONE_BRICKS, Blocks.STONE_BRICKS, Blocks.STONE_BRICKS);
+    public static final Block DIRTY_STONE_BRICKS = registerStoneBricks("dirty", Blocks.INFESTED_CRACKED_STONE_BRICKS, Blocks.CRACKED_STONE_BRICKS, Blocks.STONE_BRICKS);
+    public static final Block INFESTED_SNOWY_STONE_BRICKS = registerInfested(SNOWY_STONE_BRICKS);
+    public static final Block INFESTED_DIRTY_STONE_BRICKS = registerInfested(DIRTY_STONE_BRICKS);
+    public static final Block SPRUCE_BOOKSHELF = registerBookshelf("spruce");
+    public static final Block BIRCH_BOOKSHELF = registerBookshelf("birch");
+    public static final Block JUNGLE_BOOKSHELF = registerBookshelf("jungle");
+    public static final Block ACACIA_BOOKSHELF = registerBookshelf("acacia");
+    public static final Block DARK_OAK_BOOKSHELF = registerBookshelf("dark_oak");
+    public static final Block WARPED_BOOKSHELF = registerBookshelf("warped");
+    public static final Block CRIMSON_BOOKSHELF = registerBookshelf("crimson");
+//    public static final Block MANGROVE_BOOKSHELF = registerBookshelf("mangrove");
+    public static final Block BLACK_PLANKS = registerPlanks("black", Blocks.DARK_OAK_PLANKS, DyeColor.BLACK.getMaterialColor());
+    public static final Block BLUE_PLANKS = registerPlanks("blue", Blocks.WARPED_PLANKS, DyeColor.BLUE.getMaterialColor());
+    public static final Block BROWN_PLANKS = registerPlanks("brown", Blocks.SPRUCE_PLANKS, DyeColor.BROWN.getMaterialColor());
+    public static final Block CYAN_PLANKS = registerPlanks("cyan", Blocks.WARPED_PLANKS, DyeColor.CYAN.getMaterialColor());
+    public static final Block GRAY_PLANKS = registerPlanks("gray", Blocks.SPRUCE_PLANKS, DyeColor.GRAY.getMaterialColor());
+    public static final Block GREEN_PLANKS = registerPlanks("green", Blocks.WARPED_PLANKS, DyeColor.GREEN.getMaterialColor());
+    public static final Block LIGHT_BLUE_PLANKS = registerPlanks("light_blue", Blocks.WARPED_PLANKS, DyeColor.LIGHT_BLUE.getMaterialColor());
+    public static final Block LIGHT_GRAY_PLANKS = registerPlanks("light_gray", Blocks.OAK_PLANKS, DyeColor.LIGHT_GRAY.getMaterialColor());
+    public static final Block LIME_PLANKS = registerPlanks("lime", Blocks.WARPED_PLANKS, DyeColor.LIME.getMaterialColor());
+    public static final Block MAGENTA_PLANKS = registerPlanks("magenta", Blocks.CRIMSON_PLANKS, DyeColor.MAGENTA.getMaterialColor());
+    public static final Block ORANGE_PLANKS = registerPlanks("orange", Blocks.ACACIA_PLANKS, DyeColor.ORANGE.getMaterialColor());
+    public static final Block PINK_PLANKS = registerPlanks("pink", Blocks.JUNGLE_PLANKS, DyeColor.PINK.getMaterialColor());
+    public static final Block PURPLE_PLANKS = registerPlanks("purple", Blocks.CRIMSON_PLANKS, DyeColor.PURPLE.getMaterialColor());
+    public static final Block RED_PLANKS = registerPlanks("red", Blocks.MANGROVE_PLANKS, DyeColor.RED.getMaterialColor());
+    public static final Block WHITE_PLANKS = registerPlanks("white", Blocks.BIRCH_PLANKS, DyeColor.WHITE.getMaterialColor());
+    public static final Block YELLOW_PLANKS = registerPlanks("yellow", Blocks.BIRCH_PLANKS, DyeColor.YELLOW.getMaterialColor());
+
+    /**
+     * Based on {@link Blocks#DIRT}
+     */
+    public static final Block DIRT_BRICKS = register(
+        "dirt_bricks",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.DIRT)
+            .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.DIRT).strength(0.5F, 1.0F).sound(SoundType.GRAVEL)).mineableWithShovel().dirt(),
+        SuCraftBlockLoot::dropSelf
+    ).withCustomOneToOneStonecutterRecipe(Blocks.DIRT);
+
+    public static final Block POLISHED_CALCITE = registerPolished(Blocks.CALCITE, "calcite", Blocks.CALCITE, MaterialColor.TERRACOTTA_WHITE);
+    public static final Block POLISHED_DRIPSTONE = registerPolished(Blocks.DRIPSTONE_BLOCK, "dripstone", Blocks.DRIPSTONE_BLOCK, MaterialColor.TERRACOTTA_BROWN);
+    public static final Block POLISHED_TUFF = registerPolished(Blocks.TUFF, "tuff", Blocks.TUFF, MaterialColor.TERRACOTTA_GRAY);
+    public static final Block ANDESITE_BRICKS = registerBricks(Blocks.ANDESITE, "andesite", Blocks.POLISHED_ANDESITE, MaterialColor.STONE);
+    public static final Block CALCITE_BRICKS = registerBricks(Blocks.CALCITE, "calcite", Blocks.CALCITE, MaterialColor.TERRACOTTA_WHITE);
+    public static final Block DIORITE_BRICKS = registerBricks(Blocks.DIORITE, "diorite", Blocks.POLISHED_DIORITE, MaterialColor.QUARTZ);
+    public static final Block DRIPSTONE_BRICKS = registerBricks(Blocks.DRIPSTONE_BLOCK, "dripstone", Blocks.DRIPSTONE_BLOCK, MaterialColor.TERRACOTTA_BROWN);
+    public static final Block GRANITE_BRICKS = registerBricks(Blocks.GRANITE, "granite", Blocks.POLISHED_GRANITE, MaterialColor.DIRT);
+    public static final Block TUFF_BRICKS = registerBricks(Blocks.TUFF, "tuff", Blocks.TUFF, MaterialColor.TERRACOTTA_GRAY);
+    public static final Block CHISELED_ANDESITE_BRICKS = registerChiseledBricks(ANDESITE_BRICKS,"andesite", Blocks.POLISHED_ANDESITE, MaterialColor.STONE);
+    public static final Block CHISELED_CALCITE_BRICKS = registerChiseledBricks(CALCITE_BRICKS, "calcite", Blocks.CALCITE, MaterialColor.TERRACOTTA_WHITE);
+    public static final Block CHISELED_DIORITE_BRICKS = registerChiseledBricks(DIORITE_BRICKS, "diorite", Blocks.POLISHED_DIORITE, MaterialColor.QUARTZ);
+    public static final Block CHISELED_DRIPSTONE_BRICKS = registerChiseledBricks(DRIPSTONE_BRICKS, "dripstone", Blocks.DRIPSTONE_BLOCK, MaterialColor.TERRACOTTA_BROWN);
+    public static final Block CHISELED_GRANITE_BRICKS = registerChiseledBricks(GRANITE_BRICKS, "granite", Blocks.POLISHED_GRANITE, MaterialColor.DIRT);
+    public static final Block CHISELED_TUFF_BRICKS = registerChiseledBricks(TUFF_BRICKS, "tuff", Blocks.TUFF, MaterialColor.TERRACOTTA_GRAY);
+
+    /**
+     * Based on {@link Blocks#SANDSTONE} and {@link Blocks#SOUL_SAND}
+     */
+    public static final Block SOUL_SANDSTONE = register(
+        "soul_sandstone",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.SOUL_SOIL)
+            .withModelCreation(Model.BottomTopPillarCube.defaultCreation().withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.STONE, MaterialColor.COLOR_BROWN).strength(0.8F, 0.8F)).mineableWithPickaxe().soulSpeed().soulFireBase(),
+        SuCraftBlockLoot::dropSelf
+    );
+
+    public static final Block SANDSTONE_BRICKS = registerBricks(Blocks.SANDSTONE, "sandstone", Blocks.SANDSTONE, MaterialColor.SAND);
+    public static final Block RED_SANDSTONE_BRICKS = registerBricks(Blocks.RED_SANDSTONE, "red_sandstone", Blocks.RED_SANDSTONE, MaterialColor.COLOR_ORANGE);
+    public static final Block SOUL_SANDSTONE_BRICKS = registerBricks(SOUL_SANDSTONE, "soul_sandstone", Blocks.SOUL_SOIL, MaterialColor.COLOR_BROWN).soulSpeed().soulFireBase();
+    public static final Block ANDESITE_COBBLESTONE = registerCobblestone(Blocks.ANDESITE, "andesite", Blocks.ANDESITE, MaterialColor.STONE);
+    public static final Block DIORITE_COBBLESTONE = registerCobblestone(Blocks.DIORITE, "diorite", Blocks.DIORITE, MaterialColor.QUARTZ);
+    public static final Block GRANITE_COBBLESTONE = registerCobblestone(Blocks.GRANITE, "granite", Blocks.GRANITE, MaterialColor.DIRT);
+
+    /**
+     * Based on {@link Blocks#CHISELED_SANDSTONE} and {@link Blocks#SOUL_SAND}
+     */
+    public static final Block CHISELED_SOUL_SANDSTONE = register(
+        "chiseled_soul_sandstone",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.SOUL_SOIL)
+            .withModelCreation(Model.YPillarCube.defaultCreationWithAlternativeEnd(new Texture(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.sucraft("soul_sandstone_top"), TextureContent.Existing.getInstance())).withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.STONE, MaterialColor.COLOR_BROWN).strength(0.8F)).mineableWithPickaxe().soulSpeed().soulFireBase(),
+        SuCraftBlockLoot::dropSelf
+    ).withCustomOneToOneStonecutterRecipe(SOUL_SANDSTONE);
+
+    /**
+     * Based on {@link Blocks#CUT_SANDSTONE} and {@link Blocks#SOUL_SAND}
+     */
+    public static final Block CUT_SOUL_SANDSTONE = register(
+        "cut_soul_sandstone",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.SOUL_SOIL)
+            .withModelCreation(Model.YPillarCube.defaultCreationWithAlternativeEnd(new Texture(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.sucraft("soul_sandstone_top"), TextureContent.Existing.getInstance())).withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.STONE, MaterialColor.COLOR_BROWN).strength(0.8F)).mineableWithPickaxe().soulSpeed().soulFireBase(),
+        SuCraftBlockLoot::dropSelf
+    ).withCustomOneToOneStonecutterRecipe(SOUL_SANDSTONE);
+    public static final Block CHISELED_PRISMARINE_BRICKS = registerChiseledBricks(Blocks.PRISMARINE_BRICKS, "prismarine", Blocks.PRISMARINE_BRICKS, MaterialColor.DIAMOND);
+    public static final Block ANDESITE_PILLAR = registerStonePillar(Blocks.ANDESITE, "andesite", Blocks.POLISHED_ANDESITE, MaterialColor.STONE);
+    public static final Block CALCITE_PILLAR = registerStonePillar(Blocks.CALCITE, "calcite", Blocks.CALCITE, MaterialColor.TERRACOTTA_WHITE);
+    public static final Block DIORITE_PILLAR = registerStonePillar(Blocks.DIORITE, "diorite", Blocks.POLISHED_DIORITE, MaterialColor.QUARTZ);
+    public static final Block DRIPSTONE_PILLAR = registerStonePillar(Blocks.DRIPSTONE_BLOCK, "dripstone", Blocks.DRIPSTONE_BLOCK, MaterialColor.TERRACOTTA_BROWN);
+    public static final Block GRANITE_PILLAR = registerStonePillar(Blocks.GRANITE, "granite", Blocks.POLISHED_GRANITE, MaterialColor.DIRT);
+    public static final Block TUFF_PILLAR = registerStonePillar(Blocks.TUFF, "tuff", Blocks.TUFF, MaterialColor.TERRACOTTA_GRAY);
+    public static final Block FIERY_BIRCH_LEAVES = registerLeaves("fiery_birch", Blocks.BIRCH_LEAVES, Blocks.BIRCH_SAPLING/*TODO make drop specific sapling*/, Blocks.BIRCH_LEAVES, MaterialColor.COLOR_ORANGE);
+    public static final Block YELLOW_BIRCH_LEAVES = registerLeaves("yellow_birch", Blocks.BIRCH_LEAVES, Blocks.BIRCH_SAPLING/*TODO make drop specific sapling*/, Blocks.BIRCH_LEAVES, MaterialColor.COLOR_YELLOW);
+    public static final Block RED_OAK_LEAVES = registerLeaves("red_oak", Blocks.OAK_LEAVES, Blocks.OAK_SAPLING/*TODO make drop specific sapling*/, Blocks.OAK_LEAVES, MaterialColor.COLOR_RED);
+    public static final Block ORANGE_OAK_LEAVES = registerLeaves("orange_oak", Blocks.OAK_LEAVES, Blocks.OAK_SAPLING/*TODO make drop specific sapling*/, Blocks.OAK_LEAVES, MaterialColor.COLOR_ORANGE);
+    public static final Block RED_MAPLE_LEAVES = registerLeaves("red_maple", Blocks.OAK_LEAVES, Blocks.OAK_SAPLING/*TODO make drop specific sapling*/, Blocks.OAK_LEAVES, MaterialColor.COLOR_RED);
+    public static final Block ORANGE_MAPLE_LEAVES = registerLeaves("orange_maple", Blocks.OAK_LEAVES, Blocks.OAK_SAPLING/*TODO make drop specific sapling*/, Blocks.OAK_LEAVES, MaterialColor.COLOR_ORANGE);
+    public static final Block YELLOW_MAPLE_LEAVES = registerLeaves("yellow_maple", Blocks.OAK_LEAVES, Blocks.OAK_SAPLING/*TODO make drop specific sapling*/, Blocks.OAK_LEAVES, MaterialColor.COLOR_YELLOW);
+    public static final Block DIRT_SLAB = registerRealSlab(Blocks.DIRT, "dirt", null, Blocks.WAXED_CUT_COPPER_SLAB, Blocks.CUT_COPPER_SLAB, Blocks.MUD_BRICK_SLAB, BlockBehaviour.Properties.of(Material.DIRT).strength(0.5F).sound(SoundType.GRAVEL)).breakBeforeClientKnowsToBreak().mineableWithShovel().dirt();
+    public static final Block SNOWY_STONE_BRICK_SLAB = registerFakeSlab(SNOWY_STONE_BRICKS, "snowy_stone_brick", null, Blocks.STONE_BRICK_SLAB);
+    public static final Block DIRTY_STONE_BRICK_SLAB = registerFakeSlab(DIRTY_STONE_BRICKS, "dirty_stone_brick", null, Blocks.STONE_BRICK_SLAB);
+    public static final Block CRACKED_STONE_BRICK_SLAB = registerFakeSlab(Blocks.CRACKED_STONE_BRICKS, "cracked_stone_brick", "cracked_stone_bricks", Blocks.STONE_BRICK_SLAB);
+    public static final Block BLACK_PLANK_SLAB = registerFakeDyedPlanksSlab(BLACK_PLANKS, "black", Blocks.DARK_OAK_SLAB);
+    public static final Block BLUE_PLANK_SLAB = registerFakeDyedPlanksSlab(BLUE_PLANKS, "blue", Blocks.WARPED_SLAB);
+    public static final Block BROWN_PLANK_SLAB = registerFakeDyedPlanksSlab(BROWN_PLANKS, "brown", Blocks.SPRUCE_SLAB);
+    public static final Block CYAN_PLANK_SLAB = registerFakeDyedPlanksSlab(CYAN_PLANKS, "cyan", Blocks.WARPED_SLAB);
+    public static final Block GRAY_PLANK_SLAB = registerFakeDyedPlanksSlab(GRAY_PLANKS, "gray", Blocks.SPRUCE_SLAB);
+    public static final Block GREEN_PLANK_SLAB = registerFakeDyedPlanksSlab(GREEN_PLANKS, "green", Blocks.WARPED_SLAB);
+    public static final Block LIGHT_BLUE_PLANK_SLAB = registerFakeDyedPlanksSlab(LIGHT_BLUE_PLANKS, "light_blue", Blocks.WARPED_SLAB);
+    public static final Block LIGHT_GRAY_PLANK_SLAB = registerFakeDyedPlanksSlab(LIGHT_GRAY_PLANKS, "light_gray", Blocks.OAK_SLAB);
+    public static final Block LIME_PLANK_SLAB = registerFakeDyedPlanksSlab(LIME_PLANKS, "lime", Blocks.WARPED_SLAB);
+    public static final Block MAGENTA_PLANK_SLAB = registerFakeDyedPlanksSlab(MAGENTA_PLANKS, "magenta", Blocks.CRIMSON_SLAB);
+    public static final Block ORANGE_PLANK_SLAB = registerFakeDyedPlanksSlab(ORANGE_PLANKS, "orange", Blocks.ACACIA_SLAB);
+    public static final Block PINK_PLANK_SLAB = registerFakeDyedPlanksSlab(PINK_PLANKS, "pink", Blocks.JUNGLE_SLAB);
+    public static final Block PURPLE_PLANK_SLAB = registerFakeDyedPlanksSlab(PURPLE_PLANKS, "purple", Blocks.CRIMSON_SLAB);
+    public static final Block RED_PLANK_SLAB = registerFakeDyedPlanksSlab(RED_PLANKS, "red", Blocks.MANGROVE_SLAB);
+    public static final Block WHITE_PLANK_SLAB = registerFakeDyedPlanksSlab(WHITE_PLANKS, "white", Blocks.BIRCH_SLAB);
+    public static final Block YELLOW_PLANK_SLAB = registerFakeDyedPlanksSlab(YELLOW_PLANKS, "yellow", Blocks.BIRCH_SLAB);
+    public static final Block BLACK_WOOL_SLAB = registerFakeWoolSlab(Blocks.BLACK_WOOL, "black", Blocks.BLACKSTONE_SLAB);
+    public static final Block BLUE_WOOL_SLAB = registerFakeWoolSlab(Blocks.BLUE_WOOL, "blue", Blocks.WARPED_SLAB);
+    public static final Block BROWN_WOOL_SLAB = registerFakeWoolSlab(Blocks.BROWN_WOOL, "brown", Blocks.SPRUCE_SLAB);
+    public static final Block CYAN_WOOL_SLAB = registerFakeWoolSlab(Blocks.CYAN_WOOL, "cyan", Blocks.DARK_PRISMARINE_SLAB);
+    public static final Block GRAY_WOOL_SLAB = registerFakeWoolSlab(Blocks.GRAY_WOOL, "gray", Blocks.STONE_SLAB);
+    public static final Block GREEN_WOOL_SLAB = registerFakeWoolSlab(Blocks.GREEN_WOOL, "green", Blocks.DARK_PRISMARINE_SLAB);
+    public static final Block LIGHT_BLUE_WOOL_SLAB = registerFakeWoolSlab(Blocks.LIGHT_BLUE_WOOL, "light_blue", Blocks.PRISMARINE_BRICK_SLAB);
+    public static final Block LIGHT_GRAY_WOOL_SLAB = registerFakeWoolSlab(Blocks.LIGHT_GRAY_WOOL, "light_gray", Blocks.SMOOTH_STONE_SLAB);
+    public static final Block LIME_WOOL_SLAB = registerFakeWoolSlab(Blocks.LIME_WOOL, "lime", Blocks.OXIDIZED_CUT_COPPER_SLAB);
+    public static final Block MAGENTA_WOOL_SLAB = registerFakeWoolSlab(Blocks.MAGENTA_WOOL, "magenta", Blocks.PURPUR_SLAB);
+    public static final Block ORANGE_WOOL_SLAB = registerFakeWoolSlab(Blocks.ORANGE_WOOL, "orange", Blocks.SMOOTH_RED_SANDSTONE_SLAB);
+    public static final Block PINK_WOOL_SLAB = registerFakeWoolSlab(Blocks.PINK_WOOL, "pink", Blocks.PURPUR_SLAB);
+    public static final Block PURPLE_WOOL_SLAB = registerFakeWoolSlab(Blocks.PURPLE_WOOL, "purple", Blocks.PURPUR_SLAB);
+    public static final Block RED_WOOL_SLAB = registerFakeWoolSlab(Blocks.RED_WOOL, "red", Blocks.MANGROVE_SLAB);
+    public static final Block WHITE_WOOL_SLAB = registerFakeWoolSlab(Blocks.WHITE_WOOL, "white", Blocks.SMOOTH_QUARTZ_SLAB);
+    public static final Block YELLOW_WOOL_SLAB = registerFakeWoolSlab(Blocks.YELLOW_WOOL, "yellow", Blocks.BIRCH_SLAB);
+    public static final Block BLACK_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.BLACK_CONCRETE, "black", Blocks.BLACKSTONE_SLAB);
+    public static final Block BLUE_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.BLUE_CONCRETE, "blue", Blocks.WARPED_SLAB);
+    public static final Block BROWN_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.BROWN_CONCRETE, "brown", Blocks.SPRUCE_SLAB);
+    public static final Block CYAN_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.CYAN_CONCRETE, "cyan", Blocks.DARK_PRISMARINE_SLAB);
+    public static final Block GRAY_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.GRAY_CONCRETE, "gray", Blocks.STONE_SLAB);
+    public static final Block GREEN_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.GREEN_CONCRETE, "green", Blocks.DARK_PRISMARINE_SLAB);
+    public static final Block LIGHT_BLUE_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.LIGHT_BLUE_CONCRETE, "light_blue", Blocks.PRISMARINE_BRICK_SLAB);
+    public static final Block LIGHT_GRAY_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.LIGHT_GRAY_CONCRETE, "light_gray", Blocks.SMOOTH_STONE_SLAB);
+    public static final Block LIME_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.LIME_CONCRETE, "lime", Blocks.OXIDIZED_CUT_COPPER_SLAB);
+    public static final Block MAGENTA_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.MAGENTA_CONCRETE, "magenta", Blocks.PURPUR_SLAB);
+    public static final Block ORANGE_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.ORANGE_CONCRETE, "orange", Blocks.SMOOTH_RED_SANDSTONE_SLAB);
+    public static final Block PINK_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.PINK_CONCRETE, "pink", Blocks.PURPUR_SLAB);
+    public static final Block PURPLE_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.PURPLE_CONCRETE, "purple", Blocks.PURPUR_SLAB);
+    public static final Block RED_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.RED_CONCRETE, "red", Blocks.MANGROVE_SLAB);
+    public static final Block WHITE_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.WHITE_CONCRETE, "white", Blocks.SMOOTH_QUARTZ_SLAB);
+    public static final Block YELLOW_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.YELLOW_CONCRETE, "yellow", Blocks.BIRCH_SLAB);
+    public static final Block BLACK_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.BLACK_CONCRETE_POWDER, "black", Blocks.BLACKSTONE_SLAB);
+    public static final Block BLUE_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.BLUE_CONCRETE_POWDER, "blue", Blocks.WARPED_SLAB);
+    public static final Block BROWN_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.BROWN_CONCRETE_POWDER, "brown", Blocks.SPRUCE_SLAB);
+    public static final Block CYAN_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.CYAN_CONCRETE_POWDER, "cyan", Blocks.DARK_PRISMARINE_SLAB);
+    public static final Block GRAY_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.GRAY_CONCRETE_POWDER, "gray", Blocks.STONE_SLAB);
+    public static final Block GREEN_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.GREEN_CONCRETE_POWDER, "green", Blocks.DARK_PRISMARINE_SLAB);
+    public static final Block LIGHT_BLUE_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.LIGHT_BLUE_CONCRETE_POWDER, "light_blue", Blocks.PRISMARINE_BRICK_SLAB);
+    public static final Block LIGHT_GRAY_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.LIGHT_GRAY_CONCRETE_POWDER, "light_gray", Blocks.SMOOTH_STONE_SLAB);
+    public static final Block LIME_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.LIME_CONCRETE_POWDER, "lime", Blocks.OXIDIZED_CUT_COPPER_SLAB);
+    public static final Block MAGENTA_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.MAGENTA_CONCRETE_POWDER, "magenta", Blocks.PURPUR_SLAB);
+    public static final Block ORANGE_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.ORANGE_CONCRETE_POWDER, "orange", Blocks.SMOOTH_RED_SANDSTONE_SLAB);
+    public static final Block PINK_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.PINK_CONCRETE_POWDER, "pink", Blocks.PURPUR_SLAB);
+    public static final Block PURPLE_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.PURPLE_CONCRETE_POWDER, "purple", Blocks.PURPUR_SLAB);
+    public static final Block RED_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.RED_CONCRETE_POWDER, "red", Blocks.MANGROVE_SLAB);
+    public static final Block WHITE_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.WHITE_CONCRETE_POWDER, "white", Blocks.SMOOTH_QUARTZ_SLAB);
+    public static final Block YELLOW_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.YELLOW_CONCRETE_POWDER, "yellow", Blocks.BIRCH_SLAB);
+    public static final Block BLACK_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.BLACK_TERRACOTTA, "black", Blocks.BLACKSTONE_SLAB);
+    public static final Block BLUE_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.BLUE_TERRACOTTA, "blue", Blocks.POLISHED_BLACKSTONE_SLAB);
+    public static final Block BROWN_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.BROWN_TERRACOTTA, "brown", Blocks.DARK_OAK_SLAB);
+    public static final Block CYAN_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.CYAN_TERRACOTTA, "cyan", Blocks.STONE_SLAB);
+    public static final Block GRAY_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.GRAY_TERRACOTTA, "gray", Blocks.DARK_OAK_SLAB);
+    public static final Block GREEN_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.GREEN_TERRACOTTA, "green", Blocks.DARK_PRISMARINE_SLAB);
+    public static final Block LIGHT_BLUE_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.LIGHT_BLUE_TERRACOTTA, "light_blue", Blocks.STONE_SLAB);
+    public static final Block LIGHT_GRAY_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.LIGHT_GRAY_TERRACOTTA, "light_gray", Blocks.JUNGLE_SLAB);
+    public static final Block LIME_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.LIME_TERRACOTTA, "lime", Blocks.DARK_PRISMARINE_SLAB);
+    public static final Block MAGENTA_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.MAGENTA_TERRACOTTA, "magenta", Blocks.PURPUR_SLAB);
+    public static final Block ORANGE_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.ORANGE_TERRACOTTA, "orange", Blocks.SMOOTH_RED_SANDSTONE_SLAB);
+    public static final Block PINK_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.PINK_TERRACOTTA, "pink", Blocks.MANGROVE_SLAB);
+    public static final Block PURPLE_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.PURPLE_TERRACOTTA, "purple", Blocks.PURPUR_SLAB);
+    public static final Block RED_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.RED_TERRACOTTA, "red", Blocks.MANGROVE_SLAB);
+    public static final Block WHITE_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.WHITE_TERRACOTTA, "white", Blocks.SMOOTH_QUARTZ_SLAB);
+    public static final Block YELLOW_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.YELLOW_TERRACOTTA, "yellow", Blocks.OAK_SLAB);
+    public static final Block COARSE_DIRT_SLAB = registerFakeSlab(Blocks.COARSE_DIRT, "coarse_dirt", Blocks.MUD_BRICK_SLAB).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    public static final Block SAND_SLAB = registerFakeSlab(Blocks.SAND, "sand", Blocks.SANDSTONE_SLAB).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    public static final Block RED_SAND_SLAB = registerFakeSlab(Blocks.RED_SAND, "red_sand", Blocks.RED_SANDSTONE_SLAB).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    public static final Block CLAY_SLAB = registerFakeSlab(Blocks.CLAY, "clay", Blocks.ANDESITE_SLAB).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    public static final Block MUD_SLAB = registerFakeSlab(Blocks.MUD, "mud", Blocks.POLISHED_BLACKSTONE_SLAB).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    public static final Block PACKED_MUD_SLAB = registerFakeSlab(Blocks.PACKED_MUD, "packed_mud", Blocks.MUD_BRICK_SLAB).breakBeforeClientKnowsToBreak().mineableWithPickaxe();
+    public static final Block AMETHYST_SLAB = registerFakeSlab(Blocks.AMETHYST_BLOCK, "amethyst", "amethyst_block", Blocks.PURPUR_SLAB).mineableWithPickaxe();
+    public static final Block COAL_SLAB = registerFakeSlab(Blocks.COAL_BLOCK, "coal", "coal_block", Blocks.BLACKSTONE_SLAB).mineableWithPickaxe();
+    public static final Block OAK_BOOKSHELF_SLAB = registerFakeBookshelfSlab(Blocks.BOOKSHELF, "oak", Blocks.OAK_SLAB);
+    public static final Block SPRUCE_BOOKSHELF_SLAB = registerFakeBookshelfSlab(SPRUCE_BOOKSHELF, "spruce", Blocks.SPRUCE_SLAB);
+    public static final Block BIRCH_BOOKSHELF_SLAB = registerFakeBookshelfSlab(BIRCH_BOOKSHELF, "birch", Blocks.BIRCH_SLAB);
+    public static final Block JUNGLE_BOOKSHELF_SLAB = registerFakeBookshelfSlab(JUNGLE_BOOKSHELF, "jungle", Blocks.JUNGLE_SLAB);
+    public static final Block CALCITE_SLAB = registerFakeSlab(Blocks.CALCITE, "calcite", Blocks.SMOOTH_QUARTZ_SLAB).mineableWithPickaxe();
+    public static final Block DRIPSTONE_SLAB = registerFakeSlab(Blocks.DRIPSTONE_BLOCK, "dripstone", "dripstone_block", Blocks.GRANITE_SLAB).mineableWithPickaxe();
+    public static final Block TUFF_SLAB = registerFakeSlab(Blocks.TUFF, "tuff", Blocks.COBBLESTONE_SLAB).mineableWithPickaxe();
+    public static final Block POLISHED_CALCITE_SLAB = registerFakePolishedSlab(POLISHED_CALCITE, "calcite", Blocks.QUARTZ_SLAB);
+    public static final Block POLISHED_DRIPSTONE_SLAB = registerFakePolishedSlab(POLISHED_DRIPSTONE, "dripstone", Blocks.POLISHED_GRANITE_SLAB);
+    public static final Block POLISHED_TUFF_SLAB = registerFakePolishedSlab(POLISHED_TUFF, "tuff", Blocks.ANDESITE_SLAB);
+    public static final Block ANDESITE_BRICK_SLAB = registerFakeCustomBrickSlab(ANDESITE_BRICKS, "andesite", Blocks.POLISHED_ANDESITE_SLAB);
+    public static final Block CALCITE_BRICK_SLAB = registerFakeCustomBrickSlab(CALCITE_BRICKS, "calcite", Blocks.QUARTZ_SLAB);
+    public static final Block DIORITE_BRICK_SLAB = registerFakeCustomBrickSlab(DIORITE_BRICKS, "diorite", Blocks.POLISHED_DIORITE_SLAB);
+    public static final Block DRIPSTONE_BRICK_SLAB = registerFakeCustomBrickSlab(DRIPSTONE_BRICKS, "dripstone", Blocks.POLISHED_GRANITE_SLAB);
+    public static final Block GRANITE_BRICK_SLAB = registerFakeCustomBrickSlab(GRANITE_BRICKS, "granite", Blocks.POLISHED_GRANITE_SLAB);
+    public static final Block TUFF_BRICK_SLAB = registerFakeCustomBrickSlab(TUFF_BRICKS, "tuff", Blocks.STONE_BRICK_SLAB);
+    public static final Block ANDESITE_PILLAR_SLAB = registerFakeCustomStonePillarSlab(ANDESITE_PILLAR, "andesite", Blocks.POLISHED_ANDESITE_SLAB);
+    public static final Block CALCITE_PILLAR_SLAB = registerFakeCustomStonePillarSlab(CALCITE_PILLAR, "calcite", Blocks.QUARTZ_SLAB);
+    public static final Block DIORITE_PILLAR_SLAB = registerFakeCustomStonePillarSlab(DIORITE_PILLAR, "diorite", Blocks.POLISHED_DIORITE_SLAB);
+    public static final Block DRIPSTONE_PILLAR_SLAB = registerFakeCustomStonePillarSlab(DRIPSTONE_PILLAR, "dripstone", Blocks.POLISHED_GRANITE_SLAB);
+    public static final Block GRANITE_PILLAR_SLAB = registerFakeCustomStonePillarSlab(GRANITE_PILLAR, "granite", Blocks.POLISHED_GRANITE_SLAB);
+    public static final Block TUFF_PILLAR_SLAB = registerFakeCustomStonePillarSlab(TUFF_PILLAR, "tuff", Blocks.COBBLESTONE_SLAB);
+    public static final Block SOUL_SANDSTONE_SLAB = registerFakeSlab(SOUL_SANDSTONE, null, "soul_sandstone", NamespacedKeyWithoutIntention.sucraft("soul_sandstone"), null, null, NamespacedKeyWithoutIntention.sucraft("soul_sandstone_top"), NamespacedKeyWithoutIntention.sucraft("soul_sandstone"), NamespacedKeyWithoutIntention.sucraft("soul_sandstone_top"), Blocks.DARK_OAK_SLAB, null).mineableWithPickaxe().soulSpeed().soulFireBase();
+    public static final Block SANDSTONE_BRICK_SLAB = registerFakeSandstoneBrickSlab(SANDSTONE_BRICKS, null, Blocks.SANDSTONE_SLAB);
+    public static final Block RED_SANDSTONE_BRICK_SLAB = registerFakeSandstoneBrickSlab(RED_SANDSTONE_BRICKS, "red", Blocks.RED_SANDSTONE_SLAB);
+    public static final Block SOUL_SANDSTONE_BRICK_SLAB = registerFakeSandstoneBrickSlab(SOUL_SANDSTONE_BRICKS, "soul", Blocks.DARK_OAK_SLAB).soulSpeed().soulFireBase();
+
+    /**
+     * Based on {@link Blocks#SMOOTH_SANDSTONE} and {@link Blocks#SOUL_SAND}
+     */
+    public static final Block SMOOTH_SOUL_SANDSTONE = register(
+        "smooth_soul_sandstone",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.SOUL_SOIL)
+            .withModelCreation(Model.creation(ModelContent.OneTextureCube.creation(new Texture(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.sucraft("soul_sandstone_top"), TextureContent.Existing.getInstance()))).withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.STONE, MaterialColor.COLOR_BROWN).strength(0.8F)).mineableWithPickaxe().soulSpeed().soulFireBase(),
+        SuCraftBlockLoot::dropSelf
+    );
+
+    public static final Block SMOOTH_SOUL_SANDSTONE_SLAB = registerFakeSlab(SMOOTH_SOUL_SANDSTONE, null, "smooth_soul_sandstone", NamespacedKeyWithoutIntention.sucraft("smooth_soul_sandstone"), NamespacedKeyWithoutIntention.sucraft("soul_sandstone_top"), null, null, null, null, Blocks.OAK_SLAB, null).mineableWithPickaxe().soulSpeed().soulFireBase();
+    public static final Block CUT_SOUL_SANDSTONE_SLAB = registerFakeSlab(CUT_SOUL_SANDSTONE, null, "cut_soul_sandstone", NamespacedKeyWithoutIntention.sucraft("cut_soul_sandstone"), null, NamespacedKeyWithoutIntention.sucraft("soul_sandstone_top"), null, null, null, Blocks.DARK_OAK_SLAB, null).mineableWithPickaxe().soulSpeed().soulFireBase();
+    public static final Block GRAVEL_SLAB = registerFakeSlab(Blocks.GRAVEL, "gravel", Blocks.ANDESITE_SLAB).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    public static final Block NETHERRACK_SLAB = registerFakeSlab(Blocks.NETHERRACK, "netherrack", Blocks.RED_NETHER_BRICK_SLAB).breakBeforeClientKnowsToBreak().mineableWithPickaxe();
+    public static final Block SOUL_SOIL_SLAB = registerFakeSlab(Blocks.SOUL_SOIL, "soul_soil", Blocks.DARK_OAK_SLAB).breakBeforeClientKnowsToBreak().mineableWithShovel().soulSpeed().soulFireBase();
+    public static final Block RAW_COPPER_SLAB = registerFakeRawMetalSlab(Blocks.RAW_COPPER_BLOCK, "copper", Blocks.CUT_COPPER_SLAB);
+    public static final Block RAW_GOLD_SLAB = registerFakeRawMetalSlab(Blocks.RAW_GOLD_BLOCK, "gold", Blocks.OAK_SLAB).guardedByPiglins();
+    public static final Block RAW_IRON_SLAB = registerFakeRawMetalSlab(Blocks.RAW_IRON_BLOCK, "iron", Blocks.JUNGLE_SLAB);
+    public static final Block ANCIENT_DEBRIS_SLAB = registerFakeSlab(Blocks.ANCIENT_DEBRIS, null, "ancient_debris", NamespacedKeyWithoutIntention.minecraft("ancient_debris"), NamespacedKeyWithoutIntention.minecraft("ancient_debris_side"), NamespacedKeyWithoutIntention.minecraft("ancient_debris_top"), null, null, null, Blocks.POLISHED_GRANITE_SLAB, null).mineableWithPickaxe();
+    public static final Block DIRT_BRICK_SLAB = registerFakeSlab(DIRT_BRICKS, "dirt_brick", null, Blocks.MUD_BRICK_SLAB).breakBeforeClientKnowsToBreak().mineableWithShovel().dirt();
+    public static final Block STONE_PILLAR = registerStonePillar(Blocks.STONE, "stone", Blocks.STONE, MaterialColor.STONE);
+    public static final Block STONE_PILLAR_SLAB = registerFakeCustomStonePillarSlab(STONE_PILLAR, "stone", Blocks.STONE_SLAB);
+    public static final Block OAK_LOG_SLAB = registerFakeLogSlab(Blocks.OAK_LOG, "oak", Blocks.OAK_SLAB);
+    public static final Block SPRUCE_LOG_SLAB = registerFakeLogSlab(Blocks.SPRUCE_LOG, "spruce", Blocks.SPRUCE_SLAB);
+    public static final Block BIRCH_LOG_SLAB = registerFakeLogSlab(Blocks.BIRCH_LOG, "birch", Blocks.BIRCH_SLAB);
+    public static final Block JUNGLE_LOG_SLAB = registerFakeLogSlab(Blocks.JUNGLE_LOG, "jungle", Blocks.JUNGLE_SLAB);
+    public static final Block ACACIA_LOG_SLAB = registerFakeLogSlab(Blocks.ACACIA_LOG, "acacia", Blocks.ACACIA_SLAB);
+    public static final Block DARK_OAK_LOG_SLAB = registerFakeLogSlab(Blocks.DARK_OAK_LOG, "dark_oak", Blocks.DARK_OAK_SLAB);
+    public static final Block WARPED_STEM_SLAB = registerFakeStemSlab(Blocks.WARPED_STEM, "warped", Blocks.WARPED_SLAB);
+    public static final Block CRIMSON_STEM_SLAB = registerFakeStemSlab(Blocks.CRIMSON_STEM, "crimson", Blocks.CRIMSON_SLAB);
+    public static final Block MANGROVE_LOG_SLAB = registerFakeLogSlab(Blocks.MANGROVE_LOG, "mangrove", Blocks.MANGROVE_SLAB);
+    public static final Block STRIPPED_OAK_LOG_SLAB = registerFakeStrippedLogSlab(Blocks.STRIPPED_OAK_LOG, "oak", Blocks.OAK_SLAB);
+    public static final Block STRIPPED_SPRUCE_LOG_SLAB = registerFakeStrippedLogSlab(Blocks.STRIPPED_SPRUCE_LOG, "spruce", Blocks.SPRUCE_SLAB);
+    public static final Block STRIPPED_BIRCH_LOG_SLAB = registerFakeStrippedLogSlab(Blocks.STRIPPED_BIRCH_LOG, "birch", Blocks.BIRCH_SLAB);
+    public static final Block STRIPPED_JUNGLE_LOG_SLAB = registerFakeStrippedLogSlab(Blocks.STRIPPED_JUNGLE_LOG, "jungle", Blocks.JUNGLE_SLAB);
+    public static final Block STRIPPED_ACACIA_LOG_SLAB = registerFakeStrippedLogSlab(Blocks.STRIPPED_ACACIA_LOG, "acacia", Blocks.ACACIA_SLAB);
+    public static final Block STRIPPED_DARK_OAK_LOG_SLAB = registerFakeStrippedLogSlab(Blocks.STRIPPED_DARK_OAK_LOG, "dark_oak", Blocks.DARK_OAK_SLAB);
+    public static final Block STRIPPED_WARPED_STEM_SLAB = registerFakeStrippedStemSlab(Blocks.STRIPPED_WARPED_STEM, "warped", Blocks.WARPED_SLAB);
+    public static final Block STRIPPED_CRIMSON_STEM_SLAB = registerFakeStrippedStemSlab(Blocks.STRIPPED_CRIMSON_STEM, "crimson", Blocks.CRIMSON_SLAB);
+    public static final Block STRIPPED_MANGROVE_LOG_SLAB = registerFakeStrippedLogSlab(Blocks.STRIPPED_MANGROVE_LOG, "mangrove", Blocks.MANGROVE_SLAB);
+    public static final Block OAK_WOOD_SLAB = registerFakeWoodSlab(Blocks.OAK_WOOD, "oak", Blocks.OAK_SLAB);
+    public static final Block SPRUCE_WOOD_SLAB = registerFakeWoodSlab(Blocks.SPRUCE_WOOD, "spruce", Blocks.SPRUCE_SLAB);
+    public static final Block BIRCH_WOOD_SLAB = registerFakeWoodSlab(Blocks.BIRCH_WOOD, "birch", Blocks.BIRCH_SLAB);
+    public static final Block JUNGLE_WOOD_SLAB = registerFakeWoodSlab(Blocks.JUNGLE_WOOD, "jungle", Blocks.JUNGLE_SLAB);
+    public static final Block ACACIA_WOOD_SLAB = registerFakeWoodSlab(Blocks.ACACIA_WOOD, "acacia", Blocks.ACACIA_SLAB);
+    public static final Block DARK_OAK_WOOD_SLAB = registerFakeWoodSlab(Blocks.DARK_OAK_WOOD, "dark_oak", Blocks.DARK_OAK_SLAB);
+    public static final Block WARPED_HYPHAE_SLAB = registerFakeHyphaeSlab(Blocks.WARPED_HYPHAE, "warped", Blocks.WARPED_SLAB);
+    public static final Block CRIMSON_HYPHAE_SLAB = registerFakeHyphaeSlab(Blocks.CRIMSON_HYPHAE, "crimson", Blocks.CRIMSON_SLAB);
+    public static final Block MANGROVE_WOOD_SLAB = registerFakeWoodSlab(Blocks.MANGROVE_WOOD, "mangrove", Blocks.MANGROVE_SLAB);
+    public static final Block STRIPPED_OAK_WOOD_SLAB = registerFakeStrippedWoodSlab(Blocks.STRIPPED_OAK_WOOD, "oak", Blocks.OAK_SLAB);
+    public static final Block STRIPPED_SPRUCE_WOOD_SLAB = registerFakeStrippedWoodSlab(Blocks.STRIPPED_SPRUCE_WOOD, "spruce", Blocks.SPRUCE_SLAB);
+    public static final Block STRIPPED_BIRCH_WOOD_SLAB = registerFakeStrippedWoodSlab(Blocks.STRIPPED_BIRCH_WOOD, "birch", Blocks.BIRCH_SLAB);
+    public static final Block STRIPPED_JUNGLE_WOOD_SLAB = registerFakeStrippedWoodSlab(Blocks.STRIPPED_JUNGLE_WOOD, "jungle", Blocks.JUNGLE_SLAB);
+    public static final Block STRIPPED_ACACIA_WOOD_SLAB = registerFakeStrippedWoodSlab(Blocks.STRIPPED_ACACIA_WOOD, "acacia", Blocks.ACACIA_SLAB);
+    public static final Block STRIPPED_DARK_OAK_WOOD_SLAB = registerFakeStrippedWoodSlab(Blocks.STRIPPED_DARK_OAK_WOOD, "dark_oak", Blocks.DARK_OAK_SLAB);
+    public static final Block STRIPPED_WARPED_HYPHAE_SLAB = registerFakeStrippedHyphaeSlab(Blocks.STRIPPED_WARPED_HYPHAE, "warped", Blocks.WARPED_SLAB);
+    public static final Block STRIPPED_CRIMSON_HYPHAE_SLAB = registerFakeStrippedHyphaeSlab(Blocks.STRIPPED_CRIMSON_HYPHAE, "crimson", Blocks.CRIMSON_SLAB);
+    public static final Block STRIPPED_MANGROVE_WOOD_SLAB = registerFakeStrippedWoodSlab(Blocks.STRIPPED_MANGROVE_WOOD, "mangrove", Blocks.MANGROVE_SLAB);
+    public static final Block BONE_SLAB = registerFakeSlab(Blocks.BONE_BLOCK, null, "bone", NamespacedKeyWithoutIntention.minecraft("bone_block"), NamespacedKeyWithoutIntention.minecraft("bone_block_side"), NamespacedKeyWithoutIntention.minecraft("bone_block_top"), null, null, null, Blocks.SMOOTH_QUARTZ_SLAB, null).mineableWithPickaxe();//registerFakeSlabFromYPillarVanillaBlock(Blocks.BONE_BLOCK, null, "bone", "bone_block", Blocks.SMOOTH_QUARTZ_SLAB).mineableWithPickaxe();
+
+    /**
+     * Based on {@link Blocks#BONE_BLOCK}
+     */
+    public static final Block WITHER_BONE_BLOCK = register(
+        "wither_bone_block",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHosts()
+            .withFallback(Blocks.COAL_BLOCK)
+            .withDefaultModelCreationsForRotatedPillarBlock()
+            .withFullBlockBoundingBoxItem(),
+        new RotatedPillarBlock(BlockBehaviour.Properties.of(Material.STONE, MaterialColor.COLOR_BLACK).strength(2.0F).sound(SoundType.BONE_BLOCK)).mineableWithPickaxe(),
+        SuCraftBlockLoot::dropSelf
+    );
+
+    public static final Block WITHER_BONE_SLAB = registerFakeSlabFromYPillarCustomBlock(WITHER_BONE_BLOCK, null, "wither_bone", "wither_bone_block", Blocks.BLACKSTONE_SLAB).mineableWithPickaxe();
+    public static final Block BASALT_SLAB = registerFakeSlab(Blocks.BASALT, null, "basalt", NamespacedKeyWithoutIntention.minecraft("basalt"), NamespacedKeyWithoutIntention.minecraft("basalt_side"), NamespacedKeyWithoutIntention.minecraft("basalt_top"), null, null, null, Blocks.COBBLESTONE_SLAB, null).mineableWithPickaxe();
+    public static final Block POLISHED_BASALT_SLAB = registerFakeSlab(Blocks.POLISHED_BASALT, null, "polished_basalt", NamespacedKeyWithoutIntention.minecraft("polished_basalt"), NamespacedKeyWithoutIntention.minecraft("polished_basalt_side"), NamespacedKeyWithoutIntention.minecraft("polished_basalt_top"), null, null, null, Blocks.STONE_SLAB, null).mineableWithPickaxe();
+    public static final Block SMOOTH_BASALT_SLAB = registerFakeSlab(Blocks.SMOOTH_BASALT, "smooth_basalt", Blocks.COBBLED_DEEPSLATE_SLAB);
+
+    /**
+     * Based on {@link Blocks#COAL_BLOCK}
+     */
+    public static final Block CHARCOAL_BLOCK = register(
+        "charcoal_block",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.COAL_BLOCK)
+            .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.STONE, MaterialColor.COLOR_BLACK).strength(5.0F, 6.0F)).mineableWithPickaxe(),
+        SuCraftBlockLoot::dropSelf
+    );
+
+    public static final Block CHARCOAL_SLAB = registerFakeSlab(CHARCOAL_BLOCK, "charcoal", null, Blocks.BLACKSTONE_SLAB);
+
+    /**
+     * Based on {@link Blocks#LIGHT_GRAY_CONCRETE_POWDER}
+     */
+    public static final Block GUNPOWDER_BLOCK = register(
+        "gunpowder_block",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.LIGHT_GRAY_CONCRETE_POWDER)
+            .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.SAND, DyeColor.LIGHT_GRAY).strength(0.5F).sound(SoundType.SAND)).breakBeforeClientKnowsToBreak().mineableWithShovel(),
+        SuCraftBlockLoot::dropSelf
+    );
+
+    public static final Block GUNPOWDER_SLAB = registerFakeSlab(GUNPOWDER_BLOCK, "gunpowder", null, Blocks.SMOOTH_STONE_SLAB);
+    public static final Block PEAT = registerPeat(null);
+    public static final Block SMOULDERING_PEAT = registerPeat("smouldering");
+    public static final Block PEAT_SLAB = registerFakeSlab(PEAT, "peat", null, Blocks.MUD_BRICK_SLAB).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    public static final Block SCULK_SLAB = registerFakeSlab(Blocks.SCULK, "sculk", Blocks.BLACKSTONE_SLAB).breakBeforeClientKnowsToBreak().mineableWithHoe();
+    public static final Block CHISELED_QUARTZ_SLAB = registerFakeSlabFromYPillarVanillaBlock(Blocks.CHISELED_QUARTZ_BLOCK, null, "chiseled_quartz", "chiseled_quartz_block", Blocks.QUARTZ_SLAB).mineableWithPickaxe();
+    public static final Block QUARTZ_PILLAR_SLAB = registerFakeVanillaStonePillarSlab(Blocks.QUARTZ_PILLAR, "quartz", Blocks.QUARTZ_SLAB);
+    public static final Block QUARTZ_BRICK_SLAB = registerFakeVanillaBrickSlab(Blocks.QUARTZ_BRICKS, "quartz", Blocks.QUARTZ_SLAB);
+    public static final Block DRIED_KELP_SLAB = registerFakeSlab(Blocks.DRIED_KELP_BLOCK, null, "dried_kelp", NamespacedKeyWithoutIntention.minecraft("dried_kelp_block"), NamespacedKeyWithoutIntention.minecraft("dried_kelp_side"), NamespacedKeyWithoutIntention.minecraft("dried_kelp_bottom"), NamespacedKeyWithoutIntention.minecraft("dried_kelp_top"), NamespacedKeyWithoutIntention.minecraft("dried_kelp_bottom"), NamespacedKeyWithoutIntention.minecraft("dried_kelp_top"), Blocks.DARK_PRISMARINE_SLAB, null).mineableWithHoe();
+    public static final Block RED_FIRE = registerFire("red", Blocks.FIRE, DyeColor.RED.getMaterialColor());
+    public static final Block ORANGE_FIRE = registerFire("orange", Blocks.FIRE, DyeColor.ORANGE.getMaterialColor());
+    public static final Block YELLOW_FIRE = registerFire("yellow", Blocks.FIRE, DyeColor.YELLOW.getMaterialColor());
+    public static final Block LIME_FIRE = registerFire("lime", Blocks.SOUL_FIRE, DyeColor.LIME.getMaterialColor());
+    public static final Block GREEN_FIRE = registerFire("green", Blocks.SOUL_FIRE, DyeColor.GREEN.getMaterialColor());
+    public static final Block CYAN_FIRE = registerFire("cyan", Blocks.SOUL_FIRE, DyeColor.CYAN.getMaterialColor());
+    public static final Block LIGHT_BLUE_FIRE = registerFire("light_blue", Blocks.SOUL_FIRE, DyeColor.LIGHT_BLUE.getMaterialColor());
+    public static final Block BLUE_FIRE = registerFire("blue", Blocks.SOUL_FIRE, DyeColor.BLUE.getMaterialColor());
+    public static final Block BLACK_FIRE = registerFire("black", Blocks.SOUL_FIRE, DyeColor.BLACK.getMaterialColor());
+    public static final Block GRAY_FIRE = registerFire("gray", Blocks.SOUL_FIRE, DyeColor.GRAY.getMaterialColor());
+    public static final Block LIGHT_GRAY_FIRE = registerFire("light_gray", Blocks.SOUL_FIRE, DyeColor.LIGHT_GRAY.getMaterialColor());
+    public static final Block WHITE_FIRE = registerFire("white", Blocks.SOUL_FIRE, DyeColor.WHITE.getMaterialColor());
+    public static final Block BROWN_FIRE = registerFire("brown", Blocks.FIRE, DyeColor.BROWN.getMaterialColor());
+    public static final Block PURPLE_FIRE = registerFire("purple", Blocks.SOUL_FIRE, DyeColor.PURPLE.getMaterialColor());
+    public static final Block MAGENTA_FIRE = registerFire("magenta", Blocks.SOUL_FIRE, DyeColor.MAGENTA.getMaterialColor());
+    public static final Block PINK_FIRE = registerFire("pink", Blocks.FIRE, DyeColor.PINK.getMaterialColor());
+    public static final Block PAPER_BLOCK = register(
+        "paper_block",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.WHITE_WOOL)
+            .withModelCreation(Model.YPillarCube.defaultCreation().withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.WOOL, DyeColor.WHITE).strength(0.5F).sound(SoundType.SNOW)).breakBeforeClientKnowsToBreak().mineableWithAxe(),
+        SuCraftBlockLoot::dropSelf
+    );
+    public static final Block PAPER_SLAB = registerFakeSlabFromYPillarCustomBlock(PAPER_BLOCK, null, "paper", "paper_block", Blocks.SMOOTH_QUARTZ_SLAB).breakBeforeClientKnowsToBreak().mineableWithAxe();
+
+    /**
+     * Based on {@link Blocks#CHISELED_QUARTZ_BLOCK}
+     */
+    public static final Block QUARTZ_SPIRAL_MEANDER = register(
+        "quartz_spiral_meander",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.CHISELED_QUARTZ_BLOCK)
+            .withModelCreation(Model.creation(ModelContent.OneTextureCube.creation(new Texture(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("chiseled_quartz_block_top"), TextureContent.Existing.getInstance()))).withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.STONE, MaterialColor.QUARTZ).strength(0.8F)).mineableWithPickaxe(),
+        SuCraftBlockLoot::dropSelf
+    );
+
+    public static final Block QUARTZ_SPIRAL_MEANDER_SLAB = registerFakeSlab(QUARTZ_SPIRAL_MEANDER, null, "quartz_spiral_meander", NamespacedKeyWithoutIntention.sucraft("quartz_spiral_meander"), NamespacedKeyWithoutIntention.minecraft("chiseled_quartz_block_top"), null, null, null, null, Blocks.QUARTZ_SLAB, null).mineableWithPickaxe();
+    public static final Block ENDER_PEARL_BLOCK = register(
+        "ender_pearl_block",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.WARPED_PLANKS)
+            .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.METAL, MaterialColor.COLOR_CYAN).strength(1.5F, 3.0F)).mineableWithPickaxe(),
+        SuCraftBlockLoot::dropSelf
+    );
+    public static final Block FLINT_BLOCK = register(
+        "flint_block",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.DEEPSLATE_TILES)
+            .withModelCreation(Model.YPillarCube.defaultCreation().withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.METAL, MaterialColor.COLOR_GRAY).strength(3.5F, 6.0F)).mineableWithPickaxe(),
+        SuCraftBlockLoot::dropSelf
+    );
+    public static final Block FLINT_PILLAR = register(
+        "flint_pillar",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHosts()
+            .withDirectionalAnalogousPillarFallbacks(Blocks.POLISHED_BASALT)
+            .withDefaultModelCreationsForDirectionalBlock()
+            .withFullBlockBoundingBoxItem(),
+        new ConcreteDirectionalBlock(BlockBehaviour.Properties.of(Material.METAL, MaterialColor.COLOR_GRAY).strength(3.5F, 6.0F)).mineableWithPickaxe(),
+        SuCraftBlockLoot::dropSelf
+    ).withCustomOneToOneStonecutterRecipe(FLINT_BLOCK);
+    public static final Block FLINT_PILLAR_SLAB = registerFakeSlabFromYPillarCustomBlock(FLINT_PILLAR, null, "flint_pillar", Blocks.DEEPSLATE_TILE_SLAB).mineableWithPickaxe();
+    public static final Block FLINT_TILES = register(
+        "flint_tiles",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.DEEPSLATE_TILES)
+            .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.METAL, MaterialColor.COLOR_GRAY).strength(3.5F, 6.0F)).mineableWithPickaxe(),
+        SuCraftBlockLoot::dropSelf
+    ).withCustomOneToOneStonecutterRecipe(FLINT_BLOCK);
+    public static final Block FLINT_TILE_SLAB = registerFakeSlab(FLINT_TILES, "flint_tile", null, Blocks.DEEPSLATE_TILE_SLAB).mineableWithPickaxe();
+    public static final Block OBSIDIAN_SLAB = registerFakeSlab(Blocks.OBSIDIAN, "obsidian", Blocks.BLACKSTONE_SLAB).mineableWithPickaxe();
+    public static final Block CRYING_OBSIDIAN_SLAB = registerFakeSlab(Blocks.CRYING_OBSIDIAN, "crying_obsidian", Blocks.BLACKSTONE_SLAB).mineableWithPickaxe();
+    public static final Block GILDED_BLACKSTONE_SLAB = registerFakeSlab(Blocks.GILDED_BLACKSTONE, "gilded_blackstone", Blocks.BLACKSTONE_SLAB).mineableWithPickaxe();
+    public static final Block SNOWY_STONE_BRICK_STAIRS = registerFakeStairs(SNOWY_STONE_BRICKS, "snowy_stone_brick", null, Blocks.STONE_BRICK_STAIRS);
+
+    private static @NotNull Block register(@NotNull String id, @NotNull BlockReplacementRuleBuilder<?, ?> replacementRuleBuilder, @NotNull Block block, @Nullable Supplier<@Nullable LootTable> lootTableSupplier) {
+        return register(id, replacementRuleBuilder, block, lootTableSupplier == null ? null : ($ -> lootTableSupplier.get()));
+    }
+
+    private static @NotNull Block register(@NotNull String id, @NotNull BlockReplacementRuleBuilder<?, ?> replacementRuleBuilder, @NotNull Block block, @Nullable Function<@NotNull Block, @Nullable LootTable> lootTableFunction) {
+        ResourceLocation key = ResourceLocation.sucraft(id);
+        block.id = key;
+        @NotNull Block registeredBlock = Registry.register(Registry.BLOCK, key, block);
+        registeredBlock.isVanilla = false;
+        registeredBlock.customKey = key;
+        registeredBlock.replacementRule = replacementRuleBuilder.withReal(registeredBlock).build();
+        // Patch the break time, because the vanilla client will assume its own breaking time and if we do not allow for it, we get desync in whether the block is finished being broken
+        registeredBlock.replacementRule.updateMinDestroyTimes();
+        registeredBlock.customLootTableSupplier = lootTableFunction == null ? null : () -> lootTableFunction.apply(registeredBlock);
+        return registeredBlock;
+    }
+
+    /**
+     * Based on {@link Blocks#STONE_BRICKS}
+     */
+    private static @NotNull Block registerStoneBricks(@NotNull String type, @NotNull Block host, @NotNull Block hostReplacement, @NotNull Block fallback) {
+        return register(
+            type + "_stone_bricks",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withHost(host)
+                .withHostReplacement(hostReplacement)
+                .withFallback(fallback)
+                .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+                .withFullBlockBoundingBoxItem()
+                .withHostItemRuleFromHostBlockAndHostReplacementBlock(),
+            new Block(BlockBehaviour.Properties.of(Material.STONE).strength(1.5F, 6.0F)).mineableWithPickaxe().stoneBricks(),
+            SuCraftBlockLoot::dropSelf
+        );
+    }
+
+    /**
+     * Based on {@link Blocks#INFESTED_STONE_BRICKS} and {@link #registerStoneBricks}
+     */
+    public static @NotNull Block registerInfested(@NotNull Block uninfested) {
+        if (uninfested.isVanilla) {
+            throw new IllegalArgumentException("registerInfestedStoneBricks works only on uninfested custom blocks");
+        }
+        BlockReplacementRule replacementRule = uninfested.replacementRule;
+        if (replacementRule == null) {
+            throw new IllegalStateException("registerInfestedStoneBricks was called with an uninfested custom block for which replacementRule was not initialized yet");
+        }
+        if (replacementRule instanceof SingleStateRealBlockReplacementRule singleStateReplacementRule) {
+            Block infestedBlock = new InfestedBlock(uninfested, BlockBehaviour.Properties.of(Material.CLAY), false).withAddedTagsLike(uninfested);
+            return register(
+                "infested_" + uninfested.customKey.getPath(),
+                new SingleMultiStateRealBlockReplacementRuleBuilder()
+                    .withHostSameAs(singleStateReplacementRule)
+                    .withHostReplacementSameAs(singleStateReplacementRule)
+                    .withFallbackSameAs(singleStateReplacementRule)
+                    .withModelSameAs(singleStateReplacementRule)
+                    .withFullBlockBoundingBoxItem()
+                    .withHostItemRuleFromHostBlockAndHostReplacementBlock(),
+                infestedBlock,
+                block -> SuCraftBlockLoot.dropSingleItemWhenSilkTouch(uninfested)
+            );
+        } else {
+            throw new IllegalArgumentException("registerInfestedStoneBricks works only on uninfested custom blocks with a replacement rule of type StatelessBlockReplacementRule");
+        }
+    }
+
+    /**
+     * Based on {@link Blocks#BOOKSHELF}
+     */
+    private static @NotNull Block registerBookshelf(@NotNull String idWoodType) {
+        return register(
+            idWoodType + "_bookshelf",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withNoteBlockHost()
+                .withFallback(Blocks.BOOKSHELF)
+                .withModelCreation(Model.YPillarCube.defaultCreationWithAlternativeEnd(new Texture(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft(idWoodType + "_planks"), TextureContent.Existing.getInstance())).withNoParameters())
+                .withFullBlockBoundingBoxItem(),
+            new Block(BlockBehaviour.Properties.of(Material.WOOD).strength(1.5F).sound(SoundType.WOOD)).mineableWithAxe(),
+            block -> SuCraftBlockLoot.dropSingleItemAndSingleItemWhenSilkTouch(Items.BOOK, ConstantValue.exactly(3.0F), block)
+        );
+    }
+
+    /**
+     * Based on {@link Blocks#OAK_PLANKS}
+     */
+    private static @NotNull Block registerPlanks(@NotNull String description, @NotNull Block fallback, @NotNull MaterialColor materialColor) {
+        return register(
+            description + "_planks",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withNoteBlockHost()
+                .withFallback(fallback)
+                .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+                .withFullBlockBoundingBoxItem(),
+            new Block(BlockBehaviour.Properties.of(Material.WOOD, materialColor).strength(2.0F, 3.0F).sound(SoundType.WOOD)).mineableWithAxe().planks(),
+            SuCraftBlockLoot::dropSelf
+        );
+    }
+
+    /**
+     * Based on {@link Blocks#POLISHED_ANDESITE}
+     */
+    private static @NotNull Block registerPolished(@NotNull Block originalBlock, @NotNull String unpolished, @NotNull Block fallback, @NotNull MaterialColor materialColor) {
+        return register(
+            "polished_" + unpolished,
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withNoteBlockHost()
+                .withFallback(fallback)
+                .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+                .withFullBlockBoundingBoxItem(),
+            new Block(BlockBehaviour.Properties.of(Material.STONE, materialColor).strength(1.5F, 6.0F)).mineableWithPickaxe(),
+            SuCraftBlockLoot::dropSelf
+        ).withCustomOneToOneStonecutterRecipe(originalBlock);
+    }
+
+    /**
+     * Based on {@link Blocks#STONE_BRICKS}
+     */
+    private static @NotNull Block registerBricks(@NotNull Block originalBlock, @NotNull String type, @NotNull Block fallback, @NotNull MaterialColor materialColor) {
+        return register(
+            type + "_bricks",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withNoteBlockHost()
+                .withFallback(fallback)
+                .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+                .withFullBlockBoundingBoxItem(),
+            new Block(BlockBehaviour.Properties.of(Material.STONE, materialColor).strength(1.5F, 6.0F)).mineableWithPickaxe(),
+            SuCraftBlockLoot::dropSelf
+        ).withCustomOneToOneStonecutterRecipe(originalBlock);
+    }
+
+    /**
+     * Based on {@link Blocks#CHISELED_STONE_BRICKS}
+     */
+    private static @NotNull Block registerChiseledBricks(@NotNull Block bricksBlock, @NotNull String type, @NotNull Block fallback, @NotNull MaterialColor materialColor) {
+        return register(
+            "chiseled_" + type + "_bricks",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withNoteBlockHost()
+                .withFallback(fallback)
+                .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+                .withFullBlockBoundingBoxItem(),
+            new Block(BlockBehaviour.Properties.of(Material.STONE, materialColor).strength(1.5F, 6.0F)).mineableWithPickaxe(),
+            SuCraftBlockLoot::dropSelf
+        ).withCustomOneToOneStonecutterRecipe(bricksBlock);
+    }
+
+    /**
+     * Based on {@link Blocks#COBBLESTONE}
+     */
+    private static @NotNull Block registerCobblestone(@NotNull Block regularBlock, @NotNull String type, @NotNull Block fallback, @NotNull MaterialColor materialColor) {
+        return register(
+            type + "_cobblestone",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withNoteBlockHost()
+                .withFallback(fallback)
+                .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+                .withFullBlockBoundingBoxItem(),
+            new Block(BlockBehaviour.Properties.of(Material.STONE, materialColor).strength(2.0F, 6.0F)).mineableWithPickaxe(),
+            SuCraftBlockLoot::dropSelf
+        ).withCustomOneToOneStonecutterRecipe(regularBlock);
+    }
+
+    /**
+     * Based on {@link Blocks#QUARTZ_PILLAR}
+     */
+    private static @NotNull Block registerStonePillar(@NotNull Block originalBlock, @NotNull String stoneType, @NotNull Block fallback, @NotNull MaterialColor materialColor) {
+        return register(
+            stoneType + "_pillar",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withNoteBlockHosts()
+                .withFallback(fallback)
+                .withDefaultModelCreationsForRotatedPillarBlock()
+                .withFullBlockBoundingBoxItem(),
+            new RotatedPillarBlock(BlockBehaviour.Properties.of(Material.STONE, materialColor).strength(1.5F, 6.0F)).mineableWithPickaxe(),
+            SuCraftBlockLoot::dropSelf
+        ).withCustomOneToOneStonecutterRecipe(originalBlock);
+    }
+
+    /**
+     * Based on {@link Blocks#BIRCH_LEAVES}
+     */
+    private static @NotNull Block registerLeaves(@NotNull String leavesType, @NotNull Block host, @NotNull Block saplingBlock, @NotNull Block fallback, @NotNull MaterialColor materialColor) {
+        return register(
+            leavesType + "_leaves",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withOneNonWaterLoggedAndOneWaterLoggedHost(host)
+                .withAnalogousFallbacks(fallback)
+                .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+                .withFullBlockBoundingBoxItem(),
+            new LeavesBlock(BlockBehaviour.Properties.of(Material.LEAVES, materialColor).strength(0.2F).randomTicks().sound(SoundType.GRASS).noOcclusion().isValidSpawn(Blocks::ocelotOrParrot).isSuffocating(Blocks::never).isViewBlocking(Blocks::never)).mineableWithHoe().leaves(),
+            block -> SuCraftBlockLoot.dropLeaves(block, saplingBlock)
+        );
+    }
+
+    /**
+     * Based on {@link Blocks#OAK_SLAB}
+     * @param textureBlock If null, will be the same as the given type, else it will be assumed to be a default Minecraft model as well as texture namespaced key path (for example 'dirt' will mean the model used as double slab is 'minecraft:block/dirt' and the texture used is 'minecraft:block/dirt')
+     */
+    private static @NotNull Block registerRealSlab(@NotNull Block fullBlock, @NotNull String type, @Nullable String textureBlock, @NotNull Block host, @NotNull Block hostReplacement, @NotNull Block fallback, @NotNull BlockBehaviour.Properties properties) {
+        if (textureBlock == null) {
+            textureBlock = type;
+        }
+        return register(
+            type + "_slab",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withAnalogousHosts(host, hostReplacement)
+                .withAnalogousFallbacks(fallback)
+                .withDefaultModelCreationsForSlabReplacedBySlab(NamespacedKeyWithoutIntention.minecraft(textureBlock), ModelContent.Existing.ExistingModelContentOutwardExpansionType.CUBE)
+                .withRealItemRuleFromHostBlock()
+                .withHostItemRuleFromHostBlockAndHostReplacementBlock(),
+            new SlabBlock(properties).slab(),
+            SuCraftBlockLoot::dropSingleOrDoubleSlabSelf
+        ).withCustomSlabStonecutterRecipe(fullBlock);
+    }
+
+    private static @NotNull Block registerFakeSlab(@NotNull Block fullBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull ModelCreation doubleSlabModelCreation, @NotNull Texture sideTexture, @Nullable Texture bottomHalfBottomTexture, @Nullable Texture bottomHalfTopTexture, @Nullable Texture topHalfBottomTexture, @Nullable Texture topHalfTopTexture, @NotNull Block host, @Nullable Block fallback) {
+        if (fallback == null) {
+            fallback = host;
+        }
+        return register(
+            type + "_slab",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .rendersAsEntity()
+                .withAnalogousHosts(host)
+                .withAnalogousFallbacks(fallback)
+                .withDefaultModelCreationsForSlabReplacedBySlab(doubleSlabModelCreation, sideTexture, bottomHalfBottomTexture, bottomHalfTopTexture, topHalfBottomTexture, topHalfTopTexture)
+                .withRealItemRuleFromHostBlock(),
+            new SlabBlock(properties == null ? BlockBehaviour.Properties.copy(fullBlock).doesNotRequireCorrectToolForDrops() : properties).withAddedTagsLike(fullBlock).slab(),
+            SuCraftBlockLoot::dropSingleOrDoubleSlabSelf
+        ).withCustomSlabStonecutterRecipe(fullBlock);
+    }
+
+    private static @NotNull Block registerFakeSlab(@NotNull Block fullBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull NamespacedKeyWithoutIntention doubleSlabKey, @Nullable NamespacedKeyWithoutIntention sideTextureKey, @Nullable NamespacedKeyWithoutIntention bottomHalfBottomTextureKey, @Nullable NamespacedKeyWithoutIntention bottomHalfTopTextureKey, @Nullable NamespacedKeyWithoutIntention topHalfBottomTextureKey, @Nullable NamespacedKeyWithoutIntention topHalfTopTextureKey, @NotNull Block host, @Nullable Block fallback) {
+        if (sideTextureKey == null) {
+            sideTextureKey = doubleSlabKey;
+        }
+        return registerFakeSlab(
+            fullBlock,
+            properties,
+            type,
+            (intention, key) -> new Model(ResourcePackAssetIntention.BLOCK, doubleSlabKey, ModelContent.Existing.getInstance(ModelContent.Existing.ExistingModelContentOutwardExpansionType.CUBE)),
+            new Texture(ResourcePackAssetIntention.BLOCK, sideTextureKey, TextureContent.Existing.getInstance()),
+            bottomHalfBottomTextureKey == null ? null : new Texture(ResourcePackAssetIntention.BLOCK, bottomHalfBottomTextureKey, TextureContent.Existing.getInstance()),
+            bottomHalfTopTextureKey == null ? null : new Texture(ResourcePackAssetIntention.BLOCK, bottomHalfTopTextureKey, TextureContent.Existing.getInstance()),
+            topHalfBottomTextureKey == null ? null : new Texture(ResourcePackAssetIntention.BLOCK, topHalfBottomTextureKey, TextureContent.Existing.getInstance()),
+            topHalfTopTextureKey == null ? null : new Texture(ResourcePackAssetIntention.BLOCK, topHalfTopTextureKey, TextureContent.Existing.getInstance()),
+            host,
+            fallback
+        );
+    }
+
+    private static @NotNull Block registerFakeSlabFromYPillar(@NotNull Block fullBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull NamespacedKeyWithoutIntention doubleSlabNamespacedKey, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, properties, type, doubleSlabNamespacedKey, doubleSlabNamespacedKey, doubleSlabNamespacedKey.withKeySuffix("_top"), null, null, null, host, null);
+    }
+
+    private static @NotNull Block registerFakeSlabFromYPillarVanillaBlock(@NotNull Block fullVanillaBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull String textureType, @NotNull Block host) {
+        return registerFakeSlabFromYPillar(fullVanillaBlock, properties, type, NamespacedKeyWithoutIntention.minecraft(textureType), host);
+    }
+
+    private static @NotNull Block registerFakeSlabFromYPillarVanillaBlock(@NotNull Block fullVanillaBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlabFromYPillarVanillaBlock(fullVanillaBlock, properties, type, type, host);
+    }
+
+    private static @NotNull Block registerFakeSlabFromYPillarCustomBlock(@NotNull Block fullCustomBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull String textureType, @NotNull Block host) {
+        return registerFakeSlabFromYPillar(fullCustomBlock, properties, type, NamespacedKeyWithoutIntention.sucraft(textureType), host);
+    }
+
+    private static @NotNull Block registerFakeSlabFromYPillarCustomBlock(@NotNull Block fullCustomBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlabFromYPillarCustomBlock(fullCustomBlock, properties, type, type, host);
+    }
+
+    private static @NotNull Block registerFakeSlabFromBottomTopPillar(@NotNull Block fullBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull NamespacedKeyWithoutIntention doubleSlabNamespacedKey, @NotNull Block host) {
+        NamespacedKeyWithoutIntention bottomKey = doubleSlabNamespacedKey.withKeySuffix("_bottom");
+        NamespacedKeyWithoutIntention topKey = doubleSlabNamespacedKey.withKeySuffix("_top");
+        return registerFakeSlab(fullBlock, properties, type, doubleSlabNamespacedKey, doubleSlabNamespacedKey, bottomKey, topKey, bottomKey, topKey, host, null);
+    }
+
+    private static @NotNull Block registerFakeSlabFromBottomTopPillarVanillaBlock(@NotNull Block fullVanillaBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull String textureType, @NotNull Block host) {
+        return registerFakeSlabFromBottomTopPillar(fullVanillaBlock, properties, type, NamespacedKeyWithoutIntention.minecraft(textureType), host);
+    }
+
+    private static @NotNull Block registerFakeSlabFromBottomTopPillarVanillaBlock(@NotNull Block fullVanillaBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlabFromBottomTopPillarVanillaBlock(fullVanillaBlock, properties, type, type, host);
+    }
+
+    private static @NotNull Block registerFakeSlabFromBottomTopPillarCustomBlock(@NotNull Block fullCustomBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull String textureType, @NotNull Block host) {
+        return registerFakeSlabFromBottomTopPillar(fullCustomBlock, properties, type, NamespacedKeyWithoutIntention.sucraft(textureType), host);
+    }
+
+    private static @NotNull Block registerFakeSlabFromBottomTopPillarCustomBlock(@NotNull Block fullCustomBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlabFromBottomTopPillarCustomBlock(fullCustomBlock, properties, type, type, host);
+    }
+
+    private static @NotNull Block registerFakeBookshelfSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        String typedBookshelf = type + "_bookshelf";
+        String typedBookshelfIfNotOak = fullBlock.equals(Blocks.BOOKSHELF) ? "bookshelf" : typedBookshelf;
+        NamespacedKeyWithoutIntention doubleSlabNamespacedKey = fullBlock.equals(Blocks.BOOKSHELF) ? NamespacedKeyWithoutIntention.minecraft(typedBookshelfIfNotOak) : NamespacedKeyWithoutIntention.sucraft(typedBookshelfIfNotOak);
+        return registerFakeSlab(fullBlock, null, typedBookshelf, doubleSlabNamespacedKey, doubleSlabNamespacedKey,  NamespacedKeyWithoutIntention.minecraft(type + "_planks"), null, null, null, host, null).mineableWithAxe();
+    }
+
+    private static @NotNull Block registerFakeCustomStonePillarSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlabFromYPillarCustomBlock(fullBlock, null, type + "_pillar", host).mineableWithPickaxe();
+    }
+
+    private static @NotNull Block registerFakeVanillaStonePillarSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlabFromYPillarVanillaBlock(fullBlock, null, type + "_pillar", host).mineableWithPickaxe();
+    }
+
+    private static @NotNull Block registerFakeLogOrStemSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlabFromYPillarVanillaBlock(fullBlock, BlockBehaviour.Properties.of(Material.WOOD, fullBlock.defaultMaterialColor()).strength(2.0F, 3.0F).sound(SoundType.WOOD), type, host).mineableWithAxe();
+    }
+
+    private static @NotNull Block registerFakeLogSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeLogOrStemSlab(fullBlock, type + "_log", host);
+    }
+
+    private static @NotNull Block registerFakeStemSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeLogOrStemSlab(fullBlock, type + "_stem", host);
+    }
+
+    private static @NotNull Block registerFakeStrippedLogOrStemSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeLogOrStemSlab(fullBlock, "stripped_" + type, host);
+    }
+
+    private static @NotNull Block registerFakeStrippedLogSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeStrippedLogOrStemSlab(fullBlock, type + "_log", host);
+    }
+
+    private static @NotNull Block registerFakeStrippedStemSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeStrippedLogOrStemSlab(fullBlock, type + "_stem", host);
+    }
+
+    private static @NotNull Block registerFakeWoodOrHyphaeSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull String textureType, @NotNull Block host) {
+        NamespacedKeyWithoutIntention doubleSlabKey = NamespacedKeyWithoutIntention.minecraft(type);
+        NamespacedKeyWithoutIntention textureKey = NamespacedKeyWithoutIntention.minecraft(textureType);
+        return registerFakeSlab(fullBlock, BlockBehaviour.Properties.of(Material.WOOD, fullBlock.defaultMaterialColor()).strength(2.0F, 3.0F).sound(SoundType.WOOD), type, doubleSlabKey, textureKey, null, null, null, null, host, null).mineableWithAxe();
+    }
+
+    private static @NotNull Block registerFakeWoodSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeWoodOrHyphaeSlab(fullBlock, type + "_wood", type + "_log", host);
+    }
+
+    private static @NotNull Block registerFakeHyphaeSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeWoodOrHyphaeSlab(fullBlock, type + "_hyphae", type + "_stem", host);
+    }
+
+    private static @NotNull Block registerFakeStrippedWoodOrHyphaeSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull String textureType, @NotNull Block host) {
+        return registerFakeWoodOrHyphaeSlab(fullBlock, "stripped_" + type, "stripped_" + textureType, host);
+    }
+
+    private static @NotNull Block registerFakeStrippedWoodSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeStrippedWoodOrHyphaeSlab(fullBlock, type + "_wood", type + "_log", host);
+    }
+
+    private static @NotNull Block registerFakeStrippedHyphaeSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeStrippedWoodOrHyphaeSlab(fullBlock, type + "_hyphae", type + "_stem", host);
+    }
+
+    /**
+     * Based on {@link Blocks#OAK_SLAB}
+     * @param textureBlock If null, will be the based on the model of the full block, else it will be assumed to be a default Minecraft model as well as texture namespaced key path (for example 'dirt' will mean the model used as double slab is 'minecraft:block/dirt' and the texture used is 'minecraft:block/dirt')
+     * @param fallback If null, will be the same as host
+     */
+    private static @NotNull Block registerFakeSlab(@NotNull Block fullBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @Nullable String textureBlock, @NotNull Block host, @Nullable Block fallback) {
+        if (fallback == null) {
+            fallback = host;
+        }
+        return register(
+            type + "_slab",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .rendersAsEntity()
+                .withAnalogousHosts(host)
+                .withAnalogousFallbacks(fallback)
+                .withDefaultModelCreationsForSlabReplacedBySlab(textureBlock != null ? NamespacedKeyWithoutIntention.minecraft(textureBlock) : fullBlock.replacementRule.getModel(fullBlock.defaultBlockState()).model().getKey(), ModelContent.Existing.ExistingModelContentOutwardExpansionType.CUBE)
+                .withRealItemRuleFromHostBlock(),
+            new SlabBlock(properties == null ? BlockBehaviour.Properties.copy(fullBlock).doesNotRequireCorrectToolForDrops() : properties).withAddedTagsLike(fullBlock).slab(),
+            SuCraftBlockLoot::dropSingleOrDoubleSlabSelf
+        ).withCustomSlabStonecutterRecipe(fullBlock);
+    }
+
+    /**
+     * Based on {@link Blocks#OAK_STAIRS}
+     * @param textureBlock If null, will be the based on the model of the full block, else it will be assumed to be a default Minecraft model as well as texture namespaced key path (for example 'dirt' will mean the texture used is 'minecraft:block/dirt')
+     * @param fallback If null, will be the same as host
+     */
+    private static @NotNull Block registerFakeStairs(@NotNull Block fullBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @Nullable String textureBlock, @NotNull Block host, @Nullable Block fallback) {
+        if (fallback == null) {
+            fallback = host;
+        }
+        return register(
+            type + "_stairs",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .rendersAsEntity()
+                .withAnalogousHosts(host)
+                .withAnalogousFallbacks(fallback)
+                .withDefaultModelCreationsForStairsReplacedByStairs(textureBlock != null ? NamespacedKeyWithoutIntention.minecraft(textureBlock) : fullBlock.replacementRule.getModel(fullBlock.defaultBlockState()).model().getKey())
+                .withRealItemRuleFromHostBlock(),
+            new StairBlock(fullBlock.defaultBlockState(), properties == null ? BlockBehaviour.Properties.copy(fullBlock).doesNotRequireCorrectToolForDrops() : properties).withAddedTagsLike(fullBlock).stairs(),
+            SuCraftBlockLoot::dropSelf
+        ).withCustomOneToOneStonecutterRecipe(fullBlock);
+    }
+
+    private static @NotNull Block registerFakeSlab(@NotNull Block fullBlock, @NotNull String type, @Nullable String textureBlock, @NotNull Block host, @Nullable Block fallback) {
+        return registerFakeSlab(fullBlock, null, type, textureBlock, host, fallback);
+    }
+
+    private static @NotNull Block registerFakeStairs(@NotNull Block fullBlock, @NotNull String type, @Nullable String textureBlock, @NotNull Block host, @Nullable Block fallback) {
+        return registerFakeStairs(fullBlock, null, type, textureBlock, host, fallback);
+    }
+
+    private static @NotNull Block registerFakeSlab(@NotNull Block fullBlock, @NotNull String type, @Nullable String textureBlock, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, type, textureBlock, host, null);
+    }
+
+    private static @NotNull Block registerFakeStairs(@NotNull Block fullBlock, @NotNull String type, @Nullable String textureBlock, @NotNull Block host) {
+        return registerFakeStairs(fullBlock, type, textureBlock, host, null);
+    }
+
+    private static @NotNull Block registerFakeSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, type, type, host, null);
+    }
+
+    private static @NotNull Block registerFakeDyedPlanksSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, type + "_plank", null, host).breakBeforeClientKnowsToBreak().mineableWithAxe().woodenSlab();
+    }
+
+    private static @NotNull Block registerFakeWoolSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, type + "_wool", type + "_wool", host).breakBeforeClientKnowsToBreak().wool();
+    }
+
+    private static @NotNull Block registerFakeConcreteSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, type + "_concrete", type + "_concrete", host).mineableWithPickaxe();
+    }
+
+    private static @NotNull Block registerFakeConcretePowderSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, type + "_concrete_powder", type + "_concrete_powder", host).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    }
+
+    private static @NotNull Block registerFakeTerracottaSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, type + "_terracotta", type + "_terracotta", host).mineableWithPickaxe();
+    }
+
+    private static @NotNull Block registerFakePolishedSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, "polished_" + type, null, host).mineableWithPickaxe();
+    }
+
+    private static @NotNull Block registerFakeCustomBrickSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, type + "_brick", null, host).mineableWithPickaxe();
+    }
+
+    private static @NotNull Block registerFakeVanillaBrickSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, type + "_brick", type + "_bricks", host).mineableWithPickaxe();
+    }
+
+    private static @NotNull Block registerFakeSandstoneBrickSlab(@NotNull Block fullBlock, @Nullable String type, @NotNull Block host) {
+        return registerFakeCustomBrickSlab(fullBlock, (type == null ? "" : type + "_") + "sandstone", host);
+    }
+
+    private static @NotNull Block registerFakeRawMetalSlab(@NotNull Block fullBlock, @Nullable String type, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, "raw_" + type, "raw_" + type + "_block", host).mineableWithPickaxe();
+    }
+
+    private static @NotNull Block registerPeat(@NotNull String type) {
+        return register(
+            (type == null ? "" : type + "_") + "peat",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withNoteBlockHost()
+                .withFallback(Blocks.COARSE_DIRT)
+                .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+                .withFullBlockBoundingBoxItem(),
+            new Block(BlockBehaviour.Properties.of(Material.DIRT, MaterialColor.DIRT).strength(1.0F, 2.0F).sound(SoundType.GRAVEL)).breakBeforeClientKnowsToBreak().mineableWithShovel(),
+            SuCraftBlockLoot::dropSelf
+        );
+    }
+
+    /**
+     * Based on {@link Blocks#FIRE}
+     */
+    private static @NotNull Block registerFire(@NotNull String fireType, @NotNull Block fallback, @NotNull MaterialColor materialColor) {
+        @NotNull Block block = register(
+            fireType + "_fire",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withFireHost()
+                .withFallback(fallback),
+            new SoulFireBlock(BlockBehaviour.Properties.of(Material.FIRE, materialColor).noCollission().instabreak().sound(SoundType.WOOL).lightLevel(state -> 10)),
+            () -> null
+        );
+        block.customFireType = fireType;
+        return block;
+    }
+
+    public static Block bootstrap() {
+        SNOWY_STONE_BRICKS.toString();
+        return SNOWY_STONE_BRICKS;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/SuCraftObservableBlockTagsSpreader.java b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftObservableBlockTagsSpreader.java
new file mode 100644
index 0000000000000000000000000000000000000000..8704a102dec8468e7dee4e342361d9b65ce5dce4
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftObservableBlockTagsSpreader.java
@@ -0,0 +1,65 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.block;
+
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.core.Holder;
+import net.minecraft.core.Registry;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.tags.TagKey;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import nl.martijnmuijsers.paper.block.replacementrule.BlockReplacementRule;
+import nl.martijnmuijsers.paper.data.SuCraftTagsProvider;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Based on {@link net.minecraft.data.tags.BlockTagsProvider}
+ */
+public class SuCraftObservableBlockTagsSpreader extends SuCraftTagsProvider<Block> {
+
+    public SuCraftObservableBlockTagsSpreader(Registry<Block> registry) {
+        super(registry);
+    }
+
+    @Override
+    protected void addTags(Map<TagKey<Block>, List<Holder<Block>>> existingRegistryTagEntries) {
+        MinecraftServer.LOGGER.info("Inheriting mineable with tool tags for custom blocks...");
+        final List<TagKey<Block>> tagsToSpread = List.of(BlockTags.MINEABLE_WITH_AXE, BlockTags.MINEABLE_WITH_HOE, BlockTags.MINEABLE_WITH_PICKAXE, BlockTags.MINEABLE_WITH_SHOVEL, BlockTags.LEAVES /* To allow custom leaves to inherit being broken by shears fast */, BlockTags.WOOL /* To allow custom wool-like blocks such as wool slabs to inherit being broken by shears fast */);
+        for (boolean observationReplacementToOriginal : new boolean[] {false, true}) {
+            for (Block block : Registry.BLOCK) {
+                BlockReplacementRule blockReplacementRule = block.replacementRule;
+                if (blockReplacementRule != null) {
+                    for (@NotNull Pair<@NotNull Block, @NotNull Block> observationReplacement : blockReplacementRule.getPotentialBlockReplacementPairs()) {
+                        var observationOriginalKey = this.registry.getResourceKey(observationReplacement.first()).get();
+                        var observationOriginalHolder = this.registry.getHolderOrThrow(observationOriginalKey);
+                        var observationReplacementKey = this.registry.getResourceKey(observationReplacement.second()).get();
+                        var observationReplacementHolder = this.registry.getHolderOrThrow(observationReplacementKey);
+                        for (TagKey<Block> tag : tagsToSpread) {
+                            if (observationReplacementToOriginal) {
+                                // From observation replacement block to original block
+                                if (existingRegistryTagEntries.getOrDefault(tag, Collections.emptyList()).contains(observationReplacementHolder)) {
+                                    this.tag(tag).add(observationOriginalKey);
+                                }
+                            } else {
+                                // From original block to observation replacement block
+                                if (existingRegistryTagEntries.getOrDefault(tag, Collections.emptyList()).contains(observationOriginalHolder)) {
+                                    this.tag(tag).add(observationReplacementKey);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/UsedHostBlockStates.java b/src/main/java/nl/martijnmuijsers/paper/block/UsedHostBlockStates.java
new file mode 100644
index 0000000000000000000000000000000000000000..34357c237d9a45e91c9de0b5731fcccae3b27447
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/block/UsedHostBlockStates.java
@@ -0,0 +1,116 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.block;
+
+import it.unimi.dsi.fastutil.Pair;
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.BaseFireBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.FireBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+/**
+ * A utility class that keeps track of used block states in block replacement hosts
+ */
+public final class UsedHostBlockStates {
+
+    private UsedHostBlockStates() {}
+
+    private static final @NotNull Set<@NotNull BlockState> usedBlockStates = new HashSet<>(0);
+
+    private static @NotNull BlockState getHostReplacement(@NotNull BlockState host) {
+        // Block tags cannot be used in this method yet since it will be called before they are assigned
+        Block block = host.getBlock();
+        if (block.equals(Blocks.NOTE_BLOCK)) {
+            return block.getStateDefinition().getPossibleStates().get(0);
+        } else if (
+            block.equals(Blocks.OAK_LEAVES) ||
+                block.equals(Blocks.SPRUCE_LEAVES) ||
+                block.equals(Blocks.BIRCH_LEAVES) ||
+                block.equals(Blocks.JUNGLE_LEAVES) ||
+                block.equals(Blocks.ACACIA_LEAVES) ||
+                block.equals(Blocks.DARK_OAK_LEAVES) ||
+                block.equals(Blocks.AZALEA_LEAVES) ||
+                block.equals(Blocks.FLOWERING_AZALEA_LEAVES) ||
+                block.equals(Blocks.MANGROVE_LEAVES)
+        ) {
+            return host.getBlock().withPropertiesOf(host).setValue(BlockStateProperties.DISTANCE, 1).setValue(BlockStateProperties.PERSISTENT, true);
+        }
+        throw new IllegalArgumentException("Called UsedHostBlockStates.getHostReplacement with a host for which host replacements were not defined yet: " + host);
+    }
+
+    private static final @NotNull Map<@NotNull Block, @NotNull List<@NotNull BlockState>> defaultPossibleBlockStatesByBlock = new HashMap<>(0);
+
+    private static @NotNull List<@NotNull BlockState> getDefaultPossibleBlockStatesForBlock(@NotNull Block block) {
+        return defaultPossibleBlockStatesByBlock.computeIfAbsent(block, $ -> {
+            @NotNull List<@NotNull BlockState> allBlockStates = new ArrayList<>(block.getStateDefinition().getPossibleStates());
+            @NotNull List<@NotNull BlockState> hostReplacements = allBlockStates.stream().map(UsedHostBlockStates::getHostReplacement).distinct().toList();
+            allBlockStates.removeAll(hostReplacements);
+            return allBlockStates;
+        });
+    }
+
+    public static @NotNull Pair<@NotNull BlockState, @NotNull BlockState> generateUnusedHostAndReplacement(@NotNull Block block) {
+        return generateUnusedHostAndReplacement(getDefaultPossibleBlockStatesForBlock(block));
+    }
+
+    public static @NotNull Pair<@NotNull BlockState, @NotNull BlockState> generateUnusedHostAndReplacement(@NotNull List<@NotNull BlockState> possibleBlockStates) {
+        @NotNull List<@NotNull BlockState> possibleBlockStatesWithoutReplacements = new ArrayList<>(possibleBlockStates);
+        possibleBlockStates.stream().map(UsedHostBlockStates::getHostReplacement).distinct().forEach(possibleBlockStatesWithoutReplacements::remove);
+        for (@NotNull BlockState possibleBlockState : possibleBlockStatesWithoutReplacements) {
+            if (usedBlockStates.add(possibleBlockState)) {
+                return Pair.of(possibleBlockState, getHostReplacement(possibleBlockState));
+            }
+        }
+        throw new IllegalStateException("Tried to generate unused host block state, but all possible block states (" + possibleBlockStates + ") are already in use");
+    }
+
+    public static @NotNull BlockState generateUnusedFireState() {
+        @NotNull List<@NotNull BlockState> unusedStates = Blocks.FIRE
+            .getStateDefinition()
+            .getPossibleStates().stream()
+            .filter(state -> !usedBlockStates.contains(state) // Must not be in use yet
+                && state.getValue(BlockStateProperties.AGE_15) != 0) // Must not have an age of 0 (this is the host replacement for all fire hosts)
+            .toList();
+        if (unusedStates.isEmpty()) {
+            throw new IllegalStateException("Tried to generated unused fire host block state, but all possible acceptable block states are already in use");
+        }
+        @Nullable BlockState stateToUse = unusedStates.stream()
+            .filter(state -> !state.getValue(BlockStateProperties.UP) && !state.getValue(BlockStateProperties.EAST) && !state.getValue(BlockStateProperties.WEST) && !state.getValue(BlockStateProperties.NORTH) && !state.getValue(BlockStateProperties.SOUTH)) // This has a nice hitbox of the bottom
+            .findAny().orElse(
+                unusedStates.stream()
+                    .filter(state -> state.getValue(BlockStateProperties.EAST) && state.getValue(BlockStateProperties.WEST) && state.getValue(BlockStateProperties.NORTH) && state.getValue(BlockStateProperties.SOUTH)) // This has an acceptable hitbox of all 4 sides (both including and excluding the top)
+                    .findAny().get()
+            );
+        usedBlockStates.add(stateToUse);
+        return stateToUse;
+//        int hostAge = 1;
+//        while (usedBlockStates.contains(block.defaultBlockState().setValue(BlockStateProperties.AGE_15, hostAge))) {
+//            hostAge++;
+//            if (hostAge > 15) {
+//                throw new IllegalStateException("Tried to generate unused fire host age for block " + block + ", but all possible ages are already in use");
+//            }
+//        }
+//        for (BlockState fireState : block.getStateDefinition().getPossibleStates()) {
+//            if (fireState.getValue(BlockStateProperties.AGE_15) == hostAge) {
+//                usedBlockStates.add(fireState);
+//            }
+//        }
+//        return hostAge;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/BlockReplacementRule.java b/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/BlockReplacementRule.java
new file mode 100644
index 0000000000000000000000000000000000000000..eb069f2015ce2b9dedf1c692565624f7fc9d1c6e
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/BlockReplacementRule.java
@@ -0,0 +1,409 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.block.replacementrule;
+
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
+import nl.martijnmuijsers.paper.block.UsedHostBlockStates;
+import nl.martijnmuijsers.paper.blockanditemdata.model.BlockEntityModelVisualProperties;
+import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelContent;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelCreation;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelParameters;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelWithParameters;
+import nl.martijnmuijsers.paper.blockanditemdata.texture.TextureContent;
+import nl.martijnmuijsers.paper.resourcepack.MutableResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAssetType;
+import nl.martijnmuijsers.paper.resourcepack.asset.blockstates.MutableResourcePackBlockStates;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.MutableResourcePackModel;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.IdentityHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.BiFunction;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * A rule that is fully responsible for exactly 1 real block,
+ * and replaces each of its state with some host (multiple real states may have the same host state when the difference between those real states is not important to be observable) (multiple other replacement rules may use the same hosts),
+ * and replaces each host with some host replacement state that is a good observable alternative to the host state (multiple hosts may have the same host replacement state) (when another replacement rule uses a same host as well, it should have the same host replacement for that host (this is not checked at runtime!))
+ */
+public interface BlockReplacementRule {
+
+    @NotNull Block getReal();
+
+    boolean hasAsReal(@NotNull Block potentialReal);
+
+    boolean isFire();
+
+    boolean rendersAsEntity();
+
+    /**
+     * Contains no duplicates
+     */
+    @NotNull List<@NotNull BlockState> getHosts();
+
+    boolean hasAsHost(@NotNull BlockState potentialHost);
+
+    /**
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     */
+    @NotNull BlockState getHost(@NotNull BlockState realState);
+
+    /**
+     * This method will assume (not verify) that the given state is in fact a host of this rule
+     * <br>
+     * Returns null if @{link #rendersAsEntity} is true
+     */
+    @Nullable BlockState getHostReplacement(@NotNull BlockState host);
+
+    /**
+     * Contains no duplicates
+     */
+    @NotNull List<@NotNull BlockState> getFallbacks();
+
+    /**
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     */
+    @NotNull BlockState getFallback(@NotNull BlockState realState);
+
+    /**
+     * All blocks that serve as a host or fallback, without duplicates
+     */
+    @NotNull List<@NotNull Block> getHostAndFallbackBlocks();
+
+    /**
+     * All blocks that may potentially be observed as another block
+     * <br>
+     * Represented by an iterable of pairs, where each pair holds first a block type that may be presented as something different when sent, and second the block type that can be observed by the user instead of the first block
+     * <br>
+     * Contains no duplicates, and contains no pairs where the first and second element are equal
+     */
+    @NotNull List<@NotNull Pair<@NotNull Block, @NotNull Block>> getPotentialBlockReplacementPairs();
+
+    /**
+     * Returns a replacement state (either real to host, or host to host replacement) for the given state, if this rule is applicable
+     * <br>
+     * Returns null if this rule does not apply to the given state
+     */
+    default @Nullable BlockState replace(@NotNull BlockState state, boolean hasResourcePack) {
+        if (state.is(this.getReal())) {
+            return hasResourcePack ? this.getHost(state) : this.getFallback(state);
+        } else if (hasResourcePack && this.hasAsHost(state)) {
+            if (!this.rendersAsEntity()) {
+                return this.getHostReplacement(state);
+            }
+        }
+        return null;
+    }
+
+    default void writeToStateIdReplacementArrays() {
+        for (@NotNull BlockState realState : this.getReal().getStateDefinition().getPossibleStates()) {
+            int realStateId = Block.BLOCK_STATE_REGISTRY.getId(realState);
+            int hostId = Block.BLOCK_STATE_REGISTRY.getId(this.getHost(realState));
+            int fallbackId = Block.BLOCK_STATE_REGISTRY.getId(this.getFallback(realState));
+            Block.stateIdReplacementArrayWithResourcePack[realStateId] = hostId;
+            Block.stateIdReplacementArrayWithoutResourcePack[realStateId] = fallbackId;
+            Block.addRealStateToPlayerObservableStates(realStateId, hostId);
+            Block.addRealStateToPlayerObservableStates(realStateId, fallbackId);
+        }
+        if (!this.rendersAsEntity()) {
+            for (@NotNull BlockState host : this.getHosts()) {
+                int hostId = Block.BLOCK_STATE_REGISTRY.getId(host);
+                int hostReplacementId = Block.BLOCK_STATE_REGISTRY.getId(this.getHostReplacement(host));
+                Block.stateIdReplacementArrayWithResourcePack[hostId] = hostReplacementId;
+                Block.addRealStateToPlayerObservableStates(hostId, hostReplacementId);
+            }
+        }
+    }
+
+    default void updateMinDestroyTimes() {
+        this.updateMinDestroyTimeOfReal(); // Some will see it as the host, others as the fallback
+        this.updateMinDestroyTimeOfHosts(); // Some may see it as the host replacement
+    }
+
+    default void updateMinDestroyTimeOfReal() {
+        this.getReal().updateDestroyTime(Math.min(
+            this.getReal().properties.destroyTime,
+            this.getMinDestroyTimeOfHostsAndFallbacks()
+        ));
+    }
+
+    default void updateMinDestroyTimeOfHosts() {
+        if (!this.rendersAsEntity()) {
+            for (@NotNull BlockState host : this.getHosts()) {
+                host.getBlock().updateDestroyTime(this.getMinDestroyTimeOfHostAndHostReplacement(host));
+            }
+        }
+    }
+
+    default float getMinDestroyTimeOfHostsAndFallbacks() {
+        return Stream.concat(this.getHosts().stream(), this.getFallbacks().stream()).map(state -> state.getBlock().properties.destroyTime).min(Float::compareTo).get();
+    }
+
+    /**
+     * This method will assume (not verify) that the given state is in fact a host of this rule
+     */
+    default float getMinDestroyTimeOfHostAndHostReplacement(@NotNull BlockState host) {
+        if (this.rendersAsEntity()) {
+            return host.getBlock().properties.destroyTime;
+        }
+        return Math.min(
+            host.getBlock().properties.destroyTime,
+            this.getHostReplacement(host).getBlock().properties.destroyTime
+        );
+    }
+
+    /**
+     * This method will assume (not verify) that the given state is in fact a host of this rule
+     * <br>
+     * This method will be called multiple times, so it should never compute anything twice
+     * <br>
+     * May or may not return null if {@link #rendersAsEntity} is true and the given {@param host} is not the host for the default state of the real block
+     * @throw IllegalStateException If this rule is for fire
+     */
+    @Nullable ModelWithParameters getModel(@NotNull BlockState host);
+
+    @Nullable RealItemReplacementRule getRealItemRule();
+
+    @NotNull List<@NotNull HostItemReplacementRule> getHostItemRules();
+
+    /**
+     * Returns whether this item, when placing it as a block, would place a block state that serves as a host in this replacement rule
+     */
+    boolean isHostPlacingItem(@NotNull Item item);
+
+    /**
+     * Returns all items for which {@link #isHostPlacingItem} is true, without duplicates
+     */
+    @NotNull List<@NotNull Item> getHostPlacingItems();
+
+    /**
+     * Returns the item we would like to replace a host placing item by
+     * <br>
+     * Returns null if the item given is not a host placing item
+     */
+    @Nullable Item getHostPlacingItemReplacement(@NotNull Item item);
+
+    /**
+     * Returns a state of the real block that is representative of the real block (by default, this is the default state of the real block, which should be appropriate in most cases, but we may wish to override it in the future)
+     * <br>
+     * This is currently used as the item model if this real block has a corresponding block item
+     *
+     * @see #getRealItemModel
+     */
+    default @NotNull BlockState getRepresentativeRealState() {
+        return this.getReal().defaultBlockState();
+    }
+
+    /**
+     * Returns the model for the real block item of this block
+     * <br>
+     * Returns null or an arbitrary meaning less value if the real block does not have a corresponding block item
+     */
+    default @Nullable Model getRealItemModel() {
+        return this.getModel(this.getHost(this.getRepresentativeRealState())).model().getReference(ResourcePackAssetIntention.ITEM);
+    }
+
+    /**
+     * Non-null if {@link #rendersAsEntity} is true, null otherwise
+     * <br>
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     */
+    default @Nullable Model getBlockEntityItemModel(@NotNull BlockState realState, @NotNull BlockEntityModelVisualProperties properties) {
+        Model[] models = this.getBlockEntityItemModels(realState);
+        return models[properties.getIndex()];
+    }
+
+    /**
+     * Non-null if {@link #rendersAsEntity} is true, null otherwise
+     * <br>
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     */
+    @NotNull Model @Nullable [] getBlockEntityItemModels(@NotNull BlockState realState);
+
+    /**
+     * Non-null if {@link #rendersAsEntity} is true, null otherwise
+     * <br>
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     */
+    default @NotNull Model @Nullable [] computeBlockEntityItemModels(@NotNull BlockState realState) {
+        var base = this.getBlockEntityItemModelBase(realState);
+        if (base == null) {
+            return null;
+        }
+        return Arrays.stream(BlockEntityModelVisualProperties.values).map(base::getBlockEntityVersion).toArray(Model[]::new);
+    }
+
+    /**
+     * Non-null if {@link #rendersAsEntity} is true, null otherwise
+     * <br>
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     */
+    @Nullable Model getBlockEntityItemModelBase(@NotNull BlockState realState);
+
+    /**
+     * Non-null if {@link #rendersAsEntity} is true, null otherwise
+     * <br>
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     */
+    default @Nullable Integer getBlockEntityItemCustomModelData(@NotNull BlockState realState, @NotNull BlockEntityModelVisualProperties properties) {
+        int[] customModelData = this.getBlockEntityItemCustomModelData(realState);
+        if (customModelData == null) {
+            return null;
+        }
+        return customModelData[properties.getIndex()];
+    }
+
+    /**
+     * Non-null if {@link #rendersAsEntity} is true, null otherwise
+     * <br>
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     */
+    int @Nullable [] getBlockEntityItemCustomModelData(@NotNull BlockState realState);
+
+    /**
+     * Non-null if {@link #rendersAsEntity} is true, null otherwise
+     * <br>
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     */
+    default @Nullable ItemStack getBlockEntityItemStack(@NotNull BlockState realState, @NotNull BlockEntityModelVisualProperties properties) {
+        var itemStack = this.getBlockEntityItemStack(realState);
+        if (itemStack == null) {
+            return null;
+        }
+        return itemStack.getForContext(properties);
+    }
+
+    class BlockEntityItemStack {
+
+        private final @NotNull Function<@NotNull BlockEntityModelVisualProperties, @NotNull ItemStack> forContextFunction;
+
+        /**
+         * Only null while not initialized yet
+         */
+        private @NotNull ItemStack @Nullable [] forContext;
+
+        public @NotNull ItemStack getForContext(@NotNull BlockEntityModelVisualProperties properties) {
+            if (this.forContext == null) {
+                this.forContext = Arrays.stream(BlockEntityModelVisualProperties.values).map(this.forContextFunction).toArray(ItemStack[]::new);
+            }
+            return this.forContext[properties.getIndex()];
+        }
+
+        public BlockEntityItemStack(@NotNull Function<@NotNull BlockEntityModelVisualProperties, @NotNull ItemStack> forContextFunction) {
+            this.forContextFunction = forContextFunction;
+        }
+
+        public BlockEntityItemStack(@NotNull Supplier<@NotNull Item> itemSupplier, @NotNull Function<@NotNull BlockEntityModelVisualProperties, @NotNull Integer> customModelDataForContextFunction) {
+            this(properties -> {
+                ItemStack itemStack = new ItemStack(itemSupplier.get(), 1);
+                itemStack.getOrCreateTag().putInt(CraftMetaItem.CUSTOM_MODEL_DATA.NBT, customModelDataForContextFunction.apply(properties));
+                return itemStack;
+            });
+        }
+
+    }
+
+    /**
+     * Non-null if {@link #rendersAsEntity} is true, null otherwise
+     * <br>
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     */
+    @Nullable BlockEntityItemStack getBlockEntityItemStack(@NotNull BlockState realState);
+
+    default void addBlockEntityItemToResourcePack(@NotNull MutableResourcePack resourcePack) {
+        if (!this.rendersAsEntity()) {
+            return;
+        }
+        @NotNull Item itemHost = Validate.notNull(this.getHost(this.getReal().defaultBlockState()).getBlock().asItem());
+        @NotNull NamespacedKeyWithoutIntention itemHostKey = NamespacedKeyWithoutIntention.forMinecraft(Registry.ITEM.getKey(itemHost));
+        @NotNull MutableResourcePackModel itemHostKeyMinecraftItemModel = resourcePack.getModel(ResourcePackAssetIntention.ITEM, itemHostKey);
+        for (@NotNull BlockState realState : this.getReal().getStateDefinition().getPossibleStates()) {
+            for (@NotNull BlockEntityModelVisualProperties properties : BlockEntityModelVisualProperties.values) {
+                itemHostKeyMinecraftItemModel.addModelOverride(Validate.notNull(this.getBlockEntityItemCustomModelData(realState, properties)), Validate.notNull(this.getBlockEntityItemModel(realState, properties)), resourcePack, false);
+            }
+        }
+    }
+
+    default void addToResourcePack(@NotNull MutableResourcePack resourcePack) {
+        if (this.isFire()) {
+            @NotNull BlockState host = this.getHost(this.getReal().defaultBlockState());
+            // Add the fire blockstates override
+            resourcePack.getAsset(ResourcePackAssetType.BLOCK_STATES, NamespacedKeyWithoutIntention.minecraft("fire").withEmptyIntention(), MutableResourcePackBlockStates.class).addFireModels(host, this.getReal().customFireType);
+            // Add the block models
+            for (int textureVariant = 0; textureVariant <= 1; textureVariant++) {
+                for (@NotNull String modelLocation : new String[] {"floor", "side", "side_alt"}) {
+                    new Model(
+                        ResourcePackAssetIntention.BLOCK,
+                        NamespacedKeyWithoutIntention.sucraft(this.getReal().customFireType + "_fire_" + modelLocation + textureVariant),
+                        ModelContent.Fire.defaultCreation(modelLocation).create(
+                            ResourcePackAssetIntention.BLOCK,
+                            ResourceLocation.sucraft(this.getReal().customFireType + "_fire_" + textureVariant)
+                        )
+                    ).addToResourcePack(resourcePack, false);
+                }
+            }
+            return;
+        }
+        this.addBlockEntityItemToResourcePack(resourcePack);
+        @NotNull List<@NotNull BlockState> hosts = this.getHosts();
+        @NotNull List<@NotNull Block> hostBlocks = hosts.stream().map(BlockState::getBlock).distinct().toList();
+        boolean everyStateOfTheHostBlockHasTheSameModel =
+            hostBlocks.size() == 1 // All host states have the same block
+                && (
+                hostBlocks.get(0).getStateDefinition().getPossibleStates().size() == 1 // The host block has only one state
+                    || (
+                    hostBlocks.get(0).getStateDefinition().getPossibleStates().size() == hosts.size() // All host block states are hosts of this rule
+                        && hosts.stream().map(this::getModel).distinct().count() == 1 && hosts.stream().map(this::getModel).distinct().toList().get(0) != null // All hosts of this rule have the same model
+                )
+            );
+        forEachHostBlock: for (@NotNull Block hostBlock : hostBlocks) {
+            for (@NotNull BlockState hostBlockState : hostBlock.getStateDefinition().getPossibleStates()) {
+                if (!hosts.contains(hostBlockState)) {
+                    continue forEachHostBlock;
+                }
+            }
+            // We now know all host block states are hosts of this rule
+            // We clear any existing variant strings because we know we will be writing all new ones anyway
+            @NotNull NamespacedKeyWithIntention hostKey = NamespacedKeyWithoutIntention.forMinecraft(Registry.BLOCK.getKey(hostBlock)).withEmptyIntention();
+            @NotNull MutableResourcePackBlockStates minecraftBlockStates = resourcePack.getBlockStates(hostKey);
+            minecraftBlockStates.clearVariants();
+        }
+        for (@NotNull BlockState host : hosts) {
+            @NotNull NamespacedKeyWithIntention hostKey = NamespacedKeyWithoutIntention.forMinecraft(Registry.BLOCK.getKey(host.getBlock())).withEmptyIntention();
+            @NotNull MutableResourcePackBlockStates minecraftBlockStates = resourcePack.getBlockStates(hostKey);
+            @Nullable ModelWithParameters model = this.getModel(host);
+            if (!this.rendersAsEntity()) {
+                if (everyStateOfTheHostBlockHasTheSameModel) {
+                    minecraftBlockStates.setNoVariantModel(model, resourcePack, false);
+                } else {
+                    minecraftBlockStates.setModel(host, model, resourcePack, false);
+                }
+            } else if (model != null) {
+                model.model().addToResourcePack(resourcePack, false);
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/BlockReplacementRuleBase.java b/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/BlockReplacementRuleBase.java
new file mode 100644
index 0000000000000000000000000000000000000000..f49ca0f313f34743a2e449c591d7437073a55582
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/BlockReplacementRuleBase.java
@@ -0,0 +1,115 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.block.replacementrule;
+
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.BaseFireBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.FireBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import org.apache.commons.lang3.Validate;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Collections;
+import java.util.IdentityHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+/**
+ * Shared implementation of {@link SingleStateRealBlockReplacementRule} and {@link MultiStateRealBlockReplacementRule}
+ */
+public abstract class BlockReplacementRuleBase implements BlockReplacementRule {
+
+    protected final @NotNull Block real;
+    protected final boolean isFire;
+    protected final @Nullable RealItemReplacementRule realItemRule;
+    protected final boolean rendersAsEntity;
+    protected final @NotNull List<@NotNull HostItemReplacementRule> hostItemRules;
+
+    /**
+     * This is simply a backing field for quickly returning {@link #getHostPlacingItems}
+     * <br>
+     * Is null only when not initialized yet:
+     * late initialization is used so that items are not referenced before block bootstrapping is finished
+     */
+    protected @Nullable List<@NotNull Item> hostPlacingItemList;
+
+    /**
+     * This is simply a backing field for quickly returning {@link #isHostPlacingItem} and {@link #getHostPlacingItemReplacement}
+     * <br>
+     * Is null only when not initialized yet:
+     * late initialization is used so that items are not referenced before block bootstrapping is finished
+     */
+    protected @Nullable Map<@NotNull Item, @NotNull Item> replacementByHostPlacingItem;
+
+    protected BlockReplacementRuleBase(@NotNull Block real, @Nullable RealItemReplacementRule realItemRule, boolean rendersAsEntity, @NotNull List<@NotNull HostItemReplacementRule> hostItemRules) {
+        this.real = real;
+        this.isFire = this.real instanceof BaseFireBlock;
+        this.realItemRule = realItemRule;
+        this.rendersAsEntity = rendersAsEntity;
+        this.hostItemRules = Collections.unmodifiableList(hostItemRules);
+    }
+
+    @Override
+    public @NotNull Block getReal() {
+        return this.real;
+    }
+
+    @Override
+    public boolean hasAsReal(@NotNull Block potentialReal) {
+        return this.real.equals(potentialReal);
+    }
+
+    @Override
+    public boolean isFire() {
+        return this.isFire;
+    }
+
+    @Override
+    public @Nullable RealItemReplacementRule getRealItemRule() {
+        return this.realItemRule;
+    }
+
+    @Override
+    public boolean rendersAsEntity() {
+        return this.rendersAsEntity;
+    }
+
+    @Override
+    public @NotNull List<@NotNull HostItemReplacementRule> getHostItemRules() {
+        return this.hostItemRules;
+    }
+
+    @Override
+    public boolean isHostPlacingItem(@NotNull Item item) {
+        return this.getHostPlacingItemReplacement(item) != null;
+    }
+
+    @Override
+    public @NotNull List<@NotNull Item> getHostPlacingItems() {
+        if (this.hostPlacingItemList == null) {
+            this.hostPlacingItemList = this.getReplacementByHostPlacingItems().keySet().stream().toList();
+        }
+        return this.hostPlacingItemList;
+    }
+
+    private @NotNull Map<@NotNull Item, @NotNull Item> getReplacementByHostPlacingItems() {
+        if (this.replacementByHostPlacingItem == null) {
+            this.replacementByHostPlacingItem = new IdentityHashMap<>(this.hostItemRules.stream().collect(Collectors.toMap(HostItemReplacementRule::getHostPlacingItem, HostItemReplacementRule::getHostPlacingItemReplacement)));
+        }
+        return this.replacementByHostPlacingItem;
+    }
+
+    @Override
+    public @Nullable Item getHostPlacingItemReplacement(@Nullable Item item) {
+        return this.getReplacementByHostPlacingItems().get(item);
+    }
+
+    protected @NotNull BlockEntityItemStack computeBlockEntityItemStack(@NotNull BlockState realState) {
+        @NotNull Item item = Validate.notNull(this.getHost(this.real.defaultBlockState()).getBlock().asItem());
+        return new BlockEntityItemStack(() -> item, properties -> this.getBlockEntityItemCustomModelData(realState, properties));
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/BlockReplacementRuleBuilder.java b/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/BlockReplacementRuleBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..7189a0f1eae94ef88b661a0c243af8433aa9237d
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/BlockReplacementRuleBuilder.java
@@ -0,0 +1,515 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.block.replacementrule;
+
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.core.Direction;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.BaseFireBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.FireBlock;
+import net.minecraft.world.level.block.StairBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import net.minecraft.world.level.block.state.properties.SlabType;
+import net.minecraft.world.level.block.state.properties.StairsShape;
+import nl.martijnmuijsers.paper.block.UsedHostBlockStates;
+import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelContent;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelCreation;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelCreationWithParameters;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelParameters;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelWithParameters;
+import nl.martijnmuijsers.paper.blockanditemdata.texture.Texture;
+import nl.martijnmuijsers.paper.blockanditemdata.texture.TextureContent;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.IdentityHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.function.Supplier;
+
+public interface BlockReplacementRuleBuilder<R extends BlockReplacementRule, B extends BlockReplacementRuleBuilder<R, B>> {
+
+    @NotNull B withReal(@NotNull Block real);
+
+    @NotNull B rendersAsEntity();
+
+    /**
+     * One host for all real block states
+     */
+    @NotNull B withHost(@NotNull BlockState host);
+
+    /**
+     * One host for all real block states
+     * <br>
+     * (Takes the default state of the given block)
+     */
+    default @NotNull B withHost(@NotNull Block hostBlock) {
+        return this.withHost(hostBlock.defaultBlockState());
+    }
+
+    /**
+     * Sets the output of the given function as the host for a given real block state,
+     * but takes the host for that real block state already existing in this builder if the function returns null
+     */
+    @NotNull B withHostForRealState(@NotNull Function<@NotNull BlockState, @Nullable BlockState> hostForRealState);
+
+    /**
+     * One host for all real block states: the same one as the given rule
+     */
+    default @NotNull B withHostSameAs(@NotNull SingleStateRealBlockReplacementRule singleStateReplacementRule) {
+        return this.withHost(singleStateReplacementRule.getHost());
+    }
+
+    /**
+     * Sets the hosts based automatically on the real state's properties, assuming the properties of the real block and the host block are exactly the same (for example, both are slabs, or both are leaves)
+     */
+    default @NotNull B withAnalogousHosts(@NotNull Block hostBlock) {
+        return this.withHostForRealState(hostBlock::withPropertiesOf);
+    }
+
+    /**
+     * One host replacement for all hosts
+     */
+    @NotNull B withHostReplacement(@NotNull BlockState hostReplacement);
+
+    /**
+     * One host replacement for all hosts
+     * <br>
+     * (Takes the default state of the given block)
+     */
+    default @NotNull B withHostReplacement(@NotNull Block hostReplacementBlock) {
+        return this.withHostReplacement(hostReplacementBlock.defaultBlockState());
+    }
+
+    /**
+     * Sets the output of the given function as the host replacement for a given host,
+     * but takes the host replacement for that host already existing in this builder if the function returns null
+     */
+    @NotNull B withHostReplacementForHost(@NotNull Function<@NotNull BlockState, @Nullable BlockState> hostReplacementForHost);
+
+    /**
+     * One host replacement for all hosts: the same one as the given rule
+     */
+    default @NotNull B withHostReplacementSameAs(@NotNull SingleStateRealBlockReplacementRule singleStateReplacementRule) {
+        return this.withHostReplacement(singleStateReplacementRule.getHostReplacement());
+    }
+
+    /**
+     * Sets the hosts and their host replacements based automatically on the real state's properties, assuming the properties of the real block, the host block and the host replacement block are exactly the same (for example, all three are slabs)
+     */
+    default @NotNull B withAnalogousHosts(@NotNull Block hostBlock, @NotNull Block hostReplacementBlock) {
+        return this.withAnalogousHosts(hostBlock).withHostReplacementForHost(hostReplacementBlock::withPropertiesOf);
+    }
+
+    /**
+     * Sets the host and host replacement based automatically on the next unused state out of the given states
+     */
+    default @NotNull B withNextUnusedStateAsHost(@NotNull List<@NotNull BlockState> possibleBlockStates) {
+        @NotNull Pair<@NotNull BlockState, @NotNull BlockState> hostAndHostReplacement = UsedHostBlockStates.generateUnusedHostAndReplacement(possibleBlockStates);
+        return this.withHost(hostAndHostReplacement.left())
+            .withHostReplacement(hostAndHostReplacement.right());
+    }
+
+    /**
+     * Sets a single host and host replacement based automatically on the next unused state of the given block
+     */
+    default @NotNull B withNextUnusedStateOfHostBlock(@NotNull Block hostBlock) {
+        @NotNull Pair<@NotNull BlockState, @NotNull BlockState> hostAndHostReplacement = UsedHostBlockStates.generateUnusedHostAndReplacement(hostBlock);
+        return this.withHost(hostAndHostReplacement.left())
+            .withHostReplacement(hostAndHostReplacement.right());
+    }
+
+    /**
+     * Sets a single host and host replacement based automatically on the next unused note block state
+     */
+    default @NotNull B withNoteBlockHost() {
+        return this.withNextUnusedStateOfHostBlock(Blocks.NOTE_BLOCK);
+    }
+
+    /**
+     * Sets a host and host replacement for each real block state based automatically on the next unused state of the given block
+     */
+    default @NotNull B withNextUnusedStatesOfHostBlock(@NotNull Block hostBlock) {
+        @NotNull Map<@NotNull BlockState, @NotNull BlockState> hostByRealState = new IdentityHashMap<>();
+        @NotNull Map<@NotNull BlockState, @NotNull BlockState> hostReplacementByHost = new IdentityHashMap<>();
+        return this.withHostForRealState(realState -> {
+            if (hostByRealState.isEmpty()) {
+                for (@NotNull BlockState someRealState : realState.getBlock().getStateDefinition().getPossibleStates()) {
+                    @NotNull Pair<@NotNull BlockState, @NotNull BlockState> hostAndHostReplacement = UsedHostBlockStates.generateUnusedHostAndReplacement(hostBlock);
+                    hostByRealState.put(someRealState, hostAndHostReplacement.left());
+                    hostReplacementByHost.put(hostAndHostReplacement.left(), hostAndHostReplacement.right());
+                }
+            }
+            return hostByRealState.get(realState);
+        }).withHostReplacementForHost(host -> {
+            if (hostReplacementByHost.isEmpty()) {
+                throw new IllegalStateException("Host for real state function should be called before host replacement for host function, when using automatically generated unused state of a host block for a multi-state real block");
+            }
+            return hostReplacementByHost.get(host);
+        });
+    }
+
+    /**
+     * Sets a host and host replacement for each real block state based automatically on the next unused note block state
+     */
+    default @NotNull B withNoteBlockHosts() {
+        return this.withNextUnusedStatesOfHostBlock(Blocks.NOTE_BLOCK);
+    }
+
+    /**
+     * Takes an unused state of the host block that is not waterlogged, and sets it as the host for all real block states that are not waterlogged,
+     * and takes an unused state of the host block that is waterlogged, and sets it as the host for all real block states that are waterlogged,
+     * and also sets the host replacements appropriately
+     */
+    default @NotNull B withOneNonWaterLoggedAndOneWaterLoggedHost(@NotNull Block hostBlock) {
+        @NotNull List<@NotNull BlockState> hostBlockStates = hostBlock.getStateDefinition().getPossibleStates();
+        @NotNull List<@NotNull BlockState> nonWaterloggedHostBlockStates = hostBlockStates.stream().filter(potentialHost -> !potentialHost.getValue(BlockStateProperties.WATERLOGGED)).toList();
+        @NotNull List<@NotNull BlockState> waterloggedHostBlockStates = hostBlockStates.stream().filter(potentialHost -> potentialHost.getValue(BlockStateProperties.WATERLOGGED)).toList();
+        @NotNull Pair<@NotNull BlockState, @NotNull BlockState> nonWaterloggedHostAndReplacement = UsedHostBlockStates.generateUnusedHostAndReplacement(nonWaterloggedHostBlockStates);
+        @NotNull Pair<@NotNull BlockState, @NotNull BlockState> waterloggedHostAndReplacement = UsedHostBlockStates.generateUnusedHostAndReplacement(waterloggedHostBlockStates);
+        return this
+            .withHostForRealState(realState -> (realState.getValue(BlockStateProperties.WATERLOGGED) ? waterloggedHostAndReplacement : nonWaterloggedHostAndReplacement).left())
+            .withHostReplacementForHost(host -> {
+                if (host.equals(nonWaterloggedHostAndReplacement.left())) {
+                    return nonWaterloggedHostAndReplacement.right();
+                } else if (host.equals(waterloggedHostAndReplacement.left())) {
+                    return waterloggedHostAndReplacement.right();
+                }
+                return null;
+            });
+    }
+
+    /**
+     * Takes an unused state of the host block for every combination of east, north, south, up and west (only disregarding age),
+     * and sets the host replacements to remove the age information of the host
+     */
+    default @NotNull B withFireHost() {
+        BlockState hostToUse = UsedHostBlockStates.generateUnusedFireState();
+        return this
+            .withHostForRealState(realState -> hostToUse)
+            .withHostReplacementForHost(host -> {
+                if (host.getValue(BlockStateProperties.AGE_15) > 0) {
+                    return Blocks.FIRE.withPropertiesOf(host).setValue(BlockStateProperties.AGE_15, 0);
+                }
+                return null;
+            });
+    }
+
+    /**
+     * One fallback for all real block states
+     */
+    @NotNull B withFallback(@NotNull BlockState fallback);
+
+    /**
+     * One fallback for all real block states
+     * <br>
+     * (Takes the default state of the given block)
+     */
+    default @NotNull B withFallback(@NotNull Block fallbackBlock) {
+        return this.withFallback(fallbackBlock.defaultBlockState());
+    }
+
+    /**
+     * Sets the output of the given function as the fallback for a given real block state,
+     * but takes the fallback for that real block state already existing in this builder if the function returns null
+     */
+    @NotNull B withFallbackForRealState(@NotNull Function<@NotNull BlockState, @Nullable BlockState> fallbackForRealState);
+
+    /**
+     * One fallback for all real block states: the same one as the given rule
+     */
+    default @NotNull B withFallbackSameAs(@NotNull SingleStateRealBlockReplacementRule singleStateReplacementRule) {
+        return this.withFallback(singleStateReplacementRule.getFallback());
+    }
+
+    /**
+     * Sets the fallbacks based automatically on the real state's properties, assuming the properties of the real block and the fallback block are exactly the same (for example, both are slabs, or both are leaves)
+     */
+    default @NotNull B withAnalogousFallbacks(@NotNull Block fallbackBlock) {
+        return this.withFallbackForRealState(fallbackBlock::withPropertiesOf);
+    }
+
+    /**
+     * Sets a pillar fallback based on the directional state of this real block
+     */
+    default @NotNull B withDirectionalAnalogousPillarFallbacks(@NotNull Block fallbackBlock) {
+        return this.withFallbackForRealState(realState -> fallbackBlock.defaultBlockState().setValue(BlockStateProperties.AXIS, switch (realState.getValue(BlockStateProperties.FACING)) {
+            case NORTH, SOUTH -> Direction.Axis.Z;
+            case EAST, WEST -> Direction.Axis.X;
+            case UP, DOWN -> Direction.Axis.Y;
+        }));
+    }
+
+    /**
+     * One host overriding model for all real states
+     */
+    @NotNull B withModel(@NotNull ModelWithParameters model);
+
+    /**
+     * Sets the output of the given function as the host overriding model for a given real state,
+     * but takes the host overriding model for that real state already existing in this builder if the function returns null
+     */
+    @NotNull B withModelForRealState(@NotNull Function<@NotNull BlockState, @Nullable ModelWithParameters> modelForRealState);
+
+    /**
+     * One host overriding model for all real states
+     */
+    @NotNull B withModelCreation(@NotNull ModelCreationWithParameters modelCreation);
+
+    /**
+     * Sets the output of the given function as the host overriding model for a given real state,
+     * but takes the host overriding model for that real state already existing in this builder if the function returns null
+     */
+    @NotNull B withModelCreationForRealState(@NotNull Function<@NotNull BlockState, @Nullable ModelCreationWithParameters> modelCreationForRealState);
+
+    /**
+     * One host overriding model for all real states: the same one as the given rule
+     */
+    default @NotNull B withModelSameAs(@NotNull SingleStateRealBlockReplacementRule singleStateReplacementRule) {
+        return this.withModel(singleStateReplacementRule.getModel());
+    }
+
+    /**
+     * Sets the host overriding models to a model with parameters specifically for a rotated pillar block, using the default texture names
+     */
+    default @NotNull B withDefaultModelCreationsForRotatedPillarBlock() {
+        @NotNull ModelCreation vertical = Model.YPillarCube.defaultCreation();
+        @NotNull ModelCreation horizontal = Model.HorizontalYPillarCube.defaultCreation();
+        @NotNull ModelCreationWithParameters xAxisModel = horizontal.withParameters(new ModelParameters(json -> {
+            json.addProperty("x", 90);
+            json.addProperty("y", 90);
+        }));
+        @NotNull ModelCreationWithParameters yAxisModel = vertical.withNoParameters();
+        @NotNull ModelCreationWithParameters zAxisModel = horizontal.withParameters(new ModelParameters(json -> json.addProperty("x", 90)));
+        return this.withModelCreationForRealState(realState ->
+            switch (realState.getValue(BlockStateProperties.AXIS)) {
+                case X -> xAxisModel;
+                case Y -> yAxisModel;
+                case Z -> zAxisModel;
+            }
+        );
+    }
+
+    /**
+     * Sets the host overriding models to a model with parameters specifically for a directional block (that can face any of the 6 orthogonal directions), using the default texture names
+     */
+    default @NotNull B withDefaultModelCreationsForDirectionalBlock() {
+        @NotNull ModelCreation vertical = Model.YPillarCube.defaultCreation();
+        @NotNull ModelCreationWithParameters facingDownModel = vertical.withNoParameters();
+        @NotNull ModelCreationWithParameters facingEastModel = vertical.withParameters(new ModelParameters(json -> {
+            json.addProperty("x", 270);
+            json.addProperty("y", 90);
+        }));
+        @NotNull ModelCreationWithParameters facingNorthModel = vertical.withParameters(new ModelParameters(json -> json.addProperty("x", 270)));
+        @NotNull ModelCreationWithParameters facingSouthModel = vertical.withParameters(new ModelParameters(json -> {
+            json.addProperty("x", 270);
+            json.addProperty("y", 180);
+        }));
+        @NotNull ModelCreationWithParameters facingUpModel = vertical.withParameters(new ModelParameters(json -> {
+            json.addProperty("x", 180);
+            json.addProperty("y", 180);
+        }));
+        @NotNull ModelCreationWithParameters facingWestModel = vertical.withParameters(new ModelParameters(json -> {
+            json.addProperty("x", 270);
+            json.addProperty("y", 270);
+        }));
+        return this.withModelCreationForRealState(realState ->
+            switch (realState.getValue(BlockStateProperties.FACING)) {
+                case DOWN -> facingDownModel;
+                case EAST -> facingEastModel;
+                case NORTH -> facingNorthModel;
+                case SOUTH -> facingSouthModel;
+                case UP -> facingUpModel;
+                case WEST -> facingWestModel;
+            }
+        );
+    }
+
+    /**
+     * @param fullBlockTextureAndModelKey A key pointing to the full block texture (used as texture basis for the top and bottom slabs), and also pointing to the full block model (used directly as the model for the double slab)
+     * @see #withDefaultModelCreationsForSlabReplacedBySlab
+     */
+    default @NotNull B withDefaultModelCreationsForSlabReplacedBySlab(@NotNull NamespacedKeyWithoutIntention fullBlockTextureAndModelKey, @NotNull ModelContent.Existing.ExistingModelContentOutwardExpansionType doubleSlabExistingModelContentOutwardExpansionType) {
+        return this.withDefaultModelCreationsForSlabReplacedBySlab((intention, key) -> new Model(ResourcePackAssetIntention.BLOCK, fullBlockTextureAndModelKey, ModelContent.Existing.getInstance(doubleSlabExistingModelContentOutwardExpansionType)), new Texture(ResourcePackAssetIntention.BLOCK, fullBlockTextureAndModelKey, TextureContent.Existing.getInstance()), null, null, null, null);
+    }
+
+    /**
+     * Set a single host overriding model for the host block, that as a single model encapsulates a slab: the mechanism for this is provided by the parent model alread)
+     *
+     * @param sideTexture             A texture of a block that will be used as the texture of this slab (the mechanism for this is provided by the parent model already)
+     * @param bottomHalfBottomTexture Will be {@param sideTexture} if null
+     * @param bottomHalfTopTexture    Will be {@param bottomHalfBottomTexture} if null
+     * @param topHalfBottomTexture    Will be {@param bottomHalfTopTexture} if null
+     * @param topHalfTopTexture       Will be {@param bottomHalfBottomTexture} if null
+     */
+    default @NotNull B withDefaultModelCreationsForSlabReplacedBySlab(@NotNull ModelCreation doubleSlabModelCreation, @NotNull Texture sideTexture, @Nullable Texture bottomHalfBottomTexture, @Nullable Texture bottomHalfTopTexture, @Nullable Texture topHalfBottomTexture, @Nullable Texture topHalfTopTexture) {
+        if (bottomHalfBottomTexture == null) {
+            bottomHalfBottomTexture = sideTexture;
+        }
+        if (bottomHalfTopTexture == null) {
+            bottomHalfTopTexture = bottomHalfBottomTexture;
+        }
+        if (topHalfBottomTexture == null) {
+            topHalfBottomTexture = bottomHalfTopTexture;
+        }
+        if (topHalfTopTexture == null) {
+            topHalfTopTexture = bottomHalfBottomTexture;
+        }
+        final @NotNull Texture finalBottomHalfBottomTexture = bottomHalfBottomTexture;
+        final @NotNull Texture finalBottomHalfTopTexture = bottomHalfTopTexture;
+        final @NotNull Texture finalTopHalfBottomTexture = topHalfBottomTexture;
+        final @NotNull Texture finalTopHalfTopTexture = topHalfTopTexture;
+        return this.withModelCreationForRealState(realState ->
+            switch (realState.getValue(BlockStateProperties.SLAB_TYPE)) {
+//                case BOTTOM, DOUBLE, TOP -> {
+//                    return ((ModelCreation) (intention, key) -> {
+//                        System.out.println("Creating model for intention and key: " + intention + " and " + key);
+//                        var toReturn = Model.creation(ModelContent.BottomSlab.creationCompanion.creation(finalBottomHalfBottomTexture, sideTexture, finalBottomHalfTopTexture)).create(intention, key);
+//                        System.out.println("Got: " + toReturn.getKeyWithIntention());
+//                        var modelCreation = (ModelContent.BottomSlab) ModelContent.BottomSlab.creationCompanion.creation(finalBottomHalfBottomTexture, sideTexture, finalBottomHalfTopTexture).create(intention, key);
+//                        System.out.println("Based on content: " + modelCreation.bottomTexture.getKeyWithIntention() + " , " + modelCreation.sideTexture.getKeyWithIntention() + " , " + modelCreation.topTexture.getKeyWithIntention());
+//                        return toReturn;
+//                    }).withNoParameters();
+//                }
+                case BOTTOM ->
+                    Model.creation(ModelContent.BottomSlab.creationCompanion.creation(finalBottomHalfBottomTexture, sideTexture, finalBottomHalfTopTexture)).withNoParameters();
+                case DOUBLE ->
+                    doubleSlabModelCreation.withNoParameters();
+                case TOP ->
+                    ((ModelCreation) (intention, key) -> Model.creation(ModelContent.TopSlab.creationCompanion.creation(finalTopHalfBottomTexture, sideTexture, finalTopHalfTopTexture)).create(intention, key.withPathSuffix("_top"))).withNoParameters();
+                default ->
+                    throw new IllegalStateException("Unknown slab type: " + realState.getValue(BlockStateProperties.SLAB_TYPE));
+            }
+        );
+    }
+
+    /**
+     * @param fullBlockTextureKey A key pointing to the full block texture (used as texture basis for the stairs)
+     * @see #withDefaultModelCreationsForStairsReplacedByStairs
+     */
+    default @NotNull B withDefaultModelCreationsForStairsReplacedByStairs(@NotNull NamespacedKeyWithoutIntention fullBlockTextureKey) {
+        return this.withDefaultModelCreationsForStairsReplacedByStairs(new Texture(ResourcePackAssetIntention.BLOCK, fullBlockTextureKey, TextureContent.Existing.getInstance()), null, null);
+    }
+
+    /**
+     * Set a single host overriding model for the host block, that as a single model encapsulates stairs: the mechanism for this is provided by the parent model already
+     *
+     * @param sideTexture             A texture of a block that will be used as the texture of these stairs (the mechanism for this is provided by the parent model already)
+     * @param bottomTexture Will be {@param sideTexture} if null
+     * @param topTexture    Will be {@param bottomTexture} if null
+     */
+    default @NotNull B withDefaultModelCreationsForStairsReplacedByStairs(@NotNull Texture sideTexture, @Nullable Texture bottomTexture, @Nullable Texture topTexture) {
+        if (bottomTexture == null) {
+            bottomTexture = sideTexture;
+        }
+        if (topTexture == null) {
+            topTexture = bottomTexture;
+        }
+        final @NotNull Texture finalBottomTexture = bottomTexture;
+        final @NotNull Texture finalTopTexture = topTexture;
+        return this.withModelCreationForRealState(realState -> {
+
+            var shape = realState.getValue(StairBlock.SHAPE);
+            var half = realState.getValue(StairBlock.HALF);
+            var facing = realState.getValue(StairBlock.FACING);
+
+            // Outer stairs look the same as a different direction of inner stairs, so we create only a model for inner stairs, and replace the outer stairs by the right inner stairs
+            if (shape == StairsShape.INNER_RIGHT || shape == StairsShape.OUTER_RIGHT) {
+                shape = shape == StairsShape.INNER_RIGHT ? StairsShape.INNER_LEFT : StairsShape.OUTER_LEFT;
+            } else if (shape == StairsShape.INNER_LEFT || shape == StairsShape.OUTER_LEFT) {
+                facing = switch (facing) {
+                    case NORTH -> Direction.WEST;
+                    case WEST -> Direction.SOUTH;
+                    case EAST -> Direction.NORTH;
+                    case SOUTH -> Direction.EAST;
+                    case DOWN, UP -> throw new IllegalStateException("Illegal stairs direction: " + facing);
+                };
+            }
+
+            String stateSuffix = "_" + switch (shape) {
+                case STRAIGHT -> "a";
+                case INNER_LEFT -> "i";
+                case OUTER_LEFT -> "o";
+                case INNER_RIGHT, OUTER_RIGHT -> throw new IllegalStateException("Shape without model: " + shape);
+            } + switch (half) {
+                case TOP -> "t";
+                case BOTTOM -> "b";
+            } + switch (facing) {
+                case NORTH -> "n";
+                case WEST -> "w";
+                case EAST -> "e";
+                case SOUTH -> "s";
+                case DOWN, UP -> throw new IllegalStateException("Illegal stairs direction: " + facing);
+            };
+            final var finalFacing = facing;
+            final var creationCompanion = switch (shape) {
+                case STRAIGHT ->
+                    ModelContent.StraightStairs.creationCompanion;
+                case INNER_LEFT ->
+                    ModelContent.InnerLeftStairs.creationCompanion;
+                case OUTER_LEFT ->
+                    ModelContent.OuterLeftStairs.creationCompanion;
+                default ->
+                    throw new IllegalStateException("Unknown or illegal stairs shape: " + realState.getValue(BlockStateProperties.STAIRS_SHAPE));
+            };
+            return ((ModelCreation) (intention, key) -> Model.creation(creationCompanion.creation(finalBottomTexture, sideTexture, finalTopTexture, half, finalFacing)).create(intention, key.withPathSuffix(stateSuffix))).withNoParameters();
+
+        });
+    }
+
+    /**
+     * Sets the given real item rule as the real item rule of this builder
+     */
+    @NotNull B withRealItemRule(@NotNull RealItemReplacementRule realItemRule);
+
+    /**
+     * Removes the real item rule of this builder
+     */
+    @NotNull B withoutRealItemRule();
+
+    /**
+     * Sets the given real item rule of this builder to a rule for a full block bounding,
+     * with the high ping host being as given,
+     * and with the fallback being the item form of the fallback's block for the real block's default state
+     */
+    @NotNull B withFullBlockBoundingBoxItem(@NotNull Supplier<@NotNull Item> highPingHostSupplier);
+
+    /**
+     * Sets the given real item rule of this builder to a rule for a full block bounding,
+     * with the fallback being the item form of the fallback's block for the real block's default state,
+     * and with the high ping host being the same as the fallback
+     */
+    @NotNull B withFullBlockBoundingBoxItem();
+
+    /**
+     * Sets the given real item rule of this builder to a rule with the fallback being the item form of the fallback's block for the real block's default state,
+     * and with the low and high ping host being the item form of the host's block for the real block's default state
+     */
+    @NotNull B withRealItemRuleFromHostBlock();
+
+    /**
+     * Adds the given host item rule to the host item rules in this builder
+     */
+    @NotNull B withHostItemRule(@NotNull HostItemReplacementRule hostItemRule);
+
+    /**
+     * Resmoves all host item rules of this builder
+     */
+    @NotNull B withoutHostItemRules();
+
+    /**
+     * Adds a host item rule for when the item form of the block of the real block's default state's host would place it, and the item form of that host's replacement's block is a good replacement for the host item
+     */
+    @NotNull B withHostItemRuleFromHostBlockAndHostReplacementBlock();
+
+    @NotNull R build();
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/HostItemReplacementRule.java b/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/HostItemReplacementRule.java
new file mode 100644
index 0000000000000000000000000000000000000000..a25b1d9970f82b6d7085b977e29f83e53202763d
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/HostItemReplacementRule.java
@@ -0,0 +1,64 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.block.replacementrule;
+
+import net.minecraft.world.item.Item;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.function.Supplier;
+
+/**
+ * Potentially, if a directly placeable state (using a block item) of a block is used a host, its item form, if any, possibly multiple, may also need to be replaced (but only for players with the resource pack of course, since this is only relevant to hosts - not a fallbacks)
+ * <br>
+ * This class is not (and does not need to be) aware of the host it concerns
+ * <br>
+ * This class uses late initialization internally so that items are not referenced before block bootstrapping is finished
+ */
+public class HostItemReplacementRule {
+
+    private final @NotNull Supplier<@NotNull Item> hostPlacingItemSupplier;
+    private final @NotNull Supplier<@NotNull Item> hostPlacingItemReplacementSupplier;
+
+    /**
+     * The block item of the host block, that would place the host state if used
+     * <br>
+     * Is null only when not initialized yet
+     * @see #hostPlacingItemSupplier
+     */
+    private @Nullable Item hostPlacingItem;
+
+    /**
+     * The item we would like to replace the {@link #hostPlacingItem} by
+     * <br>
+     * Is null only when not initialized yet
+     * @see #hostPlacingItemReplacementSupplier
+     */
+    private @Nullable Item hostPlacingItemReplacement;
+
+    public HostItemReplacementRule(@NotNull Supplier<@NotNull Item> hostPlacingItemSupplier, @NotNull Supplier<@NotNull Item> hostPlacingItemReplacementSupplier) {
+        this.hostPlacingItemSupplier = hostPlacingItemSupplier;
+        this.hostPlacingItemReplacementSupplier = hostPlacingItemReplacementSupplier;
+    }
+
+    /**
+     * This must not be called before all block bootstrapping has finished
+     */
+    public @NotNull Item getHostPlacingItem() {
+        if (this.hostPlacingItem == null) {
+            this.hostPlacingItem = this.hostPlacingItemSupplier.get();
+        }
+        return this.hostPlacingItem;
+    }
+
+    /**
+     * This must not be called before all block bootstrapping has finished
+     */
+    public @NotNull Item getHostPlacingItemReplacement() {
+        if (this.hostPlacingItemReplacement == null) {
+            this.hostPlacingItemReplacement = this.hostPlacingItemReplacementSupplier.get();
+        }
+        return this.hostPlacingItemReplacement;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/MultiStateRealBlockReplacementRule.java b/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/MultiStateRealBlockReplacementRule.java
new file mode 100644
index 0000000000000000000000000000000000000000..461675bc134a1704d541ac110f996d60ea6093c3
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/MultiStateRealBlockReplacementRule.java
@@ -0,0 +1,198 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.block.replacementrule;
+
+import com.google.common.collect.Streams;
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.BlockState;
+import nl.martijnmuijsers.paper.blockanditemdata.model.BlockEntityModelVisualProperties;
+import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelWithParameters;
+import nl.martijnmuijsers.paper.item.UsedHostCustomModelData;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Collections;
+import java.util.IdentityHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class MultiStateRealBlockReplacementRule extends BlockReplacementRuleBase {
+
+    private final @NotNull List<@NotNull BlockState> hostList;
+
+    /**
+     * This is simply a backing field for quickly returning {@link #hasAsHost}
+     */
+    private final @NotNull Set<@NotNull BlockState> hostSet;
+
+    private final @NotNull Map<@NotNull BlockState, @NotNull BlockState> hostPerRealState;
+    private final @NotNull Map<@NotNull BlockState, @NotNull BlockState> hostReplacementPerHost;
+    private final @NotNull List<@NotNull BlockState> fallbackList;
+    private final @NotNull Map<@NotNull BlockState, @NotNull BlockState> fallbackPerRealState;
+
+    /**
+     * This is simply a backing field for quickly returning {@link #getHostAndFallbackBlocks}
+     */
+    private final @NotNull List<@NotNull Block> hostAndFallbackBlocks;
+
+    /**
+     * This is simply a backing field for quickly returning {@link #getPotentialBlockReplacementPairs}
+     */
+    private final @NotNull List<@NotNull Pair<@NotNull Block, @NotNull Block>> potentialBlockReplacementPairs;
+
+    private final @NotNull Map<@NotNull BlockState, @NotNull ModelWithParameters> modelPerHost;
+
+    private final @Nullable Map<@NotNull BlockState, @NotNull Model> blockEntityItemModelBasePerRealState;
+
+    /**
+     * Is at least null when not initialized yet:
+     * late initialization is used so that items are not referenced before block bootstrapping is finished
+     */
+    private @Nullable Map<@NotNull BlockState, @NotNull Model @NotNull []> blockEntityItemModelsPerRealState;
+
+    /**
+     * Is at least null when not initialized yet:
+     * late initialization is used so that items are not referenced before block bootstrapping is finished
+     */
+    private @Nullable Map<@NotNull BlockState, int @NotNull []> blockEntityItemCustomModelDataPerRealState;
+
+    /**
+     * Is at least null when not initialized yet:
+     * late initialization is used so that items are not referenced before block bootstrapping is finished
+     */
+    private @Nullable Map<@NotNull BlockState, @NotNull BlockEntityItemStack> blockEntityItemStackPerRealState;
+
+    public MultiStateRealBlockReplacementRule(@NotNull Block real, @Nullable RealItemReplacementRule realItemRule, boolean rendersAsEntity, @NotNull List<@NotNull BlockState> hosts, @NotNull Map<@NotNull BlockState, @NotNull BlockState> hostPerRealState, @NotNull Map<@NotNull BlockState, @NotNull BlockState> hostReplacementPerHost, @NotNull List<@NotNull BlockState> fallbacks, @NotNull Map<@NotNull BlockState, @NotNull BlockState> fallbackPerRealState, @NotNull Map<@NotNull BlockState, @NotNull ModelWithParameters> modelPerHost, List<@NotNull HostItemReplacementRule> hostItemRules, @Nullable Map<@NotNull BlockState, @NotNull Model> blockEntityItemModelBasePerRealState) {
+        super(real, realItemRule, rendersAsEntity, hostItemRules);
+        this.hostSet = Collections.newSetFromMap(new IdentityHashMap<>());
+        this.hostSet.addAll(hosts);
+        this.hostList = List.copyOf(hosts);
+        this.hostPerRealState = new IdentityHashMap<>(hostPerRealState);
+        this.hostReplacementPerHost = new IdentityHashMap<>(hostReplacementPerHost);
+        this.fallbackList = fallbacks;
+        this.fallbackPerRealState = new IdentityHashMap<>(fallbackPerRealState);
+        this.hostAndFallbackBlocks = Stream.of(this.hostList, this.fallbackList).flatMap(List::stream).map(BlockState::getBlock).distinct().toList();
+        this.potentialBlockReplacementPairs = Stream.of(this.hostPerRealState, this.hostReplacementPerHost, this.fallbackPerRealState)
+            .flatMap(map -> map.entrySet().stream().map(entry -> Pair.of(entry.getKey().getBlock(), entry.getValue().getBlock())))
+            .filter(pair -> !pair.left().equals(pair.right()))
+            .distinct()
+            .toList();
+        this.modelPerHost = new IdentityHashMap<>(modelPerHost);
+        this.blockEntityItemModelBasePerRealState = blockEntityItemModelBasePerRealState;
+    }
+
+    @Override
+    public @NotNull List<@NotNull BlockState> getHosts() {
+        return this.hostList;
+    }
+
+    @Override
+    public boolean hasAsHost(@NotNull BlockState potentialHost) {
+        return this.hostSet.contains(potentialHost);
+    }
+
+    @Override
+    public @NotNull BlockState getHost(@NotNull BlockState realState) {
+        return this.hostPerRealState.get(realState);
+    }
+
+    @Override
+    public @NotNull BlockState getHostReplacement(@NotNull BlockState host) {
+        return this.hostReplacementPerHost.get(host);
+    }
+
+    @Override
+    public @NotNull List<@NotNull BlockState> getFallbacks() {
+        return this.fallbackList;
+    }
+
+    @Override
+    public @NotNull BlockState getFallback(@NotNull BlockState realState) {
+        return this.fallbackPerRealState.get(realState);
+    }
+
+    @Override
+    public @NotNull List<@NotNull Block> getHostAndFallbackBlocks() {
+        return this.hostAndFallbackBlocks;
+    }
+
+    @Override
+    public @NotNull List<@NotNull Pair<@NotNull Block, @NotNull Block>> getPotentialBlockReplacementPairs() {
+        return this.potentialBlockReplacementPairs;
+    }
+
+    @Override
+    public @Nullable ModelWithParameters getModel(@NotNull BlockState host) {
+        if (this.isFire) {
+            throw new IllegalStateException("Cannot call BlockReplacementRule.getModel for fire");
+        }
+        return this.modelPerHost.get(host);
+    }
+
+    @Override
+    public @Nullable Model getBlockEntityItemModelBase(@NotNull BlockState realState) {
+        return this.blockEntityItemModelBasePerRealState == null ? null : blockEntityItemModelBasePerRealState.get(realState);
+    }
+
+    @Override
+    public @NotNull Model @Nullable [] getBlockEntityItemModels(@NotNull BlockState realState) {
+        if (this.blockEntityItemModelsPerRealState == null) {
+            if (this.rendersAsEntity) {
+                this.blockEntityItemModelsPerRealState = new IdentityHashMap<>(0);
+                for (@NotNull BlockState possibleRealState : this.getReal().getStateDefinition().getPossibleStates()) {
+                    this.blockEntityItemModelsPerRealState.put(possibleRealState, this.computeBlockEntityItemModels(possibleRealState));
+                }
+            } else {
+                return null;
+            }
+        }
+        return this.blockEntityItemModelsPerRealState.get(realState);
+    }
+
+    @Override
+    public int @Nullable [] getBlockEntityItemCustomModelData(@NotNull BlockState realState) {
+        if (this.blockEntityItemCustomModelDataPerRealState == null) {
+            if (this.rendersAsEntity) {
+                this.blockEntityItemCustomModelDataPerRealState = new IdentityHashMap<>(0);
+                @NotNull Item item = Validate.notNull(hostPerRealState.get(this.real.defaultBlockState()).getBlock().asItem());
+                for (@NotNull BlockState possibleRealState : this.getReal().getStateDefinition().getPossibleStates()) {
+                    int[] customModelData = new int[BlockEntityModelVisualProperties.values.length];
+                    for (int i = 0; i < customModelData.length; i++) {
+                        customModelData[i] = UsedHostCustomModelData.generateUnusedHostCustomModelData(item);
+                    }
+                    this.blockEntityItemCustomModelDataPerRealState.put(possibleRealState, customModelData);
+                }
+            } else {
+                return null;
+            }
+        }
+        return this.blockEntityItemCustomModelDataPerRealState.get(realState);
+    }
+
+    @Override
+    public @Nullable BlockEntityItemStack getBlockEntityItemStack(@NotNull BlockState realState) {
+        if (this.blockEntityItemStackPerRealState == null) {
+            if (this.rendersAsEntity) {
+                this.blockEntityItemStackPerRealState = new IdentityHashMap<>(0);
+                for (@NotNull BlockState possibleRealState : this.real.getStateDefinition().getPossibleStates()) {
+                    this.blockEntityItemStackPerRealState.put(possibleRealState, this.computeBlockEntityItemStack(possibleRealState));
+                }
+            } else {
+                return null;
+            }
+        }
+        return this.blockEntityItemStackPerRealState.get(realState);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/RealItemReplacementRule.java b/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/RealItemReplacementRule.java
new file mode 100644
index 0000000000000000000000000000000000000000..97d59c6c248d3323c3f3e8d320c2b91656b9f1bf
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/RealItemReplacementRule.java
@@ -0,0 +1,102 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.block.replacementrule;
+
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.function.Supplier;
+
+/**
+ * The information about a custom item for the real block of a {@link BlockReplacementRule}
+ * (note that each item can only represent one real block)
+ * <br>
+ * This class uses late initialization internally so that items are not referenced before block bootstrapping is finished
+ */
+public class RealItemReplacementRule {
+
+    private final @NotNull Supplier<@NotNull Item> lowPingHostSupplier;
+    private final @NotNull Supplier<@NotNull Item> highPingHostSupplier;
+    private final @NotNull Supplier<@NotNull Item> fallbackSupplier;
+
+    /**
+     * Is null only when not initialized yet
+     * @see #lowPingHostSupplier
+     */
+    private @Nullable Item lowPingHost;
+
+    /**
+     * Is null only when not initialized yet
+     * @see #highPingHostSupplier
+     */
+    private @Nullable Item highPingHost;
+
+    /**
+     * Is null only when not initialized yet
+     * @see #fallbackSupplier
+     */
+    private @Nullable Item fallback;
+
+    public RealItemReplacementRule(@NotNull Supplier<@NotNull Item> lowPingHostSupplier, @NotNull Supplier<@NotNull Item> highPingHostSupplier, @NotNull Supplier<@NotNull Item> fallbackSupplier) {
+        this.lowPingHostSupplier = lowPingHostSupplier;
+        this.highPingHostSupplier = highPingHostSupplier;
+        this.fallbackSupplier = fallbackSupplier;
+    }
+
+    /**
+     * This must not be called before all block bootstrapping has finished
+     * <br>
+     * This should be an item that would normally let the player place a block state with a (nearly) identical collision bounding box to the real state placed by the real item, and that is invisible
+     */
+    public @NotNull Item getLowPingHost() {
+        if (this.lowPingHost == null) {
+            this.lowPingHost = this.lowPingHostSupplier.get();
+        }
+        return this.lowPingHost;
+    }
+
+    /**
+     * This must not be called before all block bootstrapping has finished
+     * <br>
+     * This should be an item that would normally let the player place a block state with a (nearly) identical collision bounding box to the real state placed by the real item, and that looks as similar to the real state placed by the real item as possible
+     */
+    public @NotNull Item getHighPingHost() {
+        if (this.highPingHost == null) {
+            this.highPingHost = this.highPingHostSupplier.get();
+        }
+        return this.highPingHost;
+    }
+
+    /**
+     * This must not be called before all block bootstrapping has finished
+     * <br>
+     * This should be an item that would normally let the player place the block state that is the fallback for the real state placed by the real item
+     */
+    public @NotNull Item getFallback() {
+        if (this.fallback == null) {
+            this.fallback = this.fallbackSupplier.get();
+        }
+        return this.fallback;
+    }
+
+    /**
+     * Creates a {@link RealItemReplacementRule} for a real block that has a full block bounding box
+     * <br>
+     * The low ping host will be {@link Items#BARRIER}
+     */
+    public static @NotNull RealItemReplacementRule forFullBlockBoundingBox(@NotNull Supplier<@NotNull Item> highPingHostSupplier, @NotNull Supplier<@NotNull Item> fallbackSupplier) {
+        return new RealItemReplacementRule(() -> Items.BARRIER, highPingHostSupplier, fallbackSupplier);
+    }
+
+    /**
+     * Creates a {@link RealItemReplacementRule} for a real block that has a full block bounding box
+     * <br>
+     * The low ping host will be {@link Items#BARRIER}, and the high ping host will be the same as the fallback (since we already assume it looks similar)
+     */
+    public static @NotNull RealItemReplacementRule forFullBlockBoundingBox(@NotNull Supplier<@NotNull Item> fallbackSupplier) {
+        return forFullBlockBoundingBox(fallbackSupplier, fallbackSupplier);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/SingleMultiStateRealBlockReplacementRuleBuilder.java b/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/SingleMultiStateRealBlockReplacementRuleBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..23a7be7f2206ebf9749d1b47bde0ccf61baede78
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/SingleMultiStateRealBlockReplacementRuleBuilder.java
@@ -0,0 +1,275 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.block.replacementrule;
+
+import net.minecraft.core.Registry;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.BaseFireBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.FireBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelCreation;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelCreationWithParameters;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelWithParameters;
+import nl.martijnmuijsers.paper.item.UsedHostCustomModelData;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.IdentityHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.function.Supplier;
+
+/**
+ * Concrete implementation of a builder for {@link SingleStateRealBlockReplacementRule} and {@link MultiStateRealBlockReplacementRule}
+ */
+public class SingleMultiStateRealBlockReplacementRuleBuilder implements BlockReplacementRuleBuilder<BlockReplacementRuleBase, SingleMultiStateRealBlockReplacementRuleBuilder> {
+
+    protected @Nullable Block real = null;
+    protected @NotNull Supplier<@Nullable RealItemReplacementRule> justInTimeRealItemRuleSupplier = () -> null;
+    private boolean rendersAsEntity = false;
+    private @NotNull Function<@NotNull BlockState, @Nullable BlockState> hostForRealState = $ -> null;
+    private @NotNull Function<@NotNull BlockState, @Nullable BlockState> hostReplacementForHost = $ -> null;
+    private @NotNull Function<@NotNull BlockState, @Nullable BlockState> fallbackForRealState = $ -> null;
+    private @NotNull Function<@NotNull BlockState, @Nullable ModelWithParameters> modelForRealState = $ -> null;
+    private @NotNull List<@NotNull Supplier<@NotNull HostItemReplacementRule>> justInTimeHostItemRuleSuppliers = new ArrayList<>(0);
+
+    public SingleMultiStateRealBlockReplacementRuleBuilder() {}
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withReal(@NotNull Block real) {
+        this.real = real;
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder rendersAsEntity() {
+        this.rendersAsEntity = true;
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withHost(@NotNull BlockState host) {
+        this.hostForRealState = $ -> host;
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withHostForRealState(@NotNull Function<@NotNull BlockState, @Nullable BlockState> hostForRealState) {
+        @NotNull Function<@NotNull BlockState, @Nullable BlockState> existingHostForRealState = this.hostForRealState;
+        this.hostForRealState = realState -> {
+            @Nullable BlockState host = hostForRealState.apply(realState);
+            return host != null ? host : existingHostForRealState.apply(realState);
+        };
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withHostReplacement(@NotNull BlockState hostReplacement) {
+        this.hostReplacementForHost = $ -> hostReplacement;
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withHostReplacementForHost(@NotNull Function<@NotNull BlockState, @Nullable BlockState> hostReplacementForHost) {
+        @NotNull Function<@NotNull BlockState, @Nullable BlockState> existingHostReplacementForHost = this.hostReplacementForHost;
+        this.hostReplacementForHost = host -> {
+            @Nullable BlockState hostReplacement = hostReplacementForHost.apply(host);
+            return hostReplacement != null ? hostReplacement : existingHostReplacementForHost.apply(host);
+        };
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withFallback(@NotNull BlockState fallback) {
+        this.fallbackForRealState = $ -> fallback;
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withFallbackForRealState(@NotNull Function<@NotNull BlockState, @Nullable BlockState> fallbackForRealState) {
+        @NotNull Function<@NotNull BlockState, @Nullable BlockState> existingFallbackForRealState = this.fallbackForRealState;
+        this.fallbackForRealState = realState -> {
+            @Nullable BlockState host = fallbackForRealState.apply(realState);
+            return host != null ? host : existingFallbackForRealState.apply(realState);
+        };
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withModel(@NotNull ModelWithParameters model) {
+        this.modelForRealState = $ -> model;
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withModelForRealState(@NotNull Function<@NotNull BlockState, @Nullable ModelWithParameters> modelForRealState) {
+        @NotNull Function<@NotNull BlockState, @Nullable ModelWithParameters> existingModelForRealState = this.modelForRealState;
+        this.modelForRealState = realState -> {
+            @Nullable ModelWithParameters model = modelForRealState.apply(realState);
+            return model != null ? model : existingModelForRealState.apply(realState);
+        };
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withModelCreation(@NotNull ModelCreationWithParameters modelCreation) {
+        this.modelForRealState = $ -> modelCreation.create(ResourcePackAssetIntention.BLOCK, Registry.BLOCK.getKey(this.real));
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withModelCreationForRealState(@NotNull Function<@NotNull BlockState, @Nullable ModelCreationWithParameters> modelCreationForRealState) {
+        return this.withModelForRealState(realState -> {
+            @Nullable ModelCreationWithParameters modelCreation = modelCreationForRealState.apply(realState);
+            return modelCreation == null ? null : modelCreation.create(ResourcePackAssetIntention.BLOCK, Registry.BLOCK.getKey(this.real));
+        });
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withRealItemRule(@NotNull RealItemReplacementRule realItemRule) {
+        this.justInTimeRealItemRuleSupplier = () -> realItemRule;
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withoutRealItemRule() {
+        this.justInTimeRealItemRuleSupplier = () -> null;
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withFullBlockBoundingBoxItem(@NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        this.justInTimeRealItemRuleSupplier = () -> RealItemReplacementRule.forFullBlockBoundingBox(highPingHostSupplier, () -> this.fallbackForRealState.apply(this.real.defaultBlockState()).getBlock().asItem());
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withFullBlockBoundingBoxItem() {
+        this.justInTimeRealItemRuleSupplier = () -> RealItemReplacementRule.forFullBlockBoundingBox(() -> this.fallbackForRealState.apply(this.real.defaultBlockState()).getBlock().asItem());
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withRealItemRuleFromHostBlock() {
+        @NotNull Supplier<@NotNull Item> hostSupplier = () -> this.hostForRealState.apply(this.real.defaultBlockState()).getBlock().asItem();
+        @NotNull Supplier<@NotNull Item> fallbackSupplier = () -> this.fallbackForRealState.apply(this.real.defaultBlockState()).getBlock().asItem();
+        this.justInTimeRealItemRuleSupplier = () -> new RealItemReplacementRule(hostSupplier, hostSupplier, fallbackSupplier);
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withHostItemRule(@NotNull HostItemReplacementRule hostItemRule) {
+        this.justInTimeHostItemRuleSuppliers.add(() -> hostItemRule);
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withoutHostItemRules() {
+        this.justInTimeHostItemRuleSuppliers.clear();
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withHostItemRuleFromHostBlockAndHostReplacementBlock() {
+        this.justInTimeHostItemRuleSuppliers.add(() -> {
+            @NotNull BlockState host = Validate.notNull(this.hostForRealState.apply(this.real.defaultBlockState()));
+            return new HostItemReplacementRule(() -> host.getBlock().asItem(), () -> this.hostReplacementForHost.apply(host).getBlock().asItem());
+        });
+        return this;
+    }
+
+    /**
+     * May return a {@link SingleStateRealBlockReplacementRule} if possible
+     */
+    @Override
+    public @NotNull BlockReplacementRuleBase build() {
+        Validate.notNull(this.real);
+        boolean isFire = this.real instanceof BaseFireBlock;
+        @Nullable RealItemReplacementRule realItemRule = this.justInTimeRealItemRuleSupplier.get();
+        @NotNull List<@NotNull HostItemReplacementRule> hostItemRules = this.justInTimeHostItemRuleSuppliers.stream().map(Supplier::get).toList();
+        var realStates = this.real.getStateDefinition().getPossibleStates();
+        if (realStates.size() == 1) {
+            @NotNull BlockState realState = Validate.notNull(this.real.defaultBlockState());
+            @NotNull BlockState host = Validate.notNull(this.hostForRealState.apply(realState));
+            @NotNull BlockState hostReplacement = Validate.notNull(this.hostReplacementForHost.apply(host));
+            @NotNull BlockState fallback = Validate.notNull(this.fallbackForRealState.apply(realState));
+            @Nullable ModelWithParameters model = isFire ? null : Validate.notNull(this.modelForRealState.apply(realState));
+            @Nullable Model blockEntityItemModelBase = !this.rendersAsEntity ? null : model.model();
+            return new SingleStateRealBlockReplacementRule(
+                this.real,
+                realItemRule,
+                this.rendersAsEntity,
+                host,
+                hostReplacement,
+                fallback,
+                model,
+                hostItemRules,
+                blockEntityItemModelBase
+            );
+        }
+        @NotNull List<@NotNull BlockState> hosts = new ArrayList<>();
+        @NotNull Map<@NotNull BlockState, @NotNull BlockState> hostPerRealState = new IdentityHashMap<>(0);
+        @NotNull Map<@NotNull BlockState, @NotNull BlockState> hostReplacementPerHost = new IdentityHashMap<>(0);
+        @NotNull List<@NotNull BlockState> fallbacks = new ArrayList<>();
+        @NotNull Map<@NotNull BlockState, @NotNull BlockState> fallbackPerRealState = new IdentityHashMap<>(0);
+        @NotNull Map<@NotNull BlockState, @NotNull ModelWithParameters> modelPerHost = new IdentityHashMap<>(0);
+        @Nullable Map<@NotNull BlockState, @NotNull Model> blockEntityItemModelBasePerRealState = this.rendersAsEntity ? new IdentityHashMap<>(0) : null;
+        for (@NotNull BlockState realState : realStates) {
+            @NotNull BlockState host = Validate.notNull(this.hostForRealState.apply(realState));
+            if (!hosts.contains(host)) {
+                hosts.add(host);
+            }
+            hostPerRealState.put(realState, host);
+            @NotNull BlockState fallback = Validate.notNull(this.fallbackForRealState.apply(realState));
+            if (!fallbacks.contains(fallback)) {
+                fallbacks.add(fallback);
+            }
+            fallbackPerRealState.put(realState, fallback);
+            if (!isFire && !modelPerHost.containsKey(host)) {
+                @Nullable ModelWithParameters model = this.modelForRealState.apply(realState);
+                if (!this.rendersAsEntity) {
+                    Validate.notNull(model);
+                }
+                if (model != null) {
+                    modelPerHost.put(host, model);
+                }
+            }
+        }
+        if (!this.rendersAsEntity) {
+            for (@NotNull BlockState host : hosts) {
+                @NotNull BlockState hostReplacement = Validate.notNull(this.hostReplacementForHost.apply(host));
+                hostReplacementPerHost.put(host, hostReplacement);
+            }
+        }
+        if (this.rendersAsEntity) {
+            for (@NotNull BlockState realState : realStates) {
+                blockEntityItemModelBasePerRealState.put(realState, modelPerHost.get(hostPerRealState.get(realState)).model());
+            }
+        }
+        return new MultiStateRealBlockReplacementRule(
+            this.real,
+            realItemRule,
+            this.rendersAsEntity,
+            hosts,
+            hostPerRealState,
+            hostReplacementPerHost,
+            fallbacks,
+            fallbackPerRealState,
+            modelPerHost,
+            hostItemRules,
+            blockEntityItemModelBasePerRealState
+        );
+    }
+
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/SingleStateRealBlockReplacementRule.java b/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/SingleStateRealBlockReplacementRule.java
new file mode 100644
index 0000000000000000000000000000000000000000..d3901bbddfe98d597e4357543cf3d397c93727d8
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/SingleStateRealBlockReplacementRule.java
@@ -0,0 +1,227 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.block.replacementrule;
+
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.core.Registry;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.BlockState;
+import nl.martijnmuijsers.paper.blockanditemdata.model.BlockEntityModelVisualProperties;
+import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelWithParameters;
+import nl.martijnmuijsers.paper.item.UsedHostCustomModelData;
+import nl.martijnmuijsers.paper.resourcepack.MutableResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.blockstates.MutableResourcePackBlockStates;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Collections;
+import java.util.IdentityHashMap;
+import java.util.List;
+import java.util.Set;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * Single-state real blocks could be managed by a {@link MultiStateRealBlockReplacementRule} rule as well, but this implementation is slightly more efficient
+ */
+public class SingleStateRealBlockReplacementRule extends BlockReplacementRuleBase {
+
+    private final @NotNull BlockState host;
+
+    /**
+     * This is simply a backing field for quickly returning {@link #getHosts}
+     */
+    private final @NotNull List<@NotNull BlockState> hosts;
+
+    private final @NotNull BlockState hostReplacement;
+    private final @NotNull BlockState fallback;
+
+    /**
+     * This is simply a backing field for quickly returning {@link #getFallbacks}
+     */
+    private final @NotNull List<@NotNull BlockState> fallbacks;
+
+    /**
+     * This is simply a backing field for quickly returning {@link #getHostAndFallbackBlocks()}
+     */
+    private final @NotNull List<@NotNull Block> hostAndFallbackBlocks;
+
+    /**
+     * This is simply a backing field for quickly returning {@link #getPotentialBlockReplacementPairs}
+     */
+    private final @NotNull List<@NotNull Pair<@NotNull Block, @NotNull Block>> potentialBlockReplacementPairs;
+
+    /**
+     * Nullable only if {@link isFire} is true
+     */
+    private final @Nullable ModelWithParameters model;
+
+    private final @Nullable Model blockEntityItemModelBase;
+
+    /**
+     * Is at least null when not initialized yet:
+     * late initialization is used so that items are not referenced before block bootstrapping is finished
+     */
+    private @NotNull Model @Nullable [] blockEntityItemModels;
+
+    /**
+     * Is at least null when not initialized yet:
+     * late initialization is used so that items are not referenced before block bootstrapping is finished
+     */
+    private int @Nullable [] blockEntityItemCustomModelData;
+
+    /**
+     * Is at least null when not initialized yet:
+     * late initialization is used so that items are not referenced before block bootstrapping is finished
+     */
+    private @Nullable BlockEntityItemStack blockEntityItemStack;
+
+    public SingleStateRealBlockReplacementRule(@NotNull Block real, @Nullable RealItemReplacementRule realItemRule, boolean rendersAsEntity, @NotNull BlockState host, @NotNull BlockState hostReplacement, @NotNull BlockState fallback, @Nullable ModelWithParameters model, @NotNull List<@NotNull HostItemReplacementRule> hostItemRules, @Nullable Model blockEntityItemModelBase) {
+        super(real, realItemRule, rendersAsEntity, hostItemRules);
+        this.host = host;
+        this.hosts = Collections.singletonList(this.host);
+        this.hostReplacement = hostReplacement;
+        this.fallback = fallback;
+        this.fallbacks = Collections.singletonList(this.fallback);
+        this.hostAndFallbackBlocks = Stream.of(this.host.getBlock(), this.fallback.getBlock()).distinct().toList();
+        this.potentialBlockReplacementPairs = Stream.of(
+            Pair.of(this.real, this.host.getBlock()),
+            Pair.of(this.host.getBlock(), this.hostReplacement.getBlock()),
+            Pair.of(this.real, this.fallback.getBlock())
+        ).filter(pair -> !pair.left().equals(pair.right())).distinct().toList();
+        this.model = model;
+        this.blockEntityItemModelBase = blockEntityItemModelBase;
+    }
+
+    @Override
+    public @NotNull List<@NotNull BlockState> getHosts() {
+        return this.hosts;
+    }
+
+    @Override
+    public boolean hasAsHost(@NotNull BlockState potentialHost) {
+        return this.host.equals(potentialHost);
+    }
+
+    public @NotNull BlockState getHost() {
+        return this.host;
+    }
+
+    @Override
+    public @NotNull BlockState getHost(@NotNull BlockState realState) {
+        return this.host;
+    }
+
+    @Override
+    public @NotNull BlockState getHostReplacement(@NotNull BlockState host) {
+        return this.hostReplacement;
+    }
+
+    public @NotNull BlockState getHostReplacement() {
+        return this.hostReplacement;
+    }
+
+    @Override
+    public @NotNull List<@NotNull BlockState> getFallbacks() {
+        return this.fallbacks;
+    }
+
+    @Override
+    public @NotNull BlockState getFallback(@NotNull BlockState realState) {
+        return this.fallback;
+    }
+
+    public @NotNull BlockState getFallback() {
+        return this.fallback;
+    }
+
+    @Override
+    public @NotNull List<@NotNull Block> getHostAndFallbackBlocks() {
+        return this.hostAndFallbackBlocks;
+    }
+
+    @Override
+    public @NotNull List<@NotNull Pair<@NotNull Block, @NotNull Block>> getPotentialBlockReplacementPairs() {
+        return this.potentialBlockReplacementPairs;
+    }
+
+    @Override
+    public @Nullable ModelWithParameters getModel(@NotNull BlockState host) {
+        return this.getModel();
+    }
+
+    public @Nullable ModelWithParameters getModel() {
+        if (this.isFire) {
+            throw new IllegalStateException("Cannot call BlockReplacementRule.getModel for fire");
+        }
+        return this.model;
+    }
+
+    @Override
+    public @Nullable Model getBlockEntityItemModelBase(@NotNull BlockState realState) {
+        return this.blockEntityItemModelBase;
+    }
+
+    @Override
+    public @NotNull Model @Nullable [] getBlockEntityItemModels(@NotNull BlockState realState) {
+        if (this.blockEntityItemModels == null) {
+            if (this.rendersAsEntity) {
+                this.blockEntityItemModels = this.computeBlockEntityItemModels(realState);
+            }
+        }
+        return this.blockEntityItemModels;
+    }
+
+    @Override
+    public int @Nullable [] getBlockEntityItemCustomModelData(@NotNull BlockState realState) {
+        if (this.blockEntityItemCustomModelData == null) {
+            if (this.rendersAsEntity) {
+                @NotNull Item item = Validate.notNull(this.host.getBlock().asItem());
+                this.blockEntityItemCustomModelData = new int[BlockEntityModelVisualProperties.values.length];
+                for (int i = 0; i < blockEntityItemCustomModelData.length; i++) {
+                    this.blockEntityItemCustomModelData[i] = UsedHostCustomModelData.generateUnusedHostCustomModelData(item);
+                }
+            } else {
+                return null;
+            }
+        }
+        return this.blockEntityItemCustomModelData;
+    }
+
+    @Override
+    public @Nullable BlockEntityItemStack getBlockEntityItemStack(@NotNull BlockState realState) {
+        if (this.blockEntityItemStack == null) {
+            if (this.rendersAsEntity) {
+                this.blockEntityItemStack = this.computeBlockEntityItemStack(realState);
+            } else {
+                return null;
+            }
+        }
+        return this.blockEntityItemStack;
+    }
+
+    @Override
+    public void addToResourcePack(@NotNull MutableResourcePack resourcePack) {
+        if (this.isFire) {
+            super.addToResourcePack(resourcePack);
+            return;
+        }
+        this.addBlockEntityItemToResourcePack(resourcePack);
+        @NotNull NamespacedKeyWithIntention hostKey = NamespacedKeyWithoutIntention.forMinecraft(Registry.BLOCK.getKey(this.host.getBlock())).withEmptyIntention();
+        @NotNull MutableResourcePackBlockStates minecraftBlockStates = resourcePack.getBlockStates(hostKey);
+        if (this.host.getBlock().getStateDefinition().getPossibleStates().size() == 1) {
+            minecraftBlockStates.setNoVariantModel(this.model, resourcePack, false);
+        } else {
+            minecraftBlockStates.setModel(this.host, this.model, resourcePack, false);
+        }
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/BlockEntityModelPosition.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/BlockEntityModelPosition.java
new file mode 100644
index 0000000000000000000000000000000000000000..94aee86ff714ac334b42c874a2ec4d25f5d03ad1
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/BlockEntityModelPosition.java
@@ -0,0 +1,29 @@
+package nl.martijnmuijsers.paper.blockanditemdata.model;
+
+import org.jetbrains.annotations.NotNull;
+
+public enum BlockEntityModelPosition {
+
+    POSITIVE_XZ("p", 1.6F * 16 / 2, 0.5F),
+    CENTER("c", 0, 0),
+    NEGATIVE_XZ("n", -POSITIVE_XZ.displayTranslationX, -POSITIVE_XZ.armorStandPhysicalTranslationX);
+
+    public final @NotNull String blockEntityModelFileSuffix;
+    public final float displayTranslationX;
+    public final float displayTranslationZ;
+    public final float armorStandPhysicalTranslationX;
+    public final float armorStandPhysicalTranslationZ;
+
+    BlockEntityModelPosition(@NotNull String blockEntityModelFileSuffix, float displayTranslationX, float displayTranslationZ, float armorStandPhysicalTranslationX, float armorStandPhysicalTranslationZ) {
+        this.blockEntityModelFileSuffix = blockEntityModelFileSuffix;
+        this.displayTranslationX = displayTranslationX;
+        this.displayTranslationZ = displayTranslationZ;
+        this.armorStandPhysicalTranslationX = armorStandPhysicalTranslationX;
+        this.armorStandPhysicalTranslationZ = armorStandPhysicalTranslationZ;
+    }
+
+    BlockEntityModelPosition(@NotNull String blockEntityModelFileSuffix, float displayTranslationXZ, float armorStandPhysicalTranslationXZ) {
+        this(blockEntityModelFileSuffix, displayTranslationXZ, displayTranslationXZ, armorStandPhysicalTranslationXZ, armorStandPhysicalTranslationXZ);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/BlockEntityModelProximity.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/BlockEntityModelProximity.java
new file mode 100644
index 0000000000000000000000000000000000000000..d26bba52cbec3c1b352f3ead626cd52891c7339d
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/BlockEntityModelProximity.java
@@ -0,0 +1,23 @@
+package nl.martijnmuijsers.paper.blockanditemdata.model;
+
+import org.jetbrains.annotations.NotNull;
+
+public enum BlockEntityModelProximity {
+
+    NEIGHBOR_BLOCK("b", 0.005F),
+    SAME_CHUNK("s", 0.01F),
+    NEIGHBOR_CHUNK("n", 0.03F),
+    FAR("f", 0.21F);
+
+    public final @NotNull String blockEntityModelFileSuffix;
+    public final float outwardExpandedElementDistance;
+
+    BlockEntityModelProximity(@NotNull String blockEntityModelFileSuffix, float outwardExpandedElementDistance) {
+        this.blockEntityModelFileSuffix = blockEntityModelFileSuffix;
+        this.outwardExpandedElementDistance = outwardExpandedElementDistance;
+    }
+
+    public static final int maxBlockDistanceForNeighbors = 2;
+    public static final int maxSectionDistanceForNeighbors = 1;
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/BlockEntityModelVisualProperties.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/BlockEntityModelVisualProperties.java
new file mode 100644
index 0000000000000000000000000000000000000000..94b6c82758378c081996502059426b54819cc151
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/BlockEntityModelVisualProperties.java
@@ -0,0 +1,26 @@
+package nl.martijnmuijsers.paper.blockanditemdata.model;
+
+import org.jetbrains.annotations.NotNull;
+
+public record BlockEntityModelVisualProperties(@NotNull BlockEntityModelPosition position, @NotNull BlockEntityModelProximity proximity) {
+
+    public @NotNull String getBlockEntityModelFileSuffix() {
+        return this.position.blockEntityModelFileSuffix + this.proximity.blockEntityModelFileSuffix;
+    }
+
+    public int getIndex() {
+        return this.position.ordinal() + this.proximity.ordinal() * BlockEntityModelPosition.values().length;
+    }
+
+    public static BlockEntityModelVisualProperties[] values;
+    static {
+        values = new BlockEntityModelVisualProperties[BlockEntityModelPosition.values().length * BlockEntityModelProximity.values().length];
+        for (BlockEntityModelPosition position : BlockEntityModelPosition.values()) {
+            for (BlockEntityModelProximity proximity : BlockEntityModelProximity.values()) {
+                BlockEntityModelVisualProperties properties = new BlockEntityModelVisualProperties(position, proximity);
+                values[properties.getIndex()] = properties;
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/Model.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/Model.java
new file mode 100644
index 0000000000000000000000000000000000000000..69f91b1cc88165e09b6b760a5374a5e968838da7
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/Model.java
@@ -0,0 +1,269 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.blockanditemdata.model;
+
+import net.minecraft.core.Direction;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.level.block.state.properties.Half;
+import nl.martijnmuijsers.paper.blockanditemdata.texture.Texture;
+import nl.martijnmuijsers.paper.blockanditemdata.texture.TextureContent;
+import nl.martijnmuijsers.paper.blockanditemdata.texture.TextureContentCreation;
+import nl.martijnmuijsers.paper.blockanditemdata.texture.TextureCreation;
+import nl.martijnmuijsers.paper.resourcepack.MutableResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.MutableResourcePackModel;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackIntentionedAssetDataByContent;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.function.Function;
+
+/**
+ * An immutable item or block model
+ */
+public class Model extends ResourcePackIntentionedAssetDataByContent<ModelContent> {
+
+    public Model(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key, @NotNull ModelContent content) {
+       super(intention, key, content);
+    }
+
+    public @NotNull ModelWithParameters withParameters(@NotNull ModelParameters parameters) {
+        return new ModelWithParameters(this, parameters);
+    }
+
+    public @NotNull ModelWithParameters withNoParameters() {
+        return new ModelWithParameters(this, null);
+    }
+
+    public @NotNull Model getReference(@NotNull ResourcePackAssetIntention newIntention) {
+        return new Model(newIntention, this.key, new ModelContent.Reference(this));
+    }
+
+    public @NotNull Model getBlockEntityVersion(@NotNull BlockEntityModelVisualProperties properties) {
+        return new Model(ResourcePackAssetIntention.ITEM, new NamespacedKeyWithoutIntention(this.key.namespace(), this.key.keyWithoutIntention() + "_e" + properties.getBlockEntityModelFileSuffix()), this.content.getBlockEntityVersion(this, properties));
+    }
+
+    public void addToResourcePack(@NotNull MutableResourcePack resourcePack, boolean overwriteExisting) {
+        @NotNull MutableResourcePackModel resourcePackModel = resourcePack.getOrCreateModel(this.intention, this.key);
+        if (!resourcePackModel.isJsonEmpty() && !overwriteExisting) {
+            return;
+        }
+        if (!resourcePackModel.isJsonEmpty()) {
+            resourcePackModel.clearJson();
+        }
+        this.content.writeToClearResourcePackModel(resourcePackModel, resourcePack);
+    }
+
+    // Convenience methods for replacement rule builders
+
+    public static @NotNull Model create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key, @NotNull ModelContent content) {
+        return new Model(intention, NamespacedKeyWithoutIntention.forMinecraft(key), content);
+    }
+
+    public static @NotNull Model create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key, @NotNull ModelContentCreation content) {
+        return create(intention, key, content.create(intention, key));
+    }
+
+    public static @NotNull ModelCreation creation(@NotNull ModelContent content) {
+        return (intention, key) -> create(intention, key, content);
+    }
+
+    public static @NotNull ModelCreation creation(@NotNull ModelContentCreation content) {
+        return (intention, key) -> create(intention, key, content);
+    }
+
+    /**
+     * @see ModelContent.OneTextureCube
+     */
+    public static final class OneTextureCube {
+
+        private OneTextureCube() {}
+
+        private static final @NotNull ModelCreation DEFAULT_CREATION = creation(ModelContent.OneTextureCube.defaultCreation());
+
+        public static @NotNull ModelCreation defaultCreation() {
+            return DEFAULT_CREATION;
+        }
+
+    }
+
+    /**
+     * @see ModelContent.YPillarCube
+     */
+    public static final class YPillarCube {
+
+        private YPillarCube() {}
+
+        private static final @NotNull ModelCreation DEFAULT_CREATION = creation(ModelContent.YPillarCube.defaultCreation());
+
+        public static @NotNull ModelCreation defaultCreation() {
+            return DEFAULT_CREATION;
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeEnd(@NotNull Texture endTexture) {
+            return creation(ModelContent.YPillarCube.defaultCreationWithAlternativeEnd(endTexture));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeEnd(@NotNull TextureCreation endTexture) {
+            return creation(ModelContent.YPillarCube.defaultCreationWithAlternativeEnd(endTexture));
+        }
+
+    }
+
+    /**
+     * @see ModelContent.HorizontalYPillarCube
+     */
+    public static final class HorizontalYPillarCube {
+
+        private HorizontalYPillarCube() {}
+
+        private static final @NotNull ModelCreation DEFAULT_CREATION = creation(ModelContent.HorizontalYPillarCube.defaultCreation());
+
+        public static @NotNull ModelCreation defaultCreation() {
+            return DEFAULT_CREATION;
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeEnd(@NotNull Texture endTexture) {
+            return creation(ModelContent.HorizontalYPillarCube.defaultCreationWithAlternativeEnd(endTexture));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeEnd(@NotNull TextureCreation endTexture) {
+            return creation(ModelContent.HorizontalYPillarCube.defaultCreationWithAlternativeEnd(endTexture));
+        }
+
+    }
+
+    /**
+     * @see ModelContent.BottomTopPillarCube
+     */
+    public static final class BottomTopPillarCube {
+
+        private BottomTopPillarCube() {}
+
+        private static final @NotNull ModelCreation DEFAULT_CREATION = creation(ModelContent.BottomTopPillarCube.creationCompanion.defaultCreation());
+
+        public static @NotNull ModelCreation defaultCreation() {
+            return DEFAULT_CREATION;
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull Texture bottomTexture, @NotNull Texture topTexture) {
+            return creation(ModelContent.BottomTopPillarCube.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation topTexture) {
+            return creation(ModelContent.BottomTopPillarCube.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture));
+        }
+
+    }
+
+    /**
+     * @see ModelContent.BottomSlab
+     */
+    public static final class BottomSlab {
+
+        private BottomSlab() {}
+
+        private static final @NotNull ModelCreation DEFAULT_CREATION = creation(ModelContent.BottomSlab.creationCompanion.defaultCreation());
+
+        public static @NotNull ModelCreation defaultCreation() {
+            return DEFAULT_CREATION;
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull Texture bottomTexture, @NotNull Texture topTexture) {
+            return creation(ModelContent.BottomSlab.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation topTexture) {
+            return creation(ModelContent.BottomSlab.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture));
+        }
+
+    }
+
+    /**
+     * @see ModelContent.TopSlab
+     */
+    public static final class TopSlab {
+
+        private TopSlab() {}
+
+        private static final @NotNull ModelCreation DEFAULT_CREATION = creation(ModelContent.TopSlab.creationCompanion.defaultCreation());
+
+        public static @NotNull ModelCreation defaultCreation() {
+            return DEFAULT_CREATION;
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull Texture bottomTexture, @NotNull Texture topTexture) {
+            return creation(ModelContent.TopSlab.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation topTexture) {
+            return creation(ModelContent.TopSlab.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture));
+        }
+
+    }
+
+    /**
+     * @see ModelContent.StraightStairs
+     */
+    public static final class StraightStairs {
+
+        private StraightStairs() {}
+
+        public static @NotNull ModelCreation defaultCreation(@NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.StraightStairs.creationCompanion.defaultCreation(half, facing));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull Texture bottomTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.StraightStairs.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture, half, facing));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation topTexture, @NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.StraightStairs.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture, half, facing));
+        }
+
+    }
+
+    /**
+     * @see ModelContent.InnerLeftStairs
+     */
+    public static final class InnerLeftStairs {
+
+        private InnerLeftStairs() {}
+
+        public static @NotNull ModelCreation defaultCreation(@NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.InnerLeftStairs.creationCompanion.defaultCreation(half, facing));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull Texture bottomTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.InnerLeftStairs.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture, half, facing));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation topTexture, @NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.InnerLeftStairs.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture, half, facing));
+        }
+
+    }
+
+    /**
+     * @see ModelContent.OuterLeftStairs
+     */
+    public static final class OuterLeftStairs {
+
+        private OuterLeftStairs() {}
+
+        public static @NotNull ModelCreation defaultCreation(@NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.OuterLeftStairs.creationCompanion.defaultCreation(half, facing));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull Texture bottomTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.OuterLeftStairs.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture, half, facing));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation topTexture, @NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.OuterLeftStairs.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture, half, facing));
+        }
+
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelContent.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelContent.java
new file mode 100644
index 0000000000000000000000000000000000000000..2fabfd40629766c0eb16325733a5ec63fce7f65a
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelContent.java
@@ -0,0 +1,1227 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.blockanditemdata.model;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+import net.minecraft.core.Direction;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.level.block.state.properties.Half;
+import nl.martijnmuijsers.paper.blockanditemdata.texture.Texture;
+import nl.martijnmuijsers.paper.blockanditemdata.texture.TextureContent;
+import nl.martijnmuijsers.paper.blockanditemdata.texture.TextureContentCreation;
+import nl.martijnmuijsers.paper.blockanditemdata.texture.TextureCreation;
+import nl.martijnmuijsers.paper.resourcepack.MutableResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.MutableResourcePackModel;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAssetDataContent;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.texture.MutableResourcePackTexture;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.json.simple.JSONObject;
+
+import java.util.Arrays;
+import java.util.EnumMap;
+import java.util.Locale;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.function.Supplier;
+
+/**
+ * The immutable content of a model: a {@link Model} without any information about its appropriate location in a resource pack
+ */
+public abstract class ModelContent implements ResourcePackAssetDataContent {
+
+    protected ModelContent() {}
+
+    public @NotNull Model asModel(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) {
+        return new Model(intention, key, this);
+    }
+
+    /**
+     * Note that this method will attempt to add any used textures to the resource pack, but will not overwrite any existing ones
+     */
+    abstract void writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack);
+
+    public @NotNull ModelContent getBlockEntityVersion(@NotNull Model myOwningModel, @NotNull BlockEntityModelVisualProperties properties) throws UnsupportedOperationException {
+        return new ModelContent.AsBlockEntityReference(myOwningModel, properties.position(), this.getOutwardExpandedElements(properties.proximity().outwardExpandedElementDistance));
+    }
+
+    abstract @NotNull JsonArray getOutwardExpandedElements(float outwardDistance) throws UnsupportedOperationException;
+
+    // Convenience methods for replacement rule builders
+
+    /**
+     * A basic form of {@link ModelContent}: a full cube with the same texture on all 6 sides
+     */
+    public static final class OneTextureCube extends ModelContent {
+
+        private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("cube_all"), Existing.getInstance());
+
+        // Based on vanilla Minecraft resource file /assets/minecraft/models/block/cube.json
+        public static @NotNull JsonArray getCubeOutwardExpandedElements(float outwardDistance) {
+            float from = -outwardDistance;
+            float to = 16 + outwardDistance;
+            return JsonParser.parseString("""
+                [
+                    {   "from": [ %1$f, %1$f, %1$f ],
+                        "to": [ %2$f, %2$f, %2$f ],
+                        "faces": {
+                            "down":  { "texture": "#down", "cullface": "down" },
+                            "up":    { "texture": "#up", "cullface": "up" },
+                            "north": { "texture": "#north", "cullface": "north" },
+                            "south": { "texture": "#south", "cullface": "south" },
+                            "west":  { "texture": "#west", "cullface": "west" },
+                            "east":  { "texture": "#east", "cullface": "east" }
+                        }
+                    }
+                ]""".formatted(from, to)
+            ).getAsJsonArray();
+        }
+
+        private final @NotNull Texture texture;
+
+        public OneTextureCube(@NotNull Texture texture) {
+            super();
+            this.texture = texture;
+        }
+
+        @Override
+        void writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack) {
+            resourcePackModel.setParent(parent);
+            resourcePackModel.setAllTextures(this.texture);
+            this.texture.addToResourcePack(resourcePack, false);
+        }
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(float outwardDistance) {
+            return getCubeOutwardExpandedElements(outwardDistance);
+        }
+
+        public static @NotNull OneTextureCube create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key, @NotNull TextureCreation texture) {
+            return new OneTextureCube(texture.create(intention, key));
+        }
+
+        public static @NotNull ModelContentCreation creation(@NotNull Texture texture) {
+            return (intention, key) -> new OneTextureCube(texture);
+        }
+
+        public static @NotNull ModelContentCreation creation(@NotNull TextureCreation texture) {
+            return (intention, key) -> create(intention, key, texture);
+        }
+
+        private static final @NotNull ModelContentCreation DEFAULT_CREATION = creation(Texture.defaultCreation());
+
+        public static @NotNull ModelContentCreation defaultCreation() {
+            return DEFAULT_CREATION;
+        }
+
+    }
+
+    /**
+     * A form of {@link ModelContent}: a full cube with one texture for the y-oriented sides, and one texture for the x- and z-oriented sides
+     */
+    public static final class YPillarCube extends ModelContent {
+
+        private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("cube_column"), Existing.getInstance());
+
+        private final @NotNull Texture endTexture;
+        private final @NotNull Texture sideTexture;
+
+        public YPillarCube(@NotNull Texture endTexture, @NotNull Texture sideTexture) {
+            super();
+            this.endTexture = endTexture;
+            this.sideTexture = sideTexture;
+        }
+
+        @Override
+        void writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack) {
+            resourcePackModel.setParent(parent);
+            resourcePackModel.setColumnTextures(this.endTexture, this.sideTexture);
+            this.endTexture.addToResourcePack(resourcePack, false);
+            this.sideTexture.addToResourcePack(resourcePack, false);
+        }
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(float outwardDistance) {
+            return OneTextureCube.getCubeOutwardExpandedElements(outwardDistance);
+        }
+
+        public static @NotNull YPillarCube create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key, @NotNull TextureCreation endTexture, @NotNull TextureCreation sideTexture) {
+            return new YPillarCube(endTexture.create(intention, key), sideTexture.create(intention, key));
+        }
+
+        public static @NotNull ModelContentCreation creation(@NotNull Texture endTexture, @NotNull Texture sideTexture) {
+            return (intention, key) -> new YPillarCube(endTexture, sideTexture);
+        }
+
+        public static @NotNull ModelContentCreation creation(@NotNull TextureCreation endTexture, @NotNull TextureCreation sideTexture) {
+            return (intention, key) -> create(intention, key, endTexture, sideTexture);
+        }
+
+        private static final @NotNull ModelContentCreation DEFAULT_CREATION = creation(Texture.defaultEndCreation(), Texture.defaultCreation());
+
+        public static @NotNull ModelContentCreation defaultCreation() {
+            return DEFAULT_CREATION;
+        }
+
+        public static @NotNull ModelContentCreation defaultCreationWithAlternativeEnd(@NotNull Texture endTexture) {
+            return defaultCreationWithAlternativeEnd((intention, key) -> endTexture);
+        }
+
+        public static @NotNull ModelContentCreation defaultCreationWithAlternativeEnd(@NotNull TextureCreation endTexture) {
+            return (intention, key) -> create(intention, key, endTexture, Texture.defaultCreation());
+        }
+
+    }
+
+    /**
+     * A form of {@link ModelContent}: similar tp {@link YPillarCube}, but oriented horizontally
+     */
+    public static final class HorizontalYPillarCube extends ModelContent {
+
+        private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("cube_column_horizontal"), Existing.getInstance());
+
+        // Based on vanilla Minecraft resource file /assets/minecraft/models/block/cube_column_horizontal.json
+        public static @NotNull JsonArray getHorizontalColumnCubeOutwardExpandedElements(float outwardDistance) {
+            float from = -outwardDistance;
+            float to = 16 + outwardDistance;
+            return JsonParser.parseString("""
+                [
+                    {   "from": [ %1$f, %1$f, %1$f ],
+                        "to": [ %2$f, %2$f, %2$f ],
+                        "faces": {
+                            "down":  { "texture": "#down", "cullface": "down" },
+                            "up":    { "texture": "#up", "rotation": 180, "cullface": "up" },
+                            "north": { "texture": "#north", "cullface": "north" },
+                            "south": { "texture": "#south", "cullface": "south" },
+                            "west":  { "texture": "#west", "cullface": "west" },
+                            "east":  { "texture": "#east", "cullface": "east" }
+                        }
+                    }
+                ]""".formatted(from, to)
+            ).getAsJsonArray();
+        }
+
+        private final @NotNull Texture endTexture;
+        private final @NotNull Texture sideTexture;
+
+        public HorizontalYPillarCube(@NotNull Texture endTexture, @NotNull Texture sideTexture) {
+            super();
+            this.endTexture = endTexture;
+            this.sideTexture = sideTexture;
+        }
+
+        @Override
+        void writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack) {
+            resourcePackModel.setParent(parent);
+            resourcePackModel.setColumnTextures(this.endTexture, this.sideTexture);
+            this.endTexture.addToResourcePack(resourcePack, false);
+            this.sideTexture.addToResourcePack(resourcePack, false);
+        }
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(float outwardDistance) {
+            return getHorizontalColumnCubeOutwardExpandedElements(outwardDistance);
+        }
+
+        public static @NotNull HorizontalYPillarCube create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key, @NotNull TextureCreation endTexture, @NotNull TextureCreation sideTexture) {
+            return new HorizontalYPillarCube(endTexture.create(intention, key), sideTexture.create(intention, key));
+        }
+
+        public static @NotNull ModelContentCreation creation(@NotNull Texture endTexture, @NotNull Texture sideTexture) {
+            return (intention, key) -> new YPillarCube(endTexture, sideTexture);
+        }
+
+        public static @NotNull ModelContentCreation creation(@NotNull TextureCreation endTexture, @NotNull TextureCreation sideTexture) {
+            return (intention, key) -> create(intention, key, endTexture, sideTexture);
+        }
+
+        private static final @NotNull ModelContentCreation DEFAULT_CREATION = creation(Texture.defaultEndCreation(), Texture.defaultCreation());
+
+        public static @NotNull ModelContentCreation defaultCreation() {
+            return DEFAULT_CREATION;
+        }
+
+        public static @NotNull ModelContentCreation defaultCreationWithAlternativeEnd(@NotNull Texture endTexture) {
+            return defaultCreationWithAlternativeEnd((intention, key) -> endTexture);
+        }
+
+        public static @NotNull ModelContentCreation defaultCreationWithAlternativeEnd(@NotNull TextureCreation endTexture) {
+            return (intention, key) -> create(intention, key, endTexture, Texture.defaultCreation());
+        }
+
+    }
+
+    /**
+     * An abstract form of {@link ModelContent}: with one texture for the bottom, one textures for the x- and z-oriented sides, and one texture for the top
+     */
+    public static abstract class AbstractBottomTopPillarCube extends ModelContent {
+
+        public final @NotNull Texture bottomTexture;
+        public final @NotNull Texture sideTexture;
+        public final @NotNull Texture topTexture;
+
+        public AbstractBottomTopPillarCube(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture) {
+            super();
+            this.bottomTexture = bottomTexture;
+            this.sideTexture = sideTexture;
+            this.topTexture = topTexture;
+        }
+
+        protected abstract @NotNull Model getParent();
+
+        @Override
+        void writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack) {
+            resourcePackModel.setParent(getParent());
+            resourcePackModel.setBottomTopTextures(this.bottomTexture, this.sideTexture, this.topTexture);
+            this.bottomTexture.addToResourcePack(resourcePack, false);
+            this.sideTexture.addToResourcePack(resourcePack, false);
+            this.topTexture.addToResourcePack(resourcePack, false);
+        }
+
+        public static abstract class CreationCompanion<M extends AbstractBottomTopPillarCube> {
+
+            protected abstract @NotNull M construct(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture);
+
+            public @NotNull M create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key, @NotNull TextureCreation bottomTexture, @NotNull TextureCreation sideTexture, @NotNull TextureCreation topTexture) {
+                return this.construct(bottomTexture.create(intention, key), sideTexture.create(intention, key), topTexture.create(intention, key));
+            }
+
+            public @NotNull ModelContentCreation creation(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture) {
+                return (intention, key) -> this.construct(bottomTexture, sideTexture, topTexture);
+            }
+
+            public @NotNull ModelContentCreation creation(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation sideTexture, @NotNull TextureCreation topTexture) {
+                return (intention, key) -> this.create(intention, key, bottomTexture, sideTexture, topTexture);
+            }
+
+            private final @NotNull ModelContentCreation DEFAULT_CREATION = creation(Texture.defaultBottomCreation(), Texture.defaultCreation(), Texture.defaultTopCreation());
+
+            public @NotNull ModelContentCreation defaultCreation() {
+                return this.DEFAULT_CREATION;
+            }
+
+            public @NotNull ModelContentCreation defaultCreationWithAlternativeBottomTop(@NotNull Texture bottomTexture, @NotNull Texture topTexture) {
+                return this.defaultCreationWithAlternativeBottomTop((intention, key) -> bottomTexture, (intention, key) -> topTexture);
+            }
+
+            public @NotNull ModelContentCreation defaultCreationWithAlternativeBottomTop(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation topTexture) {
+                return (intention, key) -> this.create(intention, key, bottomTexture, Texture.defaultCreation(), topTexture);
+            }
+
+        }
+
+    }
+
+    /**
+     * A form of {@link ModelContent}: a full cube with one texture for the bottom, one textures for the x- and z-oriented sides, and one texture for the top
+     */
+    public static final class BottomTopPillarCube extends AbstractBottomTopPillarCube {
+
+        private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("cube_bottom_top"), Existing.getInstance());
+
+        public BottomTopPillarCube(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture) {
+            super(bottomTexture, sideTexture, topTexture);
+        }
+
+        @Override
+        protected @NotNull Model getParent() {
+            return parent;
+        }
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(float outwardDistance) {
+            return OneTextureCube.getCubeOutwardExpandedElements(outwardDistance);
+        }
+
+        public static final @NotNull CreationCompanion<BottomTopPillarCube> creationCompanion = new CreationCompanion<>() {
+
+            @Override
+            protected @NotNull BottomTopPillarCube construct(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture) {
+                return new BottomTopPillarCube(bottomTexture, sideTexture, topTexture);
+            }
+
+        };
+
+    }
+
+    /**
+     * A form of {@link ModelContent}: a bottom half slab with one texture for the bottom, one textures for the x- and z-oriented sides (representing the texture along the entire face, of which the bottom half will be used), and one texture for the top
+     */
+    public static final class BottomSlab extends AbstractBottomTopPillarCube {
+
+        private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("slab"), Existing.getInstance());
+
+        // Based on vanilla Minecraft resource file /assets/minecraft/models/block/slab.json
+        public static @NotNull JsonArray getBottomSlabOutwardExpandedElements(float outwardDistance) {
+            float from = -outwardDistance;
+            float to = 16 + outwardDistance;
+            float toMiddleY = 8 + outwardDistance;
+            return JsonParser.parseString("""
+                [
+                    {   "from": [ %1$f, %1$f, %1$f ],
+                        "to": [ %2$f, %3$f, %2$f ],
+                        "faces": {
+                            "down":  { "uv": [ 0, 0, 16, 16 ], "texture": "#bottom", "cullface": "down" },
+                            "up":    { "uv": [ 0, 0, 16, 16 ], "texture": "#top" },
+                            "north": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "north" },
+                            "south": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "south" },
+                            "west":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "west" },
+                            "east":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "east" }
+                        }
+                    }
+                ]""".formatted(from, to, toMiddleY)
+            ).getAsJsonArray();
+        }
+
+        public BottomSlab(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture) {
+            super(bottomTexture, sideTexture, topTexture);
+        }
+
+        @Override
+        protected @NotNull Model getParent() {
+            return parent;
+        }
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(float outwardDistance) {
+            return getBottomSlabOutwardExpandedElements(outwardDistance);
+        }
+
+        public static final @NotNull CreationCompanion<BottomSlab> creationCompanion = new CreationCompanion<>() {
+
+            @Override
+            protected @NotNull BottomSlab construct(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture) {
+                return new BottomSlab(bottomTexture, sideTexture, topTexture);
+            }
+
+        };
+
+    }
+
+    /**
+     * A form of {@link ModelContent}: a top half slab with one texture for the bottom, one textures for the x- and z-oriented sides (representing the texture along the entire face, of which the top half will be used), and one texture for the top
+     */
+    public static final class TopSlab extends AbstractBottomTopPillarCube {
+
+        private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("slab_top"), Existing.getInstance());
+
+        // Based on vanilla Minecraft resource file /assets/minecraft/models/block/slab_top.json
+        public static @NotNull JsonArray getTopSlabOutwardExpandedElements(float outwardDistance) {
+            float from = -outwardDistance;
+            float fromMiddleY = 8 - outwardDistance;
+            float to = 16 + outwardDistance;
+            return JsonParser.parseString("""
+                [
+                    {   "from": [ %1$f, %2$f, %1$f ],
+                        "to": [ %3$f, %3$f, %3$f ],
+                        "faces": {
+                            "down":  { "uv": [ 0, 0, 16, 16 ], "texture": "#bottom" },
+                            "up":    { "uv": [ 0, 0, 16, 16 ], "texture": "#top", "cullface": "up" },
+                            "north": { "uv": [ 0, 0, 16,  8 ], "texture": "#side", "cullface": "north" },
+                            "south": { "uv": [ 0, 0, 16,  8 ], "texture": "#side", "cullface": "south" },
+                            "west":  { "uv": [ 0, 0, 16,  8 ], "texture": "#side", "cullface": "west" },
+                            "east":  { "uv": [ 0, 0, 16,  8 ], "texture": "#side", "cullface": "east" }
+                        }
+                    }
+                ]""".formatted(from, fromMiddleY, to)
+            ).getAsJsonArray();
+        }
+
+        public TopSlab(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture) {
+            super(bottomTexture, sideTexture, topTexture);
+        }
+
+        @Override
+        protected @NotNull Model getParent() {
+            return parent;
+        }
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(float outwardDistance) {
+            return getTopSlabOutwardExpandedElements(outwardDistance);
+        }
+
+        public static final @NotNull CreationCompanion<TopSlab> creationCompanion = new CreationCompanion<>() {
+
+            @Override
+            protected @NotNull TopSlab construct(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture) {
+                return new TopSlab(bottomTexture, sideTexture, topTexture);
+            }
+
+        };
+
+    }
+
+    /**
+     * Utility class to help with models that have elements that may need to be transformed within the model (rotated or flipped)
+     */
+    public static class TransformableElement {
+
+        public static class TransformableEndpoint {
+
+            private float x, y, z;
+
+            public TransformableEndpoint(float x, float y, float z) {
+                this.x = x;
+                this.y = y;
+                this.z = z;
+            }
+
+            public @NotNull JsonArray toJson() {
+                @NotNull JsonArray json = new JsonArray(3);
+                json.add(this.x);
+                json.add(this.y);
+                json.add(this.z);
+                return json;
+            }
+
+            public void transformAccordingToState(@NotNull Half half, @NotNull Direction facing) {
+                float newX = switch (facing) {
+                    case EAST -> x;
+                    case NORTH -> z;
+                    case WEST -> 16 - x;
+                    case SOUTH -> 16 - z;
+                    default -> throw new IllegalArgumentException("Illegal stairs direction: " + facing);
+                };
+                float newY = switch (half) {
+                    case TOP -> 16 - y;
+                    case BOTTOM -> y;
+                };
+                float newZ = switch (facing) {
+                    case EAST -> z;
+                    case NORTH -> 16 - x;
+                    case WEST -> 16 - z;
+                    case SOUTH -> x;
+                    default -> throw new IllegalArgumentException("Illegal stairs direction: " + facing);
+                };
+                this.x = newX;
+                this.y = newY;
+                this.z = newZ;
+            }
+
+            private float getCoordinate(int axis) {
+                return switch (axis) {
+                    case 0 -> this.x;
+                    case 1 -> this.y;
+                    case 2 -> this.z;
+                    default -> throw new IllegalArgumentException(("Invalid axis index: " + axis));
+                };
+            }
+
+            private void setCoordinate(int axis, float coordinate) {
+                switch (axis) {
+                    case 0 -> this.x = coordinate;
+                    case 1 -> this.y = coordinate;
+                    case 2 -> this.z = coordinate;
+                    default -> throw new IllegalArgumentException(("Invalid axis index: " + axis));
+                };
+            }
+
+            public void swapCoordinatesAsFirstEndpoint(@NotNull TransformableEndpoint secondEndpoint) {
+                for (int axis = 0; axis < 3; axis++) {
+                    if (this.getCoordinate(axis) > secondEndpoint.getCoordinate(axis)) {
+                        float temp = this.getCoordinate(axis);
+                        this.setCoordinate(axis, secondEndpoint.getCoordinate(axis));
+                        secondEndpoint.setCoordinate(axis, temp);
+                    }
+                }
+            }
+
+        }
+
+        public static class TransformableFace {
+
+            public static class TransformableUV {
+
+                public static class TransformableUVEndpoint {
+
+                    private int x, y;
+
+                    public TransformableUVEndpoint(int x, int y) {
+                        this.x = x;
+                        this.y = y;
+                    }
+
+                    public @NotNull JsonArray toJson() {
+                        @NotNull JsonArray json = new JsonArray();
+                        json.add(this.x);
+                        json.add(this.y);
+                        return json;
+                    }
+
+                    public void rotate90DegreesAroundTangentAxis() {
+                        int newX = y;
+                        int newY = 16 - x;
+                        this.x = newX;
+                        this.y = newY;
+                    }
+
+                    public void flipInY() {
+                        this.y = 16 - y;
+                    }
+
+                    private int getCoordinate(int axis) {
+                        return switch (axis) {
+                            case 0 -> this.x;
+                            case 1 -> this.y;
+                            default -> throw new IllegalArgumentException(("Invalid axis index: " + axis));
+                        };
+                    }
+
+                    private void setCoordinate(int axis, int coordinate) {
+                        switch (axis) {
+                            case 0 -> this.x = coordinate;
+                            case 1 -> this.y = coordinate;
+                            default -> throw new IllegalArgumentException(("Invalid axis index: " + axis));
+                        };
+                    }
+
+                    public void swapCoordinatesAsFirstEndpoint(@NotNull TransformableUVEndpoint secondEndpoint) {
+                        for (int axis = 0; axis < 2; axis++) {
+                            if (this.getCoordinate(axis) > secondEndpoint.getCoordinate(axis)) {
+                                int temp = this.getCoordinate(axis);
+                                this.setCoordinate(axis, secondEndpoint.getCoordinate(axis));
+                                secondEndpoint.setCoordinate(axis, temp);
+                            }
+                        }
+                    }
+
+                }
+
+                private final @NotNull TransformableUVEndpoint from, to;
+
+                public TransformableUV(@NotNull TransformableUVEndpoint from, @NotNull TransformableUVEndpoint to) {
+                    this.from = from;
+                    this.to = to;
+                }
+
+                public TransformableUV(@NotNull JsonArray json) {
+                    this(new TransformableUVEndpoint(json.get(0).getAsInt(), json.get(1).getAsInt()), new TransformableUVEndpoint(json.get(2).getAsInt(), json.get(3).getAsInt()));
+                }
+
+                public @NotNull JsonArray toJson() {
+                    @NotNull JsonArray json = new JsonArray();
+                    json.addAll(this.from.toJson());
+                    json.addAll(this.to.toJson());
+                    return json;
+                }
+
+                public void rotate90DegreesAroundTangentAxis() {
+                    this.from.rotate90DegreesAroundTangentAxis();
+                    this.to.rotate90DegreesAroundTangentAxis();
+                    this.from.swapCoordinatesAsFirstEndpoint(this.to);
+                }
+
+                public void flipInY() {
+                    this.from.flipInY();
+                    this.to.flipInY();
+                    this.from.swapCoordinatesAsFirstEndpoint(this.to);
+                }
+
+            }
+
+            private @NotNull Direction facing;
+            private final @NotNull TransformableUV uv;
+            private final @NotNull String texture;
+            private final boolean cullable;
+
+            public TransformableFace(@NotNull Direction facing, @NotNull TransformableUV uv, @NotNull String texture, boolean cullable) {
+                this.facing = facing;
+                this.uv = uv;
+                this.texture = texture;
+                this.cullable = cullable;
+            }
+
+            public TransformableFace(@NotNull Direction facing, @NotNull JsonObject json) {
+                this(facing, new TransformableUV(json.getAsJsonArray("uv")), json.get("texture").getAsString(), json.has("cullface"));
+            }
+
+            public TransformableFace(@NotNull Map.Entry<@NotNull String, @NotNull JsonElement> jsonEntry) {
+                this(Direction.valueOf(jsonEntry.getKey().toUpperCase(Locale.ROOT)), jsonEntry.getValue().getAsJsonObject());
+            }
+
+            public @NotNull Direction getFacing() {
+                return this.facing;
+            }
+
+            public @NotNull JsonObject toJson() {
+                @NotNull JsonObject json = new JsonObject();
+                json.add("uv", uv.toJson());
+                json.addProperty("texture", this.texture);
+                if (this.cullable) {
+                    json.addProperty("cullface", this.facing.name().toLowerCase(Locale.ROOT));
+                }
+                return json;
+            }
+
+            public void transformAccordingToState(@NotNull Half half, @NotNull Direction facing) {
+//                if (half == Half.TOP && this.facing == Direction.UP) {
+//                    System.out.println("TEMP DEBUG - " + System.identityHashCode(this) + " - I'm originally upwards in top, and my uv is " + this.uv.toJson().toString());
+//                }
+                // For sides, we can just switch which face represents which direction based on facing, and keep the uv coordinates the same
+                int rotations = switch (facing) {
+                    case EAST -> 0;
+                    case SOUTH -> 3;
+                    case WEST -> 2;
+                    case NORTH -> 1;
+                    default -> throw new IllegalArgumentException("Illegal stairs direction: " + facing);
+                };
+                for (int rotation = 0; rotation < rotations; rotation++) {
+                    if (this.facing.getAxis().isHorizontal()) {
+                        this.facing = switch (this.facing) {
+                            case EAST -> Direction.NORTH;
+                            case SOUTH -> Direction.EAST;
+                            case WEST -> Direction.SOUTH;
+                            case NORTH -> Direction.WEST;
+                            default -> throw new IllegalStateException("Illegal stairs direction: " + this.facing);
+                        };
+                    } else {
+                        // Rotate the vertical faces simply by transforming the uv coordinates according to the rotation around the y axis, and then fix the coordinates to make the first endpoint coordinate in each axis smaller than the corresponding second endpoint coordinate
+                        uv.rotate90DegreesAroundTangentAxis();
+                    }
+                }
+//                if (half == Half.TOP && this.facing == Direction.UP) {
+//                    System.out.println("TEMP DEBUG - " + System.identityHashCode(this) + " - After " + rotations + " face rotations my uv is " + this.uv.toJson().toString());
+//                }
+                // Half-based changes are only needed for the top
+                if (half == Half.TOP) {
+                    // For the top and bottom, we switch which face represents which direction based on half
+                    if (this.facing.getAxis().isVertical()) {
+                        this.facing = this.facing == Direction.UP ? Direction.DOWN : Direction.UP;
+                        // Fix the uv for faces that now face downwards
+                        if (this.facing == Direction.DOWN) {
+                            if (facing == Direction.NORTH || facing == Direction.SOUTH) {
+                                this.uv.flipInY();
+                            }
+                        }
+                    } else {
+                        // Flip the horizontal faces simply by flipping the uv y coordinates , and then fix the coordinates to make the first endpoint coordinate in each axis smaller than the corresponding second endpoint coordinate
+                        this.uv.flipInY();
+                    }
+                }
+//                if (half == Half.TOP && this.facing == Direction.DOWN) {
+//                    System.out.println("TEMP DEBUG - " + System.identityHashCode(this) + " - Afterwards I'm downwards and my uv is " + this.uv.toJson().toString());
+//                }
+            }
+
+        }
+
+        private final @NotNull TransformableEndpoint from;
+        private final @NotNull TransformableEndpoint to;
+        private @NotNull TransformableFace @NotNull [] faces;
+
+        public TransformableElement(@NotNull TransformableEndpoint from, @NotNull TransformableEndpoint to, @NotNull TransformableFace @NotNull [] faces) {
+            this.from = from;
+            this.to = to;
+            this.faces = faces;
+        }
+
+        public TransformableElement(@NotNull TransformableEndpoint from, @NotNull TransformableEndpoint to, @NotNull String facesJsonString) {
+            this(from, to, JsonParser.parseString(facesJsonString).getAsJsonObject().entrySet().stream().map(TransformableFace::new).toArray(TransformableFace[]::new));
+        }
+
+        public @NotNull JsonObject toJson() {
+            @NotNull JsonObject json = new JsonObject();
+            json.add("from", this.from.toJson());
+            json.add("to", this.to.toJson());
+            @NotNull JsonObject facesJson = new JsonObject();
+            for (@NotNull TransformableFace face : this.faces) {
+                facesJson.add(face.getFacing().name().toLowerCase(Locale.ROOT), face.toJson());
+            }
+            json.add("faces", facesJson);
+            return json;
+        }
+
+        public void transformAccordingToState(@NotNull Half half, @NotNull Direction facing) {
+            // Transform the endpoints individually
+            this.from.transformAccordingToState(half, facing);
+            this.to.transformAccordingToState(half, facing);
+            // Flip coordinates where the from endpoint coordinate is greater than the to endpoint coordinate (which causes the texture to be rendered on the wrong side of the surface)
+            this.from.swapCoordinatesAsFirstEndpoint(this.to);
+            // Transform the faces
+            for (@NotNull TransformableFace face : this.faces) {
+                face.transformAccordingToState(half, facing);
+            }
+        }
+
+    }
+
+    public static abstract class AbstractStairs extends AbstractBottomTopPillarCube {
+
+        public final @NotNull Half half;
+        public final @NotNull Direction facing;
+
+        public AbstractStairs(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+            super(bottomTexture, sideTexture, topTexture);
+            this.half = half;
+            this.facing = facing;
+        }
+
+        public static abstract class CreationCompanion<M extends AbstractStairs> {
+
+            protected abstract @NotNull M construct(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing);
+
+            public @NotNull M create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key, @NotNull TextureCreation bottomTexture, @NotNull TextureCreation sideTexture, @NotNull TextureCreation topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return this.construct(bottomTexture.create(intention, key), sideTexture.create(intention, key), topTexture.create(intention, key), half, facing);
+            }
+
+            public @NotNull ModelContentCreation creation(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return (intention, key) -> this.construct(bottomTexture, sideTexture, topTexture, half, facing);
+            }
+
+            public @NotNull ModelContentCreation creation(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation sideTexture, @NotNull TextureCreation topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return (intention, key) -> this.create(intention, key, bottomTexture, sideTexture, topTexture, half, facing);
+            }
+
+            public @NotNull ModelContentCreation defaultCreation(@NotNull Half half, @NotNull Direction facing) {
+                return creation(Texture.defaultBottomCreation(), Texture.defaultCreation(), Texture.defaultTopCreation(), half, facing);
+            }
+
+            public @NotNull ModelContentCreation defaultCreationWithAlternativeBottomTop(@NotNull Texture bottomTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return this.defaultCreationWithAlternativeBottomTop((intention, key) -> bottomTexture, (intention, key) -> topTexture, half, facing);
+            }
+
+            public @NotNull ModelContentCreation defaultCreationWithAlternativeBottomTop(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return (intention, key) -> this.create(intention, key, bottomTexture, Texture.defaultCreation(), topTexture, half, facing);
+            }
+
+        }
+
+    }
+
+    /**
+     * A form of {@link ModelContent}: straight (not inner or outer) stairs with one texture for the bottom, one textures for the x- and z-oriented sides (representing the texture along the entire face, of which a stair-shaped cut will be used), and one texture for the top
+     */
+    public static final class StraightStairs extends AbstractStairs {
+
+        private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("stairs"), Existing.getInstance());
+
+        // Based on vanilla Minecraft resource file /assets/minecraft/models/block/stairs.json
+        public static @NotNull JsonArray getStraightStairsOutwardExpandedElements(float outwardDistance, @NotNull Half half, @NotNull Direction facing) {
+            float from = -outwardDistance;
+            float to = 16 + outwardDistance;
+            float afterMiddle = 8 + outwardDistance;
+            float beforeMiddle = 8 - outwardDistance;
+            // Initialize the physical coordinates as they would be before state modifications (so currently only the default coordinates with the outward distance applied)
+            TransformableElement[] elements = {
+                new TransformableElement(
+                    new TransformableElement.TransformableEndpoint(from, from, from),
+                    new TransformableElement.TransformableEndpoint(to, afterMiddle, to),
+                    """
+                        {
+                            "down":  { "uv": [ 0, 0, 16, 16 ], "texture": "#bottom", "cullface": "down" },
+                            "up":    { "uv": [ 0, 0, 16, 16 ], "texture": "#top" },
+                            "north": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "north" },
+                            "south": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "south" },
+                            "west":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "west" },
+                            "east":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "east" }
+                        }"""
+                ),
+                new TransformableElement(
+                    new TransformableElement.TransformableEndpoint(beforeMiddle, afterMiddle, from),
+                    new TransformableElement.TransformableEndpoint(to, to, to),
+                    """
+                        {
+                            "up":    { "uv": [ 8, 0, 16, 16 ], "texture": "#top", "cullface": "up" },
+                            "north": { "uv": [ 0, 0,  8,  8 ], "texture": "#side", "cullface": "north" },
+                            "south": { "uv": [ 8, 0, 16,  8 ], "texture": "#side", "cullface": "south" },
+                            "west":  { "uv": [ 0, 0, 16,  8 ], "texture": "#side" },
+                            "east":  { "uv": [ 0, 0, 16,  8 ], "texture": "#side", "cullface": "east" }
+                        }"""
+                )
+            };
+            // Transform the elements according to the state (half and facing)
+            for (TransformableElement element : elements) {
+                element.transformAccordingToState(half, facing);
+            }
+            // Return the elements
+            JsonArray elementsJson = new JsonArray();
+            for (TransformableElement element : elements) {
+                elementsJson.add(element.toJson());
+            }
+            return elementsJson;
+        }
+
+        public StraightStairs(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+            super(bottomTexture, sideTexture, topTexture, half, facing);
+        }
+
+        @Override
+        protected @NotNull Model getParent() {
+            return parent;
+        }
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(float outwardDistance) {
+            return getStraightStairsOutwardExpandedElements(outwardDistance, this.half, this.facing);
+        }
+
+        public static final @NotNull CreationCompanion<StraightStairs> creationCompanion = new CreationCompanion<>() {
+
+            @Override
+            protected @NotNull StraightStairs construct(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return new StraightStairs(bottomTexture, sideTexture, topTexture, half, facing);
+            }
+
+        };
+
+    }
+
+    /**
+     * A form of {@link ModelContent}: left inner stairs with one texture for the bottom, one textures for the x- and z-oriented sides (representing the texture along the entire face, of which a stair-shaped cut will be used), and one texture for the top
+     */
+    public static final class InnerLeftStairs extends AbstractStairs {
+
+        private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("inner_stairs"), Existing.getInstance());
+
+        // Based on vanilla Minecraft resource file /assets/minecraft/models/block/inner_stairs.json
+        public static @NotNull JsonArray getInnerLeftStairsOutwardExpandedElements(float outwardDistance, @NotNull Half half, @NotNull Direction facing) {
+            float from = -outwardDistance;
+            float to = 16 + outwardDistance;
+            float afterMiddle = 8 + outwardDistance;
+            float beforeMiddle = 8 - outwardDistance;
+            // Initialize the physical coordinates as they would be before state modifications (so currently only the default coordinates with the outward distance applied)
+            TransformableElement[] elements = {
+                new TransformableElement(
+                    new TransformableElement.TransformableEndpoint(from, from, from),
+                    new TransformableElement.TransformableEndpoint(to, afterMiddle, to),
+                    """
+                        {
+                 			"down":  { "uv": [ 0, 0, 16, 16 ], "texture": "#bottom", "cullface": "down" },
+                 			"up":    { "uv": [ 0, 0, 16, 16 ], "texture": "#top" },
+                 			"north": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "north" },
+                 			"south": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "south" },
+                 			"west":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "west" },
+                 			"east":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "east" }
+                 		}"""
+                ),
+                new TransformableElement(
+                    new TransformableElement.TransformableEndpoint(beforeMiddle, afterMiddle, from),
+                    new TransformableElement.TransformableEndpoint(to, to, to),
+                    """
+                        {
+                 			"up":    { "uv": [ 8, 0, 16, 16 ], "texture": "#top", "cullface": "up" },
+                 			"north": { "uv": [ 0, 0,  8,  8 ], "texture": "#side", "cullface": "north" },
+                 			"south": { "uv": [ 8, 0, 16,  8 ], "texture": "#side", "cullface": "south" },
+                 			"west":  { "uv": [ 0, 0, 16,  8 ], "texture": "#side" },
+                 			"east":  { "uv": [ 0, 0, 16,  8 ], "texture": "#side", "cullface": "east" }
+                 		}"""
+                ),
+                new TransformableElement(
+                    new TransformableElement.TransformableEndpoint(from, afterMiddle, beforeMiddle),
+                    new TransformableElement.TransformableEndpoint(beforeMiddle, to, to),
+                    """
+                        {
+                 			"up":    { "uv": [ 0, 8,  8, 16 ], "texture": "#top", "cullface": "up" },
+                 			"north": { "uv": [ 8, 0, 16,  8 ], "texture": "#side" },
+                 			"south": { "uv": [ 0, 0,  8,  8 ], "texture": "#side", "cullface": "south" },
+                 			"west":  { "uv": [ 8, 0, 16,  8 ], "texture": "#side", "cullface": "west" }
+                 		}"""
+                )
+            };
+            // Transform the elements according to the state (half and facing)
+            for (TransformableElement element : elements) {
+                element.transformAccordingToState(half, facing);
+            }
+            // Return the elements
+            JsonArray elementsJson = new JsonArray();
+            for (TransformableElement element : elements) {
+                elementsJson.add(element.toJson());
+            }
+            return elementsJson;
+        }
+
+        public InnerLeftStairs(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+            super(bottomTexture, sideTexture, topTexture, half, facing);
+        }
+
+        @Override
+        protected @NotNull Model getParent() {
+            return parent;
+        }
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(float outwardDistance) {
+            return getInnerLeftStairsOutwardExpandedElements(outwardDistance, this.half, this.facing);
+        }
+
+        public static final @NotNull CreationCompanion<InnerLeftStairs> creationCompanion = new CreationCompanion<>() {
+
+            @Override
+            protected @NotNull InnerLeftStairs construct(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return new InnerLeftStairs(bottomTexture, sideTexture, topTexture, half, facing);
+            }
+
+        };
+
+    }
+
+    /**
+     * A form of {@link ModelContent}: left outer stairs with one texture for the bottom, one textures for the x- and z-oriented sides (representing the texture along the entire face, of which a stair-shaped cut will be used), and one texture for the top
+     */
+    public static final class OuterLeftStairs extends AbstractStairs {
+
+        private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("outer_stairs"), Existing.getInstance());
+
+        // Based on vanilla Minecraft resource file /assets/minecraft/models/block/outer_stairs.json
+        public static @NotNull JsonArray getOuterLeftStairsOutwardExpandedElements(float outwardDistance, @NotNull Half half, @NotNull Direction facing) {
+            float from = -outwardDistance;
+            float to = 16 + outwardDistance;
+            float afterMiddle = 8 + outwardDistance;
+            float beforeMiddle = 8 - outwardDistance;
+            // Initialize the physical coordinates as they would be before state modifications (so currently only the default coordinates with the outward distance applied)
+            TransformableElement[] elements = {
+                new TransformableElement(
+                    new TransformableElement.TransformableEndpoint(from, from, from),
+                    new TransformableElement.TransformableEndpoint(to, afterMiddle, to),
+                    """
+                        {
+                 			"down":  { "uv": [ 0, 0, 16, 16 ], "texture": "#bottom", "cullface": "down" },
+                 			"up":    { "uv": [ 0, 0, 16, 16 ], "texture": "#top" },
+                 			"north": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "north" },
+                 			"south": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "south" },
+                 			"west":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "west" },
+                 			"east":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "east" }
+                 		}"""
+                ),
+                new TransformableElement(
+                    new TransformableElement.TransformableEndpoint(beforeMiddle, afterMiddle, beforeMiddle),
+                    new TransformableElement.TransformableEndpoint(to, to, to),
+                    """
+                        {
+                 			"up":    { "uv": [ 8, 8, 16, 16 ], "texture": "#top", "cullface": "up" },
+                 			"north": { "uv": [ 0, 0,  8,  8 ], "texture": "#side" },
+                 			"south": { "uv": [ 8, 0, 16,  8 ], "texture": "#side", "cullface": "south" },
+                 			"west":  { "uv": [ 8, 0, 16,  8 ], "texture": "#side" },
+                 			"east":  { "uv": [ 0, 0,  8,  8 ], "texture": "#side", "cullface": "east" }
+                 		}"""
+                )
+            };
+            // Transform the elements according to the state (half and facing)
+            for (TransformableElement element : elements) {
+                element.transformAccordingToState(half, facing);
+            }
+            // Return the elements
+            JsonArray elementsJson = new JsonArray();
+            for (TransformableElement element : elements) {
+                elementsJson.add(element.toJson());
+            }
+            return elementsJson;
+        }
+
+        public OuterLeftStairs(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+            super(bottomTexture, sideTexture, topTexture, half, facing);
+        }
+
+        @Override
+        protected @NotNull Model getParent() {
+            return parent;
+        }
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(float outwardDistance) {
+            return getOuterLeftStairsOutwardExpandedElements(outwardDistance, this.half, this.facing);
+        }
+
+        public static final @NotNull CreationCompanion<OuterLeftStairs> creationCompanion = new CreationCompanion<>() {
+
+            @Override
+            protected @NotNull OuterLeftStairs construct(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return new OuterLeftStairs(bottomTexture, sideTexture, topTexture, half, facing);
+            }
+
+        };
+
+    }
+
+    /**
+     * A basic form of {@link ModelContent}: a fire model (which is one of several models displayed simultaneously in a fire block: see the fire blockstates)
+     */
+    public static final class Fire extends ModelContent {
+
+        private final @NotNull Model parent;
+        private final @NotNull Texture texture;
+
+        public Fire(@NotNull String modelLocation, @NotNull Texture texture) {
+            super();
+            this.parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("template_fire_" + modelLocation), Existing.getInstance());
+            this.texture = texture;
+        }
+
+        @Override
+        void writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack) {
+            resourcePackModel.setParent(parent);
+            resourcePackModel.setFireTexture(this.texture);
+            this.texture.addToResourcePack(resourcePack, false);
+        }
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(float outwardDistance) {
+            throw new UnsupportedOperationException("Cannot call getOutwardExpandedElements on ModelContent instance of type Fire");
+        }
+
+        public static @NotNull Fire create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key, @NotNull String modelLocation, @NotNull TextureCreation texture) {
+            return new Fire(modelLocation, texture.create(intention, key));
+        }
+
+        public static @NotNull ModelContentCreation creation(@NotNull String modelLocation, @NotNull Texture texture) {
+            return (intention, key) -> new Fire(modelLocation, texture);
+        }
+
+        public static @NotNull ModelContentCreation creation(@NotNull String modelLocation, @NotNull TextureCreation texture) {
+            return (intention, key) -> create(intention, key, modelLocation, texture);
+        }
+
+        public static @NotNull ModelContentCreation defaultCreation(@NotNull String modelLocation) {
+            return creation(modelLocation, Texture.defaultCreation());
+        }
+
+    }
+
+    /**
+     * A reference to some model that is outside the scope of our own resource pack (for example a model already existing, for use as a parent)
+     */
+    public static final class Reference extends ModelContent {
+
+        private final @NotNull Model parent;
+
+        public Reference(@NotNull Model parent) {
+            super();
+            this.parent = parent;
+        }
+
+        @Override
+        void writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack) {
+            resourcePackModel.setParent(parent);
+        }
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(float outwardDistance) throws UnsupportedOperationException {
+            try {
+                return parent.getContent().getOutwardExpandedElements(outwardDistance);
+            } catch (UnsupportedOperationException e) {
+                throw new UnsupportedOperationException("Cannot call getOutwardExpandedElements on ModelContent instance of type Reference for which the parent model itself does not support a call of getOutwarExpandedElements", e);
+            }
+        }
+
+    }
+
+    /**
+     * A form of {@link ModelContent}: a model that refers to a parent, and is equal to it in every way except the size and position it appears with in an equipment head slot (to place it in the right position from the perspective of an armor stand positioned at one of the block corners), and also except for the elements the model is drawn with (which determine the surface), in order to expand them a little bit to draw over the underlying physical block, but under its block break animation
+     */
+    public static final class AsBlockEntityReference extends ModelContent {
+
+        private final @NotNull Model parent;
+        private final @NotNull BlockEntityModelPosition position;
+        private final @NotNull JsonArray outwardExpandedElements;
+
+        public AsBlockEntityReference(@NotNull Model parent, @NotNull BlockEntityModelPosition position, @NotNull JsonArray outwardExpandedElements) {
+            super();
+            this.parent = parent;
+            this.position = position;
+            this.outwardExpandedElements = outwardExpandedElements;
+        }
+
+        @Override
+        void writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack) {
+            resourcePackModel.setParent(this.parent);
+            resourcePackModel.setBlockEntityHeadDisplay(this.position);
+            resourcePackModel.setBlockEntityElements(this.outwardExpandedElements);
+            this.parent.addToResourcePack(resourcePack, false);
+        }
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(float outwardDistance) throws UnsupportedOperationException {
+            throw new UnsupportedOperationException("Cannot call getOutwardExpandedElements on ModelContent instance of type AsBlockEntityReference");
+        }
+
+    }
+
+//    /**
+//     * A form of {@link ModelContent}: a model that refers to a parent, and is equal to it in every way except the size and position it appears with in an equipment head slot
+//     */
+//    public static final class AsBlockEntityReference extends ModelContent {
+//
+//        private final @NotNull Model parent;
+//
+//        public AsBlockEntityReference(@NotNull Model parent) {
+//            super();
+//            this.parent = parent;
+//        }
+//
+//        @Override
+//        void writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack) {
+//            resourcePackModel.setParent(parent);
+//            resourcePackModel.setBlockEntityHeadDisplay();
+//            parent.addToResourcePack(resourcePack, false);
+//        }
+//
+//    }
+
+    /**
+     * A reference to some model that is outside the scope of our own resource pack (for example a model already existing) that we do not seek to modify
+     */
+    public static final class Existing extends ModelContent {
+
+        public enum ExistingModelContentOutwardExpansionType {
+
+            CUBE(OneTextureCube::getCubeOutwardExpandedElements),
+            HORIZONTAL_COLUMN_CUBE(HorizontalYPillarCube::getHorizontalColumnCubeOutwardExpandedElements),
+            BOTTOM_SLAB(BottomSlab::getBottomSlabOutwardExpandedElements),
+            TOP_SLAB(TopSlab::getTopSlabOutwardExpandedElements);
+
+            private final @NotNull Function<@NotNull Float, @NotNull JsonArray> outwardExpandedElementsFunction;
+
+            ExistingModelContentOutwardExpansionType(@NotNull Function<@NotNull Float, @NotNull JsonArray> outwardExpandedElementsFunction) {
+                this.outwardExpandedElementsFunction = outwardExpandedElementsFunction;
+            }
+
+        }
+
+        private final @Nullable ExistingModelContentOutwardExpansionType outwardExpansionType;
+
+        private Existing(@Nullable ExistingModelContentOutwardExpansionType outwardExpansionType) {
+            super();
+            this.outwardExpansionType = outwardExpansionType;
+        }
+
+        /**
+         * Since this is content that already exists, it does not need to be written
+         */
+        @Override
+        void writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack) {}
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(float outwardDistance) throws UnsupportedOperationException {
+            if (this.outwardExpansionType != null) {
+                return this.outwardExpansionType.outwardExpandedElementsFunction.apply(outwardDistance);
+            }
+            throw new UnsupportedOperationException("Cannot call getOutwardExpandedElements on ModelContent instance of type Existing that did not have an outwardExpansionType");
+        }
+
+        private static final @NotNull Existing INSTANCE = new Existing(null);
+
+        public static @NotNull Existing getInstance() {
+            return INSTANCE;
+        }
+
+        private static final @NotNull EnumMap<@NotNull ExistingModelContentOutwardExpansionType, @NotNull Existing> instancesWithOutwardExpansionType = new EnumMap<>(ExistingModelContentOutwardExpansionType.class);
+        static {
+            for (ExistingModelContentOutwardExpansionType type : ExistingModelContentOutwardExpansionType.values()) {
+                instancesWithOutwardExpansionType.put(type, new Existing(type));
+            }
+        }
+
+        public static @NotNull Existing getInstance(@NotNull ExistingModelContentOutwardExpansionType outwardExpansionType) {
+            return instancesWithOutwardExpansionType.get(outwardExpansionType);
+        }
+
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelContentCreation.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelContentCreation.java
new file mode 100644
index 0000000000000000000000000000000000000000..a8d98bfd5aa38c7c0d313855a04a0fcabf7107fb
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelContentCreation.java
@@ -0,0 +1,13 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.blockanditemdata.model;
+
+import net.minecraft.resources.ResourceLocation;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+public interface ModelContentCreation {
+
+    @NotNull ModelContent create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelCreation.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelCreation.java
new file mode 100644
index 0000000000000000000000000000000000000000..f5f95e2387db67cf1aa8c3e1a5da8ee7066c7514
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelCreation.java
@@ -0,0 +1,21 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.blockanditemdata.model;
+
+import net.minecraft.resources.ResourceLocation;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+public interface ModelCreation {
+
+    @NotNull Model create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key);
+
+    default @NotNull ModelCreationWithParameters withParameters(@NotNull ModelParameters parameters) {
+        return new ModelCreationWithParameters(this, parameters);
+    }
+
+    default @NotNull ModelCreationWithParameters withNoParameters() {
+        return new ModelCreationWithParameters(this, null);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelCreationWithParameters.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelCreationWithParameters.java
new file mode 100644
index 0000000000000000000000000000000000000000..066ca7dfc0eedf8bbb2283be3dabc578f7b025f4
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelCreationWithParameters.java
@@ -0,0 +1,19 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.blockanditemdata.model;
+
+import net.minecraft.resources.ResourceLocation;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A {@link ModelCreation}, optionally with accompanying {@link ModelParameters}
+ */
+public record ModelCreationWithParameters(@NotNull ModelCreation modelCreation, @Nullable ModelParameters parameters) {
+
+    public @NotNull ModelWithParameters create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key) {
+        return new ModelWithParameters(modelCreation.create(intention, key), parameters);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelParameters.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelParameters.java
new file mode 100644
index 0000000000000000000000000000000000000000..6a2bc73c958e5c4116fe49fd447ac5072808183a
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelParameters.java
@@ -0,0 +1,26 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.blockanditemdata.model;
+
+import com.google.gson.JsonObject;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Map;
+import java.util.function.Consumer;
+
+/**
+ * Parameters that do not belong to a model, but go with it when setting the model as the model of a block state variant.
+ */
+public final class ModelParameters {
+
+    private final @NotNull JsonObject json = new JsonObject();
+
+    public ModelParameters(@NotNull Consumer<@NotNull JsonObject> jsonInitialization) {
+        jsonInitialization.accept(json);
+    }
+
+    public @NotNull JsonObject getJson() {
+        return this.json;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelWithParameters.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelWithParameters.java
new file mode 100644
index 0000000000000000000000000000000000000000..737300e26856d5efdaf8efcb17c3838850f5c45a
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelWithParameters.java
@@ -0,0 +1,11 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.blockanditemdata.model;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A {@link Model}, optionally with accompanying {@link ModelParameters}
+ */
+public record ModelWithParameters(@NotNull Model model, @Nullable ModelParameters parameters) {}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/Texture.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/Texture.java
new file mode 100644
index 0000000000000000000000000000000000000000..f5a4becb7485702bcea41ed1abfb8cb4a8e9acf8
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/Texture.java
@@ -0,0 +1,87 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.blockanditemdata.texture;
+
+import net.minecraft.resources.ResourceLocation;
+import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelContentCreation;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelCreation;
+import nl.martijnmuijsers.paper.resourcepack.MutableResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackIntentionedAssetDataByContent;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.texture.MutableResourcePackTexture;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.function.Function;
+
+/**
+ * An immutable item or block texture
+ */
+public class Texture extends ResourcePackIntentionedAssetDataByContent<TextureContent> {
+
+    public static final @NotNull String TOP_SUFFIX = "_top";
+    public static final @NotNull String END_SUFFIX = TOP_SUFFIX;
+    public static final @NotNull String BOTTOM_SUFFIX = "_bottom";
+
+    public Texture(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key, @NotNull TextureContent content) {
+        super(intention, key, content);
+    }
+
+    public void addToResourcePack(@NotNull MutableResourcePack resourcePack, boolean overwriteExisting) {
+        @NotNull MutableResourcePackTexture resourcePackTexture = resourcePack.getOrCreateTexture(this.intention, this.key);
+        if (resourcePackTexture.hasData() && !overwriteExisting) {
+            return;
+        }
+        this.content.writeToResourcePackTexture(resourcePackTexture);
+    }
+
+    // Convenience methods for replacement rule builders
+
+    public static @NotNull Texture create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key, @NotNull TextureContent content) {
+        return new Texture(intention, NamespacedKeyWithoutIntention.forMinecraft(key), content);
+    }
+
+    public static @NotNull Texture create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key, @NotNull TextureContentCreation content) {
+        return create(intention, key, content.create(intention, key));
+    }
+
+    public static @NotNull TextureCreation creation(@NotNull TextureContent content) {
+        return (intention, key) -> create(intention, key, content);
+    }
+
+    public static @NotNull TextureCreation creation(@NotNull TextureContentCreation content) {
+        return (intention, key) -> create(intention, key, content);
+    }
+
+    public static @NotNull TextureCreation endCreation(@NotNull TextureContentCreation content) {
+        return (intention, key) -> create(intention, new ResourceLocation(key.getNamespace(), key.getPath() + END_SUFFIX), content);
+    }
+
+    public static @NotNull TextureCreation bottomCreation(@NotNull TextureContentCreation content) {
+        return (intention, key) -> create(intention, new ResourceLocation(key.getNamespace(), key.getPath() + BOTTOM_SUFFIX), content);
+    }
+
+    public static @NotNull TextureCreation topCreation(@NotNull TextureContentCreation content) {
+        return (intention, key) -> create(intention, new ResourceLocation(key.getNamespace(), key.getPath() + TOP_SUFFIX), content);
+    }
+
+    private static final @NotNull TextureCreation DEFAULT_CREATION = creation(TextureContent.ByFileToImportPath.defaultCreation());
+    private static final @NotNull TextureCreation DEFAULT_END_CREATION = endCreation(TextureContent.ByFileToImportPath.defaultCreation());
+    private static final @NotNull TextureCreation DEFAULT_BOTTOM_CREATION = bottomCreation(TextureContent.ByFileToImportPath.defaultCreation());
+    private static final @NotNull TextureCreation DEFAULT_TOP_CREATION = topCreation(TextureContent.ByFileToImportPath.defaultCreation());
+
+    public static @NotNull TextureCreation defaultCreation() {
+        return DEFAULT_CREATION;
+    }
+    public static @NotNull TextureCreation defaultEndCreation() {
+        return DEFAULT_END_CREATION;
+    }
+    public static @NotNull TextureCreation defaultBottomCreation() {
+        return DEFAULT_BOTTOM_CREATION;
+    }
+    public static @NotNull TextureCreation defaultTopCreation() {
+        return DEFAULT_TOP_CREATION;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/TextureContent.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/TextureContent.java
new file mode 100644
index 0000000000000000000000000000000000000000..f03a6387667a06bedfb33b7a0512e599d9b85d27
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/TextureContent.java
@@ -0,0 +1,88 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.blockanditemdata.texture;
+
+import net.minecraft.resources.ResourceLocation;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAssetDataContent;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAssetType;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.texture.MutableResourcePackTexture;
+import nl.martijnmuijsers.paper.resourcepack.sucraft.CreateSuCraftResourcePack;
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Path;
+
+/**
+ * The immutable content of a texture: a {@link Texture} without any information about its appropriate location in a resource pack
+ */
+public abstract class TextureContent implements ResourcePackAssetDataContent {
+
+    protected TextureContent() {}
+
+    public @NotNull Texture asTexture(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) {
+        return new Texture(intention, key, this);
+    }
+
+    abstract void writeToResourcePackTexture(@NotNull MutableResourcePackTexture resourcePackTexture);
+
+    // Convenience methods for replacement rule builders
+
+    /**
+     * A reference to some texture that is outside the scope of our own resource pack (for example a texture already existing)
+     */
+    public static final class Existing extends TextureContent {
+
+        private Existing() {
+            super();
+        }
+
+        /**
+         * Since this is content that already exists, it does not need to be written
+         */
+        @Override
+        void writeToResourcePackTexture(@NotNull MutableResourcePackTexture resourcePackTexture) {}
+
+        private static final @NotNull Existing INSTANCE = new Existing();
+
+        public static @NotNull Existing getInstance() {
+            return INSTANCE;
+        }
+
+    }
+
+    /**
+     * A basic form of {@link TextureContent}: whatever is in the file that the stored path points to
+     */
+    public static final class ByFileToImportPath extends TextureContent {
+
+        private final @NotNull String fileToImportPath;
+
+        public ByFileToImportPath(@NotNull String fileToImportPath) {
+            super();
+            this.fileToImportPath = fileToImportPath;
+        }
+
+        @Override
+        void writeToResourcePackTexture(@NotNull MutableResourcePackTexture resourcePackTexture) {
+            resourcePackTexture.setBasedOnFileToImport(this.fileToImportPath);
+        }
+
+        public static @NotNull TextureContentCreation creation(@NotNull String fileToImportPath) {
+            return (intention, key) -> new ByFileToImportPath(fileToImportPath);
+        }
+
+        public static @NotNull TextureContentCreation creationInDefaultFolder(@NotNull TextureFilenameCreation filename) {
+            return (intention, key) -> new ByFileToImportPath(Path.of(CreateSuCraftResourcePack.INPUT_TEXTURES_FOLDER_PATH, filename.create(intention, key)).toString());
+        }
+
+        private static final @NotNull TextureFilenameCreation DEFAULT_FILENAME = (intention, key) -> NamespacedKeyWithoutIntention.forMinecraft(key).withIntention(intention).keyWithIntention() + ResourcePackAssetType.TEXTURE.getDefaultFileExtension();
+        private static final @NotNull TextureContentCreation DEFAULT_CREATION = creationInDefaultFolder(DEFAULT_FILENAME);
+
+        public static @NotNull TextureContentCreation defaultCreation() {
+            return DEFAULT_CREATION;
+        }
+
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/TextureContentCreation.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/TextureContentCreation.java
new file mode 100644
index 0000000000000000000000000000000000000000..a1141f37a4295bdec3a2b5a2e1f52cf168947861
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/TextureContentCreation.java
@@ -0,0 +1,14 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.blockanditemdata.texture;
+
+import net.minecraft.resources.ResourceLocation;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelContent;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+public interface TextureContentCreation {
+
+    @NotNull TextureContent create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/TextureCreation.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/TextureCreation.java
new file mode 100644
index 0000000000000000000000000000000000000000..df18c89f3e82f74296d2642ac4577ceab9b8e81e
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/TextureCreation.java
@@ -0,0 +1,14 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.blockanditemdata.texture;
+
+import net.minecraft.resources.ResourceLocation;
+import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+public interface TextureCreation {
+
+    @NotNull Texture create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/TextureFilenameCreation.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/TextureFilenameCreation.java
new file mode 100644
index 0000000000000000000000000000000000000000..dbd573f970e913f7f7123dc5d3ccd6c5e377ab73
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/texture/TextureFilenameCreation.java
@@ -0,0 +1,13 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.blockanditemdata.texture;
+
+import net.minecraft.resources.ResourceLocation;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+public interface TextureFilenameCreation {
+
+    @NotNull String create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/command/CustomItemArgument.java b/src/main/java/nl/martijnmuijsers/paper/command/CustomItemArgument.java
new file mode 100644
index 0000000000000000000000000000000000000000..f7141a9887c825afda3e2434ccc0e575244fe79f
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/command/CustomItemArgument.java
@@ -0,0 +1,59 @@
+package nl.martijnmuijsers.paper.command;
+
+import com.mojang.brigadier.StringReader;
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
+import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.brigadier.suggestion.SuggestionsBuilder;
+import net.minecraft.commands.CommandBuildContext;
+import net.minecraft.commands.SharedSuggestionProvider;
+import net.minecraft.commands.arguments.item.ItemArgument;
+import net.minecraft.commands.arguments.item.ItemInput;
+import net.minecraft.commands.arguments.item.ItemParser;
+import net.minecraft.core.HolderLookup;
+import net.minecraft.core.Registry;
+import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.Item;
+import org.apache.commons.lang3.Validate;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.concurrent.CompletableFuture;
+
+public class CustomItemArgument implements ArgumentType<ResourceLocation> {
+
+    private static final Collection<String> EXAMPLES = Arrays.asList("snowy_stone_bricks", "sucraft:snowy_stone_bricks");
+
+    public CustomItemArgument() {}
+
+    public static CustomItemArgument item() {
+        return new CustomItemArgument();
+    }
+
+    public static <S> ItemInput getItem(CommandContext<S> context, String name) {
+        return new ItemInput(Registry.ITEM.getHolderOrThrow(Registry.ITEM.getResourceKey(Registry.ITEM.get(context.getArgument(name, ResourceLocation.class))).get()), null);
+    }
+
+    public ResourceLocation parse(StringReader stringReader) throws CommandSyntaxException {
+        ResourceLocation location = ResourceLocation.read(stringReader);
+        try {
+            Validate.notNull(Registry.ITEM.getHolderOrThrow(Registry.ITEM.getResourceKey(Registry.ITEM.get(location)).get()));
+        } catch (Exception e) {
+            throw ItemParser.ERROR_UNKNOWN_ITEM.createWithContext(stringReader, location);
+        }
+        return location;
+    }
+
+    public <S> CompletableFuture<Suggestions> listSuggestions(CommandContext<S> commandContext, SuggestionsBuilder suggestionsBuilder) {
+        return commandContext.getSource() instanceof SharedSuggestionProvider ? SharedSuggestionProvider.suggestResource(Registry.ITEM.keySet(), suggestionsBuilder) : Suggestions.empty();
+    }
+
+    public Collection<String> getExamples() {
+        return EXAMPLES;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/data/BlackHoleCachedOutput.java b/src/main/java/nl/martijnmuijsers/paper/data/BlackHoleCachedOutput.java
index 6af9cb40f08526365030843ca609220c6c16b120..9f609f9b9df23040416b3907f92cdda28153d0ad 100644
--- a/src/main/java/nl/martijnmuijsers/paper/data/BlackHoleCachedOutput.java
+++ b/src/main/java/nl/martijnmuijsers/paper/data/BlackHoleCachedOutput.java
@@ -4,8 +4,8 @@ package nl.martijnmuijsers.paper.data;
 
 import com.google.common.hash.HashCode;
 import net.minecraft.data.CachedOutput;
+import org.jetbrains.annotations.NotNull;
 
-import java.io.IOException;
 import java.nio.file.Path;
 
 /**
@@ -14,6 +14,6 @@ import java.nio.file.Path;
 public class BlackHoleCachedOutput implements CachedOutput {
 
     @Override
-    public void writeIfNeeded(Path path, byte[] data, HashCode hashCode) {}
+    public void writeIfNeeded(@NotNull Path path, byte @NotNull [] data, @NotNull HashCode hashCode) {}
 
 }
diff --git a/src/main/java/nl/martijnmuijsers/paper/data/SuCraftTagsProvider.java b/src/main/java/nl/martijnmuijsers/paper/data/SuCraftTagsProvider.java
index 1491d5ff59ee49cd230f67eebf705d81c4e17dfb..85bd1d479eee6afcadff7f905548e43ecfdcb649 100644
--- a/src/main/java/nl/martijnmuijsers/paper/data/SuCraftTagsProvider.java
+++ b/src/main/java/nl/martijnmuijsers/paper/data/SuCraftTagsProvider.java
@@ -5,18 +5,21 @@ package nl.martijnmuijsers.paper.data;
 import com.google.common.collect.Maps;
 import net.minecraft.core.Holder;
 import net.minecraft.core.Registry;
+import net.minecraft.data.tags.TagsProvider;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.tags.TagBuilder;
 import net.minecraft.tags.TagEntry;
 import net.minecraft.tags.TagKey;
+import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.stream.Stream;
 
 /**
  * Based on {@link net.minecraft.data.tags.TagsProvider}
@@ -31,7 +34,7 @@ public abstract class SuCraftTagsProvider<T> {
         this.registry = registry;
     }
 
-    protected abstract void addTags();
+    protected abstract void addTags(Map<TagKey<T>, List<Holder<T>>> existingRegistryTagEntries);
 
     public Map<TagKey<T>, List<Holder<T>>> run(Map<TagKey<T>, List<Holder<T>>> existingRegistryTagEntries) {
 
@@ -43,13 +46,13 @@ public abstract class SuCraftTagsProvider<T> {
 
             @Nullable
             @Override
-            public T element(ResourceLocation elementId) {
+            public T element(@NotNull ResourceLocation elementId) {
                 return SuCraftTagsProvider.this.registry.get(elementId);
             }
 
             @Nullable
             @Override
-            public Collection<T> tag(ResourceLocation otherTagId) {
+            public Collection<T> tag(@NotNull ResourceLocation otherTagId) {
                 TagKey<T> otherTagKey = TagKey.create(SuCraftTagsProvider.this.registry.key(), otherTagId);
                 return updatedRegistryTagEntries.get(otherTagKey).stream().map(Holder::value).toList();
             }
@@ -57,16 +60,16 @@ public abstract class SuCraftTagsProvider<T> {
         };
 
         // Create the builders: done by running this method similar to TagsProvider.addTags, which defines the elements for each tag that we wish to add elements to (both elements for custom tags and extra elements for existing tags)
-        this.addTags();
+        this.addTags(existingRegistryTagEntries);
         // For each tag for which entries were added in addTags
         this.builders.forEach((tagId, builder) -> {
             TagKey<T> tagKey = TagKey.create(SuCraftTagsProvider.this.registry.key(), tagId);
             // Get the tag entries that were added for this tag in addTags
             List<TagEntry> tagEntriesToMerge = builder.build();
-            // Filter only thetag  entries that exist (i.e. elements that exist in the registry, or tags that were defined earlier)
+            // Filter only the tag entries that exist (i.e. elements that exist in the registry, or tags that were defined earlier)
             List<TagEntry> validTagEntriesToMerge = new ArrayList<>(tagEntriesToMerge.size());
             tagEntriesToMerge.forEach(tagEntry -> {
-                if (tagEntry.verifyIfPresent(this.registry::containsKey, this.builders::containsKey)) { // Actually using existingRegistryEntries instead of this.builders seems more logical but the vanilla code uses builders so we'll just go with that
+                if (tagEntry.verifyIfPresent(this.registry::containsKey, this.builders::containsKey)) { // Actually using existingRegistryEntries instead of this.builders seems more logical but the vanilla code uses builders, so we'll just go with that
                     validTagEntriesToMerge.add(tagEntry);
                 } else {
                     MinecraftServer.LOGGER.error(String.format("The tag definition %s could not be fully defined as it is missing following reference: %s", tagId, tagEntry));
@@ -76,7 +79,7 @@ public abstract class SuCraftTagsProvider<T> {
             validTagEntriesToMerge.forEach(tagEntry ->
                 tagEntry.build(
                     lookup,
-                    newElement -> {
+                    newElement ->
                         updatedRegistryTagEntries.compute(tagKey, (sameTagKey, elementsForTag) -> {
                             if (elementsForTag == null) {
                                 // Make sure the list of elements for this tag exists
@@ -90,8 +93,7 @@ public abstract class SuCraftTagsProvider<T> {
                             elementsForTag.add(holder);
                             // Return the new list of elements for this tag
                             return elementsForTag;
-                        });
-                    }
+                        })
                 )
             );
         });
@@ -102,20 +104,25 @@ public abstract class SuCraftTagsProvider<T> {
 
     protected TagAppender<T> tag(TagKey<T> tag) {
         TagBuilder tagBuilder = this.getOrCreateRawBuilder(tag);
-        return new TagAppender<>(tagBuilder);
+        return new TagAppender<>(tagBuilder, this.registry);
     }
 
     protected TagBuilder getOrCreateRawBuilder(TagKey<T> tag) {
-        return this.builders.computeIfAbsent(tag.location(), (id) -> {
-            return TagBuilder.create();
-        });
+        return this.builders.computeIfAbsent(tag.location(), (id) -> TagBuilder.create());
     }
 
     protected static class TagAppender<T> {
         private final TagBuilder builder;
+        private final Registry<T> registry;
 
-        TagAppender(TagBuilder builder) {
+        TagAppender(TagBuilder builder, Registry<T> registry) {
             this.builder = builder;
+            this.registry = registry;
+        }
+
+        public TagAppender<T> add(T element) {
+            this.builder.addElement(this.registry.getKey(element));
+            return this;
         }
 
         @SafeVarargs
@@ -141,6 +148,15 @@ public abstract class SuCraftTagsProvider<T> {
             this.builder.addOptionalTag(id);
             return this;
         }
+
+        @SafeVarargs
+        public final TagAppender<T> add(T... elements) {
+            Stream.<T>of(elements).map(this.registry::getKey).forEach((id) -> {
+                this.builder.addElement(id);
+            });
+            return this;
+        }
+
     }
 
 }
diff --git a/src/main/java/nl/martijnmuijsers/paper/item/ItemReplacementRule.java b/src/main/java/nl/martijnmuijsers/paper/item/ItemReplacementRule.java
new file mode 100644
index 0000000000000000000000000000000000000000..b4f907556a20771185be5936aef709e29c10b863
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/item/ItemReplacementRule.java
@@ -0,0 +1,459 @@
+package nl.martijnmuijsers.paper.item;
+
+import com.google.common.collect.Lists;
+import io.papermc.paper.adventure.PaperAdventure;
+import it.unimi.dsi.fastutil.Pair;
+import net.kyori.adventure.text.format.TextDecoration;
+import net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;
+import net.minecraft.ChatFormatting;
+import net.minecraft.core.Registry;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.StringTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.Style;
+import net.minecraft.network.chat.TextColor;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Rarity;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.BlockState;
+import nl.martijnmuijsers.paper.resourcepack.MutableResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.MutableResourcePackModel;
+import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelContent;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.IdentityHashMap;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+
+import static nl.martijnmuijsers.paper.item.SuCraftItems.CUSTOM_DISPLAY_NAME_IN_LORE_DEFAULT_COLOR;
+
+public interface ItemReplacementRule {
+
+    interface Builder {
+
+        @NotNull ItemReplacementRule.Builder withReal(@NotNull Item real);
+
+        @NotNull ItemReplacementRule build();
+
+    }
+
+    @Nullable ItemStack replace(ItemStack item, boolean hasResourcePack, boolean hasHighPing, boolean isStonecutterRecipeResult);
+
+    @NotNull Item getReal();
+
+    @NotNull Model getModel();
+
+    void addToResourcePack(@NotNull MutableResourcePack resourcePack);
+
+    /**
+     * @see SuCraftItems#bootstrap
+     */
+    void initializeOrderSensitiveLateInitializations();
+
+    void setStonecutterRecipeHost(Item item);
+
+    class SimpleItemReplacementRule implements ItemReplacementRule {
+
+        public static class Builder implements ItemReplacementRule.Builder {
+
+            private @Nullable Item real;
+            private @Nullable Supplier<@NotNull Item> lowPingHostSupplier;
+            private @Nullable Function<@NotNull Item, @NotNull Integer> computeLowPingHostCustomModelData;
+            private @Nullable Supplier<@NotNull Item> highPingHostSupplier;
+            private @Nullable Function<@NotNull Item, @NotNull Integer> computeHighPingHostCustomModelData;
+            private @Nullable Supplier<@NotNull Item> fallbackSupplier;
+            private @NotNull Predicate<@NotNull Item> isBlockHostReplacingPredicate = item -> false;
+            private @NotNull Function<@NotNull Item, @Nullable Item> blockHostReplacingItemReplacementFunction = item -> null;
+            private @Nullable Supplier<@NotNull Model> modelSupplier;
+
+            @Override
+            public @NotNull SimpleItemReplacementRule.Builder withReal(@NotNull Item real) {
+                this.real = real;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withLowPingHost(@NotNull Supplier<@NotNull Item> lowPingHostSupplier) {
+                this.lowPingHostSupplier = lowPingHostSupplier;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withLowPingHostCustomModelData(int lowPingHostCustomModelData) {
+                this.computeLowPingHostCustomModelData = host -> lowPingHostCustomModelData;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withNextUnusedLowPingHostCustomModelData() {
+                this.computeLowPingHostCustomModelData = UsedHostCustomModelData::generateUnusedHostCustomModelData;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withHighPingHost(@NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+                this.highPingHostSupplier = highPingHostSupplier;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withHighPingHostCustomModelData(int highPingHostCustomModelData) {
+                this.computeHighPingHostCustomModelData = host -> highPingHostCustomModelData;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withNextUnusedHighPingHostCustomModelData() {
+                this.computeHighPingHostCustomModelData = UsedHostCustomModelData::generateUnusedHostCustomModelData;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withFallback(@NotNull Supplier<@NotNull Item> fallbackSupplier) {
+                this.fallbackSupplier = fallbackSupplier;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withIsBlockHostReplacing(@NotNull Predicate<@NotNull Item> isBlockHostReplacingPredicate) {
+                this.isBlockHostReplacingPredicate = isBlockHostReplacingPredicate;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withBlockHostReplacingItemReplacement(@NotNull Function<@NotNull Item, @Nullable Item> blockHostReplacingItemReplacementFunction) {
+                this.blockHostReplacingItemReplacementFunction = blockHostReplacingItemReplacementFunction;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withModel(@NotNull Model model) {
+                this.modelSupplier = () -> model;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withModelContent(@NotNull ModelContent modelContent) {
+                this.modelSupplier = () -> {
+                    Validate.notNull(this.real);
+                    return modelContent.asModel(ResourcePackAssetIntention.ITEM, NamespacedKeyWithoutIntention.forMinecraft(Registry.ITEM.getKey(this.real)));
+                };
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder forBlock(@NotNull Block block) {
+                return this
+                    .withLowPingHost(() -> block.replacementRule.getRealItemRule().getLowPingHost())
+                    .withHighPingHost(() -> block.replacementRule.getRealItemRule().getHighPingHost())
+                    .withNextUnusedLowPingHostCustomModelData()
+                    .withNextUnusedHighPingHostCustomModelData()
+                    .withFallback(() -> block.replacementRule.getRealItemRule().getFallback())
+                    .withModel(block.replacementRule.getRealItemModel())
+                    .withIsBlockHostReplacing(item -> block.replacementRule.isHostPlacingItem(item))
+                    .withBlockHostReplacingItemReplacement(item -> block.replacementRule.getHostPlacingItemReplacement(item));
+            }
+
+            @Override
+            public @NotNull SimpleItemReplacementRule build() {
+                Validate.notNull(this.real);
+                Validate.notNull(this.lowPingHostSupplier);
+                Validate.notNull(this.computeLowPingHostCustomModelData);
+                Validate.notNull(this.highPingHostSupplier);
+                Validate.notNull(this.computeHighPingHostCustomModelData);
+                Validate.notNull(this.fallbackSupplier);
+                Validate.notNull(this.modelSupplier);
+                return new SimpleItemReplacementRule(this.real, this.lowPingHostSupplier, this.computeLowPingHostCustomModelData, this.highPingHostSupplier, this.computeHighPingHostCustomModelData, this.fallbackSupplier, this.isBlockHostReplacingPredicate, this.blockHostReplacingItemReplacementFunction, this.modelSupplier.get());
+            }
+
+        }
+
+        /**
+         * @see SuCraftItems#bootstrap
+         */
+        private boolean orderSensitiveLateInitializationsHaveStarted = false;
+        private final @NotNull Item real;
+        private @Nullable Item lowPingHost = null;
+        private @Nullable Supplier<@NotNull Item> lowPingHostSupplier;
+        private int lowPingHostCustomModelData = -1;
+        private @Nullable Function<@NotNull Item, @NotNull Integer> computeLowPingHostCustomModelData;
+        private @Nullable Item highPingHost = null;
+        private @Nullable Supplier<@NotNull Item> highPingHostSupplier;
+        private int highPingHostCustomModelData = -1;
+        private @Nullable Function<@NotNull Item, @NotNull Integer> computeHighPingHostCustomModelData;
+        private @Nullable Item stonecutterRecipeHost = null;
+        private int stonecutterRecipeHostCustomModelData = -1;
+        private @Nullable Item fallback = null;
+        private @Nullable Supplier<@NotNull Item> fallbackSupplier;
+        private final @NotNull Predicate<@NotNull Item> isBlockHostReplacingPredicate;
+        private final @NotNull Function<@NotNull Item, @Nullable Item> blockHostReplacingItemReplacementFunction;
+        private final @NotNull Model model;
+
+        private SimpleItemReplacementRule(@NotNull Item real, @NotNull Supplier<@NotNull Item> lowPingHostSupplier, @NotNull Function<@NotNull Item, @NotNull Integer> computeLowPingHostCustomModelData, @NotNull Supplier<@NotNull Item> highPingHostSupplier, @NotNull Function<@NotNull Item, @NotNull Integer> computeHighPingHostCustomModelData, @NotNull Supplier<@NotNull Item> fallbackSupplier, @NotNull Predicate<@NotNull Item> isBlockHostReplacingPredicate, @NotNull Function<@NotNull Item, @Nullable Item> blockHostReplacingItemReplacementFunction, @NotNull Model model) {
+            this.real = real;
+            this.lowPingHostSupplier = lowPingHostSupplier;
+            this.computeLowPingHostCustomModelData = computeLowPingHostCustomModelData;
+            this.highPingHostSupplier = highPingHostSupplier;
+            this.computeHighPingHostCustomModelData = computeHighPingHostCustomModelData;
+            this.fallbackSupplier = fallbackSupplier;
+            this.isBlockHostReplacingPredicate = isBlockHostReplacingPredicate;
+            this.blockHostReplacingItemReplacementFunction = blockHostReplacingItemReplacementFunction;
+            this.model = model;
+            Validate.isTrue(this.model.getIntention() == ResourcePackAssetIntention.ITEM);
+        }
+
+        /**
+         * Will set the display name if there is no custom display name set, and if a custom display name is set, will set the given string as a prefix line in lore (to avoid confusion, by avoiding players having to look at the namespaced key shown with F3+H, which would typically be wrong)
+         * @param tag Optional, just for convenience in case we already have it to avoid unnecessarily retrieving it twice
+         * @param rarity Optional as an override, will otherwise be retrieved from the item if needed
+         */
+        public static void replaceItemStackDisplayName(@NotNull ItemStack item, @Nullable CompoundTag tag, @Nullable Rarity rarity, @NotNull String displayNameJSON, @NotNull String displayNameInLoreJSON) {
+            if (tag == null) {
+                tag = item.getOrCreateTag();
+            }
+            if (rarity == null) {
+                rarity = item.getRarity();
+            }
+            // Setting display name is based on CraftMetaItem.applyToItem(CompoundTag)
+            // Could potentially also be based on ItemStack.setHoverName(Component)
+            final CompoundTag display = tag.getCompound(CraftMetaItem.DISPLAY.NBT);
+            if (!tag.contains(CraftMetaItem.DISPLAY.NBT)) {
+                tag.put(CraftMetaItem.DISPLAY.NBT, display);
+            }
+            if (!display.contains(CraftMetaItem.NAME.NBT)) {
+                display.putString(CraftMetaItem.NAME.NBT, displayNameJSON);
+            } else {
+                display.putString(CraftMetaItem.NAME.NBT, Component.Serializer.toJson(Component.Serializer.fromJson(display.getString(CraftMetaItem.NAME.NBT)).withStyle(Style.EMPTY.withColor(rarity.color))));
+                ListTag lore;
+                if (!display.contains(CraftMetaItem.LORE.NBT)) {
+                    lore = new ListTag();
+                    display.put(CraftMetaItem.LORE.NBT, lore);
+                } else {
+                    lore = display.getList(CraftMetaItem.LORE.NBT, 8);
+                }
+                lore.add(0, StringTag.valueOf(displayNameInLoreJSON));
+            }
+        }
+
+        @Override
+        public @Nullable ItemStack replace(@NotNull ItemStack item, boolean hasResourcePack, boolean hasHighPing, boolean isStonecutterRecipeResult) {
+            if (item.is(this.getReal())) {
+                @NotNull ItemStack clone = item.copy();
+                CompoundTag tag = clone.getOrCreateTag();
+                if (hasResourcePack) {
+                    if (isStonecutterRecipeResult) {
+                        clone.setItem(this.getStonecutterRecipeHost());
+                        // Setting custom model data is based on CraftMetaItem.applyToItem(CompoundTag)
+                        tag.putInt(CraftMetaItem.CUSTOM_MODEL_DATA.NBT, this.getStonecutterRecipeHostCustomModelData());
+                    } else {
+                        clone.setItem(this.getHost(hasHighPing));
+                        // Setting custom model data is based on CraftMetaItem.applyToItem(CompoundTag)
+                        tag.putInt(CraftMetaItem.CUSTOM_MODEL_DATA.NBT, this.getHostCustomModelData(hasHighPing));
+                    }
+                } else {
+                    clone.setItem(this.getFallback());
+                }
+                replaceItemStackDisplayName(clone, tag, item.getRarity(), this.real.customDisplayNameJSON, this.real.customDisplayNameInLoreJSON);
+                storeOriginalItemInfoInItemStackNBT(clone, tag, item);
+                return clone;
+            } else if (this.isBlockHostReplacing(item.getItem()) && hasResourcePack) {
+                @NotNull ItemStack clone = item.copy();
+                clone.setItem(this.getBlockHostReplacingItemReplacement(item.getItem()));
+                var description = Component.translatable(item.getDescriptionId());
+                CompoundTag tag = clone.getOrCreateTag();
+                replaceItemStackDisplayName(clone, tag, item.getRarity(), Component.Serializer.toJson(description.withStyle(Style.EMPTY.withColor(clone.getRarity().color).withItalic(false))), Component.Serializer.toJson(description.withStyle(Style.EMPTY.withColor(CUSTOM_DISPLAY_NAME_IN_LORE_DEFAULT_COLOR).withItalic(false))));
+                storeOriginalItemInfoInItemStackNBT(clone, tag, item);
+                return clone;
+            }
+            return null;
+        }
+
+        @Override
+        public @NotNull Item getReal() {
+            return this.real;
+        }
+
+        public @NotNull Item getLowPingHost() {
+            if (!orderSensitiveLateInitializationsHaveStarted) {
+                throw new IllegalStateException("SimpleItemReplacementRule.getLowPingHost cannot be called before order-sensitive late initialization");
+            }
+            if (this.lowPingHost == null) {
+                this.lowPingHost = this.lowPingHostSupplier.get();
+                this.lowPingHostSupplier = null;
+            }
+            return this.lowPingHost;
+        }
+
+        public int getLowPingHostCustomModelData() {
+            if (!orderSensitiveLateInitializationsHaveStarted) {
+                throw new IllegalStateException("SimpleItemReplacementRule.getLowPingHostCustomModelData cannot be called before order-sensitive late initialization");
+            }
+            if (this.lowPingHostCustomModelData == -1) {
+                this.lowPingHostCustomModelData = this.computeLowPingHostCustomModelData.apply(this.getLowPingHost());
+                this.computeLowPingHostCustomModelData = null;
+            }
+            return this.lowPingHostCustomModelData;
+        }
+
+        public @NotNull Item getHighPingHost() {
+            if (!orderSensitiveLateInitializationsHaveStarted) {
+                throw new IllegalStateException("SimpleItemReplacementRule.getHighPingHost cannot be called before order-sensitive late initialization");
+            }
+            if (this.highPingHost == null) {
+                this.highPingHost = this.highPingHostSupplier.get();
+                this.highPingHostSupplier = null;
+            }
+            return this.highPingHost;
+        }
+
+        public int getHighPingHostCustomModelData() {
+            if (!orderSensitiveLateInitializationsHaveStarted) {
+                throw new IllegalStateException("SimpleItemReplacementRule.getHighPingHostCustomModelData cannot be called before order-sensitive late initialization");
+            }
+            if (this.highPingHostCustomModelData == -1) {
+                this.highPingHostCustomModelData = this.computeHighPingHostCustomModelData.apply(this.getHighPingHost());
+                this.computeHighPingHostCustomModelData = null;
+            }
+            return this.highPingHostCustomModelData;
+        }
+
+        public @NotNull Item getHost(boolean hasHighPing) {
+            return this.getLowPingHost();
+            //return hasHighPing ? this.getHighPingHost() : this.getLowPingHost();
+        }
+
+        /**
+         * @throws IllegalStateException If this rule's real does not require a stonecutter recipe host (i.e. it is not the result of any stonecutter recipe)
+         */
+        public @NotNull Item getStonecutterRecipeHost() {
+            if (this.stonecutterRecipeHost == null) {
+                throw new IllegalStateException("Called SimpleItemReplacementRule.getStonecutterRecipeHost for a rule for which no such host is defined");
+            }
+            return this.stonecutterRecipeHost;
+        }
+
+        public int getHostCustomModelData(boolean hasHighPing) {
+            return this.getLowPingHostCustomModelData();
+            //return hasHighPing ? this.getHighPingHostCustomModelData() : this.getLowPingHostCustomModelData();
+        }
+
+        /**
+         * @throws IllegalStateException If this rule's real does not require a stonecutter recipe host (i.e. it is not the result of any stonecutter recipe)
+         */
+        public @NotNull int getStonecutterRecipeHostCustomModelData() {
+            if (this.stonecutterRecipeHostCustomModelData == -1) {
+                throw new IllegalStateException("Called SimpleItemReplacementRule.getStonecutterRecipeHostCustomModelData for a rule for which no such host is defined");
+            }
+            return this.stonecutterRecipeHostCustomModelData;
+        }
+
+        public @NotNull Item getFallback() {
+            if (this.fallback == null) {
+                this.fallback = this.fallbackSupplier.get();
+                this.fallbackSupplier = null;
+            }
+            return this.fallback;
+        }
+
+        /**
+         * Returns true if the given item is a block item that if placed by a player, would place a block in a state that serves as a host for this item's block,
+         * <br>
+         * or false if:
+         * <ul>
+         *     <li>this item is not for a block, or</li>
+         *     <li>if the block this item is for does not have any hosts that can be the state for a block to appear on using some host block's item to place it</li>
+         * </ul>
+         */
+        private boolean isBlockHostReplacing(@NotNull Item item) {
+            return this.isBlockHostReplacingPredicate.test(item);
+        }
+
+        private @Nullable Item getBlockHostReplacingItemReplacement(@NotNull Item item) {
+            return this.blockHostReplacingItemReplacementFunction.apply(item);
+        }
+
+        @Override
+        public @NotNull Model getModel() {
+            return this.model;
+        }
+
+        @Override
+        public void addToResourcePack(@NotNull MutableResourcePack resourcePack) {
+
+            @NotNull NamespacedKeyWithoutIntention lowPingHostKey = NamespacedKeyWithoutIntention.forMinecraft(Registry.ITEM.getKey(this.getLowPingHost()));
+            @NotNull MutableResourcePackModel lowPingMinecraftItemModel = resourcePack.getModel(ResourcePackAssetIntention.ITEM, lowPingHostKey);
+            lowPingMinecraftItemModel.addModelOverride(this.getLowPingHostCustomModelData(), this.model, resourcePack, false);
+
+            @NotNull NamespacedKeyWithoutIntention highPingHostKey = NamespacedKeyWithoutIntention.forMinecraft(Registry.ITEM.getKey(this.getHighPingHost()));
+            @NotNull MutableResourcePackModel highPingMinecraftItemModel = resourcePack.getModel(ResourcePackAssetIntention.ITEM, highPingHostKey);
+            highPingMinecraftItemModel.addModelOverride(this.getHighPingHostCustomModelData(), this.model, resourcePack, false);
+
+            if (this.stonecutterRecipeHost != null) {
+                @NotNull NamespacedKeyWithoutIntention stonecutterRecipeHostKey = NamespacedKeyWithoutIntention.forMinecraft(Registry.ITEM.getKey(this.stonecutterRecipeHost));
+                @NotNull MutableResourcePackModel stonecutterRecipeMinecraftItemModel = resourcePack.getModel(ResourcePackAssetIntention.ITEM, stonecutterRecipeHostKey);
+                stonecutterRecipeMinecraftItemModel.addModelOverride(this.stonecutterRecipeHostCustomModelData, this.model, resourcePack, false);
+            }
+
+        }
+
+        @Override
+        public void initializeOrderSensitiveLateInitializations() {
+            this.orderSensitiveLateInitializationsHaveStarted = true;
+            this.getLowPingHost();
+            this.getLowPingHostCustomModelData();
+            this.getHighPingHost();
+            this.getHighPingHostCustomModelData();
+        }
+
+        @Override
+        public void setStonecutterRecipeHost(Item item) {
+            this.stonecutterRecipeHost = item;
+            this.stonecutterRecipeHostCustomModelData = UsedHostCustomModelData.generateUnusedHostCustomModelData(this.stonecutterRecipeHost);
+        }
+
+    }
+
+    static @NotNull SimpleItemReplacementRule.Builder simple() {
+        return new SimpleItemReplacementRule.Builder();
+    }
+
+    @NotNull String ORIGINAL_ITEM_INFO_ITEM_STACK_KEY = "OriginalItem";
+
+    /**
+     * @param tag Optional, just for convenience in case we already have it to avoid unnecessarily retrieving it twice
+     */
+    static void storeOriginalItemInfoInItemStackNBT(@NotNull ItemStack itemStack, @Nullable CompoundTag tag, @NotNull ItemStack originalItemStack) {
+        if (tag == null) {
+            tag = itemStack.getOrCreateTag();
+        }
+        tag.put(ORIGINAL_ITEM_INFO_ITEM_STACK_KEY, originalItemStack.save(new CompoundTag()));
+    }
+
+    /**
+     * Reverses {@link #replace} for a given ItemStack, assuming that ItemStack originated from the client, which may send packets containing ItemStacks that are the fake versions that we sent it
+     * <br>
+     * Will return null if and only if given null
+     */
+    static @Nullable ItemStack reverseReplacement(@Nullable ItemStack itemStack) {
+        try {
+            if (itemStack == null) {
+                return null;
+            }
+            @Nullable CompoundTag tag = itemStack.getTag();
+            if (tag == null) {
+                return itemStack;
+            }
+            if (!tag.contains(ORIGINAL_ITEM_INFO_ITEM_STACK_KEY, Tag.TAG_COMPOUND)) {
+                return itemStack;
+            }
+            CompoundTag originalNBT = tag.getCompound(ORIGINAL_ITEM_INFO_ITEM_STACK_KEY);
+            ItemStack original = ItemStack.of(originalNBT);
+            // The intended amount is chosen by the client
+            original.setCount(itemStack.getCount());
+            return original;
+        } catch (Throwable e) {
+            return itemStack;
+        }
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/item/SuCraftCraftingRecipeProvider.java b/src/main/java/nl/martijnmuijsers/paper/item/SuCraftCraftingRecipeProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..ce9744a601bb0835f65e02099d67ebeca72640c4
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/item/SuCraftCraftingRecipeProvider.java
@@ -0,0 +1,142 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.item;
+
+import com.google.common.collect.ImmutableMap;
+import it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenHashMap;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.crafting.Ingredient;
+import net.minecraft.world.item.crafting.Recipe;
+import net.minecraft.world.item.crafting.RecipeManager;
+import net.minecraft.world.item.crafting.RecipeType;
+import net.minecraft.world.item.crafting.StonecutterRecipe;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Arrays;
+import java.util.Map;
+import java.util.stream.Stream;
+
+public final class SuCraftCraftingRecipeProvider {
+
+    private SuCraftCraftingRecipeProvider() {}
+
+    /**
+     * Utility method (shorter)
+     */
+    private static void addRecipe(@NotNull Recipe<?> recipe) {
+        MinecraftServer.getServer().getRecipeManager().addRecipe(recipe);
+    }
+
+    private static void addStonecutterRecipe(@Nullable String key, @Nullable String group, @NotNull Item ingredient, @NotNull Item result, int resultAmount) {
+        if (key == null) {
+            key = result.id.getPath() + "_from_" +  ingredient.id.getPath() + "_stonecutting";
+        }
+        var recipeIngredient = new Ingredient(Stream.of(new Ingredient.ItemValue(new ItemStack(ingredient))));
+        addRecipe(new StonecutterRecipe(ResourceLocation.sucraft(key), group != null ? group : key, recipeIngredient, new ItemStack(result, resultAmount), true));
+    }
+
+    private static void addStonecutterRecipe(@NotNull Item ingredient, @NotNull Item result, int resultAmount) {
+        addStonecutterRecipe(null, null, ingredient, result, resultAmount);
+    }
+
+    private static void addStonecutterRecipe(@NotNull Item ingredient, @NotNull Item result) {
+        addStonecutterRecipe(ingredient, result, 1);
+    }
+
+    public static void run() {
+
+        // Add recipes already defined in items
+
+        for (Item item : Registry.ITEM) {
+            // Add the stonecutter recipes
+            for (var stonecutterRecipe : item.customStonecutterRecipes) {
+//                MinecraftServer.LOGGER.info("TEMP DEBUG - Adding recipe " + stonecutterRecipe.build(item).getIngredients().stream().map(y -> Arrays.stream(y.getItems()).map(x -> x.getItem().id).toList()).toList() + " -> " + stonecutterRecipe.build(item).getType() + " " + stonecutterRecipe.build(item).getId() + " " + stonecutterRecipe.build(item).getResultItem().getItem() + " x " + stonecutterRecipe.build(item).getResultItem().getCount());
+                addRecipe(stonecutterRecipe.build(item));
+            }
+        }
+
+        // Add other recipes
+
+        // Working with wood in stonecutters
+        addStonecutterRecipe(Items.OAK_PLANKS, Items.OAK_STAIRS);
+        addStonecutterRecipe(Items.SPRUCE_PLANKS, Items.SPRUCE_STAIRS);
+        addStonecutterRecipe(Items.BIRCH_PLANKS, Items.BIRCH_STAIRS);
+        addStonecutterRecipe(Items.JUNGLE_PLANKS, Items.JUNGLE_STAIRS);
+        addStonecutterRecipe(Items.ACACIA_PLANKS, Items.ACACIA_STAIRS);
+        addStonecutterRecipe(Items.DARK_OAK_PLANKS, Items.DARK_OAK_STAIRS);
+        addStonecutterRecipe(Items.WARPED_PLANKS, Items.WARPED_STAIRS);
+        addStonecutterRecipe(Items.CRIMSON_PLANKS, Items.CRIMSON_STAIRS);
+        addStonecutterRecipe(Items.MANGROVE_PLANKS, Items.MANGROVE_STAIRS);
+        addStonecutterRecipe(Items.OAK_PLANKS, Items.OAK_SLAB, 2);
+        addStonecutterRecipe(Items.SPRUCE_PLANKS, Items.SPRUCE_SLAB, 2);
+        addStonecutterRecipe(Items.BIRCH_PLANKS, Items.BIRCH_SLAB, 2);
+        addStonecutterRecipe(Items.JUNGLE_PLANKS, Items.JUNGLE_SLAB, 2);
+        addStonecutterRecipe(Items.ACACIA_PLANKS, Items.ACACIA_SLAB, 2);
+        addStonecutterRecipe(Items.DARK_OAK_PLANKS, Items.DARK_OAK_SLAB, 2);
+        addStonecutterRecipe(Items.WARPED_PLANKS, Items.WARPED_SLAB, 2);
+        addStonecutterRecipe(Items.CRIMSON_PLANKS, Items.CRIMSON_SLAB, 2);
+        addStonecutterRecipe(Items.MANGROVE_PLANKS, Items.MANGROVE_SLAB, 2);
+        Stream.of(Items.OAK_LOG, Items.STRIPPED_OAK_LOG, Items.OAK_WOOD, Items.STRIPPED_OAK_WOOD).forEach(ingredient -> {
+            addStonecutterRecipe(ingredient, Items.OAK_PLANKS, 4);
+            addStonecutterRecipe(ingredient, Items.OAK_STAIRS, 4);
+            addStonecutterRecipe(ingredient, Items.OAK_SLAB, 8);
+        });
+        Stream.of(Items.SPRUCE_LOG, Items.STRIPPED_SPRUCE_LOG, Items.SPRUCE_WOOD, Items.STRIPPED_SPRUCE_WOOD).forEach(ingredient -> {
+            addStonecutterRecipe(ingredient, Items.SPRUCE_PLANKS, 4);
+            addStonecutterRecipe(ingredient, Items.SPRUCE_STAIRS, 4);
+            addStonecutterRecipe(ingredient, Items.SPRUCE_SLAB, 8);
+        });
+        Stream.of(Items.BIRCH_LOG, Items.STRIPPED_BIRCH_LOG, Items.BIRCH_WOOD, Items.STRIPPED_BIRCH_WOOD).forEach(ingredient -> {
+            addStonecutterRecipe(ingredient, Items.BIRCH_PLANKS, 4);
+            addStonecutterRecipe(ingredient, Items.BIRCH_STAIRS, 4);
+            addStonecutterRecipe(ingredient, Items.BIRCH_SLAB, 8);
+        });
+        Stream.of(Items.JUNGLE_LOG, Items.STRIPPED_JUNGLE_LOG, Items.JUNGLE_WOOD, Items.STRIPPED_JUNGLE_WOOD).forEach(ingredient -> {
+            addStonecutterRecipe(ingredient, Items.JUNGLE_PLANKS, 4);
+            addStonecutterRecipe(ingredient, Items.JUNGLE_STAIRS, 4);
+            addStonecutterRecipe(ingredient, Items.JUNGLE_SLAB, 8);
+        });
+        Stream.of(Items.ACACIA_LOG, Items.STRIPPED_ACACIA_LOG, Items.ACACIA_WOOD, Items.STRIPPED_ACACIA_WOOD).forEach(ingredient -> {
+            addStonecutterRecipe(ingredient, Items.ACACIA_PLANKS, 4);
+            addStonecutterRecipe(ingredient, Items.ACACIA_STAIRS, 4);
+            addStonecutterRecipe(ingredient, Items.ACACIA_SLAB, 8);
+        });
+        Stream.of(Items.DARK_OAK_LOG, Items.STRIPPED_DARK_OAK_LOG, Items.DARK_OAK_WOOD, Items.STRIPPED_DARK_OAK_WOOD).forEach(ingredient -> {
+            addStonecutterRecipe(ingredient, Items.DARK_OAK_PLANKS, 4);
+            addStonecutterRecipe(ingredient, Items.DARK_OAK_STAIRS, 4);
+            addStonecutterRecipe(ingredient, Items.DARK_OAK_SLAB, 8);
+        });
+        Stream.of(Items.WARPED_STEM, Items.STRIPPED_WARPED_STEM, Items.WARPED_HYPHAE, Items.STRIPPED_WARPED_HYPHAE).forEach(ingredient -> {
+            addStonecutterRecipe(ingredient, Items.WARPED_PLANKS, 4);
+            addStonecutterRecipe(ingredient, Items.WARPED_STAIRS, 4);
+            addStonecutterRecipe(ingredient, Items.WARPED_SLAB, 8);
+        });
+        Stream.of(Items.CRIMSON_STEM, Items.STRIPPED_CRIMSON_STEM, Items.CRIMSON_HYPHAE, Items.STRIPPED_CRIMSON_HYPHAE).forEach(ingredient -> {
+            addStonecutterRecipe(ingredient, Items.CRIMSON_PLANKS, 4);
+            addStonecutterRecipe(ingredient, Items.CRIMSON_STAIRS, 4);
+            addStonecutterRecipe(ingredient, Items.CRIMSON_SLAB, 8);
+        });
+        Stream.of(Items.MANGROVE_LOG, Items.STRIPPED_MANGROVE_LOG, Items.MANGROVE_WOOD, Items.STRIPPED_MANGROVE_WOOD).forEach(ingredient -> {
+            addStonecutterRecipe(ingredient, Items.MANGROVE_PLANKS, 4);
+            addStonecutterRecipe(ingredient, Items.MANGROVE_STAIRS, 4);
+            addStonecutterRecipe(ingredient, Items.MANGROVE_SLAB, 8);
+        });
+
+        // Shortcuts
+        addStonecutterRecipe(Items.BASALT, SuCraftItems.POLISHED_BASALT_SLAB, 2);
+
+        // Quartz meander
+        Stream.of(Items.QUARTZ_BLOCK, Items.CHISELED_QUARTZ_BLOCK).forEach(ingredient -> {
+            addStonecutterRecipe(ingredient, SuCraftItems.QUARTZ_SPIRAL_MEANDER);
+            addStonecutterRecipe(ingredient, SuCraftItems.QUARTZ_SPIRAL_MEANDER_SLAB, 2);
+        });
+
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/item/SuCraftItems.java b/src/main/java/nl/martijnmuijsers/paper/item/SuCraftItems.java
new file mode 100644
index 0000000000000000000000000000000000000000..736cf46f2b2330b8301179f380d308f3348136c7
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/item/SuCraftItems.java
@@ -0,0 +1,540 @@
+
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.item;
+
+import io.papermc.paper.adventure.PaperAdventure;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.TextDecoration;
+import net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;
+import net.minecraft.ChatFormatting;
+import net.minecraft.core.Registry;
+import net.minecraft.world.item.CreativeModeTab;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Blocks;
+import nl.martijnmuijsers.paper.block.SuCraftBlocks;
+import nl.martijnmuijsers.paper.block.replacementrule.BlockReplacementRule;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.function.Function;
+import java.util.function.Supplier;
+
+/**
+ * Based on {@link net.minecraft.world.item.Items}
+ */
+public class SuCraftItems {
+
+    public static final @NotNull ChatFormatting CUSTOM_DISPLAY_NAME_IN_LORE_DEFAULT_COLOR = ChatFormatting.DARK_GRAY;
+
+    public static final Item SNOWY_STONE_BRICKS = registerStoneBricks(SuCraftBlocks.SNOWY_STONE_BRICKS, "Snowy", () -> Items.STONE_BRICKS);
+    public static final Item DIRTY_STONE_BRICKS = registerStoneBricks(SuCraftBlocks.DIRTY_STONE_BRICKS, "Dirty", () -> Items.STONE_BRICKS);
+    public static final Item INFESTED_SNOWY_STONE_BRICKS = registerInfested(SuCraftBlocks.INFESTED_SNOWY_STONE_BRICKS, "Snowy Stone Bricks", () -> Items.STONE_BRICKS);
+    public static final Item INFESTED_DIRTY_STONE_BRICKS = registerInfested(SuCraftBlocks.INFESTED_DIRTY_STONE_BRICKS, "Dirty Stone Bricks", () -> Items.STONE_BRICKS);
+    public static final Item SPRUCE_BOOKSHELF = registerBookshelf(SuCraftBlocks.SPRUCE_BOOKSHELF, "Spruce", () -> Items.SPRUCE_PLANKS);
+    public static final Item BIRCH_BOOKSHELF = registerBookshelf(SuCraftBlocks.BIRCH_BOOKSHELF, "Birch", () -> Items.BIRCH_PLANKS);
+    public static final Item JUNGLE_BOOKSHELF = registerBookshelf(SuCraftBlocks.JUNGLE_BOOKSHELF, "Jungle", () -> Items.JUNGLE_PLANKS);
+    public static final Item ACACIA_BOOKSHELF = registerBookshelf(SuCraftBlocks.ACACIA_BOOKSHELF, "Acacia", () -> Items.ACACIA_PLANKS);
+    public static final Item DARK_OAK_BOOKSHELF = registerBookshelf(SuCraftBlocks.DARK_OAK_BOOKSHELF, "Dark Oak", () -> Items.DARK_OAK_PLANKS);
+    public static final Item WARPED_BOOKSHELF = registerBookshelf(SuCraftBlocks.WARPED_BOOKSHELF, "Warped", () -> Items.WARPED_PLANKS);
+    public static final Item CRIMSON_BOOKSHELF = registerBookshelf(SuCraftBlocks.CRIMSON_BOOKSHELF, "Crimson", () -> Items.CRIMSON_PLANKS);
+//    public static final Item MANGROVE_BOOKSHELF = registerBookshelf(SuCraftBlocks.MANGROVE_BOOKSHELF, "Mangrove", () -> Items.MANGROVE_PLANKS);
+    public static final Item BLACK_PLANKS = registerPlanks(SuCraftBlocks.BLACK_PLANKS, "Black", () -> Items.BLACK_CONCRETE);
+    public static final Item BLUE_PLANKS = registerPlanks(SuCraftBlocks.BLUE_PLANKS, "Blue", () -> Items.BLUE_CONCRETE);
+    public static final Item BROWN_PLANKS = registerPlanks(SuCraftBlocks.BROWN_PLANKS, "Brown", () -> Items.BROWN_CONCRETE);
+    public static final Item CYAN_PLANKS = registerPlanks(SuCraftBlocks.CYAN_PLANKS, "Cyan", () -> Items.CYAN_CONCRETE);
+    public static final Item GRAY_PLANKS = registerPlanks(SuCraftBlocks.GRAY_PLANKS, "Gray", () -> Items.GRAY_CONCRETE);
+    public static final Item GREEN_PLANKS = registerPlanks(SuCraftBlocks.GREEN_PLANKS, "Green", () -> Items.GREEN_CONCRETE);
+    public static final Item LIGHT_BLUE_PLANKS = registerPlanks(SuCraftBlocks.LIGHT_BLUE_PLANKS, "Light Blue", () -> Items.LIGHT_BLUE_CONCRETE);
+    public static final Item LIGHT_GRAY_PLANKS = registerPlanks(SuCraftBlocks.LIGHT_GRAY_PLANKS, "Light Gray", () -> Items.LIGHT_GRAY_CONCRETE);
+    public static final Item LIME_PLANKS = registerPlanks(SuCraftBlocks.LIME_PLANKS, "Lime", () -> Items.LIME_CONCRETE);
+    public static final Item MAGENTA_PLANKS = registerPlanks(SuCraftBlocks.MAGENTA_PLANKS, "Magenta", () -> Items.MAGENTA_CONCRETE);
+    public static final Item ORANGE_PLANKS = registerPlanks(SuCraftBlocks.ORANGE_PLANKS, "Orange", () -> Items.ORANGE_CONCRETE);
+    public static final Item PINK_PLANKS = registerPlanks(SuCraftBlocks.PINK_PLANKS, "Pink", () -> Items.PINK_CONCRETE);
+    public static final Item PURPLE_PLANKS = registerPlanks(SuCraftBlocks.PURPLE_PLANKS, "Purple", () -> Items.PURPLE_CONCRETE);
+    public static final Item RED_PLANKS = registerPlanks(SuCraftBlocks.RED_PLANKS, "Red", () -> Items.RED_CONCRETE);
+    public static final Item WHITE_PLANKS = registerPlanks(SuCraftBlocks.WHITE_PLANKS, "White", () -> Items.WHITE_CONCRETE);
+    public static final Item YELLOW_PLANKS = registerPlanks(SuCraftBlocks.YELLOW_PLANKS, "Yellow", () -> Items.YELLOW_CONCRETE);
+    public static final Item DIRT_BRICKS = registerBricks(SuCraftBlocks.DIRT_BRICKS, "Dirt", () -> Items.DIRT);
+    public static final Item POLISHED_CALCITE = registerPolished(SuCraftBlocks.POLISHED_CALCITE, "Calcite", () -> Items.CALCITE);
+    public static final Item POLISHED_DRIPSTONE = registerPolished(SuCraftBlocks.POLISHED_DRIPSTONE, "Dripstone", () -> Items.DRIPSTONE_BLOCK);
+    public static final Item POLISHED_TUFF = registerPolished(SuCraftBlocks.POLISHED_TUFF, "Tuff", () -> Items.TUFF);
+    public static final Item ANDESITE_BRICKS = registerBricks(SuCraftBlocks.ANDESITE_BRICKS, "Andesite", () -> Items.POLISHED_ANDESITE);
+    public static final Item CALCITE_BRICKS = registerBricks(SuCraftBlocks.CALCITE_BRICKS, "Calcite", () -> Items.CALCITE);
+    public static final Item DIORITE_BRICKS = registerBricks(SuCraftBlocks.DIORITE_BRICKS, "Diorite", () -> Items.POLISHED_DIORITE);
+    public static final Item DRIPSTONE_BRICKS = registerBricks(SuCraftBlocks.DRIPSTONE_BRICKS, "Dripstone", () -> Items.DRIPSTONE_BLOCK);
+    public static final Item GRANITE_BRICKS = registerBricks(SuCraftBlocks.GRANITE_BRICKS, "Granite", () -> Items.POLISHED_GRANITE);
+    public static final Item TUFF_BRICKS = registerBricks(SuCraftBlocks.TUFF_BRICKS, "Tuff", () -> Items.TUFF);
+    public static final Item CHISELED_ANDESITE_BRICKS = registerChiseledBricks(SuCraftBlocks.CHISELED_ANDESITE_BRICKS, "Andesite", () -> Items.POLISHED_ANDESITE);
+    public static final Item CHISELED_CALCITE_BRICKS = registerChiseledBricks(SuCraftBlocks.CHISELED_CALCITE_BRICKS, "Calcite", () -> Items.CALCITE);
+    public static final Item CHISELED_DIORITE_BRICKS = registerChiseledBricks(SuCraftBlocks.CHISELED_DIORITE_BRICKS, "Diorite", () -> Items.POLISHED_DIORITE);
+    public static final Item CHISELED_DRIPSTONE_BRICKS = registerChiseledBricks(SuCraftBlocks.CHISELED_DRIPSTONE_BRICKS, "Dripstone", () -> Items.DRIPSTONE_BLOCK);
+    public static final Item CHISELED_GRANITE_BRICKS = registerChiseledBricks(SuCraftBlocks.CHISELED_GRANITE_BRICKS, "Granite", () -> Items.POLISHED_GRANITE);
+    public static final Item CHISELED_TUFF_BRICKS = registerChiseledBricks(SuCraftBlocks.CHISELED_TUFF_BRICKS, "Tuff", () -> Items.TUFF);
+
+    /**
+     * Based on {@link Items#SANDSTONE}
+     */
+    public static final Item SOUL_SANDSTONE = registerBlock(SuCraftBlocks.SOUL_SANDSTONE, "Soul Sandstone", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.SOUL_SOIL));
+
+    public static final Item SANDSTONE_BRICKS = registerBricks(SuCraftBlocks.SANDSTONE_BRICKS, "Sandstone", () -> Items.SANDSTONE);
+    public static final Item RED_SANDSTONE_BRICKS = registerBricks(SuCraftBlocks.RED_SANDSTONE_BRICKS, "Red Sandstone", () -> Items.RED_SANDSTONE);
+    public static final Item SOUL_SANDSTONE_BRICKS = registerBricks(SuCraftBlocks.SOUL_SANDSTONE_BRICKS, "Soul Sandstone", () -> Items.SOUL_SOIL);
+
+    /**
+     * Based on {@link Items#CHISELED_SANDSTONE}
+     */
+    public static final Item CHISELED_SOUL_SANDSTONE = registerBlock(SuCraftBlocks.CHISELED_SOUL_SANDSTONE, "Chiseled Soul Sandstone", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.SOUL_SOIL));
+
+    /**
+     * Based on {@link Items#CUT_SANDSTONE}
+     */
+    public static final Item CUT_SOUL_SANDSTONE = registerBlock(SuCraftBlocks.CUT_SOUL_SANDSTONE, "Cut Soul Sandstone", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.SOUL_SOIL));
+
+    public static final Item ANDESITE_COBBLESTONE = registerCobblestone(SuCraftBlocks.ANDESITE_COBBLESTONE, "Andesite", () -> Items.ANDESITE);
+    public static final Item DIORITE_COBBLESTONE = registerCobblestone(SuCraftBlocks.DIORITE_COBBLESTONE, "Diorite", () -> Items.DIORITE);
+    public static final Item GRANITE_COBBLESTONE = registerCobblestone(SuCraftBlocks.GRANITE_COBBLESTONE, "Granite", () -> Items.GRANITE);
+    public static final Item CHISELED_PRISMARINE_BRICKS = registerChiseledBricks(SuCraftBlocks.CHISELED_PRISMARINE_BRICKS, "Prismarine", () -> Items.PRISMARINE_BRICKS);
+    public static final Item ANDESITE_PILLAR = registerPillar(SuCraftBlocks.ANDESITE_PILLAR, "Andesite", () -> Items.POLISHED_ANDESITE);
+    public static final Item CALCITE_PILLAR = registerPillar(SuCraftBlocks.CALCITE_PILLAR, "Calcite", () -> Items.CALCITE);
+    public static final Item DIORITE_PILLAR = registerPillar(SuCraftBlocks.DIORITE_PILLAR, "Diorite", () -> Items.POLISHED_DIORITE);
+    public static final Item DRIPSTONE_PILLAR = registerPillar(SuCraftBlocks.DRIPSTONE_PILLAR, "Dripstone", () -> Items.DRIPSTONE_BLOCK);
+    public static final Item GRANITE_PILLAR = registerPillar(SuCraftBlocks.GRANITE_PILLAR, "Granite", () -> Items.POLISHED_GRANITE);
+    public static final Item TUFF_PILLAR = registerPillar(SuCraftBlocks.TUFF_PILLAR, "Tuff", () -> Items.TUFF);
+    public static final Item FIERY_BIRCH_LEAVES = registerLeaves(SuCraftBlocks.FIERY_BIRCH_LEAVES, "Fiery Birch", () -> Items.ACACIA_LEAVES);
+    public static final Item YELLOW_BIRCH_LEAVES = registerLeaves(SuCraftBlocks.YELLOW_BIRCH_LEAVES, "Yellow Birch", () -> Items.ACACIA_LEAVES);
+    public static final Item RED_OAK_LEAVES = registerLeaves(SuCraftBlocks.RED_OAK_LEAVES, "Red Oak", () -> Items.ACACIA_LEAVES);
+    public static final Item ORANGE_OAK_LEAVES = registerLeaves(SuCraftBlocks.ORANGE_OAK_LEAVES, "Orange Oak", () -> Items.ACACIA_LEAVES);
+    public static final Item RED_MAPLE_LEAVES = registerLeaves(SuCraftBlocks.RED_MAPLE_LEAVES, "Red Maple", () -> Items.ACACIA_LEAVES);
+    public static final Item ORANGE_MAPLE_LEAVES = registerLeaves(SuCraftBlocks.ORANGE_MAPLE_LEAVES, "Orange Maple", () -> Items.ACACIA_LEAVES);
+    public static final Item YELLOW_MAPLE_LEAVES = registerLeaves(SuCraftBlocks.YELLOW_MAPLE_LEAVES, "Yellow Maple", () -> Items.ACACIA_LEAVES);
+    public static final Item DIRT_SLAB = registerSlab(SuCraftBlocks.DIRT_SLAB, "Dirt");
+    public static final Item SNOWY_STONE_BRICK_SLAB = registerSlab(SuCraftBlocks.SNOWY_STONE_BRICK_SLAB, "Snowy Stone Brick");
+    public static final Item DIRTY_STONE_BRICK_SLAB = registerSlab(SuCraftBlocks.DIRTY_STONE_BRICK_SLAB, "Dirty Stone Brick");
+    public static final Item CRACKED_STONE_BRICK_SLAB = registerSlab(SuCraftBlocks.CRACKED_STONE_BRICK_SLAB, "Cracked Stone Brick");
+    public static final Item BLACK_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.BLACK_PLANK_SLAB, "Black");
+    public static final Item BLUE_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.BLUE_PLANK_SLAB, "Blue");
+    public static final Item BROWN_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.BROWN_PLANK_SLAB, "Brown");
+    public static final Item CYAN_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.CYAN_PLANK_SLAB, "Cyan");
+    public static final Item GRAY_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.GRAY_PLANK_SLAB, "Gray");
+    public static final Item GREEN_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.GREEN_PLANK_SLAB, "Green");
+    public static final Item LIGHT_BLUE_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.LIGHT_BLUE_PLANK_SLAB, "Light Blue");
+    public static final Item LIGHT_GRAY_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.LIGHT_GRAY_PLANK_SLAB, "Light Gray");
+    public static final Item LIME_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.LIME_PLANK_SLAB, "Lime");
+    public static final Item MAGENTA_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.MAGENTA_PLANK_SLAB, "Magenta");
+    public static final Item ORANGE_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.ORANGE_PLANK_SLAB, "Orange");
+    public static final Item PINK_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.PINK_PLANK_SLAB, "Pink");
+    public static final Item PURPLE_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.PURPLE_PLANK_SLAB, "Purple");
+    public static final Item RED_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.RED_PLANK_SLAB, "Red");
+    public static final Item WHITE_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.WHITE_PLANK_SLAB, "White");
+    public static final Item YELLOW_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.YELLOW_PLANK_SLAB, "Yellow");
+    public static final Item BLACK_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.BLACK_WOOL_SLAB, "Black");
+    public static final Item BLUE_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.BLUE_WOOL_SLAB, "Blue");
+    public static final Item BROWN_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.BROWN_WOOL_SLAB, "Brown");
+    public static final Item CYAN_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.CYAN_WOOL_SLAB, "Cyan");
+    public static final Item GRAY_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.GRAY_WOOL_SLAB, "Gray");
+    public static final Item GREEN_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.GREEN_WOOL_SLAB, "Green");
+    public static final Item LIGHT_BLUE_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.LIGHT_BLUE_WOOL_SLAB, "Light Blue");
+    public static final Item LIGHT_GRAY_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.LIGHT_GRAY_WOOL_SLAB, "Light Gray");
+    public static final Item LIME_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.LIME_WOOL_SLAB, "Lime");
+    public static final Item MAGENTA_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.MAGENTA_WOOL_SLAB, "Magenta");
+    public static final Item ORANGE_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.ORANGE_WOOL_SLAB, "Orange");
+    public static final Item PINK_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.PINK_WOOL_SLAB, "Pink");
+    public static final Item PURPLE_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.PURPLE_WOOL_SLAB, "Purple");
+    public static final Item RED_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.RED_WOOL_SLAB, "Red");
+    public static final Item WHITE_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.WHITE_WOOL_SLAB, "White");
+    public static final Item YELLOW_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.YELLOW_WOOL_SLAB, "Yellow");
+    public static final Item BLACK_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.BLACK_CONCRETE_SLAB, "Black");
+    public static final Item BLUE_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.BLUE_CONCRETE_SLAB, "Blue");
+    public static final Item BROWN_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.BROWN_CONCRETE_SLAB, "Brown");
+    public static final Item CYAN_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.CYAN_CONCRETE_SLAB, "Cyan");
+    public static final Item GRAY_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.GRAY_CONCRETE_SLAB, "Gray");
+    public static final Item GREEN_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.GREEN_CONCRETE_SLAB, "Green");
+    public static final Item LIGHT_BLUE_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.LIGHT_BLUE_CONCRETE_SLAB, "Light Blue");
+    public static final Item LIGHT_GRAY_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.LIGHT_GRAY_CONCRETE_SLAB, "Light Gray");
+    public static final Item LIME_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.LIME_CONCRETE_SLAB, "Lime");
+    public static final Item MAGENTA_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.MAGENTA_CONCRETE_SLAB, "Magenta");
+    public static final Item ORANGE_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.ORANGE_CONCRETE_SLAB, "Orange");
+    public static final Item PINK_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.PINK_CONCRETE_SLAB, "Pink");
+    public static final Item PURPLE_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.PURPLE_CONCRETE_SLAB, "Purple");
+    public static final Item RED_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.RED_CONCRETE_SLAB, "Red");
+    public static final Item WHITE_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.WHITE_CONCRETE_SLAB, "White");
+    public static final Item YELLOW_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.YELLOW_CONCRETE_SLAB, "Yellow");
+    public static final Item BLACK_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.BLACK_CONCRETE_POWDER_SLAB, "Black");
+    public static final Item BLUE_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.BLUE_CONCRETE_POWDER_SLAB, "Blue");
+    public static final Item BROWN_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.BROWN_CONCRETE_POWDER_SLAB, "Brown");
+    public static final Item CYAN_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.CYAN_CONCRETE_POWDER_SLAB, "Cyan");
+    public static final Item GRAY_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.GRAY_CONCRETE_POWDER_SLAB, "Gray");
+    public static final Item GREEN_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.GREEN_CONCRETE_POWDER_SLAB, "Green");
+    public static final Item LIGHT_BLUE_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.LIGHT_BLUE_CONCRETE_POWDER_SLAB, "Light Blue");
+    public static final Item LIGHT_GRAY_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.LIGHT_GRAY_CONCRETE_POWDER_SLAB, "Light Gray");
+    public static final Item LIME_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.LIME_CONCRETE_POWDER_SLAB, "Lime");
+    public static final Item MAGENTA_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.MAGENTA_CONCRETE_POWDER_SLAB, "Magenta");
+    public static final Item ORANGE_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.ORANGE_CONCRETE_POWDER_SLAB, "Orange");
+    public static final Item PINK_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.PINK_CONCRETE_POWDER_SLAB, "Pink");
+    public static final Item PURPLE_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.PURPLE_CONCRETE_POWDER_SLAB, "Purple");
+    public static final Item RED_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.RED_CONCRETE_POWDER_SLAB, "Red");
+    public static final Item WHITE_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.WHITE_CONCRETE_POWDER_SLAB, "White");
+    public static final Item YELLOW_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.YELLOW_CONCRETE_POWDER_SLAB, "Yellow");
+    public static final Item BLACK_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.BLACK_TERRACOTTA_SLAB, "Black");
+    public static final Item BLUE_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.BLUE_TERRACOTTA_SLAB, "Blue");
+    public static final Item BROWN_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.BROWN_TERRACOTTA_SLAB, "Brown");
+    public static final Item CYAN_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.CYAN_TERRACOTTA_SLAB, "Cyan");
+    public static final Item GRAY_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.GRAY_TERRACOTTA_SLAB, "Gray");
+    public static final Item GREEN_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.GREEN_TERRACOTTA_SLAB, "Green");
+    public static final Item LIGHT_BLUE_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.LIGHT_BLUE_TERRACOTTA_SLAB, "Light Blue");
+    public static final Item LIGHT_GRAY_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.LIGHT_GRAY_TERRACOTTA_SLAB, "Light Gray");
+    public static final Item LIME_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.LIME_TERRACOTTA_SLAB, "Lime");
+    public static final Item MAGENTA_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.MAGENTA_TERRACOTTA_SLAB, "Magenta");
+    public static final Item ORANGE_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.ORANGE_TERRACOTTA_SLAB, "Orange");
+    public static final Item PINK_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.PINK_TERRACOTTA_SLAB, "Pink");
+    public static final Item PURPLE_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.PURPLE_TERRACOTTA_SLAB, "Purple");
+    public static final Item RED_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.RED_TERRACOTTA_SLAB, "Red");
+    public static final Item WHITE_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.WHITE_TERRACOTTA_SLAB, "White");
+    public static final Item YELLOW_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.YELLOW_TERRACOTTA_SLAB, "Yellow Terracotta");
+    public static final Item COARSE_DIRT_SLAB = registerSlab(SuCraftBlocks.COARSE_DIRT_SLAB, "Coarse Dirt");
+    public static final Item SAND_SLAB = registerSlab(SuCraftBlocks.SAND_SLAB, "Sand");
+    public static final Item RED_SAND_SLAB = registerSlab(SuCraftBlocks.RED_SAND_SLAB, "Red Sand");
+    public static final Item CLAY_SLAB = registerSlab(SuCraftBlocks.CLAY_SLAB, "Clay");
+    public static final Item MUD_SLAB = registerSlab(SuCraftBlocks.MUD_SLAB, "Mud");
+    public static final Item PACKED_MUD_SLAB = registerSlab(SuCraftBlocks.PACKED_MUD_SLAB, "Packed Mud");
+    public static final Item AMETHYST_SLAB = registerSlab(SuCraftBlocks.AMETHYST_SLAB, "Amethyst");
+    public static final Item COAL_SLAB = registerSlab(SuCraftBlocks.COAL_SLAB, "Coal");
+    public static final Item OAK_BOOKSHELF_SLAB = registerBookshelfSlab(SuCraftBlocks.OAK_BOOKSHELF_SLAB, "Oak");
+    public static final Item SPRUCE_BOOKSHELF_SLAB = registerBookshelfSlab(SuCraftBlocks.SPRUCE_BOOKSHELF_SLAB, "Spruce");
+    public static final Item BIRCH_BOOKSHELF_SLAB = registerBookshelfSlab(SuCraftBlocks.BIRCH_BOOKSHELF_SLAB, "Birch");
+    public static final Item JUNGLE_BOOKSHELF_SLAB = registerBookshelfSlab(SuCraftBlocks.JUNGLE_BOOKSHELF_SLAB, "Jungle");
+    public static final Item CALCITE_SLAB = registerSlab(SuCraftBlocks.CALCITE_SLAB, "Calcite");
+    public static final Item DRIPSTONE_SLAB = registerSlab(SuCraftBlocks.DRIPSTONE_SLAB, "Dripstone");
+    public static final Item TUFF_SLAB = registerSlab(SuCraftBlocks.TUFF_SLAB, "Tuff");
+    public static final Item POLISHED_CALCITE_SLAB = registerPolishedSlab(SuCraftBlocks.POLISHED_CALCITE_SLAB, "Calcite");
+    public static final Item POLISHED_DRIPSTONE_SLAB = registerPolishedSlab(SuCraftBlocks.POLISHED_DRIPSTONE_SLAB, "Dripstone");
+    public static final Item POLISHED_TUFF_SLAB = registerPolishedSlab(SuCraftBlocks.POLISHED_TUFF_SLAB, "Tuff");
+    public static final Item ANDESITE_BRICK_SLAB = registerBrickSlab(SuCraftBlocks.ANDESITE_BRICK_SLAB, "Andesite");
+    public static final Item CALCITE_BRICK_SLAB = registerBrickSlab(SuCraftBlocks.CALCITE_BRICK_SLAB, "Calcite");
+    public static final Item DIORITE_BRICK_SLAB = registerBrickSlab(SuCraftBlocks.DIORITE_BRICK_SLAB, "Diorite");
+    public static final Item DRIPSTONE_BRICK_SLAB = registerBrickSlab(SuCraftBlocks.DRIPSTONE_BRICK_SLAB, "Dripstone");
+    public static final Item GRANITE_BRICK_SLAB = registerBrickSlab(SuCraftBlocks.GRANITE_BRICK_SLAB, "Granite");
+    public static final Item TUFF_BRICK_SLAB = registerBrickSlab(SuCraftBlocks.TUFF_BRICK_SLAB, "Tuff");
+    public static final Item ANDESITE_PILLAR_SLAB = registerPillarSlab(SuCraftBlocks.ANDESITE_PILLAR_SLAB, "Andesite");
+    public static final Item CALCITE_PILLAR_SLAB = registerPillarSlab(SuCraftBlocks.CALCITE_PILLAR_SLAB, "Calcite");
+    public static final Item DIORITE_PILLAR_SLAB = registerPillarSlab(SuCraftBlocks.DIORITE_PILLAR_SLAB, "Diorite");
+    public static final Item DRIPSTONE_PILLAR_SLAB = registerPillarSlab(SuCraftBlocks.DRIPSTONE_PILLAR_SLAB, "Dripstone");
+    public static final Item GRANITE_PILLAR_SLAB = registerPillarSlab(SuCraftBlocks.GRANITE_PILLAR_SLAB, "Granite");
+    public static final Item TUFF_PILLAR_SLAB = registerPillarSlab(SuCraftBlocks.TUFF_PILLAR_SLAB, "Tuff");
+    public static final Item SOUL_SANDSTONE_SLAB = registerSlab(SuCraftBlocks.SOUL_SANDSTONE_SLAB, "Soul Sandstone");
+    public static final Item SANDSTONE_BRICK_SLAB = registerSandstoneBrickSlab(SuCraftBlocks.SANDSTONE_BRICK_SLAB, null);
+    public static final Item RED_SANDSTONE_BRICK_SLAB = registerSandstoneBrickSlab(SuCraftBlocks.RED_SANDSTONE_BRICK_SLAB, "Red");
+    public static final Item SOUL_SANDSTONE_BRICK_SLAB = registerSandstoneBrickSlab(SuCraftBlocks.SOUL_SANDSTONE_BRICK_SLAB, "Soul");
+
+    /**
+     * Based on {@link Items#SMOOTH_SANDSTONE}
+     */
+    public static final Item SMOOTH_SOUL_SANDSTONE = registerBlock(SuCraftBlocks.SMOOTH_SOUL_SANDSTONE, "Smooth Soul Sandstone", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.SOUL_SOIL));
+
+    public static final Item SMOOTH_SOUL_SANDSTONE_SLAB = registerSlab(SuCraftBlocks.SMOOTH_SOUL_SANDSTONE_SLAB, "Smooth Soul Sandstone");
+    public static final Item CUT_SOUL_SANDSTONE_SLAB = registerSlab(SuCraftBlocks.CUT_SOUL_SANDSTONE_SLAB, "Cut Soul Sandstone");
+    public static final Item GRAVEL_SLAB = registerSlab(SuCraftBlocks.GRAVEL_SLAB, "Gravel");
+    public static final Item NETHERRACK_SLAB = registerSlab(SuCraftBlocks.NETHERRACK_SLAB, "Netherrack");
+    public static final Item SOUL_SOIL_SLAB = registerSlab(SuCraftBlocks.SOUL_SOIL_SLAB, "Soul Soil");
+    public static final Item RAW_COPPER_SLAB = registerRawMetalSlab(SuCraftBlocks.RAW_COPPER_SLAB, "Copper");
+    public static final Item RAW_GOLD_SLAB = registerRawMetalSlab(SuCraftBlocks.RAW_GOLD_SLAB, "Gold");
+    public static final Item RAW_IRON_SLAB = registerRawMetalSlab(SuCraftBlocks.RAW_IRON_SLAB, "Iron");
+    public static final Item ANCIENT_DEBRIS_SLAB = registerSlab(SuCraftBlocks.ANCIENT_DEBRIS_SLAB, "Ancient Debris");
+    public static final Item DIRT_BRICK_SLAB = registerSlab(SuCraftBlocks.DIRT_BRICK_SLAB, "Dirt Brick");
+    public static final Item STONE_PILLAR = registerPillar(SuCraftBlocks.STONE_PILLAR, "Stone", () -> Items.STONE);
+    public static final Item STONE_PILLAR_SLAB = registerPillarSlab(SuCraftBlocks.STONE_PILLAR_SLAB, "Stone");
+    public static final Item OAK_LOG_SLAB = registerLogSlab(SuCraftBlocks.OAK_LOG_SLAB, "Oak");
+    public static final Item SPRUCE_LOG_SLAB = registerLogSlab(SuCraftBlocks.SPRUCE_LOG_SLAB, "Spruce");
+    public static final Item BIRCH_LOG_SLAB = registerLogSlab(SuCraftBlocks.BIRCH_LOG_SLAB, "Birch");
+    public static final Item JUNGLE_LOG_SLAB = registerLogSlab(SuCraftBlocks.JUNGLE_LOG_SLAB, "Jungle");
+    public static final Item ACACIA_LOG_SLAB = registerLogSlab(SuCraftBlocks.ACACIA_LOG_SLAB, "Acacia");
+    public static final Item DARK_OAK_LOG_SLAB = registerLogSlab(SuCraftBlocks.DARK_OAK_LOG_SLAB, "Dark Oak");
+    public static final Item WARPED_STEM_SLAB = registerStemSlab(SuCraftBlocks.WARPED_STEM_SLAB, "Warped");
+    public static final Item CRIMSON_STEM_SLAB = registerStemSlab(SuCraftBlocks.CRIMSON_STEM_SLAB, "Crimson");
+    public static final Item MANGROVE_LOG_SLAB = registerLogSlab(SuCraftBlocks.MANGROVE_LOG_SLAB, "Mangrove");
+    public static final Item STRIPPED_OAK_LOG_SLAB = registerStrippedLogSlab(SuCraftBlocks.STRIPPED_OAK_LOG_SLAB, "Oak");
+    public static final Item STRIPPED_SPRUCE_LOG_SLAB = registerStrippedLogSlab(SuCraftBlocks.STRIPPED_SPRUCE_LOG_SLAB, "Spruce");
+    public static final Item STRIPPED_BIRCH_LOG_SLAB = registerStrippedLogSlab(SuCraftBlocks.STRIPPED_BIRCH_LOG_SLAB, "Birch");
+    public static final Item STRIPPED_JUNGLE_LOG_SLAB = registerStrippedLogSlab(SuCraftBlocks.STRIPPED_JUNGLE_LOG_SLAB, "Jungle");
+    public static final Item STRIPPED_ACACIA_LOG_SLAB = registerStrippedLogSlab(SuCraftBlocks.STRIPPED_ACACIA_LOG_SLAB, "Acacia");
+    public static final Item STRIPPED_DARK_OAK_LOG_SLAB = registerStrippedLogSlab(SuCraftBlocks.STRIPPED_DARK_OAK_LOG_SLAB, "Dark Oak");
+    public static final Item STRIPPED_WARPED_STEM_SLAB = registerStrippedStemSlab(SuCraftBlocks.STRIPPED_WARPED_STEM_SLAB, "Warped");
+    public static final Item STRIPPED_CRIMSON_STEM_SLAB = registerStrippedStemSlab(SuCraftBlocks.STRIPPED_CRIMSON_STEM_SLAB, "Crimson");
+    public static final Item STRIPPED_MANGROVE_LOG_SLAB = registerStrippedLogSlab(SuCraftBlocks.STRIPPED_MANGROVE_LOG_SLAB, "Mangrove");
+    public static final Item OAK_WOOD_SLAB = registerWoodSlab(SuCraftBlocks.OAK_WOOD_SLAB, "Oak");
+    public static final Item SPRUCE_WOOD_SLAB = registerWoodSlab(SuCraftBlocks.SPRUCE_WOOD_SLAB, "Spruce");
+    public static final Item BIRCH_WOOD_SLAB = registerWoodSlab(SuCraftBlocks.BIRCH_WOOD_SLAB, "Birch");
+    public static final Item JUNGLE_WOOD_SLAB = registerWoodSlab(SuCraftBlocks.JUNGLE_WOOD_SLAB, "Jungle");
+    public static final Item ACACIA_WOOD_SLAB = registerWoodSlab(SuCraftBlocks.ACACIA_WOOD_SLAB, "Acacia");
+    public static final Item DARK_OAK_WOOD_SLAB = registerWoodSlab(SuCraftBlocks.DARK_OAK_WOOD_SLAB, "Dark Oak");
+    public static final Item WARPED_HYPHAE_SLAB = registerHyphaeSlab(SuCraftBlocks.WARPED_HYPHAE_SLAB, "Warped");
+    public static final Item CRIMSON_HYPHAE_SLAB = registerHyphaeSlab(SuCraftBlocks.CRIMSON_HYPHAE_SLAB, "Crimson");
+    public static final Item MANGROVE_WOOD_SLAB = registerWoodSlab(SuCraftBlocks.MANGROVE_WOOD_SLAB, "Mangrove");
+    public static final Item STRIPPED_OAK_WOOD_SLAB = registerStrippedWoodSlab(SuCraftBlocks.STRIPPED_OAK_WOOD_SLAB, "Oak");
+    public static final Item STRIPPED_SPRUCE_WOOD_SLAB = registerStrippedWoodSlab(SuCraftBlocks.STRIPPED_SPRUCE_WOOD_SLAB, "Spruce");
+    public static final Item STRIPPED_BIRCH_WOOD_SLAB = registerStrippedWoodSlab(SuCraftBlocks.STRIPPED_BIRCH_WOOD_SLAB, "Birch");
+    public static final Item STRIPPED_JUNGLE_WOOD_SLAB = registerStrippedWoodSlab(SuCraftBlocks.STRIPPED_JUNGLE_WOOD_SLAB, "Jungle");
+    public static final Item STRIPPED_ACACIA_WOOD_SLAB = registerStrippedWoodSlab(SuCraftBlocks.STRIPPED_ACACIA_WOOD_SLAB, "Acacia");
+    public static final Item STRIPPED_DARK_OAK_WOOD_SLAB = registerStrippedWoodSlab(SuCraftBlocks.STRIPPED_DARK_OAK_WOOD_SLAB, "Dark Oak");
+    public static final Item STRIPPED_WARPED_HYPHAE_SLAB = registerStrippedHyphaeSlab(SuCraftBlocks.STRIPPED_WARPED_HYPHAE_SLAB, "Warped");
+    public static final Item STRIPPED_CRIMSON_HYPHAE_SLAB = registerStrippedHyphaeSlab(SuCraftBlocks.STRIPPED_CRIMSON_HYPHAE_SLAB, "Crimson");
+    public static final Item STRIPPED_MANGROVE_WOOD_SLAB = registerStrippedWoodSlab(SuCraftBlocks.STRIPPED_MANGROVE_WOOD_SLAB, "Mangrove");
+    public static final Item BONE_SLAB = registerSlab(SuCraftBlocks.BONE_SLAB, "Bone");
+
+    /**
+     * Based on {@link Items#BONE_BLOCK}
+     */
+    public static final Item WITHER_BONE_BLOCK = registerBlock(SuCraftBlocks.WITHER_BONE_BLOCK, "Wither Bone Block", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.COAL_BLOCK));
+
+    public static final Item WITHER_BONE_SLAB = registerSlab(SuCraftBlocks.WITHER_BONE_SLAB, "Wither Bone");
+    public static final Item BASALT_SLAB = registerSlab(SuCraftBlocks.BASALT_SLAB, "Basalt");
+    public static final Item POLISHED_BASALT_SLAB = registerSlab(SuCraftBlocks.POLISHED_BASALT_SLAB, "Polished Basalt");
+    public static final Item SMOOTH_BASALT_SLAB = registerSlab(SuCraftBlocks.SMOOTH_BASALT_SLAB, "Smooth Basalt");
+
+    /**
+     * Based on {@link Items#COAL_BLOCK}
+     */
+    public static final Item CHARCOAL_BLOCK = registerBlock(SuCraftBlocks.CHARCOAL_BLOCK, "Charcoal Block", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.COAL_BLOCK));
+
+    public static final Item CHARCOAL_SLAB = registerSlab(SuCraftBlocks.CHARCOAL_SLAB, "Charcoal");
+
+    /**
+     * Based on {@link Items#LIGHT_GRAY_CONCRETE_POWDER}
+     */
+    public static final Item GUNPOWDER_BLOCK = registerBlock(SuCraftBlocks.GUNPOWDER_BLOCK, "Gunpowder Block", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.LIGHT_GRAY_CONCRETE_POWDER));
+
+    public static final Item GUNPOWDER_SLAB = registerSlab(SuCraftBlocks.GUNPOWDER_SLAB, "Gunpowder");
+    public static final Item PEAT = registerBlock(SuCraftBlocks.PEAT, "Peat", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.COARSE_DIRT));
+    public static final Item SMOULDERING_PEAT = registerBlock(SuCraftBlocks.SMOULDERING_PEAT, "Smouldering Peat", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.COARSE_DIRT));
+    public static final Item PEAT_SLAB = registerSlab(SuCraftBlocks.PEAT_SLAB, "Peat");
+    public static final Item SCULK_SLAB = registerSlab(SuCraftBlocks.SCULK_SLAB, "Sculk");
+    public static final Item CHISELED_QUARTZ_SLAB = registerSlab(SuCraftBlocks.CHISELED_QUARTZ_SLAB, "Chiseled Quartz");
+    public static final Item QUARTZ_PILLAR_SLAB = registerPillarSlab(SuCraftBlocks.QUARTZ_PILLAR_SLAB, "Quartz");
+    public static final Item QUARTZ_BRICK_SLAB = registerBrickSlab(SuCraftBlocks.QUARTZ_BRICK_SLAB, "Quartz");
+    public static final Item DRIED_KELP_SLAB = registerSlab(SuCraftBlocks.DRIED_KELP_SLAB, "Dried Kelp");
+    public static final Item PAPER_BLOCK = registerBlock(SuCraftBlocks.PAPER_BLOCK, "Paper Block", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.WHITE_WOOL));
+    public static final Item PAPER_SLAB = registerSlab(SuCraftBlocks.PAPER_SLAB, "Paper");
+    public static final Item QUARTZ_SPIRAL_MEANDER = registerBlock(SuCraftBlocks.QUARTZ_SPIRAL_MEANDER, "Quartz Meander", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.CHISELED_QUARTZ_BLOCK));
+    public static final Item QUARTZ_SPIRAL_MEANDER_SLAB = registerSlab(SuCraftBlocks.QUARTZ_SPIRAL_MEANDER_SLAB, "Quartz Meander");
+    public static final Item ENDER_PEARL_BLOCK = registerBlock(SuCraftBlocks.ENDER_PEARL_BLOCK, "Ender Pearl Block", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.WARPED_PLANKS));
+    public static final Item FLINT_BLOCK = registerBlock(SuCraftBlocks.FLINT_BLOCK, "Flint Block", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.DEEPSLATE_TILES));
+    public static final Item FLINT_PILLAR = registerBlock(SuCraftBlocks.FLINT_PILLAR, "Flint Pillar", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.POLISHED_BASALT));
+    public static final Item FLINT_PILLAR_SLAB = registerSlab(SuCraftBlocks.FLINT_PILLAR_SLAB, "Flint Pillar");
+    public static final Item FLINT_TILES = registerBlock(SuCraftBlocks.FLINT_TILES, "Flint Tiles", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.DEEPSLATE_TILES));
+    public static final Item FLINT_TILE_SLAB = registerSlab(SuCraftBlocks.FLINT_TILE_SLAB, "Flint Tile");
+    public static final Item OBSIDIAN_SLAB = registerSlab(SuCraftBlocks.OBSIDIAN_SLAB, "Obsidian");
+    public static final Item CRYING_OBSIDIAN_SLAB = registerSlab(SuCraftBlocks.CRYING_OBSIDIAN_SLAB, "Crying Obsidian");
+    public static final Item GILDED_BLACKSTONE_SLAB = registerSlab(SuCraftBlocks.GILDED_BLACKSTONE_SLAB, "Gilded Blackstone");
+    public static final Item SNOWY_STONE_BRICK_STAIRS = registerStairs(SuCraftBlocks.SNOWY_STONE_BRICK_STAIRS, "Snowy Stone Brick");
+
+    private static @NotNull Item registerBlock(@NotNull Block block, @NotNull String displayName, CreativeModeTab group) {
+        return registerBlock(block, displayName, group, null);
+    }
+
+    private static @NotNull Item registerBlock(@NotNull Block block, @NotNull String displayName, CreativeModeTab group, @Nullable Function<ItemReplacementRule.SimpleItemReplacementRule.Builder, ItemReplacementRule.SimpleItemReplacementRule.Builder> replacementRuleFunction) {
+        Item registeredItem = Items.registerBlock(block, group);
+        block.customItemForBlock = registeredItem;
+        registeredItem.isVanilla = false;
+        registeredItem.customKey = block.customKey;
+        var replacementRuleBuilder = ItemReplacementRule.simple().withReal(registeredItem).forBlock(block);
+        if (replacementRuleFunction != null) {
+            replacementRuleBuilder = replacementRuleFunction.apply(replacementRuleBuilder);
+        }
+        registeredItem.replacementRule = replacementRuleBuilder.build();
+        registeredItem.customDisplayName = Component.text(displayName, PaperAdventure.asAdventure(registeredItem.rarity.color)).decoration(TextDecoration.ITALIC, false);
+        registeredItem.customDisplayNameJSON = GsonComponentSerializer.gson().serialize(registeredItem.customDisplayName);
+        registeredItem.customDisplayNameInLore = Component.text(displayName, PaperAdventure.asAdventure(CUSTOM_DISPLAY_NAME_IN_LORE_DEFAULT_COLOR)).decoration(TextDecoration.ITALIC, false);
+        registeredItem.customDisplayNameInLoreJSON = GsonComponentSerializer.gson().serialize(registeredItem.customDisplayNameInLore);
+        // Add crafting recipes
+        for (var stonecuttingRecipe : block.customStonecutterRecipes) {
+            registeredItem.withCustomStonecutterRecipe(new Item.CustomStonecutterRecipe(stonecuttingRecipe.key(), stonecuttingRecipe.group(), stonecuttingRecipe.ingredient().asItem(), stonecuttingRecipe.resultAmount()));
+        }
+        return registeredItem;
+    }
+
+    /**
+     * Based on {@link Items#STONE_BRICKS}
+     */
+    private static @NotNull Item registerStoneBricks(@NotNull Block block, @NotNull String typeDisplayName, @NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        return registerBlock(block, typeDisplayName + " Stone Bricks", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(highPingHostSupplier));
+    }
+
+    /**
+     * Based on {@link Items#INFESTED_STONE_BRICKS}
+     */
+    private static @NotNull Item registerInfested(@NotNull Block block, @NotNull String uninfestedDisplayName, @NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        return registerBlock(block, "Infested " + uninfestedDisplayName, CreativeModeTab.TAB_DECORATIONS, rule -> rule.withHighPingHost(highPingHostSupplier));
+    }
+
+    /**
+     * Based on {@link Items#BOOKSHELF}
+     */
+    private static @NotNull Item registerBookshelf(@NotNull Block block, @NotNull String woodTypeDisplayName, @NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        return registerBlock(block, woodTypeDisplayName + " Bookshelf", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(highPingHostSupplier));
+    }
+
+    /**
+     * Based on {@link Items#OAK_PLANKS}
+     */
+    private static @NotNull Item registerPlanks(@NotNull Block block, @NotNull String descriptionDisplayName, @NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        return registerBlock(block, descriptionDisplayName + " Planks", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(highPingHostSupplier));
+    }
+
+    /**
+     * Based on {@link Items#STONE_BRICKS}
+     */
+    private static @NotNull Item registerBricks(@NotNull Block block, @NotNull String typeDisplayName, @NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        return registerBlock(block, typeDisplayName + " Bricks", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(highPingHostSupplier));
+    }
+
+    /**
+     * Based on {@link Items#POLISHED_ANDESITE}
+     */
+    private static @NotNull Item registerPolished(@NotNull Block block, @NotNull String unpolishedDisplayName, @NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        return registerBlock(block, "Polished " + unpolishedDisplayName, CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(highPingHostSupplier));
+    }
+
+    /**
+     * Based on {@link Items#CHISELED_STONE_BRICKS}
+     */
+    private static @NotNull Item registerChiseledBricks(@NotNull Block block, @NotNull String typeDisplayName, @NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        return registerBlock(block, "Chiseled " + typeDisplayName + " Bricks", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(highPingHostSupplier));
+    }
+
+    /**
+     * Based on {@link Items#COBBLESTONE}
+     */
+    private static @NotNull Item registerCobblestone(@NotNull Block block, @NotNull String typeDisplayName, @NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        return registerBlock(block, typeDisplayName + " Cobblestone", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(highPingHostSupplier));
+    }
+
+    /**
+     * Based on {@link Items#QUARTZ_PILLAR}
+     */
+    private static @NotNull Item registerPillar(@NotNull Block block, @NotNull String typeDisplayName, @NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        return registerBlock(block, typeDisplayName + " Pillar", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(highPingHostSupplier));
+    }
+
+    /**
+     * Based on {@link Items#BIRCH_LEAVES}
+     */
+    private static @NotNull Item registerLeaves(@NotNull Block block, @NotNull String typeDisplayName, @NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        return registerBlock(block, typeDisplayName + " Leaves", CreativeModeTab.TAB_DECORATIONS, rule -> rule.withHighPingHost(highPingHostSupplier));
+    }
+
+    /**
+     * Based on {@link Items#OAK_SLAB}
+     */
+    private static @NotNull Item registerSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerBlock(block, typeDisplayName + " Slab", CreativeModeTab.TAB_BUILDING_BLOCKS);
+    }
+
+    /**
+     * Based on {@link Items#OAK_STAIRS}
+     */
+    private static @NotNull Item registerStairs(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerBlock(block, typeDisplayName + " Stairs", CreativeModeTab.TAB_BUILDING_BLOCKS);
+    }
+
+    private static @NotNull Item registerPlankSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Plank");
+    }
+
+    private static @NotNull Item registerWoolSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Wool");
+    }
+
+    private static @NotNull Item registerConcreteSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Concrete");
+    }
+
+    private static @NotNull Item registerConcretePowderSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Concrete Powder");
+    }
+
+    private static @NotNull Item registerTerracottaSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Terracotta");
+    }
+
+    private static @NotNull Item registerBookshelfSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Bookshelf");
+    }
+
+    private static @NotNull Item registerPolishedSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, "Polished " + typeDisplayName);
+    }
+
+    private static @NotNull Item registerBrickSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Brick");
+    }
+
+    private static @NotNull Item registerPillarSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Pillar");
+    }
+
+    private static @NotNull Item registerSandstoneBrickSlab(@NotNull Block block, @Nullable String typeDisplayName) {
+        return registerBrickSlab(block, (typeDisplayName == null ? "" : typeDisplayName + " ") + "Sandstone");
+    }
+
+    private static @NotNull Item registerRawMetalSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, "Raw " + typeDisplayName);
+    }
+
+    private static @NotNull Item registerLogSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Log");
+    }
+
+    private static @NotNull Item registerStemSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Stem");
+    }
+
+    private static @NotNull Item registerStrippedLogSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerLogSlab(block, "Stripped " + typeDisplayName);
+    }
+
+    private static @NotNull Item registerStrippedStemSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerStemSlab(block, "Stripped " + typeDisplayName);
+    }
+
+    private static @NotNull Item registerWoodSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Wood");
+    }
+
+    private static @NotNull Item registerHyphaeSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Hyphae");
+    }
+
+    private static @NotNull Item registerStrippedWoodSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerWoodSlab(block, "Stripped " + typeDisplayName);
+    }
+
+    private static @NotNull Item registerStrippedHyphaeSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerHyphaeSlab(block, "Stripped " + typeDisplayName);
+    }
+
+    public static Item bootstrap() {
+        SNOWY_STONE_BRICKS.toString();
+        // Make sure that the item replacement rule for block items for which the block has some hosts that are potentially placed by vanilla items is registered with those vanilla items
+        for (Block block : Registry.BLOCK) {
+            BlockReplacementRule replacementRule = block.replacementRule;
+            if (replacementRule != null) {
+                for (Item item : replacementRule.getHostPlacingItems()) {
+                    item.replacementRule = block.asItem().replacementRule;
+                }
+            }
+        }
+        // Make sure that all item replacement rule late initializations are performed already (so that we know the order in which they are performed, and the order of for example assigning item host custom model data is consistent regardless of whether the resource pack is being newly created - i.e. regardless of whether ItemReplacementRule.addToResourcePack is called
+        // Item replacement rule late initializations that require consistent order between server sessions (within the same resource pack version), such as ItemReplacementRule.getLowPingHost, ItemReplacementRule.getLowPingHostCustomModelData, ItemReplacementRule.getHighPingHost and ItemReplacementRule.getHighPingHostCustomModelData, must never be called before this point
+        for (Item item : Registry.ITEM) {
+            ItemReplacementRule replacementRule = item.replacementRule;
+            if (replacementRule != null) {
+                replacementRule.initializeOrderSensitiveLateInitializations();
+            }
+        }
+        return SNOWY_STONE_BRICKS;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/item/UsedHostCustomModelData.java b/src/main/java/nl/martijnmuijsers/paper/item/UsedHostCustomModelData.java
new file mode 100644
index 0000000000000000000000000000000000000000..06a0dc24555614354b73c1d863d9e628e4ff84bc
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/item/UsedHostCustomModelData.java
@@ -0,0 +1,30 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.item;
+
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+import net.minecraft.world.item.Item;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A utility class that keeps track of used custom model data in item replacement hosts
+ */
+public final class UsedHostCustomModelData {
+
+    private UsedHostCustomModelData() {}
+
+    private static final @NotNull Object2IntMap<@NotNull Item> lastUsed = new Object2IntOpenHashMap<>(0);
+
+    static {
+        lastUsed.defaultReturnValue(0); // After all, the custom model data 0 is always in use
+    }
+
+    public static int generateUnusedHostCustomModelData(Item host) {
+        int lastUsedCustomModelData = lastUsed.getInt(host);
+        lastUsedCustomModelData++;
+        lastUsed.put(host, lastUsedCustomModelData);
+        return lastUsedCustomModelData;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/json/JsonMerging.java b/src/main/java/nl/martijnmuijsers/paper/json/JsonMerging.java
new file mode 100644
index 0000000000000000000000000000000000000000..be98f3856147b681feb9895423e5f2a49a7f87f5
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/json/JsonMerging.java
@@ -0,0 +1,59 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.json;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Utility class to merge JSON data, with the first provided instance taking precedent over the second one when any conflict arises
+ */
+public final class JsonMerging {
+
+    private JsonMerging() {}
+
+    /**
+     * Returns a new JSON object, the result of merging the two given JSON objects (where the first provided JSON object takes precedence in any conflicts)
+     */
+    public static @NotNull JsonObject merge(@NotNull JsonObject json1, @NotNull JsonObject json2) {
+        JsonObject newJson = json1.deepCopy();
+        mergeIntoObject(newJson, json2);
+        return newJson;
+    }
+
+    /**
+     * Merges the second given JSON object into the first given JSON object (where the first provided JSON object takes precedence in any conflicts)
+     */
+    public static void mergeIntoObject(@NotNull JsonObject json1, @NotNull JsonObject json2) {
+        for (String key : json2.keySet()) {
+            @Nullable JsonElement element2 = json2.get(key);
+            if (element2 != null) {
+                @Nullable JsonElement element1 = json1.get(key);
+                if (element1 == null) {
+                    json1.add(key, element2.deepCopy());
+                } else {
+                    mergeInto(element1, element2);
+                }
+            }
+        }
+    }
+
+    /**
+     * Merges the second given JSON element into the first given JSON element (where the first provided JSON element takes precedence in any conflicts)
+     */
+    public static void mergeInto(@NotNull JsonElement json1, @NotNull JsonElement json2) {
+        if (json1 instanceof JsonArray jsonArray1) {
+            if (json2 instanceof JsonArray jsonArray2) {
+                jsonArray1.addAll(jsonArray2);
+            }
+        } else if (json1 instanceof JsonObject jsonObject1) {
+            if (json2 instanceof JsonObject jsonObject2) {
+                mergeIntoObject(jsonObject1, jsonObject2);
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/protocol/CachableCustomContentReplaceable.java b/src/main/java/nl/martijnmuijsers/paper/protocol/CachableCustomContentReplaceable.java
new file mode 100644
index 0000000000000000000000000000000000000000..c6967b23c422a0e4a0bf6f1a2bcf6465f99106cc
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/protocol/CachableCustomContentReplaceable.java
@@ -0,0 +1,21 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.protocol;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An interface for classes that have custom content that may need to be replaced when being sent to a player
+ */
+public interface CachableCustomContentReplaceable<T extends CachableCustomContentReplaceable<T>> {
+
+    /**
+     * Note: this may not make a full independent copy, merely a copy for the purpose of replacing custom content
+     *
+     * @return A copy of this instances so that it can be modified in-place
+     */
+    @NotNull T copy();
+
+    void replaceCustomContentInPlace(boolean hasResourcePack);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/protocol/ReplacedCustomContentCache.java b/src/main/java/nl/martijnmuijsers/paper/protocol/ReplacedCustomContentCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..f5dabd85a486b834daa902c16b9b960ff385f8b2
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/protocol/ReplacedCustomContentCache.java
@@ -0,0 +1,37 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.protocol;
+
+import javax.annotation.Nullable;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Class to contain a version of an instance that has been modified for players with the resource pack,
+ * and a version for players without the resource pack
+ */
+public class ReplacedCustomContentCache<T extends CachableCustomContentReplaceable<T>> {
+
+    public final @NotNull T original;
+    private @Nullable T withResourcePack;
+    private @Nullable T withoutResourcePack;
+
+    public ReplacedCustomContentCache(@NotNull T original) {
+        this.original = original;
+    }
+
+    public @NotNull T get(boolean hasResourcePack) {
+        if (hasResourcePack) {
+            if (this.withResourcePack == null) {
+                this.withResourcePack = this.original.copy();
+                this.withResourcePack.replaceCustomContentInPlace(true);
+            }
+            return this.withResourcePack;
+        }
+        if (this.withoutResourcePack == null) {
+            this.withoutResourcePack = this.original.copy();
+            this.withoutResourcePack.replaceCustomContentInPlace(false);
+        }
+        return this.withoutResourcePack;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/KeyConstants.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/KeyConstants.java
new file mode 100644
index 0000000000000000000000000000000000000000..87af6516cb683d10753a6d1accfdb9afd9f011fe
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/KeyConstants.java
@@ -0,0 +1,124 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A utility class providing the keys of JSON elements in the resource pack format
+ */
+public final class KeyConstants {
+
+    private KeyConstants() {}
+
+    /**
+     * The key for the global pack instance in pack.mcmeta
+     */
+    public static final @NotNull String pack = "pack";
+
+    /**
+     * The resource pack format version
+     */
+    public static final @NotNull String packFormat = "pack_format";
+
+    /**
+     * The description of a resource pack
+     */
+    public static final @NotNull String packDescription = "description";
+
+    /**
+     * The variants of a block (the block states)
+     */
+    public static final @NotNull String variants = "variants";
+
+    /**
+     * The variant key used as block state variant for blocks that have no block states
+     */
+    public static final @NotNull String noVariant = "";
+
+    /**
+     * The model of a variant (block state) of a block, or of a model override
+     */
+    public static final @NotNull String model = "model";
+
+    /**
+     * The parent of an asset
+     */
+    public static final @NotNull String assetParent = "parent";
+
+    /**
+     * The textures of a model
+     */
+    public static final @NotNull String modelTextures = "textures";
+
+    /**
+     * The inner key of textures of a model representing setting all textures
+     */
+    public static final @NotNull String modelTexturesAll = "all";
+
+    /**
+     * The inner key of textures of a model representing setting the fire texture
+     */
+    public static final @NotNull String modelTexturesFire = "fire";
+
+    /**
+     * The inner key of textures of a model representing setting the textures on a column's ends
+     */
+    public static final @NotNull String modelTexturesEnd = "end";
+
+    /**
+     * The inner key of textures of a model representing setting the textures on a column's sides
+     */
+    public static final @NotNull String modelTexturesSide = "side";
+
+    /**
+     * The inner key of textures of a model representing setting the texture on a column's bottom
+     */
+    public static final @NotNull String modelTexturesBottom = "bottom";
+
+    /**
+     * The inner key of textures of a model representing setting the texture on a column's top
+     */
+    public static final @NotNull String modelTexturesTop = "top";
+
+    /**
+     * The overrides of a model
+     */
+    public static final @NotNull String modelOverrides = "overrides";
+
+    /**
+     * The predicate of a model override
+     */
+    public static final @NotNull String overridePredicate = "predicate";
+
+    /**
+     * The key for custom model data
+     */
+    public static final @NotNull String customModelData = "custom_model_data";
+
+    /**
+     * The key for a model display
+     */
+    public static final @NotNull String display = "display";
+
+    /**
+     * The key for model display settings for the head slot
+     */
+    public static final @NotNull String displayHead = "head";
+
+    /**
+     * The key for a translation model display setting
+     */
+    public static final @NotNull String displayTranslation = "translation";
+
+    /**
+     * The key for a scale model display setting
+     */
+    public static final @NotNull String displayScale = "scale";
+
+    /**
+     * The key for a model's elements
+     */
+    public static final @NotNull String elements = "elements";
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/MutableResourcePack.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/MutableResourcePack.java
new file mode 100644
index 0000000000000000000000000000000000000000..40482092b4e5132462d7947741366d2612f47a9e
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/MutableResourcePack.java
@@ -0,0 +1,75 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.InitializableResourcePackAssetType;
+import nl.martijnmuijsers.paper.resourcepack.asset.MutableResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAssetType;
+import nl.martijnmuijsers.paper.resourcepack.asset.blockstates.MutableResourcePackBlockStates;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.MutableResourcePackModel;
+import nl.martijnmuijsers.paper.resourcepack.asset.texture.MutableResourcePackTexture;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A mutable {@link ResourcePack}
+ */
+public interface MutableResourcePack extends ResourcePack {
+
+    @NotNull ResourcePackSettings getSettings();
+
+    @Override
+    @NotNull MutableResourcePackAsset getAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException;
+
+    @Override
+    default @Nullable MutableResourcePackAsset getOptionalAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) {
+        return (MutableResourcePackAsset) ResourcePack.super.getOptionalAsset(type, key);
+    }
+
+    @NotNull MutableResourcePackAsset getOrCreateAsset(@NotNull InitializableResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException;
+
+    default <T extends MutableResourcePackAsset> @NotNull T getOrCreateAsset(@NotNull InitializableResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key, @NotNull Class<T> clazz) throws IllegalArgumentException {
+        //noinspection unchecked
+        return (T) this.getOrCreateAsset(type, key);
+    }
+
+    default @NotNull MutableResourcePackBlockStates getBlockStates(@NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException {
+        return this.getAsset(ResourcePackAssetType.BLOCK_STATES, key, MutableResourcePackBlockStates.class);
+    }
+
+    default @Nullable MutableResourcePackBlockStates getOptionalBlockStates(@NotNull NamespacedKeyWithIntention key) {
+        return this.getOptionalAsset(ResourcePackAssetType.BLOCK_STATES, key, MutableResourcePackBlockStates.class);
+    }
+
+    default @NotNull MutableResourcePackBlockStates getOrCreateBlockStates(@NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException {
+        return this.getOrCreateAsset(ResourcePackAssetType.BLOCK_STATES, key, MutableResourcePackBlockStates.class);
+    }
+
+    default @NotNull MutableResourcePackModel getModel(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) throws IllegalArgumentException {
+        return this.getAsset(ResourcePackAssetType.MODEL, key.withIntention(intention), MutableResourcePackModel.class);
+    }
+
+    default @Nullable MutableResourcePackModel getOptionalModel(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) {
+        return this.getOptionalAsset(ResourcePackAssetType.MODEL, key.withIntention(intention), MutableResourcePackModel.class);
+    }
+
+    default @NotNull MutableResourcePackModel getOrCreateModel(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) throws IllegalArgumentException {
+        return this.getOrCreateAsset(ResourcePackAssetType.MODEL, key.withIntention(intention), MutableResourcePackModel.class);
+    }
+
+    default @NotNull MutableResourcePackTexture getTexture(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) throws IllegalArgumentException {
+        return this.getAsset(ResourcePackAssetType.TEXTURE, key.withIntention(intention), MutableResourcePackTexture.class);
+    }
+
+    default @Nullable MutableResourcePackTexture getOptionalTexture(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) {
+        return this.getOptionalAsset(ResourcePackAssetType.TEXTURE, key.withIntention(intention), MutableResourcePackTexture.class);
+    }
+
+    default @NotNull MutableResourcePackTexture getOrCreateTexture(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) throws IllegalArgumentException {
+        return this.getOrCreateAsset(ResourcePackAssetType.TEXTURE, key.withIntention(intention), MutableResourcePackTexture.class);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/PathConstants.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/PathConstants.java
new file mode 100644
index 0000000000000000000000000000000000000000..677d97e5ccbaa0ee0e8a4df0072fcc07d8cc0275
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/PathConstants.java
@@ -0,0 +1,114 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A utility class providing the paths of files in the resource pack format
+ */
+public final class PathConstants {
+
+    private PathConstants() {}
+
+    /**
+     * The pack.mcmeta file
+     */
+    public static final class PackMeta {
+
+        public static final @NotNull String name = "pack.mcmeta";
+        public static final @NotNull String pathFromRoot = name;
+
+    }
+
+    /**
+     * The suffix for meta files for files
+     */
+    public static final String metaFileSuffix = ".mcmeta";
+
+    /**
+     * The assets folder
+     */
+    public static final class Assets {
+
+        public static final @NotNull String name = "assets";
+        public static final @NotNull String pathFromRoot = name;
+
+    }
+
+    /**
+     * The blockstates folder
+     */
+    public static final class BlockStates {
+
+        public static final @NotNull String name = "blockstates";
+        public static final @NotNull String pathInNamespaceFolder = name;
+
+    }
+
+    /**
+     * The models folder
+     */
+    public static final class Models {
+
+        public static final @NotNull String name = "models";
+        public static final @NotNull String pathInNamespaceFolder = name;
+
+        /**
+         * The block models folder
+         */
+        public static final class Block {
+
+            public static final @NotNull String name = ResourcePackAssetIntention.BLOCK.prefix;
+            public static final @NotNull String pathInNamespaceFolder = Models.pathInNamespaceFolder + "/" + name;
+
+        }
+
+        /**
+         * The item models folder
+         */
+        public static final class Item {
+
+            public static final @NotNull String name = ResourcePackAssetIntention.ITEM.prefix;
+            public static final @NotNull String pathInNamespaceFolder = Models.pathInNamespaceFolder + "/" + name;
+
+        }
+
+    }
+
+    /**
+     * The textures folder
+     */
+    public static final class Textures {
+
+        public static final @NotNull String name = "textures";
+        public static final @NotNull String pathInNamespaceFolder = name;
+
+        /**
+         * The block textures folder
+         */
+        public static final class Block {
+
+            public static final @NotNull String name = ResourcePackAssetIntention.BLOCK.prefix;
+            public static final @NotNull String pathInNamespaceFolder = Textures.pathInNamespaceFolder + "/" + name;
+
+        }
+
+        /**
+         * The item textures folder
+         */
+        public static final class Item {
+
+            public static final @NotNull String name = ResourcePackAssetIntention.ITEM.prefix;
+            public static final @NotNull String pathInNamespaceFolder = Textures.pathInNamespaceFolder + "/" + name;
+
+        }
+
+    }
+
+    public static @NotNull String getNamespaceFolderPathFromRoot(@NotNull String namespace) {
+        return Assets.pathFromRoot + "/" + namespace;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/ResourcePack.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/ResourcePack.java
new file mode 100644
index 0000000000000000000000000000000000000000..2cd9daad642bb1a76e8173a8231d1742c74e86e9
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/ResourcePack.java
@@ -0,0 +1,75 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack;
+
+import it.unimi.dsi.fastutil.Pair;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAssetType;
+import nl.martijnmuijsers.paper.resourcepack.asset.blockstates.ResourcePackBlockStates;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.ResourcePackModel;
+import nl.martijnmuijsers.paper.resourcepack.asset.texture.ResourcePackTexture;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.concurrent.Callable;
+import java.util.stream.Stream;
+
+/**
+ * An interface that provides getters to get things out of an existing resource pack, for example one defined by an archive filename, or one currently being built in memory.
+ */
+public interface ResourcePack {
+
+    @NotNull Stream<@NotNull Pair<@NotNull String, @NotNull Callable<@NotNull InputStream>>> getAllFilesStream() throws IOException;
+
+    @NotNull ResourcePackSettings getSettings();
+
+    @NotNull ResourcePackAsset getAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException;
+
+    default @Nullable ResourcePackAsset getOptionalAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) {
+        try {
+            return this.getAsset(type, key);
+        } catch (Exception e) {
+            return null;
+        }
+    }
+
+    default <T extends ResourcePackAsset> @NotNull T getAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key, @NotNull Class<T> clazz) throws IllegalArgumentException {
+        //noinspection unchecked
+        return (T) this.getAsset(type, key);
+    }
+
+    default <T extends ResourcePackAsset> @Nullable T getOptionalAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key, @NotNull Class<T> clazz) {
+        //noinspection unchecked
+        return (T) this.getOptionalAsset(type, key);
+    }
+
+    default @NotNull ResourcePackBlockStates getBlockStates(@NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException {
+        return this.getAsset(ResourcePackAssetType.BLOCK_STATES, key, ResourcePackBlockStates.class);
+    }
+
+    default @Nullable ResourcePackBlockStates getOptionalBlockStates(@NotNull NamespacedKeyWithIntention key) {
+        return this.getOptionalAsset(ResourcePackAssetType.BLOCK_STATES, key, ResourcePackBlockStates.class);
+    }
+
+    default @NotNull ResourcePackModel getModel(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) throws IllegalArgumentException {
+        return this.getAsset(ResourcePackAssetType.MODEL, key.withIntention(intention), ResourcePackModel.class);
+    }
+
+    default @Nullable ResourcePackModel getOptionalModel(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) {
+        return this.getOptionalAsset(ResourcePackAssetType.MODEL, key.withIntention(intention), ResourcePackModel.class);
+    }
+
+    default @NotNull ResourcePackTexture getTexture(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) throws IllegalArgumentException {
+        return this.getAsset(ResourcePackAssetType.TEXTURE, key.withIntention(intention), ResourcePackTexture.class);
+    }
+
+    default @Nullable ResourcePackTexture getOptionalTexture(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) {
+        return this.getOptionalAsset(ResourcePackAssetType.TEXTURE, key.withIntention(intention), ResourcePackTexture.class);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/ResourcePackHash.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/ResourcePackHash.java
new file mode 100644
index 0000000000000000000000000000000000000000..dd244b1b7bc4045e2b7b13aeaa7a9bdb49579206
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/ResourcePackHash.java
@@ -0,0 +1,47 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.math.BigInteger;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+/**
+ * Utility class to compute the SHA-1 hash of the resource pack archive file
+ */
+public final class ResourcePackHash {
+
+    private static final @NotNull String algorithm = "SHA-1";
+
+    private ResourcePackHash() {}
+
+    public static String getHash(@NotNull File resourcePackArchiveFile) {
+        try {
+
+            try {
+                MessageDigest md = MessageDigest.getInstance(algorithm);
+                try (FileInputStream inputStream = new FileInputStream(resourcePackArchiveFile)) {
+                    md.update(inputStream.readAllBytes());
+                    byte[] digest = md.digest();
+                    return toHex(digest);
+                }
+            } catch (NoSuchAlgorithmException e) {
+                throw new IllegalStateException(algorithm + " is not implemented in MessageDigest", e);
+            }
+
+        } catch (Exception e) {
+            throw new RuntimeException("Exception occurred while computing resource pack archive file " + algorithm + " hash", e);
+        }
+    }
+
+    private static String toHex(byte[] bytes) {
+        BigInteger bi = new BigInteger(1, bytes);
+        return String.format("%0" + (bytes.length << 1) + "X", bi);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/ResourcePackSettings.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/ResourcePackSettings.java
new file mode 100644
index 0000000000000000000000000000000000000000..0735331150608e9ee745263ae8f2bda7ccb3aea0
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/ResourcePackSettings.java
@@ -0,0 +1,26 @@
+package nl.martijnmuijsers.paper.resourcepack;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import nl.martijnmuijsers.paper.resourcepack.sucraft.CreateSuCraftResourcePack;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * The top-level settings of a {@link ResourcePack}
+ */
+public interface ResourcePackSettings {
+
+    @NotNull String getName();
+
+    @NotNull JsonElement getDescription();
+
+    default @NotNull JsonObject createJson() {
+        JsonObject json = new JsonObject();
+        JsonObject packJson = new JsonObject();
+        json.add(KeyConstants.pack, packJson);
+        packJson.addProperty(KeyConstants.packFormat, CreateSuCraftResourcePack.RESOURCE_PACK_FORMAT);
+        packJson.add(KeyConstants.packDescription, getDescription());
+        return json;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/InitializableResourcePackAssetType.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/InitializableResourcePackAssetType.java
new file mode 100644
index 0000000000000000000000000000000000000000..d668f71be625cd3ad1f2de4a821146b004d665b5
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/InitializableResourcePackAssetType.java
@@ -0,0 +1,17 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A {@link ResourcePackAssetType} that can be initialized to some empty state
+ */
+public class InitializableResourcePackAssetType extends ResourcePackAssetType {
+
+    protected InitializableResourcePackAssetType(@NotNull String folderPathInNamespaceFolder, @Nullable String defaultFileExtension) {
+        super(folderPathInNamespaceFolder, defaultFileExtension);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/MutableResourcePackAsset.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/MutableResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..d85c52b3cbb4eaad314e7fe66bfd83ef50615a65
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/MutableResourcePackAsset.java
@@ -0,0 +1,41 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A mutable {@link ResourcePackAsset}
+ */
+public interface MutableResourcePackAsset extends ResourcePackAsset {
+
+    /**
+     * Note that merging two assets sets the {@link #isDirty} flag if any of the two assets have it set to true
+     */
+    @Override
+    @NotNull MutableResourcePackAsset merge(@NotNull ResourcePackAsset other);
+
+    /**
+     * Whether this asset would need to be added to a resource pack when written
+     * <br>
+     * This is false when:
+     * <ul>
+     * <li>The asset was created from a default asset and has not been modified</li>
+     * <li>The asset was newly created (not based on a default asset) in an empty state and has not been modified</li>
+     * </ul>
+     * This is true otherwise, for example but not limited to:
+     * <ul>
+     * <li>The asset was created from an included asset</li>
+     * <li>The asset was newly created (not based on a default asset) in a non-empty state</li>
+     * <li>The asset was has modifications since creation that make it non-equal to the default asset, if any</li>
+     * </ul>
+     * Note that this flag may (and will usually) be true if the asset is created from a default asset and then modified in such a way that it ends up being the same as the original again, even though it would be valid (and better) to have it be false
+     */
+    boolean isDirty();
+
+    /**
+     * Sets {@link #isDirty} to true
+     */
+    void setDirty();
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackAsset.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..98cf55b68e5ded6089041d96e893d9b3ab6061f2
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackAsset.java
@@ -0,0 +1,45 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset;
+
+import nl.martijnmuijsers.paper.resourcepack.ResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * An asset (element of some asset type) in a {@link ResourcePack}
+ */
+public interface ResourcePackAsset {
+
+    @NotNull ResourcePackAssetType getType();
+
+    /**
+     * This key does not include the asset type folder (such as models) but does include any subfolders that are an intention (such as block)
+     */
+    @NotNull NamespacedKeyWithIntention getKey();
+
+    default @NotNull String getPathInResourcePack() {
+        return this.getType().getPathInResourcePack(this.getKey());
+    }
+
+    void writeTo(@NotNull OutputStream outputStream) throws IOException;
+
+    default boolean hasMeta() {
+        return false;
+    }
+
+    default void writeMetaTo(@NotNull OutputStream outputStream) throws IOException, UnsupportedOperationException, IllegalStateException {
+        throw new UnsupportedOperationException("This asset (of type " + getClass().getName() + " does not support writeMetaTo");
+    }
+
+    /**
+     * Gets the result of merging this asset with the given one
+     * <br>
+     * In any conflicts, this asset will take precedence over the given one
+     */
+    @NotNull ResourcePackAsset merge(@NotNull ResourcePackAsset other);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackAssetDataContent.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackAssetDataContent.java
new file mode 100644
index 0000000000000000000000000000000000000000..25237ac03a56ac1e26e09c651380786cb45e7bc6
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackAssetDataContent.java
@@ -0,0 +1,5 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset;
+
+public interface ResourcePackAssetDataContent {}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackAssetType.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackAssetType.java
new file mode 100644
index 0000000000000000000000000000000000000000..fb4c1abc97dfa44b9eaa5d1843e01808c1182ef6
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackAssetType.java
@@ -0,0 +1,51 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset;
+
+import net.minecraft.server.MinecraftServer;
+import nl.martijnmuijsers.paper.resourcepack.PathConstants;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.apache.commons.lang3.Validate;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A type of {@link ResourcePackAsset}
+ */
+public class ResourcePackAssetType {
+
+    public static final @NotNull InitializableResourcePackAssetType BLOCK_STATES = new InitializableResourcePackAssetType(PathConstants.BlockStates.pathInNamespaceFolder, ".json");
+    public static final @NotNull InitializableResourcePackAssetType MODEL = new InitializableResourcePackAssetType(PathConstants.Models.pathInNamespaceFolder, ".json");
+    public static final @NotNull InitializableResourcePackAssetType TEXTURE = new InitializableResourcePackAssetType(PathConstants.Textures.pathInNamespaceFolder, ".png");
+
+    private final @NotNull String folderPathInNamespaceFolder;
+    /**
+     * This extension includes the dot separating the filename from the extension (so this may be an empty string to indicate that this asset type's files have no extension at all)
+     */
+    public final @Nullable String defaultFileExtension;
+
+    protected ResourcePackAssetType(@NotNull String folderName, @Nullable String defaultFileExtension) {
+        this.folderPathInNamespaceFolder = folderName;
+        this.defaultFileExtension = defaultFileExtension;
+    }
+
+    public @NotNull String getFolderPathInNamespaceFolder() {
+        return this.folderPathInNamespaceFolder;
+    }
+
+    public @NotNull String getDefaultFileExtension() throws IllegalStateException {
+        try {
+            return Validate.notNull(this.defaultFileExtension);
+        } catch (NullPointerException e) {
+            throw new IllegalStateException("Called ResourcePackAssetType.getDefaultFileExtension for a type that does not have a default file extension");
+        }
+    }
+
+    public @NotNull String getPathInResourcePack(@NotNull NamespacedKeyWithIntention assetKey) {
+        if (this.defaultFileExtension == null) {
+            throw new IllegalStateException("Called ResourcePackAssetType.getPathInResourcePack while defaultFileExtension was not set: if a type has multiple extensions, this method cannot be used, and ResourcePackAsset.getPathInResourcePack should be overridden as appropriate");
+        }
+        return PathConstants.getNamespaceFolderPathFromRoot(assetKey.namespace()) + "/" + this.getFolderPathInNamespaceFolder() + "/" + assetKey.keyWithIntention() + this.defaultFileExtension;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackIntentionedAssetData.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackIntentionedAssetData.java
new file mode 100644
index 0000000000000000000000000000000000000000..66e5d7775df20d785860abe085356d3c8cd379ae
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackIntentionedAssetData.java
@@ -0,0 +1,32 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+public abstract class ResourcePackIntentionedAssetData {
+
+    protected final @NotNull ResourcePackAssetIntention intention;
+    protected final @NotNull NamespacedKeyWithoutIntention key;
+
+    protected ResourcePackIntentionedAssetData(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) {
+        this.intention = intention;
+        this.key = key;
+    }
+
+    public @NotNull ResourcePackAssetIntention getIntention() {
+        return this.intention;
+    }
+
+    public @NotNull NamespacedKeyWithoutIntention getKey() {
+        return this.key;
+    }
+
+    public @NotNull NamespacedKeyWithIntention getKeyWithIntention() {
+        return this.key.withIntention(this.intention);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackIntentionedAssetDataByContent.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackIntentionedAssetDataByContent.java
new file mode 100644
index 0000000000000000000000000000000000000000..3c24d7070a2958d94fb925197f8f47bc70f05bfe
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/ResourcePackIntentionedAssetDataByContent.java
@@ -0,0 +1,22 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+public abstract class ResourcePackIntentionedAssetDataByContent<T extends ResourcePackAssetDataContent> extends ResourcePackIntentionedAssetData {
+
+    protected final @NotNull T content;
+
+    protected ResourcePackIntentionedAssetDataByContent(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key, @NotNull T content) {
+        super(intention, key);
+        this.content = content;
+    }
+
+    public @NotNull T getContent() {
+        return this.content;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/SimpleResourcePackAsset.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/SimpleResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..d2c7592594da0701ed1fcd03261fd8ec6a8bcc53
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/SimpleResourcePackAsset.java
@@ -0,0 +1,44 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * Base implementation of {@link MutableResourcePackAsset}
+ */
+public abstract class SimpleResourcePackAsset implements MutableResourcePackAsset {
+
+    private final @NotNull NamespacedKeyWithIntention key;
+
+    private boolean dirty;
+
+    protected SimpleResourcePackAsset(@NotNull NamespacedKeyWithIntention key, boolean dirty) {
+        this.key = key;
+        this.dirty = dirty;
+    }
+
+    protected SimpleResourcePackAsset(@NotNull NamespacedKeyWithIntention key) {
+        this(key, false);
+    }
+
+    @Override
+    public @NotNull NamespacedKeyWithIntention getKey() {
+        return this.key;
+    }
+
+    @Override
+    public boolean isDirty() {
+        return this.dirty;
+    }
+
+    @Override
+    public void setDirty() {
+        this.dirty = true;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/blockstates/ConcreteResourcePackBlockStates.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/blockstates/ConcreteResourcePackBlockStates.java
new file mode 100644
index 0000000000000000000000000000000000000000..94ab98d296c78e95fc942e69815aedf8af2313c0
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/blockstates/ConcreteResourcePackBlockStates.java
@@ -0,0 +1,428 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.blockstates;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelParameters;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelWithParameters;
+import nl.martijnmuijsers.paper.resourcepack.KeyConstants;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAssetType;
+import nl.martijnmuijsers.paper.resourcepack.asset.json.SimpleJsonResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
+import org.checkerframework.checker.units.qual.N;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.Map;
+
+/**
+ * Concrete implementation of {@link MutableResourcePackBlockStates}
+ */
+public class ConcreteResourcePackBlockStates extends SimpleJsonResourcePackAsset<ConcreteResourcePackBlockStates> implements MutableResourcePackBlockStates {
+
+    private boolean setUpFire = false;
+
+    public ConcreteResourcePackBlockStates(@NotNull JsonObject json, @NotNull NamespacedKeyWithIntention key, boolean dirty) {
+        super(ConcreteResourcePackBlockStates::new, json, key, dirty);
+    }
+
+    public ConcreteResourcePackBlockStates(@NotNull JsonObject json, @NotNull NamespacedKeyWithIntention key) {
+        super(ConcreteResourcePackBlockStates::new, json, key);
+    }
+
+    public ConcreteResourcePackBlockStates(@NotNull ResourcePackBlockStates reference) {
+        this(reference.getJsonCopy(), reference.getKey());
+    }
+
+    @Override
+    public @NotNull ResourcePackAssetType getType() {
+        return ResourcePackAssetType.BLOCK_STATES;
+    }
+
+    private @NotNull JsonObject getOrCreateVariantsJson() {
+        @NotNull JsonObject variantsJson;
+        if (this.json.has(KeyConstants.variants)) {
+            variantsJson = this.json.getAsJsonObject(KeyConstants.variants);
+        } else {
+            variantsJson = new JsonObject();
+            this.json.add(KeyConstants.variants, variantsJson);
+        }
+        return variantsJson;
+    }
+
+    @Override
+    public void setModel(@NotNull String variant, @NotNull ModelWithParameters model) {
+        @NotNull JsonObject variantsJson = this.getOrCreateVariantsJson();
+        for (String alreadyExistingVariant : new ArrayList<>(variantsJson.keySet())) {
+            // This check is not perfect because variant properties may be in a different order, may need to improve later
+            if (alreadyExistingVariant.contains(variant)) {
+                variantsJson.remove(alreadyExistingVariant);
+            }
+        }
+        @NotNull JsonObject variantJson;
+        if (variantsJson.has(variant)) {
+            variantJson = variantsJson.getAsJsonObject(variant);
+        } else {
+            variantJson = new JsonObject();
+            variantsJson.add(variant, variantJson);
+        }
+        variantJson.addProperty(KeyConstants.model, model.model().getKeyWithIntention().toString());
+        if (model.parameters() != null) {
+            for (Map.Entry<String, JsonElement> parameter : model.parameters().getJson().entrySet()) {
+                variantJson.add(parameter.getKey(), parameter.getValue());
+            }
+        }
+        if (!variant.equals(KeyConstants.noVariant)) {
+            variantsJson.remove(KeyConstants.noVariant);
+        }
+        this.setDirty();
+    }
+
+    @Override
+    public void clearVariants() {
+        this.json.add(KeyConstants.variants, new JsonObject());
+    }
+
+    @Override
+    public void addFireModels(@NotNull BlockState hostState, @NotNull String fireType) {
+        if (!setUpFire) {
+            setUpFire = true;
+            // Based on vanilla Minecraft resource file /assets/minecraft/blockstates/fire.json
+            // All parts have an age 0 requirement added (spread over every when condition)
+            this.json = JsonParser.parseString("""
+                {
+                  "multipart": [
+                    {
+                      "apply": [
+                        {
+                          "model": "minecraft:block/fire_floor0"
+                        },
+                        {
+                          "model": "minecraft:block/fire_floor1"
+                        }
+                      ],
+                      "when": {
+                        "east": "false",
+                        "north": "false",
+                        "south": "false",
+                        "up": "false",
+                        "west": "false",
+                        "age": 0
+                      }
+                    },
+                    {
+                      "apply": [
+                        {
+                          "model": "minecraft:block/fire_side0"
+                        },
+                        {
+                          "model": "minecraft:block/fire_side1"
+                        },
+                        {
+                          "model": "minecraft:block/fire_side_alt0"
+                        },
+                        {
+                          "model": "minecraft:block/fire_side_alt1"
+                        }
+                      ],
+                      "when": {
+                        "OR": [
+                          {
+                            "north": "true",
+                            "age": 0
+                          },
+                          {
+                            "east": "false",
+                            "north": "false",
+                            "south": "false",
+                            "up": "false",
+                            "west": "false",
+                            "age": 0
+                          }
+                        ]
+                      }
+                    },
+                    {
+                      "apply": [
+                        {
+                          "model": "minecraft:block/fire_side0",
+                          "y": 90
+                        },
+                        {
+                          "model": "minecraft:block/fire_side1",
+                          "y": 90
+                        },
+                        {
+                          "model": "minecraft:block/fire_side_alt0",
+                          "y": 90
+                        },
+                        {
+                          "model": "minecraft:block/fire_side_alt1",
+                          "y": 90
+                        }
+                      ],
+                      "when": {
+                        "OR": [
+                          {
+                            "east": "true",
+                            "age": 0
+                          },
+                          {
+                            "east": "false",
+                            "north": "false",
+                            "south": "false",
+                            "up": "false",
+                            "west": "false",
+                            "age": 0
+                          }
+                        ]
+                      }
+                    },
+                    {
+                      "apply": [
+                        {
+                          "model": "minecraft:block/fire_side0",
+                          "y": 180
+                        },
+                        {
+                          "model": "minecraft:block/fire_side1",
+                          "y": 180
+                        },
+                        {
+                          "model": "minecraft:block/fire_side_alt0",
+                          "y": 180
+                        },
+                        {
+                          "model": "minecraft:block/fire_side_alt1",
+                          "y": 180
+                        }
+                      ],
+                      "when": {
+                        "OR": [
+                          {
+                            "south": "true",
+                            "age": 0
+                          },
+                          {
+                            "east": "false",
+                            "north": "false",
+                            "south": "false",
+                            "up": "false",
+                            "west": "false",
+                            "age": 0
+                          }
+                        ]
+                      }
+                    },
+                    {
+                      "apply": [
+                        {
+                          "model": "minecraft:block/fire_side0",
+                          "y": 270
+                        },
+                        {
+                          "model": "minecraft:block/fire_side1",
+                          "y": 270
+                        },
+                        {
+                          "model": "minecraft:block/fire_side_alt0",
+                          "y": 270
+                        },
+                        {
+                          "model": "minecraft:block/fire_side_alt1",
+                          "y": 270
+                        }
+                      ],
+                      "when": {
+                        "OR": [
+                          {
+                            "west": "true",
+                            "age": 0
+                          },
+                          {
+                            "east": "false",
+                            "north": "false",
+                            "south": "false",
+                            "up": "false",
+                            "west": "false",
+                            "age": 0
+                          }
+                        ]
+                      }
+                    },
+                    {
+                      "apply": [
+                        {
+                          "model": "minecraft:block/fire_up0"
+                        },
+                        {
+                          "model": "minecraft:block/fire_up1"
+                        },
+                        {
+                          "model": "minecraft:block/fire_up_alt0"
+                        },
+                        {
+                          "model": "minecraft:block/fire_up_alt1"
+                        }
+                      ],
+                      "when": {
+                        "up": "true",
+                        "age": 0
+                      }
+                    }
+                  ]
+                }""").getAsJsonObject();
+        }
+        @NotNull JsonArray multipart = this.json.getAsJsonArray("multipart");
+        // Based on vanilla Minecraft resource file /assets/minecraft/blockstates/soul_fire.json
+        // All parts have an added when condition for the right block state
+        multipart.addAll(JsonParser.parseString("""
+            [
+                {
+                  "apply": [
+                    {
+                      "model": "sucraft:block/%1$s_fire_floor0"
+                    },
+                    {
+                      "model": "sucraft:block/%1$s_fire_floor1"
+                    }
+                  ],
+                  "when": {
+                    "east": "%2$b",
+                    "north": "%3$b",
+                    "south": "%4$b",
+                    "up": "%5$b",
+                    "west": "%6$b",
+                    "age": %7$d
+                  }
+                },
+                {
+                  "apply": [
+                    {
+                      "model": "sucraft:block/%1$s_fire_side0"
+                    },
+                    {
+                      "model": "sucraft:block/%1$s_fire_side1"
+                    },
+                    {
+                      "model": "sucraft:block/%1$s_fire_side_alt0"
+                    },
+                    {
+                      "model": "sucraft:block/%1$s_fire_side_alt1"
+                    }
+                  ],
+                  "when": {
+                    "east": "%2$b",
+                    "north": "%3$b",
+                    "south": "%4$b",
+                    "up": "%5$b",
+                    "west": "%6$b",
+                    "age": %7$d
+                  }
+                },
+                {
+                  "apply": [
+                    {
+                      "model": "sucraft:block/%1$s_fire_side0",
+                      "y": 90
+                    },
+                    {
+                      "model": "sucraft:block/%1$s_fire_side1",
+                      "y": 90
+                    },
+                    {
+                      "model": "sucraft:block/%1$s_fire_side_alt0",
+                      "y": 90
+                    },
+                    {
+                      "model": "sucraft:block/%1$s_fire_side_alt1",
+                      "y": 90
+                    }
+                  ],
+                  "when": {
+                    "east": "%2$b",
+                    "north": "%3$b",
+                    "south": "%4$b",
+                    "up": "%5$b",
+                    "west": "%6$b",
+                    "age": %7$d
+                  }
+                },
+                {
+                  "apply": [
+                    {
+                      "model": "sucraft:block/%1$s_fire_side0",
+                      "y": 180
+                    },
+                    {
+                      "model": "sucraft:block/%1$s_fire_side1",
+                      "y": 180
+                    },
+                    {
+                      "model": "sucraft:block/%1$s_fire_side_alt0",
+                      "y": 180
+                    },
+                    {
+                      "model": "sucraft:block/%1$s_fire_side_alt1",
+                      "y": 180
+                    }
+                  ],
+                  "when": {
+                    "east": "%2$b",
+                    "north": "%3$b",
+                    "south": "%4$b",
+                    "up": "%5$b",
+                    "west": "%6$b",
+                    "age": %7$d
+                  }
+                },
+                {
+                  "apply": [
+                    {
+                      "model": "sucraft:block/%1$s_fire_side0",
+                      "y": 270
+                    },
+                    {
+                      "model": "sucraft:block/%1$s_fire_side1",
+                      "y": 270
+                    },
+                    {
+                      "model": "sucraft:block/%1$s_fire_side_alt0",
+                      "y": 270
+                    },
+                    {
+                      "model": "sucraft:block/%1$s_fire_side_alt1",
+                      "y": 270
+                    }
+                  ],
+                  "when": {
+                    "east": "%2$b",
+                    "north": "%3$b",
+                    "south": "%4$b",
+                    "up": "%5$b",
+                    "west": "%6$b",
+                    "age": %7$d
+                  }
+                }
+            ]"""
+            .formatted(
+                fireType,
+                hostState.getValue(BlockStateProperties.EAST),
+                hostState.getValue(BlockStateProperties.NORTH),
+                hostState.getValue(BlockStateProperties.SOUTH),
+                hostState.getValue(BlockStateProperties.UP),
+                hostState.getValue(BlockStateProperties.WEST),
+                hostState.getValue(BlockStateProperties.AGE_15)
+            )).getAsJsonArray()
+        );
+        this.setDirty();
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/blockstates/MutableResourcePackBlockStates.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/blockstates/MutableResourcePackBlockStates.java
new file mode 100644
index 0000000000000000000000000000000000000000..9aba47d2b287033aece4b2f27c4c9dc761547cd0
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/blockstates/MutableResourcePackBlockStates.java
@@ -0,0 +1,61 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.blockstates;
+
+import net.minecraft.world.level.block.state.BlockState;
+import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelWithParameters;
+import nl.martijnmuijsers.paper.resourcepack.KeyConstants;
+import nl.martijnmuijsers.paper.resourcepack.asset.json.MutableJsonResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.MutableResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A mutable {@link ResourcePackBlockStates}
+ */
+public interface MutableResourcePackBlockStates extends MutableJsonResourcePackAsset, ResourcePackBlockStates {
+
+    @Override
+    @NotNull MutableResourcePackBlockStates merge(@NotNull ResourcePackAsset other);
+
+    /**
+     * @param pack Because this instance is not aware of the resource pack it is in, this pack must be provided to automatically add the given model to the resource pack
+     * @param overwriteExistingModel Whether to overwrite an existing model in the resource pack (this has to do with the model, not with this {@link MutableResourcePackBlockStates} instance: this instance's model property is always overwritten by this method)
+     */
+    default void setModel(@NotNull String variant, @NotNull ModelWithParameters model, @NotNull MutableResourcePack pack, boolean overwriteExistingModel) {
+        this.setModel(variant, model);
+        model.model().addToResourcePack(pack, overwriteExistingModel);
+    }
+
+    /**
+     * This does not automatically add the model to the resource pack
+     *
+     * If the variant is not {@link KeyConstants#noVariant}, any existing empty variant will be removed
+     */
+    void setModel(@NotNull String variant, @NotNull ModelWithParameters model);
+
+    default void setModel(@NotNull BlockState variant, @NotNull ModelWithParameters model, @NotNull MutableResourcePack pack, boolean overwriteExistingModel) {
+        this.setModel(variant.toVariantString(), model, pack, overwriteExistingModel);
+    }
+
+    default void setModel(@NotNull BlockState variant, @NotNull ModelWithParameters model) {
+        this.setModel(variant.toVariantString(), model);
+    }
+
+    default void setNoVariantModel(@NotNull ModelWithParameters model, @NotNull MutableResourcePack pack, boolean overwriteExistingModel) {
+        this.setModel(KeyConstants.noVariant, model, pack, overwriteExistingModel);
+    }
+
+    default void setNoVariantModel(@NotNull ModelWithParameters model) {
+        this.setModel(KeyConstants.noVariant, model);
+    }
+
+    /**
+     * Removes all entries in the variants JSON object (it will be an empty object afterwards - which is not valid for a variants JSON object, so variant entries must be added afterwards)
+     */
+    void clearVariants();
+
+    void addFireModels(@NotNull BlockState hostState, @NotNull String fireType);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/blockstates/ResourcePackBlockStates.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/blockstates/ResourcePackBlockStates.java
new file mode 100644
index 0000000000000000000000000000000000000000..9716eca9c118700f8476661f981b31b592753c13
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/blockstates/ResourcePackBlockStates.java
@@ -0,0 +1,18 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.blockstates;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.json.JsonResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.ResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An element of 'blockstates' in a {@link ResourcePack}
+ */
+public interface ResourcePackBlockStates extends JsonResourcePackAsset {
+
+    @Override
+    @NotNull ResourcePackBlockStates merge(@NotNull ResourcePackAsset other);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/image/ImageResourcePackAsset.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/image/ImageResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..b6a85e9f19d80a0aacc16450fe53e1801a4e9606
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/image/ImageResourcePackAsset.java
@@ -0,0 +1,20 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.image;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A {@link ResourcePackAsset} that is intended to hold an image (though, it is possible that {@link #hasData} is false, indicating that there is no data stored in this asset instance yet, although eventually, there always must be)
+ * <br>
+ * Note that this does not necessarily store any of the data referenced in memory, an image asset can also simply hold a filename that we assume points to an image
+ */
+public interface ImageResourcePackAsset extends ResourcePackAsset {
+
+    @Override
+    @NotNull ImageResourcePackAsset merge(@NotNull ResourcePackAsset other);
+
+    boolean hasData();
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/image/MutableImageResourcePackAsset.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/image/MutableImageResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..c57ae7f9074a4fd30834e59362fc7f931d4716a3
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/image/MutableImageResourcePackAsset.java
@@ -0,0 +1,17 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.image;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.MutableResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A mutable {@link ImageResourcePackAsset}
+ */
+public interface MutableImageResourcePackAsset extends MutableResourcePackAsset, ImageResourcePackAsset {
+
+    @Override
+    @NotNull MutableImageResourcePackAsset merge(@NotNull ResourcePackAsset other);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/image/SimpleImageFileResourcePackAsset.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/image/SimpleImageFileResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..7b6d1b9c9ca978c93c792372fc0cc0b1491f1b28
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/image/SimpleImageFileResourcePackAsset.java
@@ -0,0 +1,82 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.image;
+
+import nl.martijnmuijsers.paper.resourcepack.PathConstants;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.SimpleResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.apache.commons.lang3.Validate;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * Base implementation of {@link MutableImageResourcePackAsset} that reference images by a file path (and thus does not support any operations or checks on the content of the image)
+ */
+public abstract class SimpleImageFileResourcePackAsset extends SimpleResourcePackAsset implements MutableImageResourcePackAsset {
+
+    private boolean existsInIncludedResourcePack;
+    private @Nullable String imageFilePath;
+
+    protected SimpleImageFileResourcePackAsset(boolean existsInIncludedResourcePack, @Nullable String imageFilePath, @NotNull NamespacedKeyWithIntention key, boolean dirty) {
+        super(key, dirty);
+        this.existsInIncludedResourcePack = existsInIncludedResourcePack;
+        this.imageFilePath = imageFilePath;
+    }
+
+    protected SimpleImageFileResourcePackAsset(boolean existsInIncludedResourcePack, @Nullable String imageFilePath, @NotNull NamespacedKeyWithIntention key) {
+        super(key);
+        this.existsInIncludedResourcePack = existsInIncludedResourcePack;
+        this.imageFilePath = imageFilePath;
+    }
+
+    @Override
+    public void writeTo(@NotNull OutputStream outputStream) throws IOException {
+        Validate.notNull(this.imageFilePath);
+        try (@NotNull FileInputStream fileInputStream = new FileInputStream(this.imageFilePath)) {
+            outputStream.write(fileInputStream.readAllBytes());
+        }
+    }
+
+    @Override
+    public boolean hasMeta() {
+        return new File(this.imageFilePath + PathConstants.metaFileSuffix).exists();
+    }
+
+    @Override
+    public void writeMetaTo(@NotNull OutputStream outputStream) throws IOException, UnsupportedOperationException, IllegalStateException {
+        File metaFile = new File(this.imageFilePath + PathConstants.metaFileSuffix);
+        if (!metaFile.exists()) {
+            throw new IllegalStateException("Called SimpleImageFileResourcePackAsset.writeMetaTo for an asset that has no meta");
+        }
+        try (@NotNull FileInputStream fileInputStream = new FileInputStream(metaFile)) {
+            outputStream.write(fileInputStream.readAllBytes());
+        }
+    }
+
+    public @NotNull MutableImageResourcePackAsset merge(@NotNull ResourcePackAsset other) {
+        Validate.isInstanceOf(MutableImageResourcePackAsset.class, other);
+        if (this.hasData()) {
+            return this;
+        }
+        return (MutableImageResourcePackAsset) other;
+    }
+
+    @Override
+    public boolean hasData() {
+        return this.existsInIncludedResourcePack || this.imageFilePath != null;
+    }
+
+    public void setImageFilePath(@NotNull String imageFilePath) {
+        if (!imageFilePath.equals(this.imageFilePath)) {
+            this.imageFilePath = imageFilePath;
+            this.setDirty();
+        }
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/intention/NamespacedKeyWithIntention.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/intention/NamespacedKeyWithIntention.java
new file mode 100644
index 0000000000000000000000000000000000000000..ccbb0e127dbc4e684190f986193af73131d1e6f9
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/intention/NamespacedKeyWithIntention.java
@@ -0,0 +1,31 @@
+package nl.martijnmuijsers.paper.resourcepack.asset.intention;
+
+import org.jetbrains.annotations.NotNull;
+import org.bukkit.NamespacedKey;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A simple record that represents a {@link NamespacedKey} that includes the intention in the key
+ * <br>
+ * This record just indicates that the intention, if any, was certainly included: if there is no intention for the resource this key represents, the intention can be null
+ */
+public record NamespacedKeyWithIntention(@NotNull String namespace, @Nullable ResourcePackAssetIntention intention, @NotNull String keyWithoutIntention) {
+
+    public @NotNull String keyWithIntention() {
+        return this.intention == null ? this.keyWithoutIntention : this.intention.prefix + "/" + this.keyWithoutIntention;
+    }
+
+    public @NotNull NamespacedKeyWithIntention withKeySuffix(@NotNull String suffix) {
+        return new NamespacedKeyWithIntention(namespace, intention, keyWithoutIntention + suffix);
+    }
+
+    public @NotNull NamespacedKeyWithIntention withKeyPrefix(@NotNull String prefix) {
+        return new NamespacedKeyWithIntention(namespace, intention, prefix + keyWithoutIntention);
+    }
+
+    @Override
+    public @NotNull String toString() {
+        return this.namespace + ":" + this.keyWithIntention();
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/intention/NamespacedKeyWithoutIntention.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/intention/NamespacedKeyWithoutIntention.java
new file mode 100644
index 0000000000000000000000000000000000000000..d206f4b2cab32de78fb2974dc6974ad90f127f7b
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/intention/NamespacedKeyWithoutIntention.java
@@ -0,0 +1,51 @@
+package nl.martijnmuijsers.paper.resourcepack.asset.intention;
+
+import net.minecraft.resources.ResourceLocation;
+import org.bukkit.NamespacedKey;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A simple record that represents a {@link NamespacedKey} that certainly does not include the intention in the key
+ * <br>
+ * This record just indicates that the intention, if any, was certainly excluded: if there is no intention for the resource this key represents, {@link NamespacedKeyWithIntention} should still be used when the potential (but not certainly existing) intention is required
+ */
+public record NamespacedKeyWithoutIntention(@NotNull String namespace, @NotNull String keyWithoutIntention) {
+
+    public @NotNull NamespacedKeyWithIntention withIntention(@NotNull ResourcePackAssetIntention intention) {
+        return new NamespacedKeyWithIntention(namespace, intention, keyWithoutIntention);
+    }
+
+    public @NotNull NamespacedKeyWithIntention withEmptyIntention() {
+        return new NamespacedKeyWithIntention(namespace, null, keyWithoutIntention);
+    }
+
+    public @NotNull NamespacedKeyWithoutIntention withKeySuffix(@NotNull String suffix) {
+        return new NamespacedKeyWithoutIntention(namespace, keyWithoutIntention + suffix);
+    }
+
+    public @NotNull NamespacedKeyWithoutIntention withKeyPrefix(@NotNull String prefix) {
+        return new NamespacedKeyWithoutIntention(namespace, prefix + keyWithoutIntention);
+    }
+
+    @Override
+    public @NotNull String toString() {
+        return this.namespace + ":" + this.keyWithoutIntention();
+    }
+
+    public static @NotNull NamespacedKeyWithoutIntention forBukkit(@NotNull NamespacedKey key) {
+        return new NamespacedKeyWithoutIntention(key.getNamespace(), key.getKey());
+    }
+
+    public static @NotNull NamespacedKeyWithoutIntention forMinecraft(@NotNull ResourceLocation resourceLocation) {
+        return new NamespacedKeyWithoutIntention(resourceLocation.getNamespace(), resourceLocation.getPath());
+    }
+
+    public static @NotNull NamespacedKeyWithoutIntention minecraft(@NotNull String keyWithoutIntention) {
+        return new NamespacedKeyWithoutIntention(ResourceLocation.DEFAULT_NAMESPACE, keyWithoutIntention);
+    }
+
+    public static @NotNull NamespacedKeyWithoutIntention sucraft(@NotNull String keyWithoutIntention) {
+        return new NamespacedKeyWithoutIntention(ResourceLocation.SUCRAFT_NAMESPACE, keyWithoutIntention);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/intention/ResourcePackAssetIntention.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/intention/ResourcePackAssetIntention.java
new file mode 100644
index 0000000000000000000000000000000000000000..114b57c69156c584bd818dcd902e0b72e0c67990
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/intention/ResourcePackAssetIntention.java
@@ -0,0 +1,22 @@
+package nl.martijnmuijsers.paper.resourcepack.asset.intention;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * The intention of a {@link ResourcePackAsset}
+ * <br>
+ * Not all asset types use intentions
+ */
+public enum ResourcePackAssetIntention {
+
+    BLOCK("block"),
+    ITEM("item");
+
+    public final @NotNull String prefix;
+
+    ResourcePackAssetIntention(@NotNull String prefix) {
+        this.prefix = prefix;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/json/JsonResourcePackAsset.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/json/JsonResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..876fe33b34243ddd37696bcdace1b8ee048e7c8e
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/json/JsonResourcePackAsset.java
@@ -0,0 +1,21 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.json;
+
+import com.google.gson.JsonObject;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A {@link ResourcePackAsset} with JSON data
+ */
+public interface JsonResourcePackAsset extends ResourcePackAsset {
+
+    @Override
+    @NotNull JsonResourcePackAsset merge(@NotNull ResourcePackAsset other);
+
+    @NotNull JsonObject getJsonCopy();
+
+    boolean isJsonEmpty();
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/json/MutableJsonResourcePackAsset.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/json/MutableJsonResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..e36cb8277fa667532f558ced487808dbef1d6841
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/json/MutableJsonResourcePackAsset.java
@@ -0,0 +1,19 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.json;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.MutableResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A mutable {@link JsonResourcePackAsset}
+ */
+public interface MutableJsonResourcePackAsset extends MutableResourcePackAsset, JsonResourcePackAsset {
+
+    @Override
+    @NotNull MutableJsonResourcePackAsset merge(@NotNull ResourcePackAsset other);
+
+    void clearJson();
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/json/SimpleJsonResourcePackAsset.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/json/SimpleJsonResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..57740cdc57610ed068bfe5254dde264b7f9c5e6d
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/json/SimpleJsonResourcePackAsset.java
@@ -0,0 +1,81 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.json;
+
+import com.google.common.base.Charsets;
+import com.google.gson.JsonObject;
+import nl.martijnmuijsers.paper.json.JsonMerging;
+import nl.martijnmuijsers.paper.resourcepack.asset.MutableResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.SimpleResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.apache.commons.lang3.Validate;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * Base implementation of {@link MutableJsonResourcePackAsset}
+ */
+public abstract class SimpleJsonResourcePackAsset<T extends SimpleJsonResourcePackAsset<T>> extends SimpleResourcePackAsset implements MutableJsonResourcePackAsset {
+
+    protected interface JsonResourcePackAssetConstructor<T extends SimpleJsonResourcePackAsset<T>> {
+
+        @NotNull T construct(@NotNull JsonObject json, @NotNull NamespacedKeyWithIntention key, boolean dirty);
+
+    }
+
+    private final @NotNull JsonResourcePackAssetConstructor<T> constructor;
+    protected @NotNull JsonObject json;
+
+    protected SimpleJsonResourcePackAsset(@NotNull JsonResourcePackAssetConstructor<T> constructor, @NotNull JsonObject json, @NotNull NamespacedKeyWithIntention key, boolean dirty) {
+        super(key, dirty);
+        this.constructor = constructor;
+        this.json = json;
+    }
+
+    protected SimpleJsonResourcePackAsset(@NotNull JsonResourcePackAssetConstructor<T> constructor, @NotNull JsonObject json, @NotNull NamespacedKeyWithIntention key) {
+        super(key);
+        this.constructor = constructor;
+        this.json = json;
+    }
+
+    @Override
+    public void writeTo(@NotNull OutputStream outputStream) throws IOException {
+        outputStream.write(this.json.toString().getBytes(Charsets.UTF_8));
+    }
+
+    public @NotNull T merge(@NotNull ResourcePackAsset other) {
+        Validate.isTrue(this.getType() == other.getType());
+        @NotNull JsonObject otherJson;
+        if (other instanceof SimpleJsonResourcePackAsset<?> simpleOther) {
+            otherJson = simpleOther.json;
+        } else {
+            otherJson = ((JsonResourcePackAsset) other).getJsonCopy();
+        }
+        boolean otherDirty;
+        if (other instanceof MutableResourcePackAsset mutableOther) {
+            otherDirty = mutableOther.isDirty();
+        } else {
+            otherDirty = false;
+        }
+        return this.constructor.construct(JsonMerging.merge(this.json, otherJson), this.getKey(), this.isDirty() || otherDirty);
+    }
+
+    public @NotNull JsonObject getJsonCopy() {
+        return this.json.deepCopy();
+    }
+
+    @Override
+    public boolean isJsonEmpty() {
+        return this.json.keySet().isEmpty();
+    }
+
+    @Override
+    public void clearJson() {
+        this.json = new JsonObject();
+        this.setDirty();
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/model/ConcreteResourcePackModel.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/model/ConcreteResourcePackModel.java
new file mode 100644
index 0000000000000000000000000000000000000000..224eb6840fef0888fa12d80cdba5f5aebc7ef69d
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/model/ConcreteResourcePackModel.java
@@ -0,0 +1,199 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.model;
+
+import com.google.common.base.Charsets;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import net.minecraft.network.Connection;
+import nl.martijnmuijsers.paper.blockanditemdata.model.BlockEntityModelPosition;
+import nl.martijnmuijsers.paper.resourcepack.KeyConstants;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAssetType;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
+import nl.martijnmuijsers.paper.blockanditemdata.texture.Texture;
+import nl.martijnmuijsers.paper.resourcepack.asset.json.SimpleJsonResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.List;
+import java.util.stream.StreamSupport;
+
+/**
+ * Concrete implementation of {@link MutableResourcePackModel}
+ */
+public class ConcreteResourcePackModel extends SimpleJsonResourcePackAsset<ConcreteResourcePackModel> implements MutableResourcePackModel {
+
+    public ConcreteResourcePackModel(@NotNull JsonObject json, @NotNull NamespacedKeyWithIntention key, boolean dirty) {
+        super(ConcreteResourcePackModel::new, json, key, dirty);
+    }
+
+    public ConcreteResourcePackModel(@NotNull JsonObject json, @NotNull NamespacedKeyWithIntention key) {
+        super(ConcreteResourcePackModel::new, json, key);
+    }
+
+    public ConcreteResourcePackModel(@NotNull ResourcePackModel reference) {
+        this(reference.getJsonCopy(), reference.getKey());
+    }
+
+    @Override
+    public @NotNull ResourcePackAssetType getType() {
+        return ResourcePackAssetType.MODEL;
+    }
+
+    @Override
+    public void setParent(@NotNull Model parent) {
+        this.json.addProperty(KeyConstants.assetParent, parent.getKeyWithIntention().toString());
+        this.setDirty();
+    }
+
+    @Override
+    public void setBlockEntityHeadDisplay(@NotNull BlockEntityModelPosition position) {
+        @NotNull JsonObject displayJson;
+        if (this.json.has(KeyConstants.display)) {
+            displayJson = this.json.getAsJsonObject(KeyConstants.display);
+        } else {
+            displayJson = new JsonObject();
+            this.json.add(KeyConstants.display, displayJson);
+        }
+        @NotNull JsonObject headJson;
+        if (displayJson.has(KeyConstants.displayHead)) {
+            headJson = displayJson.getAsJsonObject(KeyConstants.displayHead);
+        } else {
+            headJson = new JsonObject();
+            displayJson.add(KeyConstants.displayHead, headJson);
+        }
+        @NotNull JsonArray translationJson = new JsonArray(3);
+        @NotNull JsonArray scaleJson = new JsonArray(3);
+        // Temp
+//        boolean isBottomSlab = true;
+//        if (isBottomSlab) {
+//            translationJson.add(BLOCK_ENTITY_ARMOR_STAND_DXZ * 25.6F);
+//            translationJson.add(-30.425F - BLOCK_ENTITY_ARMOR_STAND_DY * 25.6F);
+//            translationJson.add(BLOCK_ENTITY_ARMOR_STAND_DXZ * 25.6F);
+//            for (int i = 0; i < 3; i++) {
+//                scaleJson.add(1.605F);
+//            }
+//        } else {
+//            translationJson.add(BLOCK_ENTITY_ARMOR_STAND_DXZ * 25.6F);
+//            translationJson.add(-30.425F - BLOCK_ENTITY_ARMOR_STAND_DY * 25.6F);
+//            translationJson.add(BLOCK_ENTITY_ARMOR_STAND_DXZ * 25.6F);
+//            for (int i = 0; i < 3; i++) {
+//                scaleJson.add(1.605F);
+//            }
+//        }
+//        translationJson.add(BLOCK_ENTITY_ARMOR_STAND_DXZ * (1.6F * 16));
+//        translationJson.add(-30.42555F - BLOCK_ENTITY_ARMOR_STAND_DY * (1.6F * 16)); // [-30.42575F, -30.4254)
+//        translationJson.add(BLOCK_ENTITY_ARMOR_STAND_DXZ * (1.6F * 16));
+//        for (int i = 0; i < 3; i++) {
+//            scaleJson.add(1.6F);
+//        }
+        translationJson.add(position.displayTranslationX);
+        translationJson.add(-30.42555F - BLOCK_ENTITY_ARMOR_STAND_DY * (1.6F * 16));
+        translationJson.add(position.displayTranslationZ);
+        scaleJson.add(-1.6F);
+        scaleJson.add(1.6F);
+        scaleJson.add(-1.6F);
+        headJson.add(KeyConstants.displayTranslation, translationJson);
+        headJson.add(KeyConstants.displayScale, scaleJson);
+    }
+
+    @Override
+    public void setBlockEntityElements(@NotNull JsonArray elementsJson) {
+        this.json.add(KeyConstants.elements, elementsJson);
+    }
+
+    @Override
+    public void setAllTextures(@NotNull Texture texture) {
+        @NotNull JsonObject texturesJson = new JsonObject();
+        texturesJson.addProperty(KeyConstants.modelTexturesAll, texture.getKeyWithIntention().toString());
+        this.json.add(KeyConstants.modelTextures, texturesJson);
+        this.setDirty();
+    }
+
+    @Override
+    public void setFireTexture(@NotNull Texture texture) {
+        @NotNull JsonObject texturesJson = new JsonObject();
+        texturesJson.addProperty(KeyConstants.modelTexturesFire, texture.getKeyWithIntention().toString());
+        this.json.add(KeyConstants.modelTextures, texturesJson);
+        this.setDirty();
+    }
+
+    @Override
+    public void setColumnTextures(@NotNull Texture endTexture, @NotNull Texture sideTexture) {
+        @NotNull JsonObject texturesJson = new JsonObject();
+        texturesJson.addProperty(KeyConstants.modelTexturesEnd, endTexture.getKeyWithIntention().toString());
+        texturesJson.addProperty(KeyConstants.modelTexturesSide, sideTexture.getKeyWithIntention().toString());
+        this.json.add(KeyConstants.modelTextures, texturesJson);
+        this.setDirty();
+    }
+
+    @Override
+    public void setBottomTopTextures(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture) {
+        @NotNull JsonObject texturesJson = new JsonObject();
+        texturesJson.addProperty(KeyConstants.modelTexturesBottom, bottomTexture.getKeyWithIntention().toString());
+        texturesJson.addProperty(KeyConstants.modelTexturesSide, sideTexture.getKeyWithIntention().toString());
+        texturesJson.addProperty(KeyConstants.modelTexturesTop, topTexture.getKeyWithIntention().toString());
+        this.json.add(KeyConstants.modelTextures, texturesJson);
+        this.setDirty();
+    }
+
+
+    @Override
+    public void addModelOverride(int customModelData, @NotNull Model overridingModel) {
+        @NotNull JsonArray overridesJson;
+        if (this.json.has(KeyConstants.modelOverrides)) {
+            overridesJson = this.json.getAsJsonArray(KeyConstants.modelOverrides);
+        } else {
+            overridesJson = new JsonArray();
+            this.json.add(KeyConstants.modelOverrides, overridesJson);
+        }
+        // Make sure we try to find an override with the same predicate as that we're trying to create
+        @NotNull JsonObject predicateJson = new JsonObject();
+        predicateJson.addProperty(KeyConstants.customModelData, customModelData);
+        @Nullable JsonObject overrideJson = null;
+        for (JsonElement existingOverrideJson : overridesJson) {
+            if (existingOverrideJson instanceof JsonObject existingOverrideJsonObject) {
+                @Nullable JsonElement existingOverridePredicateJson = existingOverrideJsonObject.get(KeyConstants.overridePredicate);
+                if (existingOverridePredicateJson != null && existingOverridePredicateJson.equals(predicateJson)) {
+                    overrideJson = existingOverrideJsonObject;
+                    break;
+                }
+            }
+        }
+        if (overrideJson == null) {
+            // We need to create a new override because none with the desired predicate existed
+            overrideJson = new JsonObject();
+            overrideJson.add(KeyConstants.overridePredicate, predicateJson);
+            overridesJson.add(overrideJson);
+        }
+        overrideJson.addProperty(KeyConstants.model, overridingModel.getKeyWithIntention().toString());
+        this.setDirty();
+    }
+
+    private void sortModelOverrides() {
+        if (!this.json.has(KeyConstants.modelOverrides)) {
+            return;
+        }
+        @NotNull JsonArray overridesJson = this.json.getAsJsonArray(KeyConstants.modelOverrides);
+        @NotNull JsonArray newOverridesJson = new JsonArray(overridesJson.size());
+        StreamSupport.stream(overridesJson.spliterator(), false).sorted((overrideJson1, overrideJson2) -> {
+            JsonObject overridePredicate1 = ((JsonObject) overrideJson1).getAsJsonObject(KeyConstants.overridePredicate);
+            JsonObject overridePredicate2 = ((JsonObject) overrideJson2).getAsJsonObject(KeyConstants.overridePredicate);
+            int customModelData1 = overridePredicate1.has(KeyConstants.customModelData) ? overridePredicate1.get(KeyConstants.customModelData).getAsInt() : Integer.MAX_VALUE;
+            int customModelData2 = overridePredicate2.has(KeyConstants.customModelData) ? overridePredicate2.get(KeyConstants.customModelData).getAsInt() : Integer.MAX_VALUE;
+            return Integer.compare(customModelData1, customModelData2);
+        }).forEach(newOverridesJson::add);
+        this.json.add(KeyConstants.modelOverrides, newOverridesJson);
+    }
+
+    @Override
+    public void writeTo(@NotNull OutputStream outputStream) throws IOException {
+        this.sortModelOverrides();
+        super.writeTo(outputStream);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/model/MutableResourcePackModel.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/model/MutableResourcePackModel.java
new file mode 100644
index 0000000000000000000000000000000000000000..473deb9d81e52767397c4a45df9313a52391c0fc
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/model/MutableResourcePackModel.java
@@ -0,0 +1,51 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.model;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import nl.martijnmuijsers.paper.blockanditemdata.model.BlockEntityModelPosition;
+import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
+import nl.martijnmuijsers.paper.blockanditemdata.texture.Texture;
+import nl.martijnmuijsers.paper.resourcepack.MutableResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.json.MutableJsonResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A mutable {@link ResourcePackModel}
+ */
+public interface MutableResourcePackModel extends MutableJsonResourcePackAsset, ResourcePackModel {
+
+    @Override
+    @NotNull MutableResourcePackModel merge(@NotNull ResourcePackAsset other);
+
+    void setParent(@NotNull Model parent);
+
+    void setBlockEntityHeadDisplay(@NotNull BlockEntityModelPosition position);
+
+    void setBlockEntityElements(@NotNull JsonArray elementsJson);
+
+    void setAllTextures(@NotNull Texture texture);
+
+    void setFireTexture(@NotNull Texture texture);
+
+    void setColumnTextures(@NotNull Texture endTexture, @NotNull Texture sideTexture);
+
+    void setBottomTopTextures(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture);
+
+    /**
+     * @param pack Because this instance is not aware of the resource pack it is in, this pack must be provided to automatically add the given overriding model to the resource pack
+     * @param overwriteExistingOverridingModel Whether to overwrite an existing model in the resource pack (this has to do with the overriding model, not with this model instance: this instance's overrides property is always modified by this method)
+     */
+    default void addModelOverride(int customModelData, @NotNull Model overridingModel, @NotNull MutableResourcePack pack, boolean overwriteExistingOverridingModel) {
+        this.addModelOverride(customModelData, overridingModel);
+        overridingModel.addToResourcePack(pack, overwriteExistingOverridingModel);
+    }
+
+    /**
+     * This does not automatically add the overriding model to the resource pack
+     */
+    void addModelOverride(int customModelData, @NotNull Model overridingModel);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/model/ResourcePackModel.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/model/ResourcePackModel.java
new file mode 100644
index 0000000000000000000000000000000000000000..acd5a19f1396c3b1c5404dc9cea4d04349055e05
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/model/ResourcePackModel.java
@@ -0,0 +1,21 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.model;
+
+import nl.martijnmuijsers.paper.resourcepack.ResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.json.JsonResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An element of 'models' in a {@link ResourcePack}
+ */
+public interface ResourcePackModel extends JsonResourcePackAsset {
+
+    @Override
+    @NotNull ResourcePackModel merge(@NotNull ResourcePackAsset other);
+
+    float BLOCK_ENTITY_ARMOR_STAND_DY = -0.01F;
+//    short DOUBLE_BLOCK_ENTITY_ARMOR_STAND_DXZ_AS_POS_MOVE_SHORT = 32 * 128;
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/texture/ConcreteResourcePackTexture.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/texture/ConcreteResourcePackTexture.java
new file mode 100644
index 0000000000000000000000000000000000000000..742d4558b13e1360a0617322681f599567b6f4cc
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/texture/ConcreteResourcePackTexture.java
@@ -0,0 +1,41 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.texture;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAssetType;
+import nl.martijnmuijsers.paper.resourcepack.asset.image.SimpleImageFileResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.ResourcePackModel;
+import org.apache.commons.lang3.Validate;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Concrete implementation of {@link MutableResourcePackTexture}
+ */
+public class ConcreteResourcePackTexture extends SimpleImageFileResourcePackAsset implements MutableResourcePackTexture {
+
+    public ConcreteResourcePackTexture(boolean existsInIncludedResourcePack, @Nullable String imageFilePath, @NotNull NamespacedKeyWithIntention key, boolean dirty) {
+        super(existsInIncludedResourcePack, imageFilePath, key, dirty);
+    }
+
+    public ConcreteResourcePackTexture(boolean existsInIncludedResourcePack, @Nullable String imageFilePath, @NotNull NamespacedKeyWithIntention key) {
+        super(existsInIncludedResourcePack, imageFilePath, key);
+    }
+
+    @Override
+    public @NotNull ResourcePackAssetType getType() {
+        return ResourcePackAssetType.TEXTURE;
+    }
+
+    public @NotNull ConcreteResourcePackTexture merge(@NotNull ResourcePackAsset other) {
+        Validate.isInstanceOf(ConcreteResourcePackTexture.class, other);
+        return (ConcreteResourcePackTexture) super.merge(other);
+    }
+
+    public void setBasedOnFileToImport(@NotNull String fileToImport) {
+        this.setImageFilePath(fileToImport);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/texture/MutableResourcePackTexture.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/texture/MutableResourcePackTexture.java
new file mode 100644
index 0000000000000000000000000000000000000000..3b18ece5e503170a02ee7f6b6a967064f1533fb8
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/texture/MutableResourcePackTexture.java
@@ -0,0 +1,19 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.texture;
+
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.image.MutableImageResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A mutable {@link ResourcePackTexture}
+ */
+public interface MutableResourcePackTexture extends MutableImageResourcePackAsset, ResourcePackTexture {
+
+    @Override
+    @NotNull MutableResourcePackTexture merge(@NotNull ResourcePackAsset other);
+
+    void setBasedOnFileToImport(@NotNull String filePath);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/texture/ResourcePackTexture.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/texture/ResourcePackTexture.java
new file mode 100644
index 0000000000000000000000000000000000000000..52b2cda69eb3dc8f4754e439ee64483878bc34b2
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/asset/texture/ResourcePackTexture.java
@@ -0,0 +1,18 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.asset.texture;
+
+import nl.martijnmuijsers.paper.resourcepack.ResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.image.ImageResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An element of 'textures' in a {@link ResourcePack}
+ */
+public interface ResourcePackTexture extends ImageResourcePackAsset {
+
+    @Override
+    @NotNull ResourcePackTexture merge(@NotNull ResourcePackAsset other);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/httpserver/ResourcePackHTTPServer.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/httpserver/ResourcePackHTTPServer.java
new file mode 100644
index 0000000000000000000000000000000000000000..7035f89399196b0a5440c01b7c1ce3d4d106ddf0
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/httpserver/ResourcePackHTTPServer.java
@@ -0,0 +1,126 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.httpserver;
+
+import com.sun.net.httpserver.HttpExchange;
+import com.sun.net.httpserver.HttpServer;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.dedicated.DedicatedServer;
+import nl.martijnmuijsers.paper.resourcepack.ResourcePackHash;
+import nl.martijnmuijsers.paper.resourcepack.sucraft.CreateSuCraftResourcePack;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.InetSocketAddress;
+import java.util.Optional;
+
+/**
+ * A singleton that runs an HTTP server to serve the server resource pack (or multiple variants of it)
+ */
+public final class ResourcePackHTTPServer {
+
+    private static final @NotNull String PROTOCOL = "http";
+    // Modified for easy testing
+    private static final @NotNull String IP = new File("paper_test_server").exists() ? "89.35.34.254" : "sucraft.org";
+    private static final int PORT = 25454;
+    private static final @NotNull String PATH = "resourcepack-" + CreateSuCraftResourcePack.getOutputFilePathRandomSuffix();
+
+    public static final @NotNull String RESOURCE_PACK_URL = PROTOCOL + "://" + IP + ":" + PORT + "/" + PATH;
+
+    private ResourcePackHTTPServer() {}
+
+    private static @Nullable ResourcePackHTTPServer instance;
+
+    public static @NotNull ResourcePackHTTPServer getInstance() {
+        if (instance == null) {
+            instance = new ResourcePackHTTPServer();
+        }
+        return instance;
+    }
+
+    private boolean isStarted = false;
+    /**
+     * Only null while not initialized yet
+     */
+    private @Nullable HttpServer httpServer = null;
+
+    public void startIfNotStarted() {
+        if (this.isStarted) {
+            return;
+        }
+        try {
+
+            // Start the HTTP server
+            this.httpServer = HttpServer.create(new InetSocketAddress(25454), 0);
+            httpServer.createContext("/" + PATH, ResourcePackHTTPServer::handle);
+            httpServer.setExecutor(null); // creates a default executor
+            httpServer.start();
+            this.isStarted = true;
+
+            // Update the server properties in memory to match the resource pack and HTTP server
+            this.updateServerPropertiesInMemory(false);
+
+        } catch (Exception e) {
+            throw new RuntimeException("Exception occurred while starting resource pack HTTP server", e);
+        } finally {
+            this.httpServer = null;
+        }
+    }
+
+    /**
+     * The whole resource pack is stored in memory, this seems a much better tradeoff than making retrieving it cost I/O operations
+     */
+    private static byte @Nullable [] resourcePackBytes;
+
+    public static void handle(HttpExchange httpExchange) throws IOException {
+        if (resourcePackBytes == null) {
+            resourcePackBytes = new FileInputStream(CreateSuCraftResourcePack.getOutputFile()).readAllBytes();
+        }
+        httpExchange.sendResponseHeaders(200, resourcePackBytes.length);
+        OutputStream responseBody = httpExchange.getResponseBody();
+        responseBody.write(resourcePackBytes);
+        responseBody.close();
+    }
+
+    private boolean updatedServerPropertiesInMemoryBefore = false;
+
+    public void updateServerPropertiesInMemory(boolean updateEvenIfAlreadyUpdatedBefore) {
+        if (updatedServerPropertiesInMemoryBefore && !updateEvenIfAlreadyUpdatedBefore) {
+            return;
+        }
+        try {
+
+            var server = MinecraftServer.getServer();
+            if (server == null) { // IntelliJ says that this will never be null, but that is false (due to IntelliJ not understanding the static class initialization order in practice)
+                // We cannot update the server properties if the server was not initialized yet
+                return;
+            }
+            var dedicatedServer = (DedicatedServer) server;
+            var serverProperties = dedicatedServer.getProperties();
+            if (serverProperties == null) { // IntelliJ says that this will never be null, but that is false (due to IntelliJ not understanding the static class initialization order in practice)
+                // We cannot update the server properties if the server properties were not initialized yet
+                return;
+            }
+            String hash = ResourcePackHash.getHash(CreateSuCraftResourcePack.getOutputFile());
+            var previousResourcePackInfo = serverProperties.serverResourcePackInfo.orElse(null);
+            boolean isRequired = previousResourcePackInfo != null ? previousResourcePackInfo.isRequired() : false;
+            var prompt = previousResourcePackInfo != null ? previousResourcePackInfo.prompt() : null;
+            serverProperties.serverResourcePackInfo = Optional.of(new MinecraftServer.ServerResourcePackInfo(
+                RESOURCE_PACK_URL,
+                hash,
+                isRequired,
+                prompt
+            ));
+            MinecraftServer.LOGGER.info("Update server resource pack properties: url = '" + RESOURCE_PACK_URL + "', hash = '" + hash + "', isRequired = " + isRequired + ", prompt = '" + prompt + "'");
+            updatedServerPropertiesInMemoryBefore = true;
+
+        } catch (Exception e) {
+            throw new RuntimeException("Exception occurred while updating server properties in memory, for the resource pack", e);
+        }
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/memory/MemoryResourcePack.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/memory/MemoryResourcePack.java
new file mode 100644
index 0000000000000000000000000000000000000000..e721dc9e5b948e328e643da963ba456f0d310848
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/memory/MemoryResourcePack.java
@@ -0,0 +1,227 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.memory;
+
+import com.google.common.base.Charsets;
+import com.google.common.collect.ImmutableList;
+import com.google.gson.JsonObject;
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.server.MinecraftServer;
+import nl.martijnmuijsers.paper.resourcepack.PathConstants;
+import nl.martijnmuijsers.paper.resourcepack.asset.blockstates.ConcreteResourcePackBlockStates;
+import nl.martijnmuijsers.paper.resourcepack.asset.image.MutableImageResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.ConcreteResourcePackModel;
+import nl.martijnmuijsers.paper.resourcepack.asset.InitializableResourcePackAssetType;
+import nl.martijnmuijsers.paper.resourcepack.MutableResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.MutableResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.ResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAssetType;
+import nl.martijnmuijsers.paper.resourcepack.asset.blockstates.ResourcePackBlockStates;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.ResourcePackModel;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.texture.ConcreteResourcePackTexture;
+import nl.martijnmuijsers.paper.resourcepack.asset.texture.ResourcePackTexture;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.stream.Stream;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
+
+/**
+ * A resource pack available in memory. Can be written to a file. May be backed by a default resource pack (such as the Minecraft default resource pack), and may be based on (and always fully include) a list of other resource packs.
+ */
+public class MemoryResourcePack implements MutableResourcePack {
+
+    /**
+     * The resource pack to pull defaults from (that will be included in this resource pack only if they are modified)
+     * <br>
+     * The resource packs with the lowest index are polled for the requested asset first
+     */
+    private final @NotNull List<@NotNull ResourcePack> defaultResourcePacks = new ArrayList<>();
+
+    /**
+     * The resource pack to inherit values from, that will be always be included in this resource pack
+     * <br>
+     * On a merge conflict, the resource pack with the lowest index determines the used value
+     * (of course, unless also overwritten by this resource pack itself, in which case that value becomes the used value)
+     */
+    private final @NotNull List<@NotNull ResourcePack> includedResourcePacks = new ArrayList<>();
+
+    private final @NotNull MemoryResourcePackSettings settings = new MemoryResourcePackSettings(this);
+
+    private final @NotNull Map<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>, @NotNull MutableResourcePackAsset> assets = new HashMap<>(0);
+
+    public MemoryResourcePack() {}
+
+    @Override
+    public @NotNull Stream<@NotNull Pair<@NotNull String, @NotNull Callable<@NotNull InputStream>>> getAllFilesStream() throws IOException {
+        throw new UnsupportedOperationException("Cannot stream over all files for a resource pack being constructed in memory");
+    }
+
+    public @NotNull List<@NotNull ResourcePack> getDefaultResourcePacks() {
+        return ImmutableList.copyOf(this.defaultResourcePacks);
+    }
+
+    public void addDefaultResourcePack(@NotNull ResourcePack resourcePack) {
+        if (!this.defaultResourcePacks.contains(resourcePack)) {
+            this.defaultResourcePacks.add(resourcePack);
+        }
+    }
+
+    public @NotNull List<@NotNull ResourcePack> getIncludedResourcePacks() {
+        return ImmutableList.copyOf(this.includedResourcePacks);
+    }
+
+    public void addIncludedResourcePack(@NotNull ResourcePack resourcePack) {
+        if (!this.includedResourcePacks.contains(resourcePack)) {
+            this.includedResourcePacks.add(resourcePack);
+        }
+    }
+
+    @Override
+    public @NotNull MemoryResourcePackSettings getSettings() {
+        return this.settings;
+    }
+
+    private @NotNull MutableResourcePackAsset getMutable(@NotNull ResourcePackAssetType type, @NotNull ResourcePackAsset asset) {
+        if (asset instanceof MutableResourcePackAsset mutableAsset) {
+            return mutableAsset;
+        }
+        if (type.equals(ResourcePackAssetType.BLOCK_STATES)) {
+            return new ConcreteResourcePackBlockStates((ResourcePackBlockStates) asset);
+        } else if (type.equals(ResourcePackAssetType.MODEL)) {
+            return new ConcreteResourcePackModel((ResourcePackModel) asset);
+        } else if (type.equals(ResourcePackAssetType.TEXTURE)) {
+            // We assume all ResourcePackTexture to have been MutableResourcePackAsset already (as the current only implementation is ConcreteResourcePackTexture)
+            // since there is immediate obvious way to implement a ConcreteResourcePackTexture(ResourcePackTexture reference) constructor
+            throw new UnsupportedOperationException("Not implemented yet: could implement by adding existsInIncludedResourcePack() and getImageFilePath() methods to ResourcePackTexture interface, but that feels wrong for now");
+        } else {
+            throw new IllegalArgumentException("Attempted to create mutable asset for memory resource pack by cloning a given asset, but the type (" + type.getFolderPathInNamespaceFolder() + ") is not a known copiable type");
+        }
+    }
+
+    @Override
+    public @NotNull MutableResourcePackAsset getAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException {
+        @Nullable MutableResourcePackAsset foundOrDerivedAsset = this.assets.computeIfAbsent(Pair.of(type, key), namespacedKey -> {
+            // Try creating a merged asset from the included resource packs
+            @Nullable MutableResourcePackAsset derivedAsset = null;
+            for (@NotNull ResourcePack includedResourcePack : this.getIncludedResourcePacks()) {
+                @Nullable ResourcePackAsset includedAsset = includedResourcePack.getOptionalAsset(type, key);
+                if (includedAsset != null) {
+                    if (derivedAsset == null) {
+                        derivedAsset = this.getMutable(type, includedAsset);
+                    } else {
+                        derivedAsset = derivedAsset.merge(includedAsset);
+                    }
+                }
+            }
+            if (derivedAsset != null) {
+                derivedAsset.setDirty();
+                return derivedAsset;
+            }
+            // Try finding the default form of the asset in the default resource packs
+            for (@NotNull ResourcePack defaultResourcePack : this.getDefaultResourcePacks()) {
+                @Nullable ResourcePackAsset defaultAsset = defaultResourcePack.getOptionalAsset(type, key);
+                if (defaultAsset != null) {
+                    return this.getMutable(type, defaultAsset);
+                }
+            }
+            // We can't initially derive this asset from any inherited resource packs
+            return null;
+        });
+        if (foundOrDerivedAsset != null) {
+            return foundOrDerivedAsset;
+        }
+        throw new IllegalArgumentException("Attempted to load required asset from memory resource pack, but none was already created or present in inherited resource packs");
+    }
+
+    @Override
+    public @NotNull MutableResourcePackAsset getOrCreateAsset(@NotNull InitializableResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException {
+        @Nullable MutableResourcePackAsset existingAsset = this.getOptionalAsset(type, key);
+        if (existingAsset != null) {
+            return existingAsset;
+        }
+        @NotNull MutableResourcePackAsset newAsset;
+        if (type.equals(ResourcePackAssetType.BLOCK_STATES)) {
+            newAsset = new ConcreteResourcePackBlockStates(new JsonObject(), key);
+        } else if (type.equals(ResourcePackAssetType.MODEL)) {
+            newAsset = new ConcreteResourcePackModel(new JsonObject(), key);
+        } else if (type.equals(ResourcePackAssetType.TEXTURE)) {
+            newAsset = new ConcreteResourcePackTexture(false, null, key);
+        } else {
+            throw new IllegalArgumentException("Attempted to create asset for memory resource pack, but the type (" + type.getFolderPathInNamespaceFolder() + ") is not a known initializable type");
+        }
+        this.assets.put(Pair.of(type, key), newAsset);
+        return newAsset;
+    }
+
+    public void writeToFile(@NotNull File file) throws IOException {
+        try (@NotNull FileOutputStream fileOutputStream = new FileOutputStream(file)) {
+            try (@NotNull ZipOutputStream zipOutputStream = new ZipOutputStream(fileOutputStream)) {
+                zipOutputStream.setLevel(9);
+                @NotNull Set<@NotNull String> zippedFilePaths = new HashSet<>();
+                // Add the settings
+                {
+                    zippedFilePaths.add(PathConstants.PackMeta.pathFromRoot);
+                    @NotNull ZipEntry zipEntry = new ZipEntry(PathConstants.PackMeta.pathFromRoot);
+                    zipOutputStream.putNextEntry(zipEntry);
+                    zipOutputStream.write(this.getSettings().createJson().toString().getBytes(Charsets.UTF_8));
+                }
+                // Add the cached assets
+                for (@NotNull MutableResourcePackAsset assetInMemory : this.assets.values()) {
+                    // Don't write assets just because we have them cached: only write those that are dirty (the ones that need to be included even if not dirty will be added later)
+                    if (!assetInMemory.isDirty()) {
+                        continue;
+                    }
+                    @NotNull String path = assetInMemory.getPathInResourcePack();
+                    zippedFilePaths.add(path);
+                    @NotNull ZipEntry zipEntry = new ZipEntry(path);
+                    zipOutputStream.putNextEntry(zipEntry);
+                    assetInMemory.writeTo(zipOutputStream);
+                    if (assetInMemory.hasMeta()) {
+                        @NotNull String metaPath = path + PathConstants.metaFileSuffix;
+                        zippedFilePaths.add(metaPath);
+                        @NotNull ZipEntry metaZipEntry = new ZipEntry(metaPath);
+                        zipOutputStream.putNextEntry(metaZipEntry);
+                        assetInMemory.writeMetaTo(zipOutputStream);
+                    }
+                }
+                // Add all files from included resource packs that we haven't added yet
+                for (@NotNull ResourcePack includedResourcePack : this.includedResourcePacks) {
+                    @NotNull Stream<@NotNull Pair<@NotNull String, @NotNull Callable<@NotNull InputStream>>> allFilesStream = includedResourcePack.getAllFilesStream();
+                    @NotNull Iterable<@NotNull Pair<@NotNull String, @NotNull Callable<@NotNull InputStream>>> allFilesIterable = () -> allFilesStream.iterator();
+                    for (@NotNull Pair<@NotNull String, @NotNull Callable<@NotNull InputStream>> includedResourcePackFile : allFilesIterable) {
+                        @NotNull String includedFilePath = includedResourcePackFile.left();
+                        if (zippedFilePaths.add(includedFilePath)) {
+                            try (@NotNull InputStream includedFileInputStream = includedResourcePackFile.right().call()) {
+                                zipOutputStream.putNextEntry(new ZipEntry(includedFilePath));
+                                zipOutputStream.write(includedFileInputStream.readAllBytes());
+                            } catch (Exception e) {
+                                if (e instanceof IOException ioE) {
+                                    throw ioE;
+                                }
+                                throw new IOException("An exception occurred while getting input stream for included resource pack file", e);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        // TODO write to file and make sure to include everything from the included resource packs for sure
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/memory/MemoryResourcePackSettings.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/memory/MemoryResourcePackSettings.java
new file mode 100644
index 0000000000000000000000000000000000000000..504f1da6c1018950ef154b461c5e1e6abfa38603
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/memory/MemoryResourcePackSettings.java
@@ -0,0 +1,80 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.memory;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonParser;
+import nl.martijnmuijsers.paper.resourcepack.ResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.ResourcePackSettings;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+/**
+ * The top-level settings of a {@link MemoryResourcePack}
+ */
+public class MemoryResourcePackSettings implements ResourcePackSettings {
+
+    private static final @NotNull String DEFAULT_NAME = "Resource pack";
+    private static final @NotNull JsonElement DEFAULT_DESCRIPTION = JsonParser.parseString("[\"A resource pack\"]");
+
+    private final @NotNull MemoryResourcePack pack;
+
+    /**
+     * The name of the resource pack, which is not defined within the resource pack anywhere, but is defined by its filename without the extension
+     * <br>
+     * Note: because the filename of downloaded server resource packs is changed, this value is not relevant for resource packs used as a server resource pack
+     */
+    private @Nullable String name;
+
+    /**
+     * The description of the resource pack, displayed in the resource pack GUI
+     */
+    private @Nullable JsonElement description;
+
+    MemoryResourcePackSettings(@NotNull MemoryResourcePack pack) {
+        this.pack = pack;
+    }
+
+    @Override
+    public @NotNull String getName() {
+        if (this.name == null) {
+            // Get the name from the first included resource pack
+            List<@NotNull ResourcePack> includedResourcePacks = this.pack.getDefaultResourcePacks();
+            if (!includedResourcePacks.isEmpty()) {
+                this.name = includedResourcePacks.get(0).getSettings().getName();
+            }
+            if (this.name == null) {
+                // Use the default name
+                this.name = DEFAULT_NAME;
+            }
+        }
+        return this.name;
+    }
+
+    public void setName(@NotNull String name) {
+        this.name = name;
+    }
+
+    @Override
+    public @NotNull JsonElement getDescription() {
+        if (this.description == null) {
+            // Get the description from the first included resource pack
+            List<@NotNull ResourcePack> includedResourcePacks = this.pack.getDefaultResourcePacks();
+            if (!includedResourcePacks.isEmpty()) {
+                this.description = includedResourcePacks.get(0).getSettings().getDescription();
+            }
+            if (this.description == null) {
+                // Use the default description
+                this.description = DEFAULT_DESCRIPTION;
+            }
+        }
+        return this.description;
+    }
+
+    public void setDescription(@NotNull JsonElement description) {
+        this.description = description;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/readfromarchive/ReadFromArchiveResourcePack.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/readfromarchive/ReadFromArchiveResourcePack.java
new file mode 100644
index 0000000000000000000000000000000000000000..45e527e19839fa167f76b6e59f853cb5b39f939b
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/readfromarchive/ReadFromArchiveResourcePack.java
@@ -0,0 +1,132 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.readfromarchive;
+
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+import it.unimi.dsi.fastutil.Pair;
+import nl.martijnmuijsers.paper.resourcepack.asset.blockstates.ConcreteResourcePackBlockStates;
+import nl.martijnmuijsers.paper.resourcepack.asset.model.ConcreteResourcePackModel;
+import nl.martijnmuijsers.paper.resourcepack.ResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAsset;
+import nl.martijnmuijsers.paper.resourcepack.asset.ResourcePackAssetType;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import nl.martijnmuijsers.paper.resourcepack.asset.texture.ConcreteResourcePackTexture;
+import org.apache.commons.lang3.Validate;
+import org.apache.commons.lang3.tuple.ImmutablePair;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.file.Path;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.Callable;
+import java.util.stream.Stream;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
+/**
+ * Implementation of {@link ResourcePack} based on existing ZIP archive file
+ */
+public class ReadFromArchiveResourcePack implements ResourcePack, Closeable {
+
+    private final @NotNull Path path;
+
+    private @Nullable ZipFile zipFile;
+
+    private final ReadFromArchiveResourcePackSettings settings = new ReadFromArchiveResourcePackSettings(this);
+
+    private final @NotNull Map<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>, @NotNull ResourcePackAsset> assets = new HashMap<>(0);
+
+    public ReadFromArchiveResourcePack(@NotNull Path path) {
+        this.path = path;
+    }
+
+    public ReadFromArchiveResourcePack(@NotNull String path) {
+        this(Path.of(path));
+    }
+
+    @NotNull Path getPath() {
+        return this.path;
+    }
+
+    private @NotNull ZipFile getZipFile() throws IOException {
+        if (this.zipFile == null) {
+            this.zipFile = new ZipFile(this.path.toFile());
+        }
+        return this.zipFile;
+    }
+
+    public void close() throws IOException {
+        if (this.zipFile != null) {
+            this.zipFile.close();
+            this.zipFile = null;
+        }
+    }
+
+    private @NotNull Stream<@NotNull ZipEntry> getZipFileEntriesStream() throws IOException, NullPointerException {
+        return Validate.notNull(this.getZipFile().stream().map(it -> Validate.notNull(it)));
+    }
+
+    private @NotNull ZipEntry getZipFileEntry(@NotNull String path) throws IOException, NullPointerException {
+        return Validate.notNull(this.getZipFile().getEntry(path));
+    }
+
+    private @NotNull InputStream getZipFileEntryInputStream(@NotNull String path) throws IOException, NullPointerException {
+        return Validate.notNull(this.getZipFile().getInputStream(this.getZipFileEntry(path)));
+    }
+
+    @Override
+    public @NotNull Stream<@NotNull Pair<@NotNull String, @NotNull Callable<@NotNull InputStream>>> getAllFilesStream() throws IOException {
+        return this.getZipFileEntriesStream().map(it -> Pair.of(it.getName(), () -> this.getZipFile().getInputStream(it)));
+    }
+
+    @NotNull JsonObject readJsonAsset(@NotNull String path) throws IllegalArgumentException {
+        try {
+            @NotNull InputStream inputStream = this.getZipFileEntryInputStream(path);
+            return Validate.notNull(JsonParser.parseReader(new InputStreamReader(inputStream)).getAsJsonObject());
+        } catch (Exception e) {
+            throw new IllegalArgumentException("Attempted to load required JSON asset at internal path '" + path + "' from resource pack with path '" + this.path + "' but it did not exist", e);
+        }
+    }
+
+    @Nullable JsonObject readOptionalJsonAsset(@NotNull String path) {
+        try {
+            return readJsonAsset(path);
+        } catch (Exception e) {
+            return null;
+        }
+    }
+
+    @Override
+    public @NotNull ReadFromArchiveResourcePackSettings getSettings() {
+        return this.settings;
+    }
+
+    @Override
+    public @NotNull ResourcePackAsset getAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException {
+        @Nullable ResourcePackAsset foundAsset = this.assets.computeIfAbsent(Pair.of(type, key), namespacedKey -> {
+            String path = type.getPathInResourcePack(key);
+            try {
+                this.getZipFileEntry(path);
+            } catch (IOException e) {
+                throw new IllegalArgumentException("Attempted to load required asset at internal path '" + path + "' from resource pack with path '" + this.path + "' but it did not exist", e);
+            }
+            if (type.equals(ResourcePackAssetType.BLOCK_STATES)) {
+                return new ConcreteResourcePackBlockStates(readJsonAsset(type.getPathInResourcePack(key)), key);
+            } else if (type.equals(ResourcePackAssetType.MODEL)) {
+                return new ConcreteResourcePackModel(readJsonAsset(type.getPathInResourcePack(key)), key);
+            } else if (type.equals(ResourcePackAssetType.TEXTURE)) {
+                return new ConcreteResourcePackTexture(true, null, key);
+            } else {
+                throw new IllegalArgumentException("Attempted to read asset from archive resource pack, but the type (" + type.getFolderPathInNamespaceFolder() + ") is not a known readable type");
+            }
+        });
+        return foundAsset;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/readfromarchive/ReadFromArchiveResourcePackSettings.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/readfromarchive/ReadFromArchiveResourcePackSettings.java
new file mode 100644
index 0000000000000000000000000000000000000000..3d9a586c9ca60ea8797d586a54d5233e9c2f3cb3
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/readfromarchive/ReadFromArchiveResourcePackSettings.java
@@ -0,0 +1,69 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.readfromarchive;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import nl.martijnmuijsers.paper.resourcepack.KeyConstants;
+import nl.martijnmuijsers.paper.resourcepack.PathConstants;
+import nl.martijnmuijsers.paper.resourcepack.ResourcePackSettings;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Implementation of {@link ResourcePackSettings} for a {@link ReadFromArchiveResourcePack}
+ */
+public class ReadFromArchiveResourcePackSettings implements ResourcePackSettings {
+
+    private final @NotNull ReadFromArchiveResourcePack pack;
+
+    private @Nullable JsonObject packMetaJson;
+
+    private @Nullable String name;
+
+    private @Nullable JsonElement description;
+
+    ReadFromArchiveResourcePackSettings(@NotNull ReadFromArchiveResourcePack pack) {
+        this.pack = pack;
+    }
+
+    private @NotNull JsonObject getPackMetaJson() {
+        if (this.packMetaJson == null) {
+            this.packMetaJson = this.pack.readJsonAsset(PathConstants.PackMeta.pathFromRoot);
+        }
+        return this.packMetaJson;
+    }
+
+    @Override
+    public @NotNull String getName() {
+        if (this.name == null) {
+            // Read the name from the pack path
+            String filename = this.pack.getPath().getFileName().toString();
+            int dotIndex = filename.lastIndexOf('.');
+            if (dotIndex != -1) {
+                if (dotIndex == 0) {
+                    this.name = "";
+                } else {
+                    this.name = filename.substring(0, dotIndex);
+                }
+            } else {
+                this.name = filename;
+            }
+        }
+        return this.name;
+    }
+
+    @Override
+    public @NotNull JsonElement getDescription() {
+        if (this.description == null) {
+            // Read the description from the archive
+            this.description = this.getPackMetaJson().getAsJsonObject(KeyConstants.pack).get(KeyConstants.packDescription);
+        }
+        return this.description;
+    }
+
+    public void setDescription(@NotNull JsonElement description) {
+        this.description = description;
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/sucraft/CreateSuCraftResourcePack.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/sucraft/CreateSuCraftResourcePack.java
new file mode 100644
index 0000000000000000000000000000000000000000..0215fb53a604a6c4e6ec6bc27f4e94b5aa8bfe0f
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/sucraft/CreateSuCraftResourcePack.java
@@ -0,0 +1,190 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.sucraft;
+
+import com.google.common.collect.Iterables;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonParser;
+import net.minecraft.core.Registry;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.Block;
+import nl.martijnmuijsers.paper.block.replacementrule.BlockReplacementRule;
+import nl.martijnmuijsers.paper.item.ItemReplacementRule;
+import nl.martijnmuijsers.paper.resourcepack.ResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.memory.MemoryResourcePack;
+import nl.martijnmuijsers.paper.resourcepack.memory.MemoryResourcePackSettings;
+import nl.martijnmuijsers.paper.resourcepack.readfromarchive.ReadFromArchiveResourcePack;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.nio.file.Path;
+import java.util.Random;
+
+/**
+ * Utility class to create and write the server resource pack.
+ */
+public final class CreateSuCraftResourcePack {
+
+    private CreateSuCraftResourcePack() {}
+
+    private static final boolean useRandomResourcePackVersion = true;
+    private static final int currentResourcePackVersion;
+    static {
+        if (useRandomResourcePackVersion) {
+            currentResourcePackVersion = (int) (Math.random() * -2000000000) - 1;
+        } else {
+            currentResourcePackVersion = 149;
+        }
+    }
+
+    private static final String RESOURCE_PACK_FOLDER_PATH = "resourcepack";
+    private static final String OUTPUT_FOLDER_PATH = RESOURCE_PACK_FOLDER_PATH + "/output";
+    private static final String LAST_RESOURCE_PACK_VERSION_FILE_PATH = OUTPUT_FOLDER_PATH + "/last_resource_pack_version.txt";
+    private static final String INPUT_FOLDER_PATH = RESOURCE_PACK_FOLDER_PATH + "/input";
+    public static final String INPUT_TEXTURES_FOLDER_PATH = INPUT_FOLDER_PATH + "/textures";
+    public static final String INHERITED_RESOURCE_PACKS_FOLDER_PATH = INPUT_FOLDER_PATH + "/inheritedpacks";
+    private static final String VANILLA_RESOURCE_PACK_ARCHIVE_PATH = INHERITED_RESOURCE_PACKS_FOLDER_PATH + "/vanilla_client_1.19_only_assets_minecraft.zip";
+
+    public static final int RESOURCE_PACK_FORMAT = 9;
+    private static final String NAME = "SuCraft";
+    private static final JsonElement DESCRIPTION = JsonParser.parseString("[{\"text\":\"\\u2764 Made with love\",\"color\":\"gray\"},{\"text\":\"\\n\"},{\"text\":\"~SuCraft\",\"color\":\"gold\"}]");
+
+    /**
+     * Only null while not initialized
+     */
+    private static @Nullable String outputFilePathRandomSuffix;
+
+    public static @NotNull String getOutputFilePathRandomSuffix() {
+        StringBuilder randomSuffixBuilder = new StringBuilder();
+        Random random = new Random(currentResourcePackVersion * 17 + currentResourcePackVersion * currentResourcePackVersion + 13371 + 17922347);
+        for (int i = 0; i < 10; i++) {
+            int randomCharacter = random.nextInt(62);
+            if (randomCharacter < 26) {
+                randomSuffixBuilder.append((char) (randomCharacter + 'a'));
+            } else if (randomCharacter < 52) {
+                randomSuffixBuilder.append((char) (randomCharacter - 26 + 'A'));
+            } else {
+                randomSuffixBuilder.append((char) (randomCharacter - 52 + '0'));
+            }
+        }
+        return "-" + randomSuffixBuilder;
+    }
+
+    /**
+     * Only null while not initialized
+     */
+    private static @Nullable String outputFilePath;
+
+    public static @NotNull File getOutputFile() throws IOException {
+        if (outputFilePath == null) {
+            @NotNull File folder = new File(OUTPUT_FOLDER_PATH);
+            if (!folder.isDirectory()) {
+                throw new IOException("CreateSuCraftResourcePack.OUTPUT_FOLDER_PATH does not point to a folder");
+            }
+
+            outputFilePath = Path.of(OUTPUT_FOLDER_PATH, NAME + getOutputFilePathRandomSuffix() + ".zip").toString();
+        }
+        return new File(outputFilePath);
+    }
+
+    public static void createAndWrite() {
+        File lastResourcePackVersionFile = new File(LAST_RESOURCE_PACK_VERSION_FILE_PATH);
+        if (lastResourcePackVersionFile.exists()) {
+            try (FileInputStream fileInputStream = new FileInputStream(lastResourcePackVersionFile)) {
+                try (BufferedReader reader = new BufferedReader(new InputStreamReader(fileInputStream))) {
+                    int lastResourcePackVersion = Integer.parseInt(reader.readLine());
+                    if (lastResourcePackVersion == currentResourcePackVersion) {
+                        MinecraftServer.LOGGER.info("Skipping creating server resource pack because it is up-to-date (version " + currentResourcePackVersion + ")");
+                        return;
+                    }
+                }
+            } catch (Exception e) {
+                throw new RuntimeException("Exception occurred while checking last resource pack version", e);
+            }
+        }
+        MinecraftServer.LOGGER.info("Creating server resource pack...");
+        try {
+
+            // Construct the resource pack
+            @NotNull MemoryResourcePack resourcePack = new MemoryResourcePack();
+
+            try {
+
+                // Add the vanilla JAR as default resource pack
+                resourcePack.addDefaultResourcePack(new ReadFromArchiveResourcePack(VANILLA_RESOURCE_PACK_ARCHIVE_PATH));
+
+                // Add included resource packs
+                resourcePack.addIncludedResourcePack(new ReadFromArchiveResourcePack(INHERITED_RESOURCE_PACKS_FOLDER_PATH + "/SuCraft resource pack logo.zip"));
+                resourcePack.addIncludedResourcePack(new ReadFromArchiveResourcePack(INHERITED_RESOURCE_PACKS_FOLDER_PATH + "/Technoblade Pigs.zip"));
+
+                // Set the settings
+                @NotNull MemoryResourcePackSettings settings = resourcePack.getSettings();
+                settings.setName(NAME);
+                settings.setDescription(DESCRIPTION);
+
+                // Add all custom blocks
+                for (Block block : Registry.BLOCK) {
+                    @Nullable BlockReplacementRule replacementRule = block.replacementRule;
+                    if (replacementRule != null) {
+                        replacementRule.addToResourcePack(resourcePack);
+                    }
+                }
+
+                // Add all custom items
+                for (Item item : Registry.ITEM) {
+                    @Nullable ItemReplacementRule replacementRule = item.replacementRule;
+                    if (replacementRule != null) {
+                        replacementRule.addToResourcePack(resourcePack);
+                    }
+                }
+
+                // Delete old resource pack files
+                for (File file : new File(OUTPUT_FOLDER_PATH).listFiles()) {
+                    if (file.getName().endsWith(".zip")) {
+                        file.delete();
+                    }
+                }
+
+                // Write the resource pack to the output file
+                resourcePack.writeToFile(getOutputFile());
+
+                // Write the resource pack version to the file
+                try (FileOutputStream fileOutputStream = new FileOutputStream(LAST_RESOURCE_PACK_VERSION_FILE_PATH)) {
+                    try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(fileOutputStream))) {
+                        writer.write(currentResourcePackVersion + "\n");
+                    }
+                } catch (Exception e) {
+                    throw new RuntimeException("Exception occurred while writing new resource pack version to file", e);
+                }
+
+            } finally {
+
+                // Close all opened inherited resource packs
+                for (@NotNull ResourcePack inheritedResourcePack : Iterables.concat(resourcePack.getDefaultResourcePacks(), resourcePack.getIncludedResourcePacks())) {
+                    if (inheritedResourcePack instanceof ReadFromArchiveResourcePack readInheritedResourcePack) {
+                        try {
+                            readInheritedResourcePack.close();
+                        } catch (Exception e) {
+                            MinecraftServer.LOGGER.warn("Exception occurred while closing inherited resource pack read from archive:");
+                            e.printStackTrace();
+                        }
+                    }
+                }
+
+            }
+
+        } catch (Exception e) {
+            throw new RuntimeException("Exception occurred while creating server resource pack", e);
+        }
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/structure/CraftWorldStructurePiece.java b/src/main/java/nl/martijnmuijsers/paper/structure/CraftWorldStructurePiece.java
index c5e428bbb05f801da88449307e7c75b00f7e7cfd..60158b10b5258016a89eb879f22661463e539d47 100644
--- a/src/main/java/nl/martijnmuijsers/paper/structure/CraftWorldStructurePiece.java
+++ b/src/main/java/nl/martijnmuijsers/paper/structure/CraftWorldStructurePiece.java
@@ -66,8 +66,8 @@ public class CraftWorldStructurePiece implements WorldStructurePiece {
             if (tag == null) {
                 this.cachedFullStructureTemplateName = Optional.empty();
             } else {
-                @Nullable String name = tag.getString("Template");
-                if (name != null && name.isBlank()) {
+                @NotNull String name = tag.getString("Template");
+                if (name.isBlank()) {
                     this.cachedFullStructureTemplateName = Optional.empty();
                 } else {
                     this.cachedFullStructureTemplateName = Optional.ofNullable(name);
@@ -115,8 +115,8 @@ public class CraftWorldStructurePiece implements WorldStructurePiece {
                     this.cachedFullPoolElementName = Optional.empty();
                 } else {
                     @NotNull CompoundTag poolElementTag = tag.getCompound("pool_element");
-                    @Nullable String name = poolElementTag.getString("location");
-                    if (name != null && name.isBlank()) {
+                    @NotNull String name = poolElementTag.getString("location");
+                    if (name.isBlank()) {
                         this.cachedFullPoolElementName = Optional.empty();
                     } else {
                         this.cachedFullPoolElementName = Optional.ofNullable(name);
@@ -140,8 +140,8 @@ public class CraftWorldStructurePiece implements WorldStructurePiece {
             if (colonIndex == -1) {
                 this.cachedShortPoolElementName = Optional.of(fullPoolElementName);
             } else {
-                @Nullable String name = fullPoolElementName.substring(colonIndex + 1);
-                if (name != null && name.isBlank()) {
+                @NotNull String name = fullPoolElementName.substring(colonIndex + 1);
+                if (name.isBlank()) {
                     this.cachedShortPoolElementName = Optional.empty();
                 } else {
                     this.cachedShortPoolElementName = Optional.ofNullable(name);
diff --git a/src/main/java/nl/martijnmuijsers/paper/structure/SuCraftStructureTagsProvider.java b/src/main/java/nl/martijnmuijsers/paper/structure/SuCraftStructureTagsProvider.java
index d8999bae8bd0fea2265320fc6505eb7e09fc3e12..106e07afaf3164ebe1d63e9e48f543c99da83d4c 100644
--- a/src/main/java/nl/martijnmuijsers/paper/structure/SuCraftStructureTagsProvider.java
+++ b/src/main/java/nl/martijnmuijsers/paper/structure/SuCraftStructureTagsProvider.java
@@ -2,12 +2,17 @@
 
 package nl.martijnmuijsers.paper.structure;
 
+import net.minecraft.core.Holder;
 import net.minecraft.core.Registry;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.tags.StructureTags;
+import net.minecraft.tags.TagKey;
 import net.minecraft.world.level.levelgen.structure.Structure;
 import nl.martijnmuijsers.paper.data.SuCraftTagsProvider;
 
+import java.util.List;
+import java.util.Map;
+
 /**
  * Based on {@link net.minecraft.data.tags.StructureTagsProvider}
  */
@@ -18,7 +23,7 @@ public class SuCraftStructureTagsProvider extends SuCraftTagsProvider<Structure>
     }
 
     @Override
-    protected void addTags() {
+    protected void addTags(Map<TagKey<Structure>, List<Holder<Structure>>> existingRegistryTagEntries) {
         MinecraftServer.LOGGER.info("Adding onto existing structure tags...");
         this.tag(StructureTags.EYE_OF_ENDER_LOCATED).add(SuCraftBuiltinStructures.STRONGHOLD_SURFACE);
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 50d8c6d75e3ab4d1109e591091438f01e7ae64af..9bb7fc289e4992d0f7f44f4992b179f321eee3db 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -6,6 +6,7 @@ import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import io.papermc.paper.configuration.GlobalConfiguration;
 import io.papermc.paper.world.structure.ConfiguredStructure;
+import it.unimi.dsi.fastutil.Pair;
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
@@ -67,6 +68,7 @@ import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
 import nl.martijnmuijsers.paper.structure.WorldStructure;
 import org.apache.commons.lang.Validate;
+import org.apache.commons.lang3.tuple.ImmutablePair;
 import org.bukkit.BlockChangeDelegate;
 import org.bukkit.Bukkit;
 import org.bukkit.Chunk;
@@ -539,13 +541,16 @@ public class CraftWorld extends CraftRegionAccessor implements World {
                 if (playersInRange.isEmpty()) return;
 
                 // Paper start - Anti-Xray - Bypass
-                Map<Object, ClientboundLevelChunkWithLightPacket> refreshPackets = new HashMap<>();
+                Map<ImmutablePair<Boolean, Boolean>, ClientboundLevelChunkWithLightPacket> refreshPackets = new HashMap<>(); // Martijn - custom blocks and items
                 for (ServerPlayer player : playersInRange) {
                     if (player.connection == null) continue;
 
                     Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
-                    player.connection.send(refreshPackets.computeIfAbsent(shouldModify, s -> { // Use connection to prevent creating firing event
-                        return new ClientboundLevelChunkWithLightPacket(chunk, this.world.getLightEngine(), null, null, true, (Boolean) s);
+                    // Martijn start - custom blocks and items
+                    boolean hasResourcePack = player.hasSuCraftResourcePack();
+                    player.connection.send(refreshPackets.computeIfAbsent(new ImmutablePair<>(shouldModify, hasResourcePack), s -> { // Use connection to prevent creating firing event
+                        return new ClientboundLevelChunkWithLightPacket(chunk, this.world.getLightEngine(), null, null, true, s.left, s.right);
+                        // Martijn end - custom blocks and items
                     }));
                     // Paper end
                 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 2a7c9a82e5b5797f9a49889ae6fc251870258d49..330f635dadc2d165a404b02daa0d7b122a55a68f 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -27,6 +27,8 @@ import java.util.WeakHashMap;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.configuration.GlobalConfiguration;
 import net.minecraft.advancements.AdvancementProgress;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos; // Paper
@@ -133,6 +135,7 @@ import org.bukkit.entity.LivingEntity;
 import org.bukkit.entity.Player;
 import org.bukkit.event.player.PlayerHideEntityEvent;
 import org.bukkit.event.player.PlayerRegisterChannelEvent;
+import org.bukkit.event.player.PlayerResourcePackStatusEvent;
 import org.bukkit.event.player.PlayerShowEntityEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.event.player.PlayerUnregisterChannelEvent;
@@ -2429,6 +2432,24 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public void setResourcePackStatus(org.bukkit.event.player.PlayerResourcePackStatusEvent.Status status) {
         this.resourcePackStatus = status;
     }
+
+    // Martijn start - custom blocks and items
+
+    @Override
+    public boolean hasSuCraftResourcePack() {
+        // Currently we simply assume that if any resource pack was successfully loaded, it includes at least the SuCraft resource pack
+        // TODO maybe make this smarter, but for now taking ACCEPTED is nicer at the start - even though it may lead to FAILED_DOWNLOAD later in a small number of cases
+        // TODO ^ Maybe it's best to assume the player has the resource while status is ACCEPTED, and refresh the most important things (world chunks, player's own inventory) on FAILED_DOWNLOAD - which will be rare but then it's fixed reasonably enough I think
+        return this.resourcePackStatus == PlayerResourcePackStatusEvent.Status.ACCEPTED || this.resourcePackStatus == PlayerResourcePackStatusEvent.Status.SUCCESSFULLY_LOADED;
+    }
+
+    @Override
+    public boolean hasHighPingForCustomBlocks() {
+        return this.getPing() > GlobalConfiguration.get().customBlocksAndItems.maxPingThatCountsAsLowForCustomBlocks;
+    }
+
+    // Martijn end - custom blocks and items
+
     // Paper end
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
index 3c4dadd0012c11191c873fe25a7625193563915d..b3bc3e8ef51dfdcb264962ecf9a6267adc72ea42 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
@@ -112,9 +112,9 @@ import java.util.Collections;
  * <li> SerializableMeta.Deserializers deserializer()
  */
 @DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
-class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
+public class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta { // Martijn - custom blocks and items
 
-    static class ItemMetaKey {
+    public static class ItemMetaKey { // Martijn - custom blocks and items
 
         @Retention(RetentionPolicy.SOURCE)
         @Target(ElementType.FIELD)
@@ -128,7 +128,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         }
 
         final String BUKKIT;
-        final String NBT;
+        public final String NBT; // Martijn - custom blocks and items
 
         ItemMetaKey(final String both) {
             this(both, both);
@@ -238,12 +238,12 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         }
     }
 
-    static final ItemMetaKey NAME = new ItemMetaKey("Name", "display-name");
+    public static final ItemMetaKey NAME = new ItemMetaKey("Name", "display-name"); // Martijn - custom blocks and items
     static final ItemMetaKey LOCNAME = new ItemMetaKey("LocName", "loc-name");
     @Specific(Specific.To.NBT)
-    static final ItemMetaKey DISPLAY = new ItemMetaKey("display");
-    static final ItemMetaKey LORE = new ItemMetaKey("Lore", "lore");
-    static final ItemMetaKey CUSTOM_MODEL_DATA = new ItemMetaKey("CustomModelData", "custom-model-data");
+    public static final ItemMetaKey DISPLAY = new ItemMetaKey("display"); // Martijn - custom blocks and items
+    public static final ItemMetaKey LORE = new ItemMetaKey("Lore", "lore"); // Martijn - custom blocks and items
+    public static final ItemMetaKey CUSTOM_MODEL_DATA = new ItemMetaKey("CustomModelData", "custom-model-data"); // Martijn - custom blocks and items
     static final ItemMetaKey ENCHANTMENTS = new ItemMetaKey("Enchantments", "enchants");
     @Specific(Specific.To.NBT)
     static final ItemMetaKey ENCHANTMENTS_ID = new ItemMetaKey("id");
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index 7c1e510a0ad4b69c1fedc3367a8216046efb228e..0a0ea287897b4cbe15ca18bda99d6115f3aea31c 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -144,11 +144,25 @@ public final class CraftMagicNumbers implements UnsafeValues {
         }
         // Paper end
         for (Block block : net.minecraft.core.Registry.BLOCK) {
-            BLOCK_MATERIAL.put(block, Material.getMaterial(net.minecraft.core.Registry.BLOCK.getKey(block).getPath().toUpperCase(Locale.ROOT)));
+            // Martijn start - custom blocks and items
+            var key = net.minecraft.core.Registry.BLOCK.getKey(block);
+            String materialName = key.getPath().toUpperCase(Locale.ROOT);
+            if (key.getNamespace().equals(ResourceLocation.SUCRAFT_NAMESPACE)) {
+                materialName = "SUCRAFT_" + materialName;
+            }
+            BLOCK_MATERIAL.put(block, Material.getMaterial(materialName));
+            // Martijn end - custom blocks and items
         }
 
         for (Item item : net.minecraft.core.Registry.ITEM) {
-            ITEM_MATERIAL.put(item, Material.getMaterial(net.minecraft.core.Registry.ITEM.getKey(item).getPath().toUpperCase(Locale.ROOT)));
+            // Martijn start - custom blocks and items
+            var key = net.minecraft.core.Registry.ITEM.getKey(item);
+            String materialName = key.getPath().toUpperCase(Locale.ROOT);
+            if (key.getNamespace().equals(ResourceLocation.SUCRAFT_NAMESPACE)) {
+                materialName = "SUCRAFT_" + materialName;
+            }
+            ITEM_MATERIAL.put(item, Material.getMaterial(materialName));
+            // Martijn end - custom blocks and items
         }
 
         for (net.minecraft.world.level.material.Fluid fluid : net.minecraft.core.Registry.FLUID) {
