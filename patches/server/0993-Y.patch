From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Mon, 27 Jun 2022 21:59:41 +0200
Subject: [PATCH] Y


diff --git a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java
index aabad39d13ead83042ec2e4dd7f4ed4966af650d..78db7a5c1da164ee0c134d1a1ef50d9e73690578 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java
@@ -13,7 +13,7 @@ import net.minecraft.world.level.chunk.LevelChunk;
 
 public class ChunkPacketBlockController {
 
-    public static final ChunkPacketBlockController NO_OPERATION_INSTANCE = new ChunkPacketBlockController();
+    //public static final ChunkPacketBlockController NO_OPERATION_INSTANCE = new ChunkPacketBlockController(); // Martijn - custom blocks and items
 
     protected ChunkPacketBlockController() {
 
diff --git a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java
index a5d43901595f864c8a5dd5d013aa42d7f294e489..0fec5b98077ce888362870e5bc33b9d20bb093d2 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java
@@ -19,6 +19,8 @@ import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.EntityBlock;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.*;
+import nl.martijnmuijsers.paper.antixray.ChunkPacketBlockControllerModifier;
+import nl.martijnmuijsers.paper.antixray.ChunkPacketBlockControllerModifierBase;
 import org.bukkit.Bukkit;
 import org.spongepowered.configurate.serialize.ScalarSerializer;
 import org.spongepowered.configurate.serialize.SerializationException;
@@ -30,11 +32,9 @@ import java.util.concurrent.ThreadLocalRandom;
 import java.util.function.IntSupplier;
 import java.util.function.Predicate;
 
-public final class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockController {
+// Martijn start - custom blocks and items
+public class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockControllerModifierBase { // Martijn - custom blocks and items
 
-    private static final Palette<BlockState> GLOBAL_BLOCKSTATE_PALETTE = new GlobalPalette<>(Block.BLOCK_STATE_REGISTRY);
-    private static final LevelChunkSection EMPTY_SECTION = null;
-    private final Executor executor;
     private final EngineMode engineMode;
     private final int maxBlockHeight;
     private final int updateRadius;
@@ -56,7 +56,7 @@ public final class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockCo
     private final int maxBlockHeightUpdatePosition;
 
     public ChunkPacketBlockControllerAntiXray(Level level, Executor executor) {
-        this.executor = executor;
+        super(level, executor);
         WorldConfiguration.AntiCheat.AntiXRay paperWorldConfig = level.paperConfig().anticheat.antiXray;
         engineMode = paperWorldConfig.engineMode;
         maxBlockHeight = paperWorldConfig.maxBlockHeight >> 4 << 4;
@@ -168,44 +168,24 @@ public final class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockCo
         return !usePermission || !player.getBukkitEntity().hasPermission("paper.antixray.bypass");
     }
 
-    @Override
-    public ChunkPacketInfoAntiXray getChunkPacketInfo(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk) {
-        // Return a new instance to collect data and objects in the right state while creating the chunk packet for thread safe access later
-        return new ChunkPacketInfoAntiXray(chunkPacket, chunk, this);
-    }
-
-    @Override
-    public void modifyBlocks(ClientboundLevelChunkWithLightPacket chunkPacket, ChunkPacketInfo<BlockState> chunkPacketInfo) {
-        if (!(chunkPacketInfo instanceof ChunkPacketInfoAntiXray)) {
-            chunkPacket.setReady(true);
-            return;
-        }
-
-        if (!Bukkit.isPrimaryThread()) {
-            // Plugins?
-            MinecraftServer.getServer().scheduleOnMain(() -> modifyBlocks(chunkPacket, chunkPacketInfo));
-            return;
-        }
-
-        LevelChunk chunk = chunkPacketInfo.getChunk();
-        int x = chunk.getPos().x;
-        int z = chunk.getPos().z;
-        Level level = chunk.getLevel();
-        ((ChunkPacketInfoAntiXray) chunkPacketInfo).setNearbyChunks(level.getChunkIfLoaded(x - 1, z), level.getChunkIfLoaded(x + 1, z), level.getChunkIfLoaded(x, z - 1), level.getChunkIfLoaded(x, z + 1));
-        executor.execute((Runnable) chunkPacketInfo);
-    }
-
     // Actually these fields should be variables inside the obfuscate method but in sync mode or with SingleThreadExecutor in async mode it's okay (even without ThreadLocal)
     // If an ExecutorService with multiple threads is used, ThreadLocal must be used here
     private final ThreadLocal<int[]> presetBlockStateBits = ThreadLocal.withInitial(() -> new int[getPresetBlockStatesFullLength()]);
-    private static final ThreadLocal<boolean[]> SOLID = ThreadLocal.withInitial(() -> new boolean[Block.BLOCK_STATE_REGISTRY.size()]);
-    private static final ThreadLocal<boolean[]> OBFUSCATE = ThreadLocal.withInitial(() -> new boolean[Block.BLOCK_STATE_REGISTRY.size()]);
+    protected static final ThreadLocal<boolean[]> SOLID = ThreadLocal.withInitial(() -> new boolean[Block.BLOCK_STATE_REGISTRY.size()]);
+    protected static final ThreadLocal<boolean[]> OBFUSCATE = ThreadLocal.withInitial(() -> new boolean[Block.BLOCK_STATE_REGISTRY.size()]);
     // These boolean arrays represent chunk layers, true means don't obfuscate, false means obfuscate
-    private static final ThreadLocal<boolean[][]> CURRENT = ThreadLocal.withInitial(() -> new boolean[16][16]);
-    private static final ThreadLocal<boolean[][]> NEXT = ThreadLocal.withInitial(() -> new boolean[16][16]);
-    private static final ThreadLocal<boolean[][]> NEXT_NEXT = ThreadLocal.withInitial(() -> new boolean[16][16]);
+    protected static final ThreadLocal<boolean[][]> CURRENT = ThreadLocal.withInitial(() -> new boolean[16][16]);
+    protected static final ThreadLocal<boolean[][]> NEXT = ThreadLocal.withInitial(() -> new boolean[16][16]);
+    protected static final ThreadLocal<boolean[][]> NEXT_NEXT = ThreadLocal.withInitial(() -> new boolean[16][16]);
 
-    public void obfuscate(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+    // Martijn start- custom blocks and items
+    @Override
+    public void obfuscateInternal(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        this.obfuscateXray(chunkPacketInfoAntiXray);
+    }
+
+    public void obfuscateXray(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        // Martijn end - custom blocks and items
         int[] presetBlockStateBits = this.presetBlockStateBits.get();
         boolean[] solid = SOLID.get();
         boolean[] obfuscate = OBFUSCATE.get();
@@ -349,8 +329,6 @@ public final class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockCo
                 bitStorageWriter.flush();
             }
         }
-
-        chunkPacketInfoAntiXray.getChunkPacket().setReady(true);
     }
 
     private void obfuscateLayer(int y, BitStorageReader bitStorageReader, BitStorageWriter bitStorageWriter, boolean[] solid, boolean[] obfuscate, int[] presetBlockStateBits, boolean[][] current, boolean[][] next, boolean[][] nextNext, LevelChunkSection[] nearbyChunkSections, IntSupplier random) {
@@ -690,3 +668,4 @@ public final class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockCo
         }
     }
 }
+// Martijn end - custom blocks and items
diff --git a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfoAntiXray.java b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfoAntiXray.java
index 80a2dfb266ae1221680a7b24fee2f7e2a8330b7d..13262d4e31d4bfd1a0dbc15b9a10ce0569fabdee 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfoAntiXray.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfoAntiXray.java
@@ -3,13 +3,15 @@ package com.destroystokyo.paper.antixray;
 import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.LevelChunk;
+import nl.martijnmuijsers.paper.antixray.ChunkPacketBlockControllerAntiXrayCustom;
+import nl.martijnmuijsers.paper.antixray.ChunkPacketBlockControllerModifier;
 
 public final class ChunkPacketInfoAntiXray extends ChunkPacketInfo<BlockState> implements Runnable {
 
-    private final ChunkPacketBlockControllerAntiXray chunkPacketBlockControllerAntiXray;
+    private final ChunkPacketBlockControllerModifier chunkPacketBlockControllerAntiXray; // Martijn - custom blocks and items
     private LevelChunk[] nearbyChunks;
 
-    public ChunkPacketInfoAntiXray(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk, ChunkPacketBlockControllerAntiXray chunkPacketBlockControllerAntiXray) {
+    public ChunkPacketInfoAntiXray(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk, ChunkPacketBlockControllerModifier chunkPacketBlockControllerAntiXray) { // Martijn - custom blocks and items
         super(chunkPacket, chunk);
         this.chunkPacketBlockControllerAntiXray = chunkPacketBlockControllerAntiXray;
     }
diff --git a/src/main/java/net/minecraft/network/Connection.java b/src/main/java/net/minecraft/network/Connection.java
index d5a083c678adcaeca6509f331aafcfb4c9ceae48..2e8b6073bcc80a0927da8a6bd906e11b5ffdd144 100644
--- a/src/main/java/net/minecraft/network/Connection.java
+++ b/src/main/java/net/minecraft/network/Connection.java
@@ -45,8 +45,11 @@ import net.minecraft.server.network.ServerGamePacketListenerImpl;
 import net.minecraft.server.network.ServerLoginPacketListenerImpl;
 import net.minecraft.util.LazyLoadedValue;
 import net.minecraft.util.Mth;
+import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.level.chunk.LevelChunk;
 import org.apache.commons.lang3.Validate;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.slf4j.Logger;
 import org.slf4j.Marker;
 import org.slf4j.MarkerFactory;
@@ -327,6 +330,23 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             return null;
         }
     }
+
+    // Martijn start - custom blocks and items
+
+    public boolean doesPlayerHaveSuCraftResourcePack() {
+        var player = getPlayer();
+        if (player == null) {
+            return false;
+        }
+        var bukkitPlayer = player.getBukkitEntity();
+        if (bukkitPlayer == null) {
+            return false;
+        }
+        return bukkitPlayer.hasSuCraftResourcePack();
+    }
+
+    // Martijn end - custom blocks and items
+
     private static class InnerUtil { // Attempt to hide these methods from ProtocolLib so it doesn't accidently pick them up.
         private static java.util.List<Packet> buildExtraPackets(Packet packet) {
             java.util.List<Packet> extra = packet.getExtraPackets();
@@ -433,24 +453,22 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             this.channel.config().setAutoRead(false);
         }
 
-        // Martijn start - custom blocks and items
-        packet = packet.replaceCustomContent(getPlayer().getBukkitEntity().hasSuCraftResourcePack());
-        // Martijn end - custom blocks and items
+        Packet<?> modifiedPacket = packet.replaceCustomContent(this.doesPlayerHaveSuCraftResourcePack()); // Martijn - custom blocks and items
 
         if (this.channel.eventLoop().inEventLoop()) {
-            this.doSendPacket(packet, callback, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter
+            this.doSendPacket(modifiedPacket, callback, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter // Martijn - custom blocks and items
         } else {
             // Paper start - optimise packets that are not flushed
             // note: since the type is not dynamic here, we need to actually copy the old executor code
             // into two branches. On conflict, just re-copy - no changes were made inside the executor code.
             if (!flush) {
                 AbstractEventExecutor.LazyRunnable run = () -> {
-                    this.doSendPacket(packet, callback, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter
+                    this.doSendPacket(modifiedPacket, callback, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter // Martijn - custom blocks and items
                 };
                 this.channel.eventLoop().execute(run);
             } else { // Paper end - optimise packets that are not flushed
             this.channel.eventLoop().execute(() -> {
-                this.doSendPacket(packet, callback, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter // Paper - diff on change
+                this.doSendPacket(modifiedPacket, callback, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter // Paper - diff on change // Martijn - custom blocks and items
             });
             } // Paper
         }
diff --git a/src/main/java/net/minecraft/network/protocol/Packet.java b/src/main/java/net/minecraft/network/protocol/Packet.java
index e8fcd56906d26f6dc87959e32c4c7c78cfea9658..dde21b11d9b612eeac03be1835c815a697358bcb 100644
--- a/src/main/java/net/minecraft/network/protocol/Packet.java
+++ b/src/main/java/net/minecraft/network/protocol/Packet.java
@@ -2,6 +2,7 @@ package net.minecraft.network.protocol;
 
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.PacketListener;
+import org.jetbrains.annotations.NotNull;
 
 public interface Packet<T extends PacketListener> {
     void write(FriendlyByteBuf buf);
@@ -30,4 +31,21 @@ public interface Packet<T extends PacketListener> {
     default boolean isSkippable() {
         return false;
     }
+
+    // Martijn start - custom blocks and items
+
+    /**
+     * Replaces any custom blocks or items in this packet will their intended replacement, based
+     * on whether a player has accepted the resource pack.
+     *
+     * This will usually replace the custom content in-place, returning this instance itself. However, when there is
+     * a real risk of a single packet instance with custom content to be replaced being sent to multiple players with
+     * differing resource pack statuses, this method may return a different instance.
+     */
+    default @NotNull Packet<T> replaceCustomContent(boolean hasResourcePack) {
+        return this;
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
index 6c30f3bf85ec0e0dfbae1b5ed192b43b1dbd48be..9423375fb5a7adb40cdff5558bc8bfab9b554d9f 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
@@ -18,6 +18,7 @@ import net.minecraft.world.level.block.entity.BlockEntityType;
 import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.chunk.LevelChunkSection;
 import net.minecraft.world.level.levelgen.Heightmap;
+import org.jetbrains.annotations.NotNull;
 
 public class ClientboundLevelChunkPacketData {
     private static final int TWO_MEGABYTES = 2097152;
@@ -191,4 +192,5 @@ public class ClientboundLevelChunkPacketData {
     public interface BlockEntityTagOutput {
         void accept(BlockPos pos, BlockEntityType<?> type, @Nullable CompoundTag nbt);
     }
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
index 2072aa8710f6e285f7c8f76c63b7bcf85cc11030..294d03d788dd325735104ad38a2f309731c558b2 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
@@ -7,6 +7,7 @@ import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.lighting.LevelLightEngine;
+import org.jetbrains.annotations.NotNull;
 
 public class ClientboundLevelChunkWithLightPacket implements Packet<ClientGamePacketListener> {
     private final int x;
@@ -81,4 +82,5 @@ public class ClientboundLevelChunkWithLightPacket implements Packet<ClientGamePa
         return this.chunkData.getExtraPackets();
     }
     // Paper end
+
 }
diff --git a/src/main/java/net/minecraft/world/item/Items.java b/src/main/java/net/minecraft/world/item/Items.java
index 6534c9f44323a3cc97e74f3347562d1561b1326e..f15618f9c16b9179c033666fbc25ca556eeed138 100644
--- a/src/main/java/net/minecraft/world/item/Items.java
+++ b/src/main/java/net/minecraft/world/item/Items.java
@@ -1223,6 +1223,9 @@ public class Items {
     // Martijn start - custom blocks and items
 
     static {
+        // Evaluate the last element to bootstrap Items
+        ECHO_SHARD.asItem();
+        // Then bootstrap SuCraftItems
         SuCraftItems.bootstrap();
     }
 
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 94dd87584de8cf23ff8fc4396400ff39730709f0..d5cae13c0cdf4171541d43e512970ea2cdca34b1 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -1,10 +1,7 @@
 package net.minecraft.world.level;
 
-import co.aikar.timings.Timing;
-import co.aikar.timings.Timings;
 import com.destroystokyo.paper.event.server.ServerExceptionEvent;
 import com.destroystokyo.paper.exception.ServerInternalException;
-import com.google.common.base.MoreObjects;
 import com.google.common.collect.Lists;
 import com.mojang.serialization.Codec;
 import java.io.IOException;
@@ -17,7 +14,6 @@ import java.util.function.Supplier;
 import javax.annotation.Nullable;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
-import net.minecraft.ReportedException;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Holder;
@@ -40,8 +36,6 @@ import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.DifficultyInstance;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.boss.EnderDragonPart;
-import net.minecraft.world.entity.boss.enderdragon.EnderDragon;
 import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
@@ -89,18 +83,17 @@ import net.minecraft.network.protocol.game.ClientboundSetBorderLerpSizePacket;
 import net.minecraft.network.protocol.game.ClientboundSetBorderSizePacket;
 import net.minecraft.network.protocol.game.ClientboundSetBorderWarningDelayPacket;
 import net.minecraft.network.protocol.game.ClientboundSetBorderWarningDistancePacket;
+import nl.martijnmuijsers.paper.antixray.ChunkPacketBlockControllerAntiXrayCustom;
+import nl.martijnmuijsers.paper.antixray.ChunkPacketBlockControllerCustom;
 import org.bukkit.Bukkit;
-import org.bukkit.Location;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.block.CapturedBlockState;
 import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.craftbukkit.util.CraftSpawnCategory;
-import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.entity.SpawnCategory;
 import org.bukkit.event.block.BlockPhysicsEvent;
-import org.bukkit.event.world.GenericGameEvent;
 // CraftBukkit end
 
 public abstract class Level implements LevelAccessor, AutoCloseable {
@@ -374,7 +367,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         this.keepSpawnInMemory = this.paperConfig().spawn.keepSpawnLoaded; // Paper
         this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
         this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
-        this.chunkPacketBlockController = this.paperConfig().anticheat.antiXray.enabled ? new com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray(this, executor) : com.destroystokyo.paper.antixray.ChunkPacketBlockController.NO_OPERATION_INSTANCE; // Paper - Anti-Xray
+        this.chunkPacketBlockController = this.paperConfig().anticheat.antiXray.enabled ? new ChunkPacketBlockControllerAntiXrayCustom(this, executor) : new ChunkPacketBlockControllerCustom(this, executor); // Paper - Anti-Xray // Martijn - custom blocks and items
         this.entitySliceManager = new io.papermc.paper.world.EntitySliceManager((ServerLevel)this); // Paper
     }
 
diff --git a/src/main/java/net/minecraft/world/level/block/Blocks.java b/src/main/java/net/minecraft/world/level/block/Blocks.java
index daa20c9b3b6ae543f2b2525b9f8d67eb736eb9f5..eac7db586991732b8c98357bb5e16812ec455731 100644
--- a/src/main/java/net/minecraft/world/level/block/Blocks.java
+++ b/src/main/java/net/minecraft/world/level/block/Blocks.java
@@ -1183,6 +1183,9 @@ public class Blocks {
     }
 
     static {
+        // Evaluate the last element to bootstrap Blocks
+        REINFORCED_DEEPSLATE.asBlock();
+        // Then bootstrap SuCraftBlocks
         SuCraftBlocks.bootstrap(); // Martijn - custom blocks and items
         for(Block block : Registry.BLOCK) {
             for(BlockState blockState : block.getStateDefinition().getPossibleStates()) {
diff --git a/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerAntiXrayCustom.java b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerAntiXrayCustom.java
new file mode 100644
index 0000000000000000000000000000000000000000..6b1c7b68d566f352cf0534f5f9ec62d98c8c6b49
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerAntiXrayCustom.java
@@ -0,0 +1,68 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.antixray;
+
+import com.destroystokyo.paper.antixray.BitStorageReader;
+import com.destroystokyo.paper.antixray.BitStorageWriter;
+import com.destroystokyo.paper.antixray.ChunkPacketBlockController;
+import com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray;
+import com.destroystokyo.paper.antixray.ChunkPacketInfo;
+import com.destroystokyo.paper.antixray.ChunkPacketInfoAntiXray;
+import io.papermc.paper.configuration.WorldConfiguration;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.core.Registry;
+import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
+import net.minecraft.network.protocol.game.ServerboundPlayerActionPacket;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.level.ServerPlayerGameMode;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.biome.Biomes;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.EntityBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.EmptyLevelChunk;
+import net.minecraft.world.level.chunk.GlobalPalette;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.LevelChunkSection;
+import net.minecraft.world.level.chunk.MissingPaletteEntryException;
+import net.minecraft.world.level.chunk.Palette;
+import org.bukkit.Bukkit;
+import org.spongepowered.configurate.serialize.ScalarSerializer;
+import org.spongepowered.configurate.serialize.SerializationException;
+
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.LinkedHashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Objects;
+import java.util.Set;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.function.IntSupplier;
+import java.util.function.Predicate;
+
+public final class ChunkPacketBlockControllerAntiXrayCustom extends ChunkPacketBlockControllerAntiXray {
+
+    public ChunkPacketBlockControllerAntiXrayCustom(Level level, Executor executor) {
+        super(level, executor);
+    }
+
+    @Override
+    public boolean shouldModify(ServerPlayer player, LevelChunk chunk) {
+        return true;
+    }
+
+    @Override
+    public void obfuscateInternal(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        obfuscateXray(chunkPacketInfoAntiXray);
+        ChunkPacketBlockControllerCustom.replaceCustom(chunkPacketInfoAntiXray);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerCustom.java b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerCustom.java
new file mode 100644
index 0000000000000000000000000000000000000000..a9c26bcff171ddb6aaafa26b2e6057c84ae65d60
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerCustom.java
@@ -0,0 +1,104 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.antixray;
+
+import com.destroystokyo.paper.antixray.BitStorageReader;
+import com.destroystokyo.paper.antixray.BitStorageWriter;
+import com.destroystokyo.paper.antixray.ChunkPacketBlockController;
+import com.destroystokyo.paper.antixray.ChunkPacketInfo;
+import com.destroystokyo.paper.antixray.ChunkPacketInfoAntiXray;
+import io.papermc.paper.configuration.WorldConfiguration;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.core.Registry;
+import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
+import net.minecraft.network.protocol.game.ServerboundPlayerActionPacket;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.level.ServerPlayerGameMode;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.biome.Biomes;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.EntityBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.EmptyLevelChunk;
+import net.minecraft.world.level.chunk.GlobalPalette;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.LevelChunkSection;
+import net.minecraft.world.level.chunk.MissingPaletteEntryException;
+import net.minecraft.world.level.chunk.Palette;
+import org.bukkit.Bukkit;
+import org.spongepowered.configurate.serialize.ScalarSerializer;
+import org.spongepowered.configurate.serialize.SerializationException;
+
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.LinkedHashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Objects;
+import java.util.Set;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.function.IntSupplier;
+import java.util.function.Predicate;
+
+public final class ChunkPacketBlockControllerCustom extends ChunkPacketBlockControllerModifierBase {
+
+    public ChunkPacketBlockControllerCustom(Level level, Executor executor) {
+        super(level, executor);
+    }
+
+    @Override
+    public boolean shouldModify(ServerPlayer player, LevelChunk chunk) {
+        return true;
+    }
+
+    @Override
+    public void obfuscateInternal(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        replaceCustom(chunkPacketInfoAntiXray);
+    }
+
+    public static void replaceCustom(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        // bitStorageReader, bitStorageWriter and nearbyChunkSections could also be reused (with ThreadLocal if necessary) but it's not worth it
+        BitStorageReader bitStorageReader = new BitStorageReader();
+        BitStorageWriter bitStorageWriter = new BitStorageWriter();
+        LevelChunk chunk = chunkPacketInfoAntiXray.getChunk();
+        int sectionsCount = chunk.getSectionsCount();
+        Level level = chunk.getLevel();
+        boolean[] obfuscateTemp = null;
+        bitStorageReader.setBuffer(chunkPacketInfoAntiXray.getBuffer());
+        bitStorageWriter.setBuffer(chunkPacketInfoAntiXray.getBuffer());
+
+        for (int chunkSectionIndex = 0; chunkSectionIndex < sectionsCount; chunkSectionIndex++) {
+            if (chunkPacketInfoAntiXray.isWritten(chunkSectionIndex) && chunkPacketInfoAntiXray.getPresetValues(chunkSectionIndex) != null) {
+
+                bitStorageReader.setBits(chunkPacketInfoAntiXray.getBits(chunkSectionIndex));
+                bitStorageReader.setIndex(chunkPacketInfoAntiXray.getIndex(chunkSectionIndex));
+                bitStorageWriter.setBits(chunkPacketInfoAntiXray.getBits(chunkSectionIndex));
+                bitStorageWriter.setIndex(chunkPacketInfoAntiXray.getIndex(chunkSectionIndex));
+
+                // Modify all layers of the current chunk section
+                for (int y = 0; y < 16; y++) {
+                    for (int x = 0; x < 16; x++) {
+                        for (int z = 0; z < 16; z++) {
+                            int bits = bitStorageReader.read();
+                            // TODO change
+                            // temporary test
+                            if (bits != 0) {
+                                bits = 1;
+                            }
+                            bitStorageWriter.write(bits);
+                        }
+                    }
+                }
+                bitStorageWriter.flush();
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerModifier.java b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerModifier.java
new file mode 100644
index 0000000000000000000000000000000000000000..5657efde50d31c1661b9c47a596f0df58c137803
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerModifier.java
@@ -0,0 +1,15 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.antixray;
+
+import com.destroystokyo.paper.antixray.ChunkPacketInfoAntiXray;
+
+public interface ChunkPacketBlockControllerModifier {
+
+    /**
+     * This method represents modifying the blocks, which can be obfuscation, but doesn't have to be
+     * (naming based on existing method in ChunkPacketBlockControllerAntiXray)
+     */
+    void obfuscate(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray);
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerModifierBase.java b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerModifierBase.java
new file mode 100644
index 0000000000000000000000000000000000000000..d74ce7ebb85a2bcac532f5b00468f507c0a2cc56
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/antixray/ChunkPacketBlockControllerModifierBase.java
@@ -0,0 +1,96 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.antixray;
+
+import com.destroystokyo.paper.antixray.BitStorageReader;
+import com.destroystokyo.paper.antixray.BitStorageWriter;
+import com.destroystokyo.paper.antixray.ChunkPacketBlockController;
+import com.destroystokyo.paper.antixray.ChunkPacketInfo;
+import com.destroystokyo.paper.antixray.ChunkPacketInfoAntiXray;
+import io.papermc.paper.configuration.WorldConfiguration;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.core.Registry;
+import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
+import net.minecraft.network.protocol.game.ServerboundPlayerActionPacket;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.level.ServerPlayerGameMode;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.biome.Biomes;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.EntityBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.EmptyLevelChunk;
+import net.minecraft.world.level.chunk.GlobalPalette;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.LevelChunkSection;
+import net.minecraft.world.level.chunk.MissingPaletteEntryException;
+import net.minecraft.world.level.chunk.Palette;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.Nullable;
+import org.spongepowered.configurate.serialize.ScalarSerializer;
+import org.spongepowered.configurate.serialize.SerializationException;
+
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.LinkedHashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Objects;
+import java.util.Set;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.function.IntSupplier;
+import java.util.function.Predicate;
+
+public abstract class ChunkPacketBlockControllerModifierBase extends ChunkPacketBlockController implements ChunkPacketBlockControllerModifier { // Martijn - custom blocks and items
+
+    public static final Palette<BlockState> GLOBAL_BLOCKSTATE_PALETTE = new GlobalPalette<>(Block.BLOCK_STATE_REGISTRY);
+    public static final LevelChunkSection EMPTY_SECTION = null;
+    protected final Executor executor;
+
+    public ChunkPacketBlockControllerModifierBase(Level level, Executor executor) {
+        this.executor = executor;
+    }
+
+    @Override
+    public void obfuscate(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        this.obfuscateInternal(chunkPacketInfoAntiXray);
+        chunkPacketInfoAntiXray.getChunkPacket().setReady(true);
+    }
+
+    public abstract void obfuscateInternal(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray);
+
+    @Override
+    public ChunkPacketInfoAntiXray getChunkPacketInfo(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk) {
+        // Return a new instance to collect data and objects in the right state while creating the chunk packet for thread safe access later
+        return new ChunkPacketInfoAntiXray(chunkPacket, chunk, this);
+    }
+
+    @Override
+    public void modifyBlocks(ClientboundLevelChunkWithLightPacket chunkPacket, ChunkPacketInfo<BlockState> chunkPacketInfo) {
+        if (!(chunkPacketInfo instanceof ChunkPacketInfoAntiXray)) {
+            chunkPacket.setReady(true);
+            return;
+        }
+
+        if (!Bukkit.isPrimaryThread()) {
+            // Plugins?
+            MinecraftServer.getServer().scheduleOnMain(() -> modifyBlocks(chunkPacket, chunkPacketInfo));
+            return;
+        }
+
+        LevelChunk chunk = chunkPacketInfo.getChunk();
+        int x = chunk.getPos().x;
+        int z = chunk.getPos().z;
+        Level level = chunk.getLevel();
+        ((ChunkPacketInfoAntiXray) chunkPacketInfo).setNearbyChunks(level.getChunkIfLoaded(x - 1, z), level.getChunkIfLoaded(x + 1, z), level.getChunkIfLoaded(x, z - 1), level.getChunkIfLoaded(x, z + 1));
+        executor.execute((Runnable) chunkPacketInfo);
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/BlockReplacementRule.java b/src/main/java/nl/martijnmuijsers/paper/block/BlockReplacementRule.java
index 31ce381b7d9ca3c1bc276542db5b115f92dd1f20..e2cbe13e8e18fed745f9d4b38205ffd8f628e05f 100644
--- a/src/main/java/nl/martijnmuijsers/paper/block/BlockReplacementRule.java
+++ b/src/main/java/nl/martijnmuijsers/paper/block/BlockReplacementRule.java
@@ -10,13 +10,15 @@ import org.checkerframework.checker.units.qual.N;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+import java.util.function.Supplier;
+
 public interface BlockReplacementRule {
 
     interface Builder {
 
         @NotNull BlockReplacementRule.Builder withReal(@NotNull Block real);
 
-        @NotNull BlockReplacementRule.Builder withFallbackItem(@NotNull Item fallbackItem);
+        @NotNull BlockReplacementRule.Builder withFallbackItem(@NotNull Supplier<@NotNull Item> fallbackItemSupplier);
 
         @NotNull BlockReplacementRule build();
 
@@ -54,7 +56,7 @@ public interface BlockReplacementRule {
             private @Nullable BlockState host;
             private @Nullable BlockState hostReplacement;
             private @Nullable BlockState fallback;
-            private @Nullable Item fallbackItem;
+            private @Nullable Supplier<@NotNull Item> fallbackItemSupplier;
 
             @Override
             public @NotNull StatelessBlockReplacementRule.Builder withReal(@NotNull Block real) {
@@ -94,14 +96,14 @@ public interface BlockReplacementRule {
             }
 
             @Override
-            public @NotNull StatelessBlockReplacementRule.Builder withFallbackItem(@NotNull Item fallbackItem) {
-                this.fallbackItem = fallbackItem;
+            public @NotNull StatelessBlockReplacementRule.Builder withFallbackItem(@NotNull Supplier<@NotNull Item> fallbackItemSupplier) {
+                this.fallbackItemSupplier = fallbackItemSupplier;
                 return this;
             }
 
             public @NotNull StatelessBlockReplacementRule.Builder withFallbackBlockAsItem() {
                 Validate.notNull(this.fallback);
-                return this.withFallbackItem(this.fallback.getBlock().asItem());
+                return this.withFallbackItem(() -> this.fallback.getBlock().asItem());
             }
 
             @Override
@@ -110,7 +112,7 @@ public interface BlockReplacementRule {
                 Validate.notNull(this.host);
                 Validate.notNull(this.hostReplacement);
                 Validate.notNull(this.fallback);
-                return new StatelessBlockReplacementRule(this.real, this.host, this.hostReplacement, this.fallback, fallbackItem);
+                return new StatelessBlockReplacementRule(this.real, this.host, this.hostReplacement, this.fallback, fallbackItemSupplier);
             }
 
         }
@@ -122,15 +124,24 @@ public interface BlockReplacementRule {
 
         /**
          * May be null if this block has no item form, must be non-null if this block has an item form
+         * Will also be null if not initialized yet
+         */
+        private @Nullable Item fallbackItem = null;
+
+        /**
+         * This is used to get the fallback item the first time it is needed: this is to ensure no calls to the Items class are made before the blocks have finished initializing, otherwise we cannot refer to the blocks when we wish to create items for them
+         *
+         * May be null if this block has no item form, must be non-null if this block has an item form
+         * Will also be set to null after the first evaluation
          */
-        private final @Nullable Item fallbackItem;
+        private @Nullable Supplier<@NotNull Item> fallbackItemSupplier;
 
-        private StatelessBlockReplacementRule(@NotNull Block real, @NotNull BlockState host, @NotNull BlockState hostReplacement, @NotNull BlockState fallback, @Nullable Item fallbackItem) {
+        private StatelessBlockReplacementRule(@NotNull Block real, @NotNull BlockState host, @NotNull BlockState hostReplacement, @NotNull BlockState fallback, @Nullable Supplier<@NotNull Item> fallbackItemSupplier) {
             this.real = real;
             this.host = host;
             this.hostReplacement = hostReplacement;
             this.fallback = fallback;
-            this.fallbackItem = fallbackItem;
+            this.fallbackItemSupplier = fallbackItemSupplier;
         }
 
         @Override
@@ -150,6 +161,13 @@ public interface BlockReplacementRule {
 
         @Override
         public @Nullable Item getFallbackItem() {
+            if (this.fallbackItem == null) {
+                if (this.fallbackItemSupplier == null) {
+                    return null;
+                }
+                this.fallbackItem = this.fallbackItemSupplier.get();
+                this.fallbackItemSupplier = null;
+            }
             return this.fallbackItem;
         }
 
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlocks.java b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlocks.java
index 7b5f47a5d8b4ee7f958abcb453b7d4bca2cfc23f..35663c5ba47e9930d7793879272b8dfa436322c8 100644
--- a/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlocks.java
+++ b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlocks.java
@@ -4,6 +4,7 @@ package nl.martijnmuijsers.paper.block;
 
 import net.minecraft.core.Registry;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockBehaviour;
diff --git a/src/main/java/nl/martijnmuijsers/paper/item/ItemReplacementRule.java b/src/main/java/nl/martijnmuijsers/paper/item/ItemReplacementRule.java
index 78438cedd0536224cc10f17138bffb5d240932bd..15e9bd86c9a91f110c322ec2e3947d75c864cb4b 100644
--- a/src/main/java/nl/martijnmuijsers/paper/item/ItemReplacementRule.java
+++ b/src/main/java/nl/martijnmuijsers/paper/item/ItemReplacementRule.java
@@ -1,5 +1,6 @@
 package nl.martijnmuijsers.paper.item;
 
+import it.unimi.dsi.fastutil.objects.Object2IntFunction;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.StringTag;
 import net.minecraft.world.item.Item;
@@ -13,7 +14,9 @@ import org.bukkit.craftbukkit.inventory.CraftMetaItem;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+import java.util.function.Function;
 import java.util.function.IntSupplier;
+import java.util.function.Supplier;
 
 public interface ItemReplacementRule {
 
@@ -34,9 +37,9 @@ public interface ItemReplacementRule {
         public static class Builder implements ItemReplacementRule.Builder {
 
             private @Nullable Item real;
-            private @Nullable Item host;
-            private @Nullable IntSupplier computeHostCustomModelData;
-            private @Nullable Item fallback;
+            private @Nullable Supplier<@NotNull Item> hostSupplier;
+            private @Nullable Function<@NotNull Item, @NotNull Integer> computeHostCustomModelData;
+            private @Nullable Supplier<@NotNull Item> fallbackSupplier;
 
             @Override
             public @NotNull SimpleItemReplacementRule.Builder withReal(@NotNull Item real) {
@@ -44,54 +47,57 @@ public interface ItemReplacementRule {
                 return this;
             }
 
-            public @NotNull SimpleItemReplacementRule.Builder withHost(@NotNull Item host) {
-                this.host = host;
+            public @NotNull SimpleItemReplacementRule.Builder withHost(@NotNull Supplier<@NotNull Item> hostSupplier) {
+                this.hostSupplier = hostSupplier;
                 return this;
             }
 
             public @NotNull SimpleItemReplacementRule.Builder withHostCustomModelData(int hostCustomModelData) {
-                this.computeHostCustomModelData = () -> hostCustomModelData;
+                this.computeHostCustomModelData = host -> hostCustomModelData;
                 return this;
             }
 
             public @NotNull SimpleItemReplacementRule.Builder withNextUnusedHostCustomModelData() {
-                this.computeHostCustomModelData = () -> UsedHostCustomModelData.generateUnusedHostCustomModelData(host);
+                this.computeHostCustomModelData = host -> UsedHostCustomModelData.generateUnusedHostCustomModelData(host);
                 return this;
             }
 
-            public @NotNull SimpleItemReplacementRule.Builder withFallback(@NotNull Item real) {
-                this.real = real;
+            public @NotNull SimpleItemReplacementRule.Builder withFallback(@NotNull Supplier<@NotNull Item> fallbackSupplier) {
+                this.fallbackSupplier = fallbackSupplier;
                 return this;
             }
 
             public @NotNull SimpleItemReplacementRule.Builder forBlock(@NotNull Block block) {
                 return this
-                    .withHost(Items.BARRIER)
+                    .withHost(() -> Items.BARRIER)
                     .withNextUnusedHostCustomModelData()
-                    .withFallback(block.replacementRule.getFallbackItem());
+                    .withFallback(() -> block.replacementRule.getFallbackItem());
             }
 
             @Override
             public @NotNull SimpleItemReplacementRule build() {
                 Validate.notNull(this.real);
-                Validate.notNull(this.host);
-                Validate.notNull(this.fallback);
+                Validate.notNull(this.hostSupplier);
                 Validate.notNull(this.computeHostCustomModelData);
-                return new SimpleItemReplacementRule(this.real, this.host, this.computeHostCustomModelData.getAsInt(), this.fallback);
+                Validate.notNull(this.fallbackSupplier);
+                return new SimpleItemReplacementRule(this.real, this.hostSupplier, this.computeHostCustomModelData, this.fallbackSupplier);
             }
 
         }
 
         private final @NotNull Item real;
-        private final @NotNull Item host;
-        private final int hostCustomModelData;
-        private final @NotNull Item fallback;
-
-        private SimpleItemReplacementRule(@NotNull Item real, @NotNull Item host, int hostCustomModelData, @NotNull Item fallback) {
+        private @Nullable Item host = null;
+        private @Nullable Supplier<@NotNull Item> hostSupplier;
+        private int hostCustomModelData = -1;
+        private @Nullable Function<@NotNull Item, @NotNull Integer> computeHostCustomModelData;
+        private @Nullable Item fallback = null;
+        private @Nullable Supplier<@NotNull Item> fallbackSupplier;
+
+        private SimpleItemReplacementRule(@NotNull Item real, @NotNull Supplier<@NotNull Item> hostSupplier, @NotNull Function<@NotNull Item, @NotNull Integer> computeHostCustomModelData, @NotNull Supplier<@NotNull Item> fallbackSupplier) {
             this.real = real;
-            this.host = host;
-            this.hostCustomModelData = hostCustomModelData;
-            this.fallback = fallback;
+            this.hostSupplier = hostSupplier;
+            this.computeHostCustomModelData = computeHostCustomModelData;
+            this.fallbackSupplier = fallbackSupplier;
         }
 
         @Override
@@ -100,11 +106,11 @@ public interface ItemReplacementRule {
                 @NotNull ItemStack clone = item.copy();
                 CompoundTag tag = clone.getOrCreateTag();
                 if (hasResourcePack) {
-                    clone.setItem(this.host);
+                    clone.setItem(this.getHost());
                     // Setting custom model data is based on CraftMetaItem.applyToItem(CompoundTag)
-                    tag.putInt(CraftMetaItem.CUSTOM_MODEL_DATA.NBT, this.hostCustomModelData);
+                    tag.putInt(CraftMetaItem.CUSTOM_MODEL_DATA.NBT, this.getHostCustomModelData());
                 } else {
-                    clone.setItem(this.fallback);
+                    clone.setItem(this.getFallback());
                 }
                 // Setting display name is based on CraftMetaItem.applyToItem(CompoundTag)
                 // Could potentially also be based on ItemStack.setHoverName(Component)
@@ -123,6 +129,30 @@ public interface ItemReplacementRule {
             return this.real;
         }
 
+        public @NotNull Item getHost() {
+            if (this.host == null) {
+                this.host = this.hostSupplier.get();
+                this.hostSupplier = null;
+            }
+            return this.host;
+        }
+
+        public int getHostCustomModelData() {
+            if (this.hostCustomModelData == -1) {
+                this.hostCustomModelData = this.computeHostCustomModelData.apply(this.getHost());
+                this.computeHostCustomModelData = null;
+            }
+            return this.hostCustomModelData;
+        }
+
+        public @NotNull Item getFallback() {
+            if (this.fallback == null) {
+                this.fallback = this.fallbackSupplier.get();
+                this.fallbackSupplier = null;
+            }
+            return this.fallback;
+        }
+
     }
 
     static @NotNull SimpleItemReplacementRule.Builder simple() {
diff --git a/src/main/java/nl/martijnmuijsers/paper/item/SuCraftItems.java b/src/main/java/nl/martijnmuijsers/paper/item/SuCraftItems.java
index e52cb61cc11d4a945f15cc73763293e2e736d22b..2ef9ccdcc6d7294fd739f139535b9f23c50e1c12 100644
--- a/src/main/java/nl/martijnmuijsers/paper/item/SuCraftItems.java
+++ b/src/main/java/nl/martijnmuijsers/paper/item/SuCraftItems.java
@@ -3,6 +3,8 @@
 package nl.martijnmuijsers.paper.item;
 
 import net.kyori.adventure.text.format.TextDecoration;
+import net.minecraft.core.Registry;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.world.item.CreativeModeTab;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.level.block.Block;
@@ -21,7 +23,7 @@ public class SuCraftItems {
 
     public static Item registerBlock(Block block, String displayName, CreativeModeTab group) {
         Item registeredItem = Items.registerBlock(block, group);
-        registeredItem.replacementRule = ItemReplacementRule.simple().forBlock(block).build();
+        registeredItem.replacementRule = ItemReplacementRule.simple().withReal(registeredItem).forBlock(block).build();
         registeredItem.customDisplayName = net.kyori.adventure.text.Component.text(displayName).decoration(TextDecoration.ITALIC, false);
         registeredItem.customDisplayNameJSON = net.kyori.adventure.text.serializer.gson.GsonComponentSerializer.gson().serialize(registeredItem.customDisplayName);
         return registeredItem;
