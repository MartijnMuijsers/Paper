From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Thu, 25 Nov 2021 12:38:19 +0100
Subject: [PATCH] Squashed patch from old personal branch: custom
 enchantability, stronghold generation, player chunk sending and entity view
 distance


diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index 00e302a278c1aef17596a5f1b91230614b13ceb2..4b0a0188a74c31205d442ff37c580ce5f36f3157 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -780,8 +780,16 @@ public class PaperWorldConfig {
     }
 
     public int noTickViewDistance;
+    // Martijn in Paper start - entity tracking view distance
+    public int entityTrackingViewDistance;
+    public boolean allowEntityTrackingBeyondNoTickViewDistance;
+    // Martijn in Paper end - entity tracking view distance
     private void viewDistance() {
         this.noTickViewDistance = this.getInt("viewdistances.no-tick-view-distance", -1);
+        // Martijn in Paper start - entity tracking view distance
+        this.entityTrackingViewDistance = this.getInt("viewdistances.entity-tracking-view-distance", -1);
+        this.allowEntityTrackingBeyondNoTickViewDistance = this.getBoolean("viewdistances.allow-entity-tracking-beyond-no-tick-view-distance", false);
+        // Martijn in Paper end - entity tracking view distance
     }
 
     public long delayChunkUnloadsBy;
diff --git a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
index 4eadc15f747528b59349f095171dd5a649a46ed9..55dee52c9c57898a4625182024363cf4faa277fa 100644
--- a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
@@ -22,11 +22,17 @@ import net.minecraft.server.level.TicketType;
 import net.minecraft.util.Mth;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.chunk.LevelChunk;
+import nl.martijnmuijsers.paper.event.player.PlayerChunkSendEvent; // Martijn in Paper - controllable chunk sending
+import org.bukkit.Bukkit; // Martijn in Paper - controllable chunk sending
+
 import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.HashSet; // Martijn in Paper - expose player chunk information
 import java.util.List;
+import java.util.Set; // Martijn in Paper - expose player chunk information
 import java.util.TreeSet;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.stream.Collectors; // Martijn in Paper - expose player chunk information
 
 public final class PlayerChunkLoader {
 
@@ -69,7 +75,15 @@ public final class PlayerChunkLoader {
             return 0;
         }
 
-        final int timeCompare = Long.compare(p1.nextChunkSendTarget, p2.nextChunkSendTarget);
+        // Martijn in Paper start - controllable chunk sending
+        // make sure that players to which no chunks will be sent are behind in the queue
+        final int canSendChunkAtAllCompare = -Boolean.compare(p1.getCanSendChunkAtAll(), p2.getCanSendChunkAtAll());
+        if (canSendChunkAtAllCompare != 0) {
+            return canSendChunkAtAllCompare;
+        }
+
+        final int timeCompare = Long.compare(p1.getNextChunkSendTarget(), p2.getNextChunkSendTarget());
+        // Martijn in Paper end - controllable chunk sending
         if (timeCompare != 0) {
             return timeCompare;
         }
@@ -113,6 +127,13 @@ public final class PlayerChunkLoader {
      */
     protected int rawSendDistance = -1;
 
+    // Martijn in Paper start - entity tracking view distance
+    /**
+     * -1 if defaulting to [load distance], else always >= 2
+     */
+    protected int rawEntityTrackingDistance = -1;
+    // Martijn in Paper end - entity tracking view distance
+
     /**
      * -1 if defaulting to [tick view distance + 1], else always in [tick view distance + 1, 32 + 1]
      */
@@ -123,6 +144,8 @@ public final class PlayerChunkLoader {
      */
     protected int rawTickDistance = -1;
 
+    protected boolean allowEntityTrackingBeyondNoTickViewDistance = false; // Martijn in Paper - entity tracking view distance
+
     // methods to bridge for API
 
     public int getTargetViewDistance() {
@@ -149,6 +172,30 @@ public final class PlayerChunkLoader {
         this.setSendDistance(distance);
     }
 
+    // Martijn in Paper start - entity tracking view distance
+    public int getTargetEntityTrackingDistance() {
+        return this.rawEntityTrackingDistance == -1 ? this.getTargetNoTickViewDistance() : (this.getAllowEntityTrackingBeyondNoTickViewDistance() ? this.rawEntityTrackingDistance : Math.min(this.rawEntityTrackingDistance, this.getTargetNoTickViewDistance()));
+    }
+
+    public void setTargetEntityTrackingDistance(final int distance) {
+        this.setEntityTrackingDistance(distance);
+    }
+
+    public boolean getAllowEntityTrackingBeyondNoTickViewDistance() {
+        return this.allowEntityTrackingBeyondNoTickViewDistance;
+    }
+
+    public void setAllowEntityTrackingBeyondNoTickViewDistance(final boolean allow) {
+        this.allowEntityTrackingBeyondNoTickViewDistance = allow;
+    }
+    // Martijn in Paper end - entity tracking view distance
+
+    // Martijn in Paper start - expose player chunk information
+    public int getConcurrentChunksBeingSent() {
+        return this.concurrentChunkSends.get();
+    }
+    // Martijn in Paper end - expose player chunk information
+
     // internal methods
 
     public int getSendDistance() {
@@ -163,6 +210,25 @@ public final class PlayerChunkLoader {
         this.rawSendDistance = distance;
     }
 
+    // Martijn in Paper start - entity tracking view distance
+    public int getRawEntityTrackingDistance() {
+        return this.rawEntityTrackingDistance;
+    }
+
+    public int getEntityTrackingDistance() {
+        final int loadDistance = this.getLoadDistance();
+        final int noTickDistance = loadDistance - 1;
+        return this.rawEntityTrackingDistance == -1 ? noTickDistance : (this.allowEntityTrackingBeyondNoTickViewDistance ? this.rawEntityTrackingDistance : Math.min(this.rawEntityTrackingDistance, noTickDistance));
+    }
+
+    public void setEntityTrackingDistance(final int distance) {
+        if (distance != -1 && distance < MIN_VIEW_DISTANCE) {
+            throw new IllegalArgumentException(Integer.toString(distance));
+        }
+        this.rawEntityTrackingDistance = distance;
+    }
+    // Martijn in Paper end - entity tracking view distance
+
     public int getLoadDistance() {
         final int tickDistance = this.getTickDistance();
         return this.rawLoadDistance == -1 ? tickDistance + 1 : Math.max(tickDistance + 1, this.rawLoadDistance);
@@ -304,12 +370,18 @@ public final class PlayerChunkLoader {
         return (int)Math.ceil(Math.min(config * MinecraftServer.getServer().getPlayerCount(), max <= 1.0 ? Double.MAX_VALUE : max));
     }
 
-    protected long getTargetSendPerPlayerAddend() {
-        return PaperConfig.playerTargetChunkSendRate <= 1.0 ? 0L : (long)Math.round(1.0e9 / PaperConfig.playerTargetChunkSendRate);
+    // Martijn in Paper start - per-player chunk send rate
+    public long getTargetSendPerPlayerAddend(ServerPlayer player) { // Martijn - update chunk send deadline based on chunk send rate
+        final double chunkSendRate = player.getBukkitEntity().getTargetChunkSendRate();
+        // disable the limit for any given negative rate (with -1 the intended value to denote this, and 0L the appropriate output of this method in that case)
+        return chunkSendRate < 0 ? 0L : (long) Math.round(1.0e9 / chunkSendRate);
     }
+    // Martijn in Paper end - per-player chunk send rate
 
     protected long getMaxSendAddend() {
-        return PaperConfig.globalMaxChunkSendRate <= 1.0 ? 0L : (long)Math.round(1.0e9 / PaperConfig.globalMaxChunkSendRate);
+        // Martijn in Paper start - allow low chunk send rates
+        return PaperConfig.globalMaxChunkSendRate < 0 ? 0L : (long)Math.round(1.0e9 / Math.max(PaperConfig.globalMaxChunkSendRate, 1e-6));
+        // Martijn in Paper end - allow low chunk send rates
     }
 
     public void onChunkPlayerTickReady(final int chunkX, final int chunkZ) {
@@ -442,7 +514,7 @@ public final class PlayerChunkLoader {
         while (!this.chunkSendWaitQueue.isEmpty()) {
             final PlayerLoaderData data = this.chunkSendWaitQueue.first();
 
-            if (data.nextChunkSendTarget > time) {
+            if (!data.getCanSendChunkAtAll() || data.getNextChunkSendTarget() > time) { // Martijn in Paper - controllable chunk sending
                 break;
             }
 
@@ -456,7 +528,6 @@ public final class PlayerChunkLoader {
         }
 
         final int maxSends = this.getMaxConcurrentChunkSends();
-        final long nextPlayerDeadline = this.getTargetSendPerPlayerAddend() + time;
         for (;;) {
             if (this.chunkSendQueue.isEmpty()) {
                 break;
@@ -489,13 +560,17 @@ public final class PlayerChunkLoader {
                 throw new IllegalStateException();
             }
 
-            data.nextChunkSendTarget = nextPlayerDeadline;
+            final long nextPlayerDeadline = getTargetSendPerPlayerAddend(data.player) + time; // Martijn in Paper - per-player chunk send rate
+            data.updateNextChunkSendTarget(nextPlayerDeadline); // Martijn in Paper - controllable chunk sending
             this.chunkSendWaitQueue.add(data);
 
             synchronized (this.sendingChunkCounts) {
                 this.sendingChunkCounts.addTo(data, 1);
             }
 
+            PlayerChunkSendEvent event = new PlayerChunkSendEvent(data.player.getBukkitEntity(), queuedSend.chunkX, queuedSend.chunkZ);
+            Bukkit.getPluginManager().callEvent(event);
+
             data.sendChunk(queuedSend.chunkX, queuedSend.chunkZ, () -> {
                 synchronized (this.sendingChunkCounts) {
                     final int count = this.sendingChunkCounts.getInt(data);
@@ -671,10 +746,11 @@ public final class PlayerChunkLoader {
         protected int lastSendDistance = Integer.MIN_VALUE;
         protected int lastLoadDistance = Integer.MIN_VALUE;
         protected int lastTickDistance = Integer.MIN_VALUE;
+        protected int lastEntityTrackingDistance = Integer.MIN_VALUE; // Martijn in Paper - entity tracking view distance
         protected boolean usingLookingPriority;
 
         protected final ServerPlayer player;
-        protected final PlayerChunkLoader loader;
+        public final PlayerChunkLoader loader; // Martijn in Paper - update chunk send deadline based on chunk send rate
 
         // warning: modifications of this field must be aware that the loadQueue inside PlayerChunkLoader uses this field
         // in a comparator!
@@ -696,10 +772,49 @@ public final class PlayerChunkLoader {
         });
 
         protected int sendViewDistance = -1;
+        protected int entityTrackingViewDistance = -1; // Martijn in Paper - entity tracking view distance
         protected int loadViewDistance = -1;
         protected int tickViewDistance = -1;
+        // Martijn in Paper start - entity tracking view distance
+        /**
+         * Deferred to {@link PlayerChunkLoader#getAllowEntityTrackingBeyondNoTickViewDistance} if null
+         */
+        protected Boolean allowEntityTrackingBeyondNoTickViewDistance = null;
+        // Martijn in Paper end - entity tracking view distance
+
+        // Martijn in Paper start - controllable chunk sending
+        private long nextChunkSendTarget;
+
+        public long getNextChunkSendTarget() {
+            return this.nextChunkSendTarget;
+        }
+
+        public void updateNextChunkSendTarget(long target) {
+            if (target == this.nextChunkSendTarget) {
+                return;
+            }
+            boolean removedFromChunkSendWaitQueue = this.loader.chunkSendWaitQueue.remove(this);
+            this.nextChunkSendTarget = target;
+            if (removedFromChunkSendWaitQueue) {
+                this.loader.chunkSendWaitQueue.add(this);
+            }
+        }
 
-        protected long nextChunkSendTarget;
+        public boolean getCanSendChunkAtAll() {
+            return this.player.canSendChunkAtAll;
+        }
+
+        public void updateCanSendChunkAtAll(boolean can) {
+            if (can == this.player.canSendChunkAtAll) {
+                return;
+            }
+            boolean removedFromChunkSendWaitQueue = this.loader.chunkSendWaitQueue.remove(this);
+            this.player.canSendChunkAtAll = can;
+            if (removedFromChunkSendWaitQueue) {
+                this.loader.chunkSendWaitQueue.add(this);
+            }
+        }
+        // Martijn in Paper end - controllable chunk sending
 
         public PlayerLoaderData(final ServerPlayer player, final PlayerChunkLoader loader) {
             this.player = player;
@@ -722,6 +837,33 @@ public final class PlayerChunkLoader {
             this.sendViewDistance = distance;
         }
 
+        // Martijn in Paper start - entity tracking view distance
+        public int getTargetEntityTrackingViewDistance() {
+            // If a specific entity tracking view distance is set: return it (or the no-tick view distance if entity tracking beyond no-tick view distance is not allowed)
+            // If not, first we see if a specific entity tracking view distance is set in the world, if so: return it
+            // If not, we return the no-tick view distance for this player (which may be deferred further to the world's no-tick view distance)
+            if (this.entityTrackingViewDistance == -1) {
+                return this.loader.getRawEntityTrackingDistance() == -1 ? this.getTargetNoTickViewDistance() : this.loader.getEntityTrackingDistance();
+            }
+            return this.getAllowEntityTrackingBeyondNoTickViewDistance() ? this.entityTrackingViewDistance : Math.min(this.entityTrackingViewDistance, this.getTargetNoTickViewDistance());
+        }
+
+        public void setTargetEntityTrackingViewDistance(final int distance) {
+            if (distance != -1 && distance < MIN_VIEW_DISTANCE) {
+                throw new IllegalArgumentException(Integer.toString(distance));
+            }
+            this.entityTrackingViewDistance = distance;
+        }
+
+        public boolean getAllowEntityTrackingBeyondNoTickViewDistance() {
+            return this.allowEntityTrackingBeyondNoTickViewDistance == null ? this.loader.getAllowEntityTrackingBeyondNoTickViewDistance() : this.allowEntityTrackingBeyondNoTickViewDistance;
+        }
+
+        public void setAllowEntityTrackingBeyondNoTickViewDistance(final Boolean allow) {
+            this.allowEntityTrackingBeyondNoTickViewDistance = allow;
+        }
+        // Martijn in Paper end - entity tracking view distance
+
         public int getTargetNoTickViewDistance() {
             return (this.loadViewDistance == -1 ? this.getLoadDistance() : this.loadViewDistance) - 1;
         }
@@ -750,6 +892,28 @@ public final class PlayerChunkLoader {
             return Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
         }
 
+        // Martijn in Paper start - expose player chunk information
+        public Set<Long> getUnorderedChunksQueuedToBeLoaded() {
+            return this.loadQueue.stream().map(chunkPriorityHolder -> CoordinateUtils.getChunkKey(chunkPriorityHolder.chunkX, chunkPriorityHolder.chunkZ)).collect(Collectors.toUnmodifiableSet());
+        }
+
+        public Set<Long> getUnorderedChunksQueuedToBeSent() {
+            return this.sendQueue.stream().map(chunkPriorityHolder -> CoordinateUtils.getChunkKey(chunkPriorityHolder.chunkX, chunkPriorityHolder.chunkZ)).collect(Collectors.toUnmodifiableSet());
+        }
+
+        public List<Long> getOrderedChunksQueuedToBeLoaded() {
+            return this.loadQueue.stream().map(chunkPriorityHolder -> CoordinateUtils.getChunkKey(chunkPriorityHolder.chunkX, chunkPriorityHolder.chunkZ)).toList();
+        }
+
+        public List<Long> getOrderedChunksQueuedToBeSent() {
+            return this.sendQueue.stream().map(chunkPriorityHolder -> CoordinateUtils.getChunkKey(chunkPriorityHolder.chunkX, chunkPriorityHolder.chunkZ)).toList();
+        }
+
+        public Set<Long> getSentChunks() {
+            return new HashSet<>(this.sentChunks);
+        }
+        // Martijn in Paper end - expose player chunk information
+
         public boolean hasSentChunk(final int chunkX, final int chunkZ) {
             return this.sentChunks.contains(CoordinateUtils.getChunkKey(chunkX, chunkZ));
         }
@@ -823,6 +987,7 @@ public final class PlayerChunkLoader {
             // send view cannot be greater-than load view
             final int clientViewDistance = this.getClientViewDistance();
             final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!PaperConfig.playerAutoConfigureSendViewDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
+            final int entityTrackingViewDistance = this.entityTrackingViewDistance == -1 ? this.loader.getEntityTrackingDistance() : this.entityTrackingViewDistance; // Martijn in Paper - entity tracking view distance
 
             final double posX = this.player.getX();
             final double posZ = this.player.getZ();
@@ -840,6 +1005,7 @@ public final class PlayerChunkLoader {
                     sendViewDistance == this.lastSendDistance
                             && loadViewDistance == this.lastLoadDistance
                             && tickViewDistance == this.lastTickDistance
+                            && entityTrackingViewDistance == this.lastEntityTrackingDistance // Martijn in Paper - entity tracking view distance
 
                             && (this.usingLookingPriority ? (
                                     // has our block stayed the same (this also accounts for chunk change)?
@@ -884,6 +1050,7 @@ public final class PlayerChunkLoader {
             this.lastSendDistance = sendViewDistance;
             this.lastLoadDistance = loadViewDistance;
             this.lastTickDistance = tickViewDistance;
+            this.lastEntityTrackingDistance = entityTrackingViewDistance; // Martijn in Paper - entity tracking view distance
             this.usingLookingPriority = useLookPriority;
 
             this.lastChunkX = centerChunkX;
diff --git a/src/main/java/net/minecraft/server/commands/EnchantCommand.java b/src/main/java/net/minecraft/server/commands/EnchantCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..3c5d7c19986edb873dc9e2573f0144240a3a76fc
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/EnchantCommand.java
@@ -0,0 +1,85 @@
+package net.minecraft.server.commands;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.arguments.IntegerArgumentType;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.Dynamic2CommandExceptionType;
+import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import java.util.Collection;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.commands.arguments.ItemEnchantmentArgument;
+import net.minecraft.network.chat.TranslatableComponent;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.EnchantmentHelper;
+import nl.martijnmuijsers.paper.enchantments.EnchantmentSource; // Martijn in Minecraft - per-source enchantability
+
+public class EnchantCommand {
+    private static final DynamicCommandExceptionType ERROR_NOT_LIVING_ENTITY = new DynamicCommandExceptionType((entityName) -> {
+        return new TranslatableComponent("commands.enchant.failed.entity", entityName);
+    });
+    private static final DynamicCommandExceptionType ERROR_NO_ITEM = new DynamicCommandExceptionType((entityName) -> {
+        return new TranslatableComponent("commands.enchant.failed.itemless", entityName);
+    });
+    private static final DynamicCommandExceptionType ERROR_INCOMPATIBLE = new DynamicCommandExceptionType((itemName) -> {
+        return new TranslatableComponent("commands.enchant.failed.incompatible", itemName);
+    });
+    private static final Dynamic2CommandExceptionType ERROR_LEVEL_TOO_HIGH = new Dynamic2CommandExceptionType((level, maxLevel) -> {
+        return new TranslatableComponent("commands.enchant.failed.level", level, maxLevel);
+    });
+    private static final SimpleCommandExceptionType ERROR_NOTHING_HAPPENED = new SimpleCommandExceptionType(new TranslatableComponent("commands.enchant.failed"));
+
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("enchant").requires((source) -> {
+            return source.hasPermission(2);
+        }).then(Commands.argument("targets", EntityArgument.entities()).then(Commands.argument("enchantment", ItemEnchantmentArgument.enchantment()).executes((context) -> {
+            return enchant(context.getSource(), EntityArgument.getEntities(context, "targets"), ItemEnchantmentArgument.getEnchantment(context, "enchantment"), 1);
+        }).then(Commands.argument("level", IntegerArgumentType.integer(0)).executes((context) -> {
+            return enchant(context.getSource(), EntityArgument.getEntities(context, "targets"), ItemEnchantmentArgument.getEnchantment(context, "enchantment"), IntegerArgumentType.getInteger(context, "level"));
+        })))));
+    }
+
+    private static int enchant(CommandSourceStack source, Collection<? extends Entity> targets, Enchantment enchantment, int level) throws CommandSyntaxException {
+        if (level > enchantment.getMaxLevel()) {
+            throw ERROR_LEVEL_TOO_HIGH.create(level, enchantment.getMaxLevel());
+        } else {
+            int i = 0;
+
+            for(Entity entity : targets) {
+                if (entity instanceof LivingEntity) {
+                    LivingEntity livingEntity = (LivingEntity)entity;
+                    ItemStack itemStack = livingEntity.getMainHandItem();
+                    if (!itemStack.isEmpty()) {
+                        if (enchantment.canEnchant(itemStack, EnchantmentSource.ENCHANT_COMMAND) && EnchantmentHelper.isEnchantmentCompatible(EnchantmentHelper.getEnchantments(itemStack).keySet(), enchantment)) { // Martijn in Minecraft - per-source enchantability
+                            itemStack.enchant(enchantment, level);
+                            ++i;
+                        } else if (targets.size() == 1) {
+                            throw ERROR_INCOMPATIBLE.create(itemStack.getItem().getName(itemStack).getString());
+                        }
+                    } else if (targets.size() == 1) {
+                        throw ERROR_NO_ITEM.create(livingEntity.getName().getString());
+                    }
+                } else if (targets.size() == 1) {
+                    throw ERROR_NOT_LIVING_ENTITY.create(entity.getName().getString());
+                }
+            }
+
+            if (i == 0) {
+                throw ERROR_NOTHING_HAPPENED.create();
+            } else {
+                if (targets.size() == 1) {
+                    source.sendSuccess(new TranslatableComponent("commands.enchant.success.single", enchantment.getFullname(level), targets.iterator().next().getDisplayName()), true);
+                } else {
+                    source.sendSuccess(new TranslatableComponent("commands.enchant.success.multiple", enchantment.getFullname(level), targets.size()), true);
+                }
+
+                return i;
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 7bb12a30d8b4a817f5a85969c6200306fd45a43d..5c12f883a3f3bd7824d4eac13a38810cc1bdb6c7 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -233,7 +233,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
             int trackRange = this.entityTrackerTrackRanges[i];
 
-            trackMap.add(player, chunkX, chunkZ, Math.min(trackRange, player.getBukkitEntity().getViewDistance())); // Paper - per player view distances
+            trackMap.add(player, chunkX, chunkZ, Math.min(trackRange, player.getBukkitEntity().getEntityTrackingViewDistance())); // Martijn in Paper - entity tracking view distance
         }
         // Paper end - use distance map to optimise entity tracker
         // Paper start - optimise PlayerChunkMap#isOutsideRange
@@ -273,7 +273,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
             int trackRange = this.entityTrackerTrackRanges[i];
 
-            trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, player.getBukkitEntity().getViewDistance())); // Paper - per player view distances
+            trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, player.getBukkitEntity().getEntityTrackingViewDistance())); // Martijn in Paper - entity tracking view distance
         }
         // Paper end - use distance map to optimise entity tracker
         // Paper start - optimise PlayerChunkMap#isOutsideRange
@@ -444,6 +444,10 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper start - no-tick view distance
         this.setNoTickViewDistance(this.level.paperConfig.noTickViewDistance); // Paper - replace chunk loading system
         // Paper end - no-tick view distance
+        // Martijn in Paper start - entity tracking view distance
+        this.setEntityTrackingViewDistance(this.level.paperConfig.entityTrackingViewDistance);
+        this.setAllowEntityTrackingBeyondNoTickViewDistance(this.level.paperConfig.allowEntityTrackingBeyondNoTickViewDistance);
+        // Martijn in Paper end - entity tracking view distance
         this.playerMobDistanceMap = this.level.paperConfig.perPlayerMobSpawns ? new com.destroystokyo.paper.util.PlayerMobDistanceMap() : null; // Paper
         // Paper start - use distance map to optimise entity tracker
         this.playerEntityTrackerTrackMaps = new com.destroystokyo.paper.util.misc.PlayerAreaMap[TRACKING_RANGE_TYPES.length];
@@ -1595,6 +1599,17 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
     }
 
+    // Martijn in Paper start - entity tracking view distance
+    public final void setEntityTrackingViewDistance(int viewDistance) {
+        viewDistance = viewDistance == -1 ? -1 : Math.max(viewDistance, 2);
+        this.playerChunkManager.setEntityTrackingDistance(viewDistance);
+    }
+
+    public final void setAllowEntityTrackingBeyondNoTickViewDistance(boolean allow) {
+        this.playerChunkManager.setAllowEntityTrackingBeyondNoTickViewDistance(allow);
+    }
+    // Martijn in Paper end - entity tracking view distance
+
     // Paper start - no-tick view distance
     public final void setNoTickViewDistance(int viewDistance) {
         viewDistance = viewDistance == -1 ? -1 : Mth.clamp(viewDistance, 2, 32);
@@ -2387,7 +2402,7 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
                 double vec3d_dy = player.getY() - this.entity.getY();
                 double vec3d_dz = player.getZ() - this.entity.getZ();
                 // Paper end - remove allocation of Vec3D here
-                int i = Math.min(this.getEffectiveRange(), player.getBukkitEntity().getViewDistance() * 16); // Paper - per player view distance
+                int i = Math.min(this.getEffectiveRange(), player.getBukkitEntity().getEntityTrackingViewDistance() * 16); // Martijn in Minecraft - entity tracking view distance
                 boolean flag = vec3d_dx >= (double) (-i) && vec3d_dx <= (double) i && vec3d_dz >= (double) (-i) && vec3d_dz <= (double) i && this.entity.broadcastToPlayer(player); // Paper - remove allocation of Vec3D here
 
                 // CraftBukkit start - respect vanish API
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 78fda0c982810b8b881a87099f355247566e513a..1f74da6766db059b5b095140932f89cc250b49ac 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -240,6 +240,11 @@ public class ServerPlayer extends Player {
     public final int[] mobCounts = new int[MOBCATEGORY_TOTAL_ENUMS]; // Paper
     public final com.destroystokyo.paper.util.PooledHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> cachedSingleMobDistanceMap;
     // Paper end
+    // Martijn in Minecraft start - per-player chunk send rate
+    // the target chunk send rate (in chunks per second) for this player, or null if no specific value for this player is set
+    public Double targetChunkSendRate = null;
+    // Martijn in Minecraft end - per-player chunk send rate
+    public boolean canSendChunkAtAll = true; // Martijn in Minecraft - controllable chunk sending
 
     // CraftBukkit start
     public String displayName;
diff --git a/src/main/java/net/minecraft/world/entity/Mob.java b/src/main/java/net/minecraft/world/entity/Mob.java
index 55d07e70a67e08bab3a7a66076c980986736e5b8..c82d0b9bd1ba4b3806b7d80e8ba2822c6040dd78 100644
--- a/src/main/java/net/minecraft/world/entity/Mob.java
+++ b/src/main/java/net/minecraft/world/entity/Mob.java
@@ -72,6 +72,7 @@ import net.minecraft.world.level.ServerLevelAccessor;
 import net.minecraft.world.level.material.Fluid;
 import net.minecraft.world.level.pathfinder.BlockPathTypes;
 import net.minecraft.world.level.storage.loot.LootContext;
+import nl.martijnmuijsers.paper.enchantments.EnchantmentSource; // Martijn in Minecraft - per-source enchantability
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.entity.CraftLivingEntity;
 import org.bukkit.event.entity.CreatureSpawnEvent;
@@ -1148,7 +1149,7 @@ public abstract class Mob extends LivingEntity {
 
     protected void enchantSpawnedWeapon(float power) {
         if (!this.getMainHandItem().isEmpty() && this.random.nextFloat() < 0.25F * power) {
-            this.setItemSlot(EquipmentSlot.MAINHAND, EnchantmentHelper.enchantItem(this.random, this.getMainHandItem(), (int) (5.0F + power * (float) this.random.nextInt(18)), false));
+            this.setItemSlot(EquipmentSlot.MAINHAND, EnchantmentHelper.enchantItem(this.random, this.getMainHandItem(), (int) (5.0F + power * (float) this.random.nextInt(18)), false, EnchantmentSource.SPAWNED_MOB_MAIN_HAND)); // Martijn in Minecraft - per-source enchantability
         }
 
     }
@@ -1157,7 +1158,7 @@ public abstract class Mob extends LivingEntity {
         ItemStack itemstack = this.getItemBySlot(slot);
 
         if (!itemstack.isEmpty() && this.random.nextFloat() < 0.5F * power) {
-            this.setItemSlot(slot, EnchantmentHelper.enchantItem(this.random, itemstack, (int) (5.0F + power * (float) this.random.nextInt(18)), false));
+            this.setItemSlot(slot, EnchantmentHelper.enchantItem(this.random, itemstack, (int) (5.0F + power * (float) this.random.nextInt(18)), false, EnchantmentSource.SPAWNED_MOB_ARMOR)); // Martijn in Minecraft - per-source enchantability
         }
 
     }
diff --git a/src/main/java/net/minecraft/world/entity/animal/horse/SkeletonTrapGoal.java b/src/main/java/net/minecraft/world/entity/animal/horse/SkeletonTrapGoal.java
index 1b874f8a72f5b1ac64dd66621b039295f5dc1f18..65527f2e7e0f443e455a656e605fc9f72cff3eb9 100644
--- a/src/main/java/net/minecraft/world/entity/animal/horse/SkeletonTrapGoal.java
+++ b/src/main/java/net/minecraft/world/entity/animal/horse/SkeletonTrapGoal.java
@@ -14,6 +14,7 @@ import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.item.enchantment.EnchantmentHelper;
 import net.minecraft.world.level.Level;
+import nl.martijnmuijsers.paper.enchantments.EnchantmentSource; // Martijn in Minecraft - per-source enchantability
 
 public class SkeletonTrapGoal extends Goal {
 
@@ -83,8 +84,8 @@ public class SkeletonTrapGoal extends Goal {
             entityskeleton.setItemSlot(EquipmentSlot.HEAD, new ItemStack(Items.IRON_HELMET));
         }
 
-        entityskeleton.setItemSlot(EquipmentSlot.MAINHAND, EnchantmentHelper.enchantItem(entityskeleton.getRandom(), this.disenchant(entityskeleton.getMainHandItem()), (int) (5.0F + localDifficulty.getSpecialMultiplier() * (float) entityskeleton.getRandom().nextInt(18)), false));
-        entityskeleton.setItemSlot(EquipmentSlot.HEAD, EnchantmentHelper.enchantItem(entityskeleton.getRandom(), this.disenchant(entityskeleton.getItemBySlot(EquipmentSlot.HEAD)), (int) (5.0F + localDifficulty.getSpecialMultiplier() * (float) entityskeleton.getRandom().nextInt(18)), false));
+        entityskeleton.setItemSlot(EquipmentSlot.MAINHAND, EnchantmentHelper.enchantItem(entityskeleton.getRandom(), this.disenchant(entityskeleton.getMainHandItem()), (int) (5.0F + localDifficulty.getSpecialMultiplier() * (float) entityskeleton.getRandom().nextInt(18)), false, EnchantmentSource.SPAWNED_SKELETON_TRAP_MAIN_HAND)); // Martijn in Minecraft - per-source enchantability
+        entityskeleton.setItemSlot(EquipmentSlot.HEAD, EnchantmentHelper.enchantItem(entityskeleton.getRandom(), this.disenchant(entityskeleton.getItemBySlot(EquipmentSlot.HEAD)), (int) (5.0F + localDifficulty.getSpecialMultiplier() * (float) entityskeleton.getRandom().nextInt(18)), false, EnchantmentSource.SPAWNED_SKELETON_TRAP_HELMET)); // Martijn in Minecraft - per-source enchantability
         return entityskeleton;
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/npc/VillagerTrades.java b/src/main/java/net/minecraft/world/entity/npc/VillagerTrades.java
index 314617cb0d2df92cc394f7a80011f5b6d075419b..a1f16429fceccb9a65e5429f2deae83af29f1b39 100644
--- a/src/main/java/net/minecraft/world/entity/npc/VillagerTrades.java
+++ b/src/main/java/net/minecraft/world/entity/npc/VillagerTrades.java
@@ -43,6 +43,7 @@ import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.levelgen.feature.StructureFeature;
 import net.minecraft.world.level.saveddata.maps.MapDecoration;
 import net.minecraft.world.level.saveddata.maps.MapItemSavedData;
+import nl.martijnmuijsers.paper.enchantments.EnchantmentSource; // Martijn in Minecraft - per-source enchantability
 
 public class VillagerTrades {
     private static final int DEFAULT_SUPPLY = 12;
@@ -223,7 +224,7 @@ public class VillagerTrades {
         @Override
         public MerchantOffer getOffer(Entity entity, Random random) {
             int i = 5 + random.nextInt(15);
-            ItemStack itemStack = EnchantmentHelper.enchantItem(random, new ItemStack(this.itemStack.getItem()), i, false);
+            ItemStack itemStack = EnchantmentHelper.enchantItem(random, new ItemStack(this.itemStack.getItem()), i, false, EnchantmentSource.VILLAGER_TRADE); // Martijn in Minecraft - per-source enchantability
             int j = Math.min(this.baseEmeraldCost + i, 64);
             ItemStack itemStack2 = new ItemStack(Items.EMERALD, j);
             return new MerchantOffer(itemStack2, itemStack, this.maxUses, this.villagerXp, this.priceMultiplier);
diff --git a/src/main/java/net/minecraft/world/inventory/AnvilMenu.java b/src/main/java/net/minecraft/world/inventory/AnvilMenu.java
index b62c6b56867b645520cb3c3e382ec96d421e7e97..603a746ce1234718d28f8edf65d5702a1aae15f3 100644
--- a/src/main/java/net/minecraft/world/inventory/AnvilMenu.java
+++ b/src/main/java/net/minecraft/world/inventory/AnvilMenu.java
@@ -15,6 +15,7 @@ import net.minecraft.world.item.enchantment.Enchantment;
 import net.minecraft.world.item.enchantment.EnchantmentHelper;
 import net.minecraft.world.level.block.AnvilBlock;
 import net.minecraft.world.level.block.state.BlockState;
+import nl.martijnmuijsers.paper.enchantments.EnchantmentSource; // Martijn in Minecraft - per-source enchantability
 import org.apache.commons.lang3.StringUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -192,7 +193,7 @@ public class AnvilMenu extends ItemCombinerMenu {
                             int i2 = (Integer) map1.get(enchantment);
 
                             i2 = l1 == i2 ? i2 + 1 : Math.max(i2, l1);
-                            boolean flag3 = enchantment.canEnchant(itemstack);
+                            boolean flag3 = enchantment.canEnchant(itemstack, EnchantmentSource.ANVIL); // Martijn in Minecraft - per-source enchantability
 
                             if (this.player.getAbilities().instabuild || itemstack.is(Items.ENCHANTED_BOOK)) {
                                 flag3 = true;
diff --git a/src/main/java/net/minecraft/world/inventory/EnchantmentMenu.java b/src/main/java/net/minecraft/world/inventory/EnchantmentMenu.java
index 717b101bd2492037a9ca1d65d8cb3cebb7d6d4fe..9d9afae84b4b217507c2d320cda7be1c90277aa9 100644
--- a/src/main/java/net/minecraft/world/inventory/EnchantmentMenu.java
+++ b/src/main/java/net/minecraft/world/inventory/EnchantmentMenu.java
@@ -22,6 +22,7 @@ import java.util.Map;
 import net.minecraft.world.item.enchantment.Enchantment;
 import net.minecraft.world.item.enchantment.EnchantmentHelper;
 import net.minecraft.world.item.enchantment.EnchantmentInstance;
+import nl.martijnmuijsers.paper.enchantments.EnchantmentSource; // Martijn in Bukkit - per-source enchantability
 import org.bukkit.Location;
 import org.bukkit.NamespacedKey;
 import org.bukkit.craftbukkit.inventory.CraftInventoryEnchanting;
@@ -327,7 +328,7 @@ public class EnchantmentMenu extends AbstractContainerMenu {
 
     private List<EnchantmentInstance> getEnchantmentList(ItemStack stack, int slot, int level) {
         this.random.setSeed((long) (this.enchantmentSeed.get() + slot));
-        List<EnchantmentInstance> list = EnchantmentHelper.selectEnchantment(this.random, stack, level, false);
+        List<EnchantmentInstance> list = EnchantmentHelper.selectEnchantment(this.random, stack, level, false, EnchantmentSource.ENCHANTING_TABLE); // Martijn in Minecraft - per-source enchantability
 
         if (stack.is(Items.BOOK) && list.size() > 1) {
             list.remove(this.random.nextInt(list.size()));
diff --git a/src/main/java/net/minecraft/world/item/enchantment/DamageEnchantment.java b/src/main/java/net/minecraft/world/item/enchantment/DamageEnchantment.java
index d6c354856c71d9629828e2ddbe316306bfaf6ea6..1fc99fd25586441f11c1b1138c8f39dd410d54d0 100644
--- a/src/main/java/net/minecraft/world/item/enchantment/DamageEnchantment.java
+++ b/src/main/java/net/minecraft/world/item/enchantment/DamageEnchantment.java
@@ -50,10 +50,12 @@ public class DamageEnchantment extends Enchantment {
         return !(other instanceof DamageEnchantment);
     }
 
+    // Martijn in Minecraft start - per-source enchantability
     @Override
-    public boolean canEnchant(ItemStack stack) {
-        return stack.getItem() instanceof AxeItem ? true : super.canEnchant(stack);
+    public boolean canEnchantInVanilla(ItemStack stack) {
+        return stack.getItem() instanceof AxeItem ? true : super.canEnchantInVanilla(stack);
     }
+    // Martijn in Minecraft end - per-source enchantability
 
     @Override
     public void doPostAttack(LivingEntity user, Entity target, int level) {
diff --git a/src/main/java/net/minecraft/world/item/enchantment/DigDurabilityEnchantment.java b/src/main/java/net/minecraft/world/item/enchantment/DigDurabilityEnchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..58f50e970d590ce1ed4dbdc777b410480bd36c54
--- /dev/null
+++ b/src/main/java/net/minecraft/world/item/enchantment/DigDurabilityEnchantment.java
@@ -0,0 +1,42 @@
+package net.minecraft.world.item.enchantment;
+
+import java.util.Random;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.item.ArmorItem;
+import net.minecraft.world.item.ItemStack;
+
+public class DigDurabilityEnchantment extends Enchantment {
+    protected DigDurabilityEnchantment(Enchantment.Rarity weight, EquipmentSlot... slotTypes) {
+        super(weight, EnchantmentCategory.BREAKABLE, slotTypes);
+    }
+
+    @Override
+    public int getMinCost(int level) {
+        return 5 + (level - 1) * 8;
+    }
+
+    @Override
+    public int getMaxCost(int level) {
+        return super.getMinCost(level) + 50;
+    }
+
+    @Override
+    public int getMaxLevel() {
+        return 3;
+    }
+
+    // Martijn in Minecraft start - per-source enchantability
+    @Override
+    public boolean canEnchantInVanilla(ItemStack stack) {
+        return stack.isDamageableItem() ? true : super.canEnchantInVanilla(stack);
+    }
+    // Martijn in Minecraft end - per-source enchantability
+
+    public static boolean shouldIgnoreDurabilityDrop(ItemStack item, int level, Random random) {
+        if (item.getItem() instanceof ArmorItem && random.nextFloat() < 0.6F) {
+            return false;
+        } else {
+            return random.nextInt(level + 1) > 0;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/item/enchantment/DiggingEnchantment.java b/src/main/java/net/minecraft/world/item/enchantment/DiggingEnchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..2b7d8ca53df1ae9a1c0189f74f538362752ebd6b
--- /dev/null
+++ b/src/main/java/net/minecraft/world/item/enchantment/DiggingEnchantment.java
@@ -0,0 +1,33 @@
+package net.minecraft.world.item.enchantment;
+
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+
+public class DiggingEnchantment extends Enchantment {
+    protected DiggingEnchantment(Enchantment.Rarity weight, EquipmentSlot... slotTypes) {
+        super(weight, EnchantmentCategory.DIGGER, slotTypes);
+    }
+
+    @Override
+    public int getMinCost(int level) {
+        return 1 + 10 * (level - 1);
+    }
+
+    @Override
+    public int getMaxCost(int level) {
+        return super.getMinCost(level) + 50;
+    }
+
+    @Override
+    public int getMaxLevel() {
+        return 5;
+    }
+
+    // Martijn in Minecraft start - per-source enchantability
+    @Override
+    public boolean canEnchantInVanilla(ItemStack stack) {
+        return stack.is(Items.SHEARS) ? true : super.canEnchantInVanilla(stack);
+    }
+    // Martijn in Minecraft end - per-source enchantability
+}
diff --git a/src/main/java/net/minecraft/world/item/enchantment/Enchantment.java b/src/main/java/net/minecraft/world/item/enchantment/Enchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..06f8d82b097cf02f12ff67a09ef0782618b6794d
--- /dev/null
+++ b/src/main/java/net/minecraft/world/item/enchantment/Enchantment.java
@@ -0,0 +1,169 @@
+package net.minecraft.world.item.enchantment;
+
+import com.google.common.collect.Maps;
+import java.util.Map;
+import java.util.function.BiPredicate; // Martijn in Minecraft - per-source enchantability
+import javax.annotation.Nullable;
+import net.minecraft.ChatFormatting;
+import net.minecraft.Util;
+import net.minecraft.core.Registry;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.network.chat.TranslatableComponent;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.MobType;
+import net.minecraft.world.item.ItemStack;
+import nl.martijnmuijsers.paper.enchantments.EnchantmentSource; // Martijn in Minecraft - per-source enchantability
+
+public abstract class Enchantment {
+    public final EquipmentSlot[] slots;
+    private final Enchantment.Rarity rarity;
+    public final EnchantmentCategory category;
+    @Nullable
+    protected String descriptionId;
+    public BiPredicate<ItemStack, EnchantmentSource> canEnchantPredicate = (item, source) -> this.canEnchantInVanilla(item); // Martijn in Minecraft - per-source enchantability
+
+    @Nullable
+    public static Enchantment byId(int id) {
+        return Registry.ENCHANTMENT.byId(id);
+    }
+
+    protected Enchantment(Enchantment.Rarity weight, EnchantmentCategory type, EquipmentSlot[] slotTypes) {
+        this.rarity = weight;
+        this.category = type;
+        this.slots = slotTypes;
+    }
+
+    public Map<EquipmentSlot, ItemStack> getSlotItems(LivingEntity entity) {
+        Map<EquipmentSlot, ItemStack> map = Maps.newEnumMap(EquipmentSlot.class);
+
+        for(EquipmentSlot equipmentSlot : this.slots) {
+            ItemStack itemStack = entity.getItemBySlot(equipmentSlot);
+            if (!itemStack.isEmpty()) {
+                map.put(equipmentSlot, itemStack);
+            }
+        }
+
+        return map;
+    }
+
+    public Enchantment.Rarity getRarity() {
+        return this.rarity;
+    }
+
+    public int getMinLevel() {
+        return 1;
+    }
+
+    public int getMaxLevel() {
+        return 1;
+    }
+
+    public int getMinCost(int level) {
+        return 1 + level * 10;
+    }
+
+    public int getMaxCost(int level) {
+        return this.getMinCost(level) + 5;
+    }
+
+    public int getDamageProtection(int level, DamageSource source) {
+        return 0;
+    }
+
+    public float getDamageBonus(int level, MobType group) {
+        return 0.0F;
+    }
+
+    public final boolean isCompatibleWith(Enchantment other) {
+        return this.checkCompatibility(other) && other.checkCompatibility(this);
+    }
+
+    protected boolean checkCompatibility(Enchantment other) {
+        return this != other;
+    }
+
+    protected String getOrCreateDescriptionId() {
+        if (this.descriptionId == null) {
+            this.descriptionId = Util.makeDescriptionId("enchantment", Registry.ENCHANTMENT.getKey(this));
+        }
+
+        return this.descriptionId;
+    }
+
+    public String getDescriptionId() {
+        return this.getOrCreateDescriptionId();
+    }
+
+    public Component getFullname(int level) {
+        MutableComponent mutableComponent = new TranslatableComponent(this.getDescriptionId());
+        if (this.isCurse()) {
+            mutableComponent.withStyle(ChatFormatting.RED);
+        } else {
+            mutableComponent.withStyle(ChatFormatting.GRAY);
+        }
+
+        if (level != 1 || this.getMaxLevel() != 1) {
+            mutableComponent.append(" ").append(new TranslatableComponent("enchantment.level." + level));
+        }
+
+        return mutableComponent;
+    }
+
+    // Martijn in Minecraft start - per-source enchantability
+    @Deprecated
+    public boolean canEnchant(ItemStack stack) {
+        return this.canEnchantInVanilla(stack);
+    }
+
+    public boolean canEnchant(ItemStack stack, EnchantmentSource source) {
+        return this.canEnchantPredicate.test(stack, source);
+    }
+
+    public boolean canEnchantInVanilla(ItemStack stack) {
+        return this.category.canEnchant(stack.getItem());
+    }
+    // Martijn in Minecraft end - per-source enchantability
+
+    public void doPostAttack(LivingEntity user, Entity target, int level) {
+    }
+
+    public void doPostHurt(LivingEntity user, Entity attacker, int level) {
+    }
+
+    public boolean isTreasureOnly() {
+        return false;
+    }
+
+    public boolean isCurse() {
+        return false;
+    }
+
+    public boolean isTradeable() {
+        return true;
+    }
+
+    public boolean isDiscoverable() {
+        return true;
+    }
+
+    public static enum Rarity {
+        COMMON(10),
+        UNCOMMON(5),
+        RARE(2),
+        VERY_RARE(1);
+
+        private final int weight;
+
+        private Rarity(int weight) {
+            this.weight = weight;
+        }
+
+        public int getWeight() {
+            return this.weight;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/item/enchantment/EnchantmentHelper.java b/src/main/java/net/minecraft/world/item/enchantment/EnchantmentHelper.java
index d439e8ce87bf7da03683a336941c7673b8b166e4..8c339d39bb57efc4c2f61da8f51162d290b3c417 100644
--- a/src/main/java/net/minecraft/world/item/enchantment/EnchantmentHelper.java
+++ b/src/main/java/net/minecraft/world/item/enchantment/EnchantmentHelper.java
@@ -27,6 +27,7 @@ import net.minecraft.world.item.EnchantedBookItem;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
+import nl.martijnmuijsers.paper.enchantments.EnchantmentSource; // Martijn in Minecraft - per-source enchantability
 import org.apache.commons.lang3.mutable.MutableFloat;
 import org.apache.commons.lang3.mutable.MutableInt;
 
@@ -318,8 +319,8 @@ public class EnchantmentHelper {
         }
     }
 
-    public static ItemStack enchantItem(Random random, ItemStack target, int level, boolean treasureAllowed) {
-        List<EnchantmentInstance> list = selectEnchantment(random, target, level, treasureAllowed);
+    public static ItemStack enchantItem(Random random, ItemStack target, int level, boolean treasureAllowed, EnchantmentSource source) { // Martijn in Minecraft - per-source enchantability
+        List<EnchantmentInstance> list = selectEnchantment(random, target, level, treasureAllowed, source); // Martijn in Minecraft - per-source enchantability
         boolean bl = target.is(Items.BOOK);
         if (bl) {
             target = new ItemStack(Items.ENCHANTED_BOOK);
@@ -336,7 +337,7 @@ public class EnchantmentHelper {
         return target;
     }
 
-    public static List<EnchantmentInstance> selectEnchantment(Random random, ItemStack stack, int level, boolean treasureAllowed) {
+    public static List<EnchantmentInstance> selectEnchantment(Random random, ItemStack stack, int level, boolean treasureAllowed, EnchantmentSource source) { // Martijn in Minecraft - per-source enchantability
         List<EnchantmentInstance> list = Lists.newArrayList();
         Item item = stack.getItem();
         int i = item.getEnchantmentValue();
@@ -346,7 +347,7 @@ public class EnchantmentHelper {
             level = level + 1 + random.nextInt(i / 4 + 1) + random.nextInt(i / 4 + 1);
             float f = (random.nextFloat() + random.nextFloat() - 1.0F) * 0.15F;
             level = Mth.clamp(Math.round((float)level + (float)level * f), 1, Integer.MAX_VALUE);
-            List<EnchantmentInstance> list2 = getAvailableEnchantmentResults(level, stack, treasureAllowed);
+            List<EnchantmentInstance> list2 = getAvailableEnchantmentResults(level, stack, treasureAllowed, source); // Martijn in Minecraft - per-source enchantability
             if (!list2.isEmpty()) {
                 WeightedRandom.getRandomItem(random, list2).ifPresent(list::add);
 
@@ -389,13 +390,13 @@ public class EnchantmentHelper {
         return true;
     }
 
-    public static List<EnchantmentInstance> getAvailableEnchantmentResults(int power, ItemStack stack, boolean treasureAllowed) {
+    public static List<EnchantmentInstance> getAvailableEnchantmentResults(int power, ItemStack stack, boolean treasureAllowed, EnchantmentSource source) { // Martijn in Minecraft - per-source enchantability
         List<EnchantmentInstance> list = Lists.newArrayList();
         Item item = stack.getItem();
         boolean bl = stack.is(Items.BOOK);
 
         for(Enchantment enchantment : Registry.ENCHANTMENT) {
-            if ((!enchantment.isTreasureOnly() || treasureAllowed) && enchantment.isDiscoverable() && (enchantment.category.canEnchant(item) || bl)) {
+            if ((!enchantment.isTreasureOnly() || treasureAllowed) && enchantment.isDiscoverable() && (enchantment.canEnchant(new ItemStack(item), source) || bl)) { // Martijn in Minecraft - per-source enchantability
                 for(int i = enchantment.getMaxLevel(); i > enchantment.getMinLevel() - 1; --i) {
                     if (power >= enchantment.getMinCost(i) && power <= enchantment.getMaxCost(i)) {
                         list.add(new EnchantmentInstance(enchantment, i));
diff --git a/src/main/java/net/minecraft/world/item/enchantment/ThornsEnchantment.java b/src/main/java/net/minecraft/world/item/enchantment/ThornsEnchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..a665fb9f0133e42ab0e4c5a69db5a0fa4723e3b7
--- /dev/null
+++ b/src/main/java/net/minecraft/world/item/enchantment/ThornsEnchantment.java
@@ -0,0 +1,70 @@
+package net.minecraft.world.item.enchantment;
+
+import java.util.Random;
+import java.util.Map.Entry;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.ArmorItem;
+import net.minecraft.world.item.ItemStack;
+
+public class ThornsEnchantment extends Enchantment {
+    private static final float CHANCE_PER_LEVEL = 0.15F;
+
+    public ThornsEnchantment(Enchantment.Rarity weight, EquipmentSlot... slotTypes) {
+        super(weight, EnchantmentCategory.ARMOR_CHEST, slotTypes);
+    }
+
+    @Override
+    public int getMinCost(int level) {
+        return 10 + 20 * (level - 1);
+    }
+
+    @Override
+    public int getMaxCost(int level) {
+        return super.getMinCost(level) + 50;
+    }
+
+    @Override
+    public int getMaxLevel() {
+        return 3;
+    }
+
+    // Martijn in Minecraft start - per-source enchantability
+    @Override
+    public boolean canEnchantInVanilla(ItemStack stack) {
+        return stack.getItem() instanceof ArmorItem ? true : super.canEnchantInVanilla(stack);
+    }
+    // Martijn in Minecraft end - per-source enchantability
+
+    @Override
+    public void doPostHurt(LivingEntity user, Entity attacker, int level) {
+        Random random = user.getRandom();
+        Entry<EquipmentSlot, ItemStack> entry = EnchantmentHelper.getRandomItemWith(Enchantments.THORNS, user);
+        if (shouldHit(level, random)) {
+            if (attacker != null) {
+                attacker.hurt(DamageSource.thorns(user), (float)getDamage(level, random));
+            }
+
+            if (entry != null) {
+                entry.getValue().hurtAndBreak(2, user, (entity) -> {
+                    entity.broadcastBreakEvent(entry.getKey());
+                });
+            }
+        }
+
+    }
+
+    public static boolean shouldHit(int level, Random random) {
+        if (level <= 0) {
+            return false;
+        } else {
+            return random.nextFloat() < 0.15F * (float)level;
+        }
+    }
+
+    public static int getDamage(int level, Random random) {
+        return level > 10 ? level - 10 : 1 + random.nextInt(4);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java b/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
index fde436065aeeb47cd177656a7c9fe8dc34178e87..0f568b040dae9e3fff579c7e237cd973d0c72bcb 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
@@ -4,11 +4,13 @@ import com.google.common.collect.Lists;
 import com.mojang.serialization.Codec;
 import io.papermc.paper.event.world.StructureLocateEvent; // Paper - Add import due to naming conflict.
 import java.util.BitSet;
+import java.util.HashSet; // Martijn in Minecraft - more strongholds
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.Objects;
 import java.util.Random;
+import java.util.Set; // Martijn in Minecraft - more strongholds
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.function.Function;
@@ -57,6 +59,7 @@ import net.minecraft.world.level.levelgen.feature.configurations.StrongholdConfi
 import net.minecraft.world.level.levelgen.feature.configurations.StructureFeatureConfiguration;
 import net.minecraft.world.level.levelgen.structure.StructureStart;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureManager;
+import org.bukkit.Bukkit;
 
 public abstract class ChunkGenerator {
 
@@ -66,6 +69,7 @@ public abstract class ChunkGenerator {
     private final StructureSettings settings;
     public final long strongholdSeed; // PAIL private -> public
     private final List<ChunkPos> strongholdPositions;
+    private final Set<ChunkPos> strongholdPositionsSet; // Martijn in Minecraft - more strongholds
     private final BaseStoneSource defaultBaseStoneSource;
 
     public ChunkGenerator(BiomeSource biomeSource, StructureSettings structuresConfig) {
@@ -74,6 +78,7 @@ public abstract class ChunkGenerator {
 
     public ChunkGenerator(BiomeSource populationSource, BiomeSource biomeSource, StructureSettings structuresConfig, long worldSeed) {
         this.strongholdPositions = Lists.newArrayList();
+        this.strongholdPositionsSet = new HashSet<>();
         this.biomeSource = populationSource;
         this.runtimeBiomeSource = biomeSource;
         this.settings = structuresConfig;
@@ -97,9 +102,13 @@ public abstract class ChunkGenerator {
                     }
                 }
 
-                int i = structuresettingsstronghold.distance();
-                int j = structuresettingsstronghold.count();
-                int k = structuresettingsstronghold.spread();
+                // Martijn in Minecraft start - more strongholds
+                // The default for the settings below is:
+                // DEFAULT_STRONGHOLD = new StrongholdConfiguration(distance: 32, spread: 3, count: 128);
+                // (taken from net.minecraft.world.level.levelgen.StructureSettings)
+                int strongholdDistance = structuresettingsstronghold.distance();
+                int strongholdCount = structuresettingsstronghold.count();
+                int strongholdSpread = structuresettingsstronghold.spread();
                 Random random = new Random();
 
                 random.setSeed(this.strongholdSeed);
@@ -107,33 +116,118 @@ public abstract class ChunkGenerator {
                 int l = 0;
                 int i1 = 0;
 
-                for (int j1 = 0; j1 < j; ++j1) {
-                    double d1 = (double) (4 * i + i * i1 * 6) + (random.nextDouble() - 0.5D) * (double) i * 2.5D;
-                    int k1 = (int) Math.round(Math.cos(d0) * d1);
-                    int l1 = (int) Math.round(Math.sin(d0) * d1);
+                for (int j1 = 0; j1 < strongholdCount; ++j1) {
+                    double d1 = (double) (4 * strongholdDistance + strongholdDistance * i1 * 6) + (random.nextDouble() - 0.5D) * (double) strongholdDistance * 2.5D;
+                    int chunkX = (int) Math.round(Math.cos(d0) * d1);
+                    int chunkZ = (int) Math.round(Math.sin(d0) * d1);
                     BiomeSource worldchunkmanager = this.biomeSource;
-                    int i2 = SectionPos.sectionToBlockCoord(k1, 8);
-                    int j2 = SectionPos.sectionToBlockCoord(l1, 8);
+                    int chunkMiddleBlockX = SectionPos.sectionToBlockCoord(chunkX, 8);
+                    int chunkMiddleBlockZ = SectionPos.sectionToBlockCoord(chunkZ, 8);
 
                     Objects.requireNonNull(list);
-                    BlockPos blockposition = worldchunkmanager.findBiomeHorizontal(i2, 0, j2, 112, list::contains, random);
+                    BlockPos closebyBlockPositionInValidBiome = worldchunkmanager.findBiomeHorizontal(chunkMiddleBlockX, 0, chunkMiddleBlockZ, 112, list::contains, random);
 
-                    if (blockposition != null) {
-                        k1 = SectionPos.blockToSectionCoord(blockposition.getX());
-                        l1 = SectionPos.blockToSectionCoord(blockposition.getZ());
+                    if (closebyBlockPositionInValidBiome != null) {
+                        chunkX = SectionPos.blockToSectionCoord(closebyBlockPositionInValidBiome.getX());
+                        chunkZ = SectionPos.blockToSectionCoord(closebyBlockPositionInValidBiome.getZ());
                     }
 
-                    this.strongholdPositions.add(new ChunkPos(k1, l1));
-                    d0 += 6.283185307179586D / (double) k;
+                    this.strongholdPositions.add(new ChunkPos(chunkX, chunkZ));
+                    d0 += 6.283185307179586D / (double) strongholdSpread;
                     ++l;
-                    if (l == k) {
+                    if (l == strongholdSpread) {
                         ++i1;
                         l = 0;
-                        k += 2 * k / (i1 + 1);
-                        k = Math.min(k, j - j1);
+                        strongholdSpread += 2 * strongholdSpread / (i1 + 1);
+                        strongholdSpread = Math.min(strongholdSpread, strongholdCount - j1);
                         d0 += random.nextDouble() * 3.141592653589793D * 2.0D;
                     }
                 }
+                Bukkit.getLogger().info("Default strongholds were generated: " + this.strongholdPositions);
+
+                List<ChunkPos> additionalStrongholdPositions = Lists.newArrayList();
+
+                final int bigRegionSizeInBlocks = 2000;
+                final int bigRegionGapInBlocks = 1000;
+                // The expected max distance from spawn that strongholds will generate to is (sqrt(additionStrongholdAmount) - 1) / 2 * (bigRegionSizeInBlocks + bigRegionGapInBlocks)
+                final int additionStrongholdAmount = 10000;
+
+                class AdditionalStrongholdGenerationStatus {
+
+                    Random random = new Random(ChunkGenerator.this.strongholdSeed * 717 + 1371);
+                    int currentBigRegionX = 0;
+                    int currentBigRegionZ = 0;
+
+                    int currentBigRegionDX = 0;
+                    int currentBigRegionDZ = 1;
+
+                    int currentBigRegionXTarget = currentBigRegionX + currentBigRegionDX;
+                    int currentBigRegionZTarget = currentBigRegionZ + currentBigRegionDZ;
+
+                    int getCurrentBigRegionCenterBlockX() {
+                        return currentBigRegionX * (bigRegionSizeInBlocks + bigRegionGapInBlocks);
+                    }
+
+                    int getCurrentBigRegionMinBlockX() {
+                        return getCurrentBigRegionCenterBlockX() - bigRegionSizeInBlocks / 2;
+                    }
+
+                    int getCurrentBigRegionCenterBlockZ() {
+                        return currentBigRegionZ * (bigRegionSizeInBlocks + bigRegionGapInBlocks);
+                    }
+
+                    int getCurrentBigRegionMinBlockZ() {
+                        return getCurrentBigRegionCenterBlockZ() - bigRegionSizeInBlocks / 2;
+                    }
+
+                    void moveToNextBigRegion() {
+
+                        currentBigRegionX += currentBigRegionDX == 0 ? 0 : (currentBigRegionDX < 0 ? -1 : 1);
+                        currentBigRegionZ += currentBigRegionDZ == 0 ? 0 : (currentBigRegionDZ < 0 ? -1 : 1);
+
+                        if (currentBigRegionX == currentBigRegionXTarget && currentBigRegionZ == currentBigRegionZTarget) {
+
+                            if (currentBigRegionDZ > 0) {
+                                currentBigRegionDX = -currentBigRegionDZ;
+                                currentBigRegionDZ = 0;
+                            } else if (currentBigRegionDX < 0) {
+                                currentBigRegionDZ = currentBigRegionDX - 1;
+                                currentBigRegionDX = 0;
+                            } else if (currentBigRegionDZ < 0) {
+                                currentBigRegionDX = -currentBigRegionDZ;;
+                                currentBigRegionDZ = 0;
+                            } else {
+                                currentBigRegionDZ = currentBigRegionDX + 1;
+                                currentBigRegionDX = 0;
+                            }
+
+                            currentBigRegionXTarget = currentBigRegionX + currentBigRegionDX;
+                            currentBigRegionZTarget = currentBigRegionZ + currentBigRegionDZ;
+
+                        }
+
+                    }
+
+                }
+
+                AdditionalStrongholdGenerationStatus status = new AdditionalStrongholdGenerationStatus();
+
+                for (int strongholdI = 0; strongholdI < additionStrongholdAmount; strongholdI++) {
+
+                    int strongholdBlockX = status.getCurrentBigRegionMinBlockX() + random.nextInt(bigRegionSizeInBlocks + 1);
+                    int strongholdBlockZ = status.getCurrentBigRegionMinBlockZ() + random.nextInt(bigRegionSizeInBlocks + 1);
+                    int strongholdChunkX = SectionPos.blockToSectionCoord(strongholdBlockX);
+                    int strongholdChunkZ = SectionPos.blockToSectionCoord(strongholdBlockZ);
+                    additionalStrongholdPositions.add(new ChunkPos(strongholdChunkX, strongholdChunkZ));
+
+                    status.moveToNextBigRegion();
+
+                }
+
+                Bukkit.getLogger().info("Additional strongholds were generated: " + additionalStrongholdPositions);
+                this.strongholdPositions.addAll(additionalStrongholdPositions);
+                this.strongholdPositionsSet.addAll(this.strongholdPositions);
+                // Martijn in Minecraft end - more strongholds
 
             }
         }
@@ -496,7 +590,7 @@ public abstract class ChunkGenerator {
 
     public boolean hasStronghold(ChunkPos pos) {
         this.generateStrongholds();
-        return this.strongholdPositions.contains(pos);
+        return this.strongholdPositionsSet.contains(pos); // Martijn in Minecraft - more strongholds
     }
 
     public BaseStoneSource getBaseStoneSource() {
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/StrongholdFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/StrongholdFeature.java
new file mode 100644
index 0000000000000000000000000000000000000000..084fc420843ee45ae3d9dfe4c794a5683ff9c47d
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/StrongholdFeature.java
@@ -0,0 +1,95 @@
+package net.minecraft.world.level.levelgen.feature;
+
+import com.mojang.serialization.Codec;
+import java.util.List;
+import java.util.Random; // Martijn in Minecraft - more surface strongholds
+
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.LevelHeightAccessor;
+import net.minecraft.world.level.biome.Biome;
+import net.minecraft.world.level.biome.BiomeSource;
+import net.minecraft.world.level.chunk.ChunkGenerator;
+import net.minecraft.world.level.levelgen.WorldgenRandom;
+import net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration;
+import net.minecraft.world.level.levelgen.structure.NoiseAffectingStructureStart;
+import net.minecraft.world.level.levelgen.structure.StrongholdPieces;
+import net.minecraft.world.level.levelgen.structure.StructurePiece;
+import net.minecraft.world.level.levelgen.structure.templatesystem.StructureManager;
+import org.bukkit.Bukkit; // Martijn in Minecraft - more surface strongholds
+
+public class StrongholdFeature extends StructureFeature<NoneFeatureConfiguration> {
+    public StrongholdFeature(Codec<NoneFeatureConfiguration> codec) {
+        super(codec);
+    }
+
+    @Override
+    public StructureFeature.StructureStartFactory<NoneFeatureConfiguration> getStartFactory() {
+        return StrongholdFeature.StrongholdStart::new;
+    }
+
+    @Override
+    protected boolean isFeatureChunk(ChunkGenerator chunkGenerator, BiomeSource biomeSource, long worldSeed, WorldgenRandom random, ChunkPos pos, Biome biome, ChunkPos chunkPos, NoneFeatureConfiguration config, LevelHeightAccessor world) {
+        return chunkGenerator.hasStronghold(pos);
+    }
+
+    public static class StrongholdStart extends NoiseAffectingStructureStart<NoneFeatureConfiguration> {
+        private final long seed;
+
+        public StrongholdStart(StructureFeature<NoneFeatureConfiguration> feature, ChunkPos pos, int references, long seed) {
+            super(feature, pos, references, seed);
+            this.seed = seed;
+        }
+
+        @Override
+        public void generatePieces(RegistryAccess registryManager, ChunkGenerator chunkGenerator, StructureManager manager, ChunkPos pos, Biome biome, NoneFeatureConfiguration config, LevelHeightAccessor world) {
+            int i = 0;
+
+            StrongholdPieces.StartPiece startPiece;
+            do {
+                this.clearPieces();
+                long largeFeatureSeed = this.random.setLargeFeatureSeed(this.seed + (long)(i++), pos.x, pos.z); // Martijn in Minecraft - more surface strongholds
+                StrongholdPieces.resetPieces();
+                startPiece = new StrongholdPieces.StartPiece(this.random, pos.getBlockX(2), pos.getBlockZ(2));
+                this.addPiece(startPiece);
+                startPiece.addChildren(startPiece, this, this.random);
+                List<StructurePiece> list = startPiece.pendingChildren;
+
+                while(!list.isEmpty()) {
+                    int j = this.random.nextInt(list.size());
+                    StructurePiece structurePiece = list.remove(j);
+                    structurePiece.addChildren(startPiece, this, this.random);
+                }
+
+                // Martijn in Minecraft start - more surface strongholds
+                Integer potentialYIncrease = null;
+                Random surfaceStrongholdRandom = new Random(largeFeatureSeed * 137 + 57131);
+                if (surfaceStrongholdRandom.nextDouble() < 0.2) { // 20 % chance
+                    Biome.BiomeCategory biomeCategory = biome.getBiomeCategory();
+                    if (!(biomeCategory == Biome.BiomeCategory.BEACH || biomeCategory == Biome.BiomeCategory.ICY || biomeCategory == Biome.BiomeCategory.NETHER || biomeCategory == Biome.BiomeCategory.NONE || biomeCategory == Biome.BiomeCategory.OCEAN || biomeCategory == Biome.BiomeCategory.SWAMP || biomeCategory == Biome.BiomeCategory.THEEND || biomeCategory == Biome.BiomeCategory.UNDERGROUND)) {
+                        String biomeString = biome.toString();
+                        biomeString = biomeString.toLowerCase();
+                        if (biomeString.contains("plateau")) {
+                            potentialYIncrease = 16;
+                        } else if (biomeString.contains("extreme") || biomeString.contains("mountain")) {
+                            potentialYIncrease = 10;
+                        } else if (biomeString.contains("hill")) {
+                            potentialYIncrease = 5;
+                        } else {
+                            potentialYIncrease = 0;
+                        }
+                    }
+                }
+                if (potentialYIncrease != null) {
+                    int yIncrease = surfaceStrongholdRandom.nextInt(potentialYIncrease + 1);
+                    Bukkit.getLogger().info("To create more surface strongholds, vertically offsetting stronghold at chunk " + pos + " by " + yIncrease);
+                    this.offsetPiecesVertically(yIncrease);
+                } else {
+                    this.moveBelowSeaLevel(chunkGenerator.getSeaLevel(), chunkGenerator.getMinY(), this.random, 10);
+                }
+                // Martijn in Minecraft end - more surface strongholds
+            } while(this.hasNoPieces() || startPiece.portalRoomPiece == null);
+
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/storage/loot/LootTable.java b/src/main/java/net/minecraft/world/level/storage/loot/LootTable.java
index 9827229d125addcfec8b0025724b9a4570c40a12..a5d150e86357a16e95ea6a51829ec590ed425d15 100644
--- a/src/main/java/net/minecraft/world/level/storage/loot/LootTable.java
+++ b/src/main/java/net/minecraft/world/level/storage/loot/LootTable.java
@@ -55,14 +55,13 @@ public class LootTable {
     }
 
     @Deprecated // Paper - preserve overstacked items
-    public static Consumer<ItemStack> createStackSplitter(Consumer<ItemStack> lootConsumer) {
-    // Paper start - preserve overstacked items
+    public static Consumer<ItemStack> createStackSplitter(Consumer<ItemStack> lootConsumer) {// Paper start - preserve overstacked items
         return createStackSplitter(lootConsumer, null);
     }
 
     public static Consumer<ItemStack> createStackSplitter(Consumer<ItemStack> lootConsumer, @org.jetbrains.annotations.Nullable net.minecraft.server.level.ServerLevel world) {
         boolean skipSplitter = world != null && !world.paperConfig.splitOverstackedLoot;
-    // Paper end
+        // Paper end
         return (itemstack) -> {
             if (skipSplitter || itemstack.getCount() < itemstack.getMaxStackSize()) { // Paper - preserve overstacked items
                 lootConsumer.accept(itemstack);
diff --git a/src/main/java/net/minecraft/world/level/storage/loot/functions/EnchantRandomlyFunction.java b/src/main/java/net/minecraft/world/level/storage/loot/functions/EnchantRandomlyFunction.java
new file mode 100644
index 0000000000000000000000000000000000000000..119e24e299ab7dac03a187c4a1844a3f43f40c9a
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/storage/loot/functions/EnchantRandomlyFunction.java
@@ -0,0 +1,149 @@
+package net.minecraft.world.level.storage.loot.functions;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonPrimitive;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSyntaxException;
+import java.util.Collection;
+import java.util.List;
+import java.util.Random;
+import java.util.Set;
+import java.util.stream.Collectors;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.util.GsonHelper;
+import net.minecraft.util.Mth;
+import net.minecraft.world.item.EnchantedBookItem;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.EnchantmentInstance;
+import net.minecraft.world.level.storage.loot.LootContext;
+import net.minecraft.world.level.storage.loot.predicates.LootItemCondition;
+import nl.martijnmuijsers.paper.enchantments.EnchantmentSource; // Martijn in Minecraft - per-source enchantability
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class EnchantRandomlyFunction extends LootItemConditionalFunction {
+    private static final Logger LOGGER = LogManager.getLogger();
+    final List<Enchantment> enchantments;
+
+    EnchantRandomlyFunction(LootItemCondition[] conditions, Collection<Enchantment> collection) {
+        super(conditions);
+        this.enchantments = ImmutableList.copyOf(collection);
+    }
+
+    @Override
+    public LootItemFunctionType getType() {
+        return LootItemFunctions.ENCHANT_RANDOMLY;
+    }
+
+    @Override
+    public ItemStack run(ItemStack stack, LootContext context) {
+        Random random = context.getRandom();
+        Enchantment enchantment;
+        if (this.enchantments.isEmpty()) {
+            boolean bl = stack.is(Items.BOOK);
+            // Martijn in Minecraft start - per-source enchantability
+            List<Enchantment> list = Registry.ENCHANTMENT.stream().filter(Enchantment::isDiscoverable).filter((consideredEnchantment) -> {
+                return bl || consideredEnchantment.canEnchant(stack, EnchantmentSource.GENERATED_LOOT);
+            }).collect(Collectors.toList());
+            // Martijn in Minecraft end - per-source enchantability
+            if (list.isEmpty()) {
+                LOGGER.warn("Couldn't find a compatible enchantment for {}", (Object)stack);
+                return stack;
+            }
+
+            enchantment = list.get(random.nextInt(list.size()));
+        } else {
+            enchantment = this.enchantments.get(random.nextInt(this.enchantments.size()));
+        }
+
+        return enchantItem(stack, enchantment, random);
+    }
+
+    private static ItemStack enchantItem(ItemStack stack, Enchantment enchantment, Random random) {
+        int i = Mth.nextInt(random, enchantment.getMinLevel(), enchantment.getMaxLevel());
+        if (stack.is(Items.BOOK)) {
+            stack = new ItemStack(Items.ENCHANTED_BOOK);
+            EnchantedBookItem.addEnchantment(stack, new EnchantmentInstance(enchantment, i));
+        } else {
+            stack.enchant(enchantment, i);
+        }
+
+        return stack;
+    }
+
+    public static EnchantRandomlyFunction.Builder randomEnchantment() {
+        return new EnchantRandomlyFunction.Builder();
+    }
+
+    public static LootItemConditionalFunction.Builder<?> randomApplicableEnchantment() {
+        return simpleBuilder((conditions) -> {
+            return new EnchantRandomlyFunction(conditions, ImmutableList.of());
+        });
+    }
+
+    public static class Builder extends LootItemConditionalFunction.Builder<EnchantRandomlyFunction.Builder> {
+        private final Set<Enchantment> enchantments = Sets.newHashSet();
+
+        @Override
+        protected EnchantRandomlyFunction.Builder getThis() {
+            return this;
+        }
+
+        public EnchantRandomlyFunction.Builder withEnchantment(Enchantment enchantment) {
+            this.enchantments.add(enchantment);
+            return this;
+        }
+
+        @Override
+        public LootItemFunction build() {
+            return new EnchantRandomlyFunction(this.getConditions(), this.enchantments);
+        }
+    }
+
+    public static class Serializer extends LootItemConditionalFunction.Serializer<EnchantRandomlyFunction> {
+        @Override
+        public void serialize(JsonObject json, EnchantRandomlyFunction object, JsonSerializationContext context) {
+            super.serialize(json, object, context);
+            if (!object.enchantments.isEmpty()) {
+                JsonArray jsonArray = new JsonArray();
+
+                for(Enchantment enchantment : object.enchantments) {
+                    ResourceLocation resourceLocation = Registry.ENCHANTMENT.getKey(enchantment);
+                    if (resourceLocation == null) {
+                        throw new IllegalArgumentException("Don't know how to serialize enchantment " + enchantment);
+                    }
+
+                    jsonArray.add(new JsonPrimitive(resourceLocation.toString()));
+                }
+
+                json.add("enchantments", jsonArray);
+            }
+
+        }
+
+        @Override
+        public EnchantRandomlyFunction deserialize(JsonObject jsonObject, JsonDeserializationContext jsonDeserializationContext, LootItemCondition[] lootItemConditions) {
+            List<Enchantment> list = Lists.newArrayList();
+            if (jsonObject.has("enchantments")) {
+                for(JsonElement jsonElement : GsonHelper.getAsJsonArray(jsonObject, "enchantments")) {
+                    String string = GsonHelper.convertToString(jsonElement, "enchantment");
+                    Enchantment enchantment = Registry.ENCHANTMENT.getOptional(new ResourceLocation(string)).orElseThrow(() -> {
+                        return new JsonSyntaxException("Unknown enchantment '" + string + "'");
+                    });
+                    list.add(enchantment);
+                }
+            }
+
+            return new EnchantRandomlyFunction(lootItemConditions, list);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/storage/loot/functions/EnchantWithLevelsFunction.java b/src/main/java/net/minecraft/world/level/storage/loot/functions/EnchantWithLevelsFunction.java
new file mode 100644
index 0000000000000000000000000000000000000000..10e1f5b6f266b0991fe392192c2af5d2b4a13fa8
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/storage/loot/functions/EnchantWithLevelsFunction.java
@@ -0,0 +1,86 @@
+package net.minecraft.world.level.storage.loot.functions;
+
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonSerializationContext;
+import java.util.Random;
+import java.util.Set;
+import net.minecraft.util.GsonHelper;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.enchantment.EnchantmentHelper;
+import net.minecraft.world.level.storage.loot.LootContext;
+import net.minecraft.world.level.storage.loot.parameters.LootContextParam;
+import net.minecraft.world.level.storage.loot.predicates.LootItemCondition;
+import net.minecraft.world.level.storage.loot.providers.number.NumberProvider;
+import nl.martijnmuijsers.paper.enchantments.EnchantmentSource; // Martijn in Minecraft - per-source enchantability
+
+public class EnchantWithLevelsFunction extends LootItemConditionalFunction {
+    final NumberProvider levels;
+    final boolean treasure;
+
+    EnchantWithLevelsFunction(LootItemCondition[] conditions, NumberProvider numberProvider, boolean bl) {
+        super(conditions);
+        this.levels = numberProvider;
+        this.treasure = bl;
+    }
+
+    @Override
+    public LootItemFunctionType getType() {
+        return LootItemFunctions.ENCHANT_WITH_LEVELS;
+    }
+
+    @Override
+    public Set<LootContextParam<?>> getReferencedContextParams() {
+        return this.levels.getReferencedContextParams();
+    }
+
+    @Override
+    public ItemStack run(ItemStack stack, LootContext context) {
+        Random random = context.getRandom();
+        return EnchantmentHelper.enchantItem(random, stack, this.levels.getInt(context), this.treasure, EnchantmentSource.GENERATED_LOOT); // Martijn in Minecraft - per-source enchantability
+    }
+
+    public static EnchantWithLevelsFunction.Builder enchantWithLevels(NumberProvider range) {
+        return new EnchantWithLevelsFunction.Builder(range);
+    }
+
+    public static class Builder extends LootItemConditionalFunction.Builder<EnchantWithLevelsFunction.Builder> {
+        private final NumberProvider levels;
+        private boolean treasure;
+
+        public Builder(NumberProvider range) {
+            this.levels = range;
+        }
+
+        @Override
+        protected EnchantWithLevelsFunction.Builder getThis() {
+            return this;
+        }
+
+        public EnchantWithLevelsFunction.Builder allowTreasure() {
+            this.treasure = true;
+            return this;
+        }
+
+        @Override
+        public LootItemFunction build() {
+            return new EnchantWithLevelsFunction(this.getConditions(), this.levels, this.treasure);
+        }
+    }
+
+    public static class Serializer extends LootItemConditionalFunction.Serializer<EnchantWithLevelsFunction> {
+        @Override
+        public void serialize(JsonObject json, EnchantWithLevelsFunction object, JsonSerializationContext context) {
+            super.serialize(json, object, context);
+            json.add("levels", context.serialize(object.levels));
+            json.addProperty("treasure", object.treasure);
+        }
+
+        @Override
+        public EnchantWithLevelsFunction deserialize(JsonObject jsonObject, JsonDeserializationContext jsonDeserializationContext, LootItemCondition[] lootItemConditions) {
+            NumberProvider numberProvider = GsonHelper.getAsObject(jsonObject, "levels", jsonDeserializationContext, NumberProvider.class);
+            boolean bl = GsonHelper.getAsBoolean(jsonObject, "treasure", false);
+            return new EnchantWithLevelsFunction(lootItemConditions, numberProvider, bl);
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 858e29ad77aee8a1b7797c2d82902abbfd662da2..b48473079c212b492c0355a1093216cf3253d933 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -2115,6 +2115,35 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     public void setSendViewDistance(int viewDistance) {
         getHandle().getChunkSource().chunkMap.playerChunkManager.setTargetSendDistance(viewDistance);
     }
+
+    // Martijn in Paper start - entity tracking view distance
+    @Override
+    public int getEntityTrackingViewDistance() {
+        return getHandle().getChunkSource().chunkMap.playerChunkManager.getTargetEntityTrackingDistance();
+    }
+
+    @Override
+    public void setEntityTrackingViewDistance(int viewDistance) {
+        getHandle().getChunkSource().chunkMap.playerChunkManager.setTargetEntityTrackingDistance(viewDistance);
+    }
+
+    @Override
+    public boolean getAllowEntityTrackingBeyondNoTickViewDistance() {
+        return getHandle().getChunkSource().chunkMap.playerChunkManager.getAllowEntityTrackingBeyondNoTickViewDistance();
+    }
+
+    @Override
+    public void setAllowEntityTrackingBeyondNoTickViewDistance(boolean allow) {
+        getHandle().getChunkSource().chunkMap.playerChunkManager.setAllowEntityTrackingBeyondNoTickViewDistance(allow);
+    }
+    // Martijn in Paper end - entity tracking view distance
+
+    // Martijn in Paper start - expose player chunk information
+    @Override
+    public int getConcurrentChunksBeingSent() {
+        return getHandle().getChunkSource().chunkMap.playerChunkManager.getConcurrentChunksBeingSent();
+    }
+    // Martijn in Paper end - expose player chunk information
     // Paper end - add view distances
 
     // Spigot start
diff --git a/src/main/java/org/bukkit/craftbukkit/enchantments/CraftEnchantment.java b/src/main/java/org/bukkit/craftbukkit/enchantments/CraftEnchantment.java
index 11c1eb0e0bc326b28dc0cab16f67c413cc52e98c..962b4e1cd69010937430c5609e2cc1ea9f880e11 100644
--- a/src/main/java/org/bukkit/craftbukkit/enchantments/CraftEnchantment.java
+++ b/src/main/java/org/bukkit/craftbukkit/enchantments/CraftEnchantment.java
@@ -1,8 +1,10 @@
 package org.bukkit.craftbukkit.enchantments;
 
+import net.kyori.adventure.text.Component;
 import net.minecraft.core.Registry;
 import net.minecraft.world.item.enchantment.BindingCurseEnchantment;
 import net.minecraft.world.item.enchantment.VanishingCurseEnchantment;
+import nl.martijnmuijsers.paper.enchantments.EnchantmentSource; // Martijn in Bukkit - per-source enchantability
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.enchantments.Enchantment;
@@ -10,6 +12,8 @@ import org.bukkit.enchantments.EnchantmentTarget;
 import org.bukkit.enchantments.EnchantmentWrapper;
 import org.bukkit.inventory.ItemStack;
 
+import java.util.function.BiPredicate; // Martijn in Bukkit - per-source enchantability
+
 public class CraftEnchantment extends Enchantment {
     private final net.minecraft.world.item.enchantment.Enchantment target;
 
@@ -74,11 +78,35 @@ public class CraftEnchantment extends Enchantment {
         return this.target.isCurse(); // Paper
     }
 
+    // Martijn in Bukkit start - per-source enchantability
     @Override
+    @Deprecated
     public boolean canEnchantItem(ItemStack item) {
         return this.target.canEnchant(CraftItemStack.asNMSCopy(item));
     }
 
+    @Override
+    public boolean canEnchantItem(ItemStack item, EnchantmentSource source) {
+        return this.target.canEnchant(CraftItemStack.asNMSCopy(item), source);
+    }
+
+    @Override
+    public boolean canEnchantItemInVanilla(ItemStack item) {
+        return this.target.canEnchantInVanilla(CraftItemStack.asNMSCopy(item));
+    }
+
+    @Override
+    public BiPredicate<ItemStack, EnchantmentSource> getCanEnchantItemPredicate() {
+        final BiPredicate<net.minecraft.world.item.ItemStack, EnchantmentSource> predicate = this.target.canEnchantPredicate;
+        return (item, source) -> predicate.test(CraftItemStack.asNMSCopy(item), source);
+    }
+
+    @Override
+    public void setCanEnchantItemPredicate(BiPredicate<ItemStack, EnchantmentSource> predicate) {
+        this.target.canEnchantPredicate = (stack, source) -> predicate.test(CraftItemStack.asBukkitCopy(stack), source);
+    }
+    // Martijn in Bukkit end - per-source enchantability
+
     @Override
     public String getName() {
         // PAIL: migration paths
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 4ff4143f3a7cd89ef92f4b8882fa3e5addfe0f06..02688afa718d521ec6d872419ad432eaf0dcdbe8 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1,5 +1,6 @@
 package org.bukkit.craftbukkit.entity;
 
+import com.destroystokyo.paper.PaperConfig; // Martijn in Bukkit
 import com.destroystokyo.paper.Title;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableSet;
@@ -13,6 +14,7 @@ import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
@@ -24,7 +26,10 @@ import java.util.UUID;
 import java.util.WeakHashMap;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+import java.util.stream.Collectors;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.util.CoordinateUtils;
 import net.minecraft.Util;
 import net.minecraft.advancements.AdvancementProgress;
 import net.minecraft.core.BlockPos;
@@ -539,6 +544,50 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         data.setTargetSendViewDistance(viewDistance);
     }
 
+    // Martijn in Paper start - entity tracking view distance
+    @Override
+    public int getEntityTrackingViewDistance() {
+        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+        if (data == null) {
+            return chunkMap.playerChunkManager.getTargetEntityTrackingDistance();
+        }
+        return data.getTargetEntityTrackingViewDistance();
+    }
+
+    @Override
+    public void setEntityTrackingViewDistance(int viewDistance) {
+        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+        if (data == null) {
+            throw new IllegalStateException("Player is not attached to world");
+        }
+
+        data.setTargetEntityTrackingViewDistance(viewDistance);
+    }
+
+    @Override
+    public boolean getAllowEntityTrackingBeyondNoTickViewDistance() {
+        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+        if (data == null) {
+            return chunkMap.playerChunkManager.getAllowEntityTrackingBeyondNoTickViewDistance();
+        }
+        return data.getAllowEntityTrackingBeyondNoTickViewDistance();
+    }
+
+    @Override
+    public void setAllowEntityTrackingBeyondNoTickViewDistance(Boolean allow) {
+        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+        if (data == null) {
+            throw new IllegalStateException("Player is not attached to world");
+        }
+
+        data.setAllowEntityTrackingBeyondNoTickViewDistance(allow);
+    }
+    // Martijn in Paper end - entity tracking view distance
+
     @Override
     public int getNoTickViewDistance() {
         net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
@@ -580,6 +629,114 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
         data.setTargetTickViewDistance(viewDistance);
     }
+
+    // Martijn in Paper start - per-player chunk send rate
+    @Override
+    public double getTargetChunkSendRate() {
+        final Double playerTargetChunkSendRate = this.getHandle().targetChunkSendRate;
+        final double effectiveTargetChunkSendRate = playerTargetChunkSendRate == null ? PaperConfig.playerTargetChunkSendRate : playerTargetChunkSendRate;
+        // Make sure the returned rate is -1, or >= 1
+        return effectiveTargetChunkSendRate < 0 ? -1 : Math.max(effectiveTargetChunkSendRate, 1.0e-6);
+    }
+
+    @Override
+    public void setTargetChunkSendRate(Double chunkSendRate) {
+        this.getHandle().targetChunkSendRate = chunkSendRate;
+        // Martijn start - update chunk send deadline based on chunk send rate
+        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+        if (data != null) {
+            if (data.getNextChunkSendTarget() != 0) { // Martijn - controllable chunk sending
+                long scheduleDelay = data.loader.getTargetSendPerPlayerAddend(this.getHandle());
+                if (scheduleDelay != 0) {
+                    long newTimeIfCurrentlyScheduled = System.nanoTime() + scheduleDelay;
+                    data.updateNextChunkSendTarget(Math.min(data.getNextChunkSendTarget(), newTimeIfCurrentlyScheduled)); // Martijn - controllable chunk sending
+                }
+            }
+        }
+        // Martijn end - update chunk send deadline based on chunk send rate
+    }
+    // Martijn in Paper end - per-player chunk send rate
+
+    // Martijn in Paper start - controllable chunk sending
+    @Override
+    public boolean getCanBeSentChunks() {
+        return getHandle().canSendChunkAtAll;
+    }
+
+    @Override
+    public void setCanBeSentChunks(boolean canBeSentChunks) {
+        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+        if (data != null) {
+            data.updateCanSendChunkAtAll(canBeSentChunks);
+        } else {
+            getHandle().canSendChunkAtAll = canBeSentChunks;
+        }
+    }
+    // Martijn in Paper end - controllable chunk sending
+
+    // Martijn in Paper start - expose player chunk information
+    @Override
+    public Set<Long> getUnorderedChunksQueuedToBeLoaded() {
+        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+        if (data == null) {
+            return Collections.emptySet();
+        }
+        return data.getUnorderedChunksQueuedToBeLoaded();
+    }
+
+    @Override
+    public Set<Long> getUnorderedChunksQueuedToBeSent() {
+        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+        if (data == null) {
+            return Collections.emptySet();
+        }
+        return data.getUnorderedChunksQueuedToBeSent();
+    }
+
+    @Override
+    public List<Long> getOrderedChunksQueuedToBeLoaded() {
+        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+        if (data == null) {
+            return Collections.emptyList();
+        }
+        return data.getOrderedChunksQueuedToBeLoaded();
+    }
+
+    @Override
+    public List<Long> getOrderedChunksQueuedToBeSent() {
+        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+        if (data == null) {
+            return Collections.emptyList();
+        }
+        return data.getOrderedChunksQueuedToBeSent();
+    }
+
+    @Override
+    public Set<Long> getSentChunks() {
+        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+        if (data == null) {
+            return Collections.emptySet();
+        }
+        return data.getSentChunks();
+    }
+
+    @Override
+    public boolean hasSentChunk(int chunkX, int chunkZ) {
+        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+        if (data == null) {
+            return false;
+        }
+        return data.hasSentChunk(chunkX, chunkZ);
+    }
+    // Martijn in Paper end - expose player chunk information
     // Paper end - implement view distances
 
     @Override
