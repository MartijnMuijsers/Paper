From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Wed, 26 Jan 2022 01:21:31 +0100
Subject: [PATCH] Network-constrained chunk tracking


diff --git a/src/main/java/com/destroystokyo/paper/PaperConfig.java b/src/main/java/com/destroystokyo/paper/PaperConfig.java
index 868067ab2f33ec29e533bc661b80dfc0e1149906..4829ecad255b29cf062c2ac17d0ec6b8f65b4b90 100644
--- a/src/main/java/com/destroystokyo/paper/PaperConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperConfig.java
@@ -187,6 +187,15 @@ public class PaperConfig {
 
     // Martijn end - survival debug stick
 
+    // Martijn start - network-constrained chunk tracking
+
+    public static int initialMaxNumberOfChunkPacketsInTransit = 1;
+    private static void initialMaxNumberOfChunkPacketsInTransit() {
+        initialMaxNumberOfChunkPacketsInTransit = getInt("settings.network-constrained-chunk-tracking.max-chunk-packets-in-transit.initial", initialMaxNumberOfChunkPacketsInTransit);
+    }
+
+    // Martijn end - network-constrained chunk tracking
+
     public static boolean logPlayerIpAddresses = true;
     private static void playerIpAddresses() {
         logPlayerIpAddresses = getBoolean("settings.log-player-ip-addresses", logPlayerIpAddresses);
diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index 57f9976da6b91470e81dda368470870176bc9922..f0d0c6cbf749ba2e9681f878955ccede4882b5ed 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -227,6 +227,28 @@ public class PaperWorldConfig {
 
     // Martijn end - sort chunks by distance
 
+    // Martijn start - network-constrained chunk tracking
+
+    public int minMaxNumberOfChunkPacketsInTransit = 1;
+    private void minMaxNumberOfChunkPacketsInTransit() {
+        this.minMaxNumberOfChunkPacketsInTransit = getInt("network-constrained-chunk-tracking.max-chunk-packets-in-transit.min", this.minMaxNumberOfChunkPacketsInTransit);
+    }
+
+    public int maxMaxNumberOfChunkPacketsInTransit = 7;
+    private void maxMaxNumberOfChunkPacketsInTransit() {
+        this.maxMaxNumberOfChunkPacketsInTransit = getInt("network-constrained-chunk-tracking.max-chunk-packets-in-transit.max", this.maxMaxNumberOfChunkPacketsInTransit);
+    }
+
+    /**
+     * -1 indicates no limit
+     */
+    public int maxChunksToNewlyTrackOrSeePerTick = -1;
+    private void maxChunksToNewlyTrackOrSeePerTick() {
+        this.maxChunksToNewlyTrackOrSeePerTick = getInt("network-constrained-chunk-tracking.max-to-newly-track-or-see-per-tick", this.maxChunksToNewlyTrackOrSeePerTick);
+    }
+
+    // Martijn end - network-constrained chunk tracking
+
     public boolean zombiesTargetTurtleEggs = true;
     private void zombiesTargetTurtleEggs() {
         zombiesTargetTurtleEggs = getBoolean("zombies-target-turtle-eggs", zombiesTargetTurtleEggs);
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index e8aec6972def3c6e4f7daedcc387d48c1f34be6e..edca32e3a8f2a14d076a558e77bc73119eee82a4 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -36,6 +36,7 @@ import net.minecraft.world.level.chunk.ProtoChunk;
 import net.minecraft.world.level.lighting.LevelLightEngine;
 // CraftBukkit start
 import net.minecraft.server.MinecraftServer;
+import org.bukkit.Chunk;
 // CraftBukkit end
 
 public class ChunkHolder {
@@ -341,13 +342,15 @@ public class ChunkHolder {
 
     }
 
+    // Martijn start - network-constrained chunk tracking
     public void broadcast(Packet<?> packet, boolean onlyOnWatchDistanceEdge) {
         LevelChunk chunk = this.getTickingChunk(); // Will be null if not present
         if (chunk == null) return;
         this.playerProvider.getPlayersNearChunkForSending(this.pos, onlyOnWatchDistanceEdge, true).forEach((entityplayer) -> { // Martijn - per-player send distance
-            entityplayer.connection.send(packet);
+            entityplayer.connection.sendIfTracking(chunk, packet);
         });
     }
+    // Martijn end - network-constrained chunk tracking
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getOrScheduleFuture(ChunkStatus targetStatus, ChunkMap chunkStorage) {
         int i = targetStatus.getIndex();
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 9c1d58e4f1b8d61c3743a868c8cfeb0070d8e3dd..73e0e773078972c8c2b811eb10029845c4a729dd 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -29,7 +29,7 @@ import java.io.IOException;
 import java.io.Writer;
 import java.nio.file.Path;
 import java.util.ArrayList;
-import java.util.BitSet;
+import java.util.Comparator;
 import java.util.HashMap; // Paper
 import java.util.Collection;
 import java.util.Comparator;
@@ -107,7 +107,6 @@ import org.apache.commons.lang3.mutable.MutableBoolean;
 import org.apache.commons.lang3.mutable.MutableObject;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
-import org.bukkit.entity.Player;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
 
@@ -1456,13 +1455,13 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             either.ifLeft((chunk) -> {
                 this.tickingGenerated.getAndIncrement();
                 MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> mutableobject = new MutableObject<>(); // Paper - Anti-Xray - Bypass
-                // Martijn start - per-player track and see distance
+                // Martijn start - per-player track and see distance, network-constrained chunk tracking
                 for (boolean track : new boolean[] {true, false}) {
                     this.getPlayersNearChunkForSending(chunkcoordintpair, false, track).forEach((entityplayer) -> {
-                        entityplayer.trackOrSeeChunk(chunk, entityplayer.getClientboundChunkInitializationPacket(chunk), track);
+                        entityplayer.planToTrackOrSeeChunk(/*mutableobject, */chunk, track);
                     });
                 }
-                // Martijn end - per-player track and see distance
+                // Martijn end - per-player track and see distance, network-constrained chunk tracking
             });
         }, (runnable) -> {
             this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(holder, runnable));
@@ -1684,7 +1683,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                     LevelChunk chunk = playerchunk.getTickingChunk();
 
                     if (chunk != null) {
-                        player.trackOrSeeChunk(chunk, player.getClientboundChunkInitializationPacket(chunk), concernsTracking); // Martijn - per-player track and see view distance
+                        player.planToTrackOrSeeChunk(/*mutableobject, */chunk, concernsTracking); // Martijn - per-player track and see view distance, network-constrained chunk tracking
                     }
 
                     DebugPackets.sendPoiPacketsForChunk(this.level, pos);
@@ -1972,7 +1971,6 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
         // Martijn end - sort chunks by distance, per-player track and see view distance
 
-
     }
 
     private SectionPos updatePlayerPos(ServerPlayer player) {
@@ -2025,7 +2023,6 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         int l1;
 
         // Martijn start - per-player track and see view distance
-
         for (boolean track : new boolean[] {true, false}) {
 
             int viewDistance = (track ? player.getTrackViewDistance() : player.getSeeViewDistance()) + 1;
@@ -2079,6 +2076,9 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                         }
                     }
                 }
+
+                // Martijn end - track new chunks before untracking old chunks
+
             }
 
         }
@@ -2212,6 +2212,10 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // Paper end - optimised tracker
 
     protected void tick() {
+        // Martijn start - network-constrained chunk tracking
+        this.level.players.forEach(ServerPlayer::resetChunksNewlyTrackedOrSeenThisTick);
+        attemptToTrackOrSeePlannedChunksForAllPlayers();
+        // Martijn end - network-constrained chunk tracking
         // Paper start - optimized tracker
         if (true) {
             this.processTrackQueue();
@@ -2342,6 +2346,14 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 //
 //    }
 
+    // Martijn start - network-constrained chunk tracking
+    public void attemptToTrackOrSeePlannedChunksForAllPlayers() {
+        for (ServerPlayer player : this.level.players) {
+            player.tickAttemptToTrackOrSeePlannedChunks();
+        }
+    }
+    // Martijn end - network-constrained chunk tracking
+
     public PoiManager getPoiManager() {
         return this.poiManager;
     }
diff --git a/src/main/java/net/minecraft/server/level/DistanceManager.java b/src/main/java/net/minecraft/server/level/DistanceManager.java
index 9ee2441cb104d5a8fab62b6c94eca1d1d4631540..7d2289cb28f6b5937cbb746aa4c0e9cbfafb419d 100644
--- a/src/main/java/net/minecraft/server/level/DistanceManager.java
+++ b/src/main/java/net/minecraft/server/level/DistanceManager.java
@@ -774,9 +774,10 @@ public abstract class DistanceManager {
             boolean withinSomeViewDistance = withinViewDistance;
             for (PlayerTicketTracker otherTracker : DistanceManager.this.getPlayerTicketManagers()) {
                 if (otherTracker != tracker) {
-                    minDistance = Math.min(distance, otherTracker.getLevel(pos));
-                    oldWithinSomeViewDistance |= otherTracker.haveTicketFor(distance);
-                    withinSomeViewDistance |= otherTracker.haveTicketFor(distance);
+                    int otherTrackerDistance = otherTracker.getLevel(pos);
+                    minDistance = Math.min(minDistance, otherTracker.getLevel(pos));
+                    oldWithinSomeViewDistance |= otherTracker.haveTicketFor(otherTrackerDistance);
+                    withinSomeViewDistance |= otherTracker.haveTicketFor(otherTrackerDistance);
                 }
             }
             this.onCombinedPlayerTicketTrackerLevelChange(pos, minDistance, oldWithinSomeViewDistance, withinSomeViewDistance);
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 3fcdbc2ec4b85950ed165145612b3339c21240b2..ab09281b1dff85b104cad906f6d1b149a1f20bf8 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -441,6 +441,309 @@ public class ServerPlayer extends Player {
     public final com.destroystokyo.paper.util.PooledHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> cachedSingleMobDistanceMap;
     // Paper end
 
+    // Martijn start - network-constrained chunk tracking
+
+    private final Object networkConstrainedTrackingLock = new Object();
+
+    private int maxNumberOfChunkPacketsInTransitBasedOnConnection = PaperConfig.initialMaxNumberOfChunkPacketsInTransit;
+
+    public int getMaxNumberOfChunkPacketsInTransitBasedOnConnection() {
+        synchronized (this.networkConstrainedTrackingLock) {
+            return this.maxNumberOfChunkPacketsInTransitBasedOnConnection;
+        }
+    }
+
+    public void setMaxNumberOfChunkPacketsInTransitBasedOnConnection(int maxNumberOfChunkPacketsInTransitBasedOnConnection) {
+        synchronized (this.networkConstrainedTrackingLock) {
+            this.maxNumberOfChunkPacketsInTransitBasedOnConnection = maxNumberOfChunkPacketsInTransitBasedOnConnection;
+        }
+    }
+
+    // Keep track of chunk packets in transit
+    private final ArrayDeque<Long> chunkInitializationPacketsInTransitKeepaliveIds = new ArrayDeque<>();
+
+    private void addChunkInitializationPacketInTransitKeepaliveId(long id) {
+        synchronized (this.networkConstrainedTrackingLock) {
+            this.chunkInitializationPacketsInTransitKeepaliveIds.add(id);
+        }
+    }
+
+    private int getNumberOfChunkInitializationPacketsInTransit() {
+        synchronized (this.networkConstrainedTrackingLock) {
+            return this.chunkInitializationPacketsInTransitKeepaliveIds.size();
+        }
+    }
+
+    private int numberOfChunksNewlyTrackedOrSeenThisTick = 0;
+
+    public void resetChunksNewlyTrackedOrSeenThisTick() {
+        synchronized (networkConstrainedTrackingLock) {
+            numberOfChunksNewlyTrackedOrSeenThisTick = 0;
+        }
+    }
+
+    private void incrementChunksNewlyTrackedOrSeenThisTick() {
+        synchronized (networkConstrainedTrackingLock) {
+            numberOfChunksNewlyTrackedOrSeenThisTick++;
+        }
+    }
+
+    private boolean canNewlyTrackOrSeeMoreChunksThisTick() {
+        if (this.getLevel().paperConfig.maxChunksToNewlyTrackOrSeePerTick == -1) return true;
+        synchronized (networkConstrainedTrackingLock) {
+            return numberOfChunksNewlyTrackedOrSeenThisTick < this.getLevel().paperConfig.maxChunksToNewlyTrackOrSeePerTick;
+        }
+    }
+
+    private final Object2ObjectMap<UUID, LongSet> plannedToTrack = new Object2ObjectOpenHashMap<>();
+    private final Object2ObjectMap<UUID, LongSet> tracking = new Object2ObjectOpenHashMap<>();
+    private final Object2ObjectMap<UUID, LongSet> plannedToSee = new Object2ObjectOpenHashMap<>();
+    private final Object2ObjectMap<UUID, LongSet> seeing = new Object2ObjectOpenHashMap<>();
+    private UUID quickAccessLevelUUID = null;
+    private LongSet quickAccessPlannedToTrack = null;
+    private LongSet quickAccessTracking = null;
+    private LongSet quickAccessPlannedToSee = null;
+    private LongSet quickAccessSeeing = null;
+
+    private void setQuickAccessTrackingLevel(UUID levelUUID) {
+        synchronized (this.networkConstrainedTrackingLock) {
+            LongSet plannedToTrackForLevel = this.plannedToTrack.computeIfAbsent(levelUUID, $ -> new LongOpenHashSet(0));
+            LongSet trackingForLevel = this.tracking.computeIfAbsent(levelUUID, $ -> new LongOpenHashSet(0));
+            LongSet plannedToSeeForLevel = this.plannedToSee.computeIfAbsent(levelUUID, $ -> new LongOpenHashSet(0));
+            LongSet seeingForLevel = this.seeing.computeIfAbsent(levelUUID, $ -> new LongOpenHashSet(0));
+            this.quickAccessLevelUUID = levelUUID;
+            this.quickAccessPlannedToTrack = plannedToTrackForLevel;
+            this.quickAccessTracking = trackingForLevel;
+            this.quickAccessPlannedToSee = plannedToSeeForLevel;
+            this.quickAccessSeeing = seeingForLevel;
+        }
+    }
+
+    private @NotNull LongSet getOrCreatePlannedToTrackOrSeeForLevel(UUID levelUUID, boolean concernsTracking) {
+        synchronized (this.networkConstrainedTrackingLock) {
+            if (levelUUID.equals(this.quickAccessLevelUUID)) {
+                return concernsTracking ? this.quickAccessPlannedToTrack : this.quickAccessPlannedToSee;
+            } else {
+                return (concernsTracking ? this.plannedToTrack : this.plannedToSee).computeIfAbsent(levelUUID, it -> new LongOpenHashSet(0));
+            }
+        }
+    }
+
+    private @Nullable LongSet getPlannedToTrackOrSeeForLevelIfExists(UUID levelUUID, boolean concernsTracking) {
+        if (levelUUID.equals(this.quickAccessLevelUUID)) {
+            return concernsTracking ? this.quickAccessPlannedToTrack : this.quickAccessPlannedToSee;
+        } else {
+            return (concernsTracking ? this.plannedToTrack : this.plannedToSee).get(levelUUID);
+        }
+    }
+
+    private @NotNull LongSet getOrCreateTrackingOrSeeingForLevel(UUID levelUUID, boolean concernsTracking) {
+        synchronized (this.networkConstrainedTrackingLock) {
+            if (levelUUID.equals(this.quickAccessLevelUUID)) {
+                return concernsTracking ? this.quickAccessTracking : this.quickAccessSeeing;
+            } else {
+                return (concernsTracking ? this.tracking : this.seeing).computeIfAbsent(levelUUID, it -> new LongOpenHashSet(0));
+            }
+        }
+    }
+
+    private @Nullable LongSet getTrackingOrSeeingForLevelIfExists(UUID levelUUID, boolean concernsTracking) {
+        if (levelUUID.equals(this.quickAccessLevelUUID)) {
+            return concernsTracking ? this.quickAccessTracking : this.quickAccessSeeing;
+        } else {
+            return (concernsTracking ? this.tracking : this.seeing).get(levelUUID);
+        }
+    }
+
+    private boolean isPlannedToTrackOrSee(UUID levelUUID, long chunkKey, boolean concernsTracking) {
+        synchronized (this.networkConstrainedTrackingLock) {
+            LongSet plannedToTrackForLevel = this.getPlannedToTrackOrSeeForLevelIfExists(levelUUID, concernsTracking);
+            return plannedToTrackForLevel != null && plannedToTrackForLevel.contains(chunkKey);
+        }
+    }
+
+    private boolean isPlannedToTrackOrSee(LevelChunk chunk, boolean concernsTracking) {
+        return this.isPlannedToTrackOrSee(chunk.level.uuid, chunk.getPos().longKey, concernsTracking);
+    }
+
+    /**
+     * This method will not synchronize, so it doesn't need to wait for any other threads and request the lock field from RAM, but the return value may be inconsistent with the truth
+     */
+    public boolean isTrackingOrSeeingNonSync(UUID levelUUID, long chunkKey, boolean concernsTracking) {
+        if (levelUUID.equals(this.quickAccessLevelUUID)) return (concernsTracking ? this.quickAccessTracking : this.quickAccessSeeing).contains(chunkKey);
+        LongSet trackingOrSeeingForLevel = (concernsTracking ? this.tracking : this.seeing).get(levelUUID);
+        return trackingOrSeeingForLevel != null && trackingOrSeeingForLevel.contains(chunkKey);
+    }
+
+    public boolean isTrackingOrSeeing(UUID levelUUID, long chunkKey, boolean concernsTracking) {
+        synchronized (this.networkConstrainedTrackingLock) {
+            return isTrackingOrSeeingNonSync(levelUUID, chunkKey, concernsTracking);
+        }
+    }
+
+    /**
+     * This method will not synchronize, so it doesn't need to wait for any other threads and request the lock field from RAM, but the return value may be inconsistent with the truth
+     */
+    public boolean isTrackingOrSeeingNonSync(LevelChunk chunk, boolean concernsTracking) {
+        return this.isTrackingOrSeeingNonSync(chunk.level.uuid, chunk.getPos().longKey, concernsTracking);
+    }
+
+    public boolean isTrackingOrSeeing(LevelChunk chunk, boolean concernsTracking) {
+        return this.isTrackingOrSeeing(chunk.level.uuid, chunk.getPos().longKey, concernsTracking);
+    }
+
+    private void removePlannedToTrackOrSee(UUID levelUUID, long chunkKey, boolean concernsTracking) {
+        synchronized (this.networkConstrainedTrackingLock) {
+            LongSet plannedToTrackOrSeeForLevel = this.getPlannedToTrackOrSeeForLevelIfExists(levelUUID, concernsTracking);
+            if (plannedToTrackOrSeeForLevel != null) plannedToTrackOrSeeForLevel.remove(chunkKey);
+        }
+    }
+
+    private void removeTrackingOrSeeing(UUID levelUUID, long chunkKey, boolean concernsTracking) {
+        synchronized (this.networkConstrainedTrackingLock) {
+            LongSet trackingOrSeeingForLevel = this.getTrackingOrSeeingForLevelIfExists(levelUUID, concernsTracking);
+            if (trackingOrSeeingForLevel != null) trackingOrSeeingForLevel.remove(chunkKey);
+        }
+    }
+
+    private void addPlannedToTrackOrSee(UUID levelUUID, long chunkKey, boolean concernsTracking) {
+        synchronized (this.networkConstrainedTrackingLock) {
+            this.getOrCreatePlannedToTrackOrSeeForLevel(levelUUID, concernsTracking).add(chunkKey);
+        }
+    }
+
+    private void addTrackingOrSeeing(UUID levelUUID, long chunkKey, boolean concernsTracking) {
+        synchronized (this.networkConstrainedTrackingLock) {
+            this.getOrCreateTrackingOrSeeingForLevel(levelUUID, concernsTracking).add(chunkKey);
+        }
+    }
+
+    private boolean isNotTrackingOrSeeingNorPlanningToTrackOrSeeOwnChunk() {
+        UUID ownLevelUUID = this.getLevelUUID();
+        if (ownLevelUUID == null) {
+            return true;
+        }
+        long ownChunkKey = this.getChunkPosLongKey();
+        synchronized (this.networkConstrainedTrackingLock) {
+            return !this.isTrackingOrSeeing(ownLevelUUID, ownChunkKey, false) && !this.isPlannedToTrackOrSee(ownLevelUUID, ownChunkKey, false);
+        }
+    }
+
+    private boolean isTrackingOrSeeingOwnChunk(boolean concernsTracking) {
+        UUID ownLevelUUID = this.getLevelUUID();
+        if (ownLevelUUID == null) {
+            return false;
+        }
+        long ownChunkKey = this.getChunkPosLongKey();
+        synchronized (this.networkConstrainedTrackingLock) {
+            return this.isTrackingOrSeeing(ownLevelUUID, ownChunkKey, concernsTracking);
+        }
+    }
+
+    /**
+     * @return A pair of: the long key of the first planned chunk to track or see, and a boolean that is true if it is planned to be tracked, and false if it splanned to be seen
+     */
+    private @Nullable Pair<Long, Boolean> getFirstPlannedChunkToTrackOrSee() {
+        UUID ownLevelUUID = this.getLevelUUID();
+        if (ownLevelUUID == null) {
+            // None if this player is not in a world
+            return null;
+        }
+        synchronized (this.networkConstrainedTrackingLock) {
+
+            for (boolean track : new boolean[] {true, false}) {
+
+                LongSet plannedToTrackOrSeeForLevel = getPlannedToTrackOrSeeForLevelIfExists(ownLevelUUID, track);
+
+                // None if there are no more chunks planned
+                if (plannedToTrackOrSeeForLevel == null || plannedToTrackOrSeeForLevel.isEmpty()) {
+                    continue;
+                }
+
+                // Get the closest chunk that is planned
+                @Nullable Long closestChunkPlanned = plannedToTrackOrSeeForLevel.stream()
+                    .min(Comparator.comparingLong(this::getSquaredPythagoreanDistanceToChunk))
+                    .orElse(null);
+                if (closestChunkPlanned != null) {
+                    return new ObjectObjectImmutablePair<>(closestChunkPlanned, track);
+                }
+
+            }
+
+            return null;
+
+        }
+    }
+
+    private boolean canStartTrackingOrSeeingChunkRightNow(ChunkPos chunkPos, boolean concernsTracking) {
+
+        long ownChunkKey = this.getChunkPosLongKey();
+        long chunkKey = chunkPos.longKey;
+        // Can always immediately start tracking or seeing the chunk the player is in
+        if (ownChunkKey == chunkKey) {
+            return true;
+        }
+        // Otherwise, if not yet tracking or seeing the chunk the player is in, if they are indeed not, we cannot start tracking or seeing any others
+        synchronized (this.networkConstrainedTrackingLock) {
+            if (!this.isTrackingOrSeeingOwnChunk(concernsTracking)) {
+                return false;
+            }
+        }
+
+        // We cannot newly track or see a new chunk if we already did so for too many this tick
+        synchronized (this.networkConstrainedTrackingLock) {
+            if (!this.canNewlyTrackOrSeeMoreChunksThisTick()) return false;
+        }
+
+        int manhattanDistance = this.getManhattanDistanceToChunk(chunkKey);
+        // Do not track or see if the Manhattan distance is much greater than the respective view distance (+2 because this is also what is normally used for the inclusive square area in which chunks can potentially be tracked or seen)
+        if (manhattanDistance > (concernsTracking ? this.getTrackViewDistance() : this.getSeeViewDistance()) + 2) {
+            return false;
+        }
+
+        // Do not track or see if the number of chunks in transit is greater than the threshold we set before we allow this chunk, based on its distance
+        // ^ Edit: we no longer do this, it was added to prevent screen lag due to receiving many chunks simultaneously, but the max number of chunks to send per tick has become the replacement solution
+//        long squaredPythagoreanDistance = this.getSquaredPythagoreanDistanceToChunk(chunkKey);
+//        // Should be turned into configuration options
+//        int maxNumberOfChunkPacketsInTransitByDistance = 7;
+//
+//        if (squaredPythagoreanDistance >= 729) { // 27^2
+//            maxNumberOfChunkPacketsInTransitByDistance = 1;
+//        } else if (squaredPythagoreanDistance >= 400) { // 20^2
+//            maxNumberOfChunkPacketsInTransitByDistance = 2;
+//        } else if (squaredPythagoreanDistance >= 196) { // 14^2
+//            maxNumberOfChunkPacketsInTransitByDistance = 3;
+//        } else if (squaredPythagoreanDistance >= 81) { // 9^2
+//            maxNumberOfChunkPacketsInTransitByDistance = 4;
+//        } else if (squaredPythagoreanDistance >= 25) { // 5^2
+//            maxNumberOfChunkPacketsInTransitByDistance = 5;
+//        } else if (squaredPythagoreanDistance >= 4) { // 2^2
+//            maxNumberOfChunkPacketsInTransitByDistance = 6;
+//        }
+        synchronized (this.networkConstrainedTrackingLock) {
+//            int maxNumberOfChunkPacketsInTransitToUse = Math.min(
+//                this.getMaxNumberOfChunkPacketsInTransitBasedOnConnection(),
+//                maxNumberOfChunkPacketsInTransitByDistance
+//            );
+            return this.getNumberOfChunkInitializationPacketsInTransit() < this.getMaxNumberOfChunkPacketsInTransitBasedOnConnection();
+        }
+
+    }
+
+    public void sendKeepaliveForChunkInTransit() {
+
+        // Quickly write a keep-alive packet after sending a chunk
+        // Generate a keep-alive challenge that is not the same as any real one (the real ones use the current system time itself)
+        long keepAliveChallenge = -System.currentTimeMillis();
+
+        Packet<?> followingKeepAlivePacket = new ClientboundKeepAlivePacket(keepAliveChallenge);
+        this.addChunkInitializationPacketInTransitKeepaliveId(keepAliveChallenge);
+        this.connection.send(followingKeepAlivePacket);
+
+    }
+
+    // Martijn end - network-constrained chunk tracking
+
     // CraftBukkit start
     public String displayName;
     public net.kyori.adventure.text.Component adventure$displayName; // Paper
@@ -465,6 +768,11 @@ public class ServerPlayer extends Player {
 
     public ServerPlayer(MinecraftServer server, ServerLevel world, GameProfile profile) {
         super(world, world.getSharedSpawnPos(), world.getSharedSpawnAngle(), profile);
+        // Martijn start - network-constrained chunk tracking
+        if (world != null) {
+            setQuickAccessTrackingLevel(world.uuid);
+        }
+        // Martijn end - network-constrained chunk tracking
         this.chatVisibility = ChatVisiblity.FULL;
         this.canChatColor = true;
         this.lastActionTime = Util.getMillis();
@@ -816,6 +1124,11 @@ public class ServerPlayer extends Player {
     // CraftBukkit start - World fallback code, either respawn location or global spawn
     public void spawnIn(Level world) {
         this.level = world;
+        // Martijn start - network-constrained chunk tracking
+        if (world != null && world instanceof ServerLevel) {
+            setQuickAccessTrackingLevel(((ServerLevel) world).uuid);
+        }
+        // Martijn end - network-constrained chunk tracking
         if (world == null) {
             this.unsetRemoved();
             Vec3 position = null;
@@ -1420,6 +1733,9 @@ public class ServerPlayer extends Player {
 
                 // CraftBukkit end
                 this.setLevel(worldserver);
+
+                setQuickAccessTrackingLevel(worldserver.uuid); // Martijn - network-constrained chunk tracking
+
                 worldserver.addDuringPortalTeleport(this);
                 this.connection.teleport(exit); // CraftBukkit - use internal teleport without event
                 this.connection.resetPosition(); // CraftBukkit - sync position after changing it (from PortalTravelAgent#findAndteleport)
@@ -2440,25 +2756,81 @@ public class ServerPlayer extends Player {
 
     }
 
-    // Martijn start - per-player track and see view distance
+    // Martijn start - per-player track and see view distance, network-constrained chunk tracking
 
-    public void trackOrSeeChunk(LevelChunk chunk, Packet<?> chunkDataPacket, boolean concernsTracking) {
+    public void planToTrackOrSeeChunk(LevelChunk chunk, boolean concernsTracking) {
 
-        this.connection.send(chunkDataPacket);
+        UUID levelUUID = chunk.level.uuid;
+        ChunkPos chunkPos = chunk.getPos();
+
+        UUID ownLevelUUID = this.getLevelUUID();
+
+        boolean trackOrSeeInstantly;
+        synchronized (this.networkConstrainedTrackingLock) {
+            if (ownLevelUUID != null && ownLevelUUID.equals(levelUUID) && this.canStartTrackingOrSeeingChunkRightNow(chunkPos, concernsTracking)) {
+                trackOrSeeInstantly = true;
+            } else {
+                trackOrSeeInstantly = false;
+                if (this.isTrackingOrSeeing(levelUUID, chunkPos.longKey, concernsTracking)) return;
+                this.addPlannedToTrackOrSee(levelUUID, chunkPos.longKey, concernsTracking);
+            }
+        }
+
+        if (trackOrSeeInstantly) {
+            this.actuallyTrackOrSeeChunk(chunk, concernsTracking);
+        }
+
+    }
+    // Note: does nothing if the chunk is already tracked or seen
+    private boolean actuallyTrackOrSeeChunk(LevelChunk chunk, boolean concernsTracking) {
+        return this.actuallyTrackOrSeeChunk(chunk, () -> this.getClientboundChunkInitializationPacket(chunk), concernsTracking);
+    }
+
+    // Note: does nothing if the chunk is already tracked or seen
+    private boolean actuallyTrackOrSeeChunk(LevelChunk chunk, Supplier<Packet<?>> chunkInitializationPacketSupplier, boolean concernsTracking) {
+
+        UUID levelUUID = chunk.level.uuid;
+        ChunkMap chunkMap = this.getLevel().getChunkSource().chunkMap;
+        ChunkPos chunkPos = chunk.getPos();
+
+        // Update tracked or seen status
+        synchronized (this.networkConstrainedTrackingLock) {
+
+            // This is important: when already tracked or seen, do nothing
+            if (this.isTrackingOrSeeing(levelUUID, chunkPos.longKey, concernsTracking)) {
+                return false;
+            }
+
+            this.removePlannedToTrackOrSee(levelUUID, chunkPos.longKey, concernsTracking);
+            this.addTrackingOrSeeing(levelUUID, chunkPos.longKey, concernsTracking);
+            // If we start tracking, we also start seeing, no need to send double initialization packets
+            if (concernsTracking) {
+                this.removePlannedToTrackOrSee(levelUUID, chunkPos.longKey, false);
+                this.addTrackingOrSeeing(levelUUID, chunkPos.longKey, false);
+            }
+
+        }
+
+        // Send the initialization packet
+        this.connection.send(chunkInitializationPacketSupplier.get());
 
-        // Paper start
         if (concernsTracking) {
+
+            // Paper start
             if (io.papermc.paper.event.packet.PlayerChunkLoadEvent.getHandlerList().getRegisteredListeners().length > 0) {
-                new io.papermc.paper.event.packet.PlayerChunkLoadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunk.getPos().longKey), this.getBukkitEntity()).callEvent();
+                new io.papermc.paper.event.packet.PlayerChunkLoadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
             }
+            // Paper end
+
         }
-        // Paper end
+
+        this.sendKeepaliveForChunkInTransit();
 
         if (concernsTracking) {
 
             // The following used to be the tail of ChunkMap.playerLoadedChunk, after the call to ServerPlayer.trackChunk
 
-            DebugPackets.sendPoiPacketsForChunk(getLevel(), chunk.getPos());
+            DebugPackets.sendPoiPacketsForChunk(getLevel(), chunkPos);
             List<Entity> list = Lists.newArrayList();
             List<Entity> list1 = Lists.newArrayList();
             // Paper start - optimise entity tracker
@@ -2469,7 +2841,7 @@ public class ServerPlayer extends Player {
                 if (entity == this) {
                     continue;
                 }
-                ChunkMap.TrackedEntity tracker = this.getLevel().getChunkSource().chunkMap.entityMap.get(entity.getId());
+                ChunkMap.TrackedEntity tracker = chunkMap.entityMap.get(entity.getId());
                 if (tracker != null) { // dumb plugins... move on...
                     tracker.updatePlayer(this);
                 }
@@ -2509,10 +2881,65 @@ public class ServerPlayer extends Player {
             }
 
         }
+
+        this.incrementChunksNewlyTrackedOrSeenThisTick();
+        return true;
+
     }
 
+    public void tickAttemptToTrackOrSeePlannedChunks() {
+
+        {
+            // Small optimization
+            if (this.isNotTrackingOrSeeingNorPlanningToTrackOrSeeOwnChunk()) {
+                return;
+            }
+        }
+
+        while (true) {
+
+            Pair<Long, Boolean> planned = this.getFirstPlannedChunkToTrackOrSee();
+            boolean plannedToTrack;
+            if (planned == null) {
+                break;
+            }
+
+            // Check if the player can start tracking this chunk
+            ChunkPos chunkPos = new ChunkPos(planned.first());
+            boolean canStartTracking = this.canStartTrackingOrSeeingChunkRightNow(chunkPos, planned.second());
+
+            // If the player can be informed of something, inform, otherwise break
+            if (canStartTracking) {
+                actuallyTrackOrSeeChunk(level.getChunk(chunkPos.x, chunkPos.z), planned.second());
+//                    incrementChunksNewlyTrackedOrSeenThisTick();
+                    // Break if we informed of enough packets - to make sure enough other players get a go without going over the tick time for this tick
+                    // ^ Edit: no longer necessary, we will break on the next step when canStartTrackingOrSeeingChunkRightNow returns false because of this - we don't want to break here in case the next planned chunk has some reason to be exempted from this rule
+//                    if (amountNewlyTrackedOrSeen >= level.paperConfig.maxChunksToNewlyTrackOrSeePerTick) {
+//                        break;
+//                    }
+//                }
+            } else {
+                break;
+            }
+
+        }
+
+    }
+
+    // Note that this will execute untracking or unseeing actions even if the chunk was not tracked or seen
     public void untrackOrUnseeChunk(ChunkPos chunkPos, boolean concernsTracking) {
 
+        ServerLevel level = this.getLevel();
+        if (level != null) {
+            UUID levelUUID = level.uuid;
+            synchronized (this.networkConstrainedTrackingLock) {
+
+                this.removePlannedToTrackOrSee(levelUUID, chunkPos.longKey, concernsTracking);
+                this.removeTrackingOrSeeing(levelUUID, chunkPos.longKey, concernsTracking);
+
+            }
+        }
+
         if (this.isAlive()) {
             if (!concernsTracking) {
                 this.connection.send(new ClientboundForgetLevelChunkPacket(chunkPos.x, chunkPos.z));
@@ -2528,13 +2955,36 @@ public class ServerPlayer extends Player {
 
     }
 
-    public ClientboundLevelChunkWithLightPacket getClientboundChunkInitializationPacket(LevelChunk chunk) {
+    private ClientboundLevelChunkWithLightPacket getClientboundChunkInitializationPacket(LevelChunk chunk) {
         boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(this, chunk);
         ChunkMap chunkMap = this.getLevel().getChunkSource().chunkMap;
         return new ClientboundLevelChunkWithLightPacket(chunk, chunkMap.lightEngine, (BitSet) null, (BitSet) null, true, shouldModify);
     }
 
-    // Martijn end - per-player track and see view distance
+    /**
+     * @return If this keepalive id was recognized as a fake one sent after a chunk initialization
+     */
+    public boolean removePacketsInTransitUpToKeepaliveId(long id) {
+
+        synchronized (this.networkConstrainedTrackingLock) {
+            if (this.chunkInitializationPacketsInTransitKeepaliveIds.contains(id)) {
+                // This is a response to one of our fake keep-alive packets
+                // We will remove all chunk packets in transition up to the received one that was apparently successful
+                while (!this.chunkInitializationPacketsInTransitKeepaliveIds.isEmpty()) {
+                    if (this.chunkInitializationPacketsInTransitKeepaliveIds.peekFirst() == id) {
+                        this.chunkInitializationPacketsInTransitKeepaliveIds.removeFirst();
+                        break;
+                    }
+                    this.chunkInitializationPacketsInTransitKeepaliveIds.removeFirst();
+                }
+                return true;
+            }
+        }
+        return false;
+
+    }
+
+    // Martijn end - per-player track and see view distance, network-constrained chunk tracking
 
     public SectionPos getLastSectionPos() {
         return this.lastSectionPos;
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 2b1c0e420bcf665c6d58d8690cb91c885f3268ec..44a22539de85e5703c3abfb294e005093d053aa4 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -145,6 +145,7 @@ import net.minecraft.world.level.block.entity.SignBlockEntity;
 import net.minecraft.world.level.block.entity.StructureBlockEntity;
 import net.minecraft.world.level.block.state.BlockBehaviour;
 import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.HitResult;
@@ -2006,6 +2007,15 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
 
     }
 
+    // Martijn start - network-constrained chunk tracking
+    public void sendIfTracking(LevelChunk chunk, Packet<?> packet) {
+        if (chunk == null) return;
+        if (this.getPlayer().isTrackingOrSeeingNonSync(chunk, true)) {
+            this.send(packet);
+        }
+    }
+    // Martijn end - network-constrained chunk tracking
+
     @Override
     public void send(Packet<?> packet) {
         this.send(packet, (GenericFutureListener) null);
@@ -3106,11 +3116,46 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
 
     @Override
     public void handleKeepAlive(ServerboundKeepAlivePacket packet) {
+        if (player.removePacketsInTransitUpToKeepaliveId(packet.getId())) return; // Martijn - network-constrained chunk tracking
         //PlayerConnectionUtils.ensureMainThread(packetplayinkeepalive, this, this.player.getWorldServer()); // CraftBukkit // Paper - This shouldn't be on the main thread
         if (this.keepAlivePending && packet.getId() == this.keepAliveChallenge) {
             int i = (int) (Util.getMillis() - this.keepAliveTime);
 
             this.player.latency = (this.player.latency * 3 + i) / 4;
+
+            // Martijn start - network-constrained chunk tracking
+            // Player ping was updated: if it is too high we update the max number of chunk packets in transit
+            // TODO turn into configuration options
+            if (this.player.latency > 500) {
+                // This ping is unnaceptable
+                this.player.setMaxNumberOfChunkPacketsInTransitBasedOnConnection(player.level.paperConfig.minMaxNumberOfChunkPacketsInTransit);
+            } else {
+                int maxNumberOfChunkPacketsInTransitChange = 0;
+                if (this.player.latency > 330) {
+                    // This ping is very undesired
+                    maxNumberOfChunkPacketsInTransitChange = -2;
+                } else if (this.player.latency > 260) {
+                    // This ping is quite undesired
+                    maxNumberOfChunkPacketsInTransitChange = -1;
+                } else if (this.player.latency < 50) {
+                    // This ping is very good
+                    maxNumberOfChunkPacketsInTransitChange = 2;
+                } else if (this.player.latency < 130) {
+                    // This ping is quite good
+                    maxNumberOfChunkPacketsInTransitChange = 1;
+                }
+                if (maxNumberOfChunkPacketsInTransitChange != 0) {
+                    this.player.setMaxNumberOfChunkPacketsInTransitBasedOnConnection(Math.max(
+                        player.level.paperConfig.minMaxNumberOfChunkPacketsInTransit,
+                        Math.min(
+                            player.level.paperConfig.maxMaxNumberOfChunkPacketsInTransit,
+                            this.player.getMaxNumberOfChunkPacketsInTransitBasedOnConnection() + maxNumberOfChunkPacketsInTransitChange
+                        )
+                    ));
+                }
+            }
+            // Martijn end - network-constrained chunk tracking
+
             this.keepAlivePending = false;
         } else if (!this.isSingleplayerOwner()) {
             // Martijn start - no disconnect on late or wrong keepalive
