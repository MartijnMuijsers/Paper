From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Sun, 3 Jul 2022 18:52:48 +0200
Subject: [PATCH] Resending inventory and chunks works, and silverfish can
 infest snowy stone bricks


diff --git a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
index 89f86e52ff8b85a48e28ff60ca23853105df2f31..80e4cf626351901b96132627483749aefa117f9f 100644
--- a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
@@ -925,7 +925,7 @@ public final class PlayerChunkLoader {
         protected final TreeSet<ChunkPriorityHolder> sendQueueForTracking = createSendQueue();
         protected final TreeSet<ChunkPriorityHolder> sendQueueForSeeing = createSendQueue();
 
-        protected LongOpenHashSet getSentChunks(final boolean concernsTracking) {
+        public LongOpenHashSet getSentChunks(final boolean concernsTracking) { // Martijn - custom blocks and items
             return concernsTracking ? this.sentChunksForTracking : this.sentChunksForSeeing;
         }
         protected LongOpenHashSet getChunksToBeSent(final boolean concernsTracking) {
diff --git a/src/main/java/net/minecraft/data/loot/BlockLoot.java b/src/main/java/net/minecraft/data/loot/BlockLoot.java
index 3ec6a393045f66f6d92e58a92c5facfe3f547468..15d312defd3c588d826f75c5b49aa4b1a3bf4ec6 100644
--- a/src/main/java/net/minecraft/data/loot/BlockLoot.java
+++ b/src/main/java/net/minecraft/data/loot/BlockLoot.java
@@ -141,7 +141,7 @@ public class BlockLoot implements Consumer<BiConsumer<ResourceLocation, LootTabl
         return createSilkTouchDispatchTable(dropWithSilkTouch, applyExplosionDecay(dropWithSilkTouch, LootItem.lootTableItem(drop).apply(SetItemCountFunction.setCount(count))));
     }
 
-    private static LootTable.Builder createSilkTouchOnlyTable(ItemLike drop) {
+    public static LootTable.Builder createSilkTouchOnlyTable(ItemLike drop) { // Martijn - custom blocks and items
         return LootTable.lootTable().withPool(LootPool.lootPool().when(HAS_SILK_TOUCH).setRolls(ConstantValue.exactly(1.0F)).add(LootItem.lootTableItem(drop)));
     }
 
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 959af26e523eec92fbe3c4d1d71eb7fb97e16d8e..8dfc2e103c8ea0430cde8995cf8847c90929b4a2 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -2251,7 +2251,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     // Paper start - Anti-Xray - Bypass
-    private void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<ImmutablePair<Boolean, Boolean>, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk, boolean concernsTracking) { // Martijn - per-player track and see view distance // Martijn - custom blocks and items
+    public void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<ImmutablePair<Boolean, Boolean>, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk, boolean concernsTracking) { // Martijn - per-player track and see view distance // Martijn - custom blocks and items
         if (cachedDataPackets.getValue() == null) {
             cachedDataPackets.setValue(new java.util.HashMap<>());
         }
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 89450e30b34aa8439fef29d27177d6718a200d61..1be5e8621ad391fa3745ca909e0460017b381a89 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -24,6 +24,9 @@ import io.papermc.paper.chunk.PlayerChunkLoader;
 import io.papermc.paper.configuration.GlobalConfiguration;
 import it.unimi.dsi.fastutil.Pair;
 import it.unimi.dsi.fastutil.ints.IntIntPair;
+import it.unimi.dsi.fastutil.longs.LongArrayList;
+import it.unimi.dsi.fastutil.longs.LongList;
+import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.objects.ObjectObjectImmutablePair;
 import net.minecraft.BlockUtil;
 import net.minecraft.ChatFormatting;
@@ -151,11 +154,13 @@ import net.minecraft.world.level.block.entity.CommandBlockEntity;
 import net.minecraft.world.level.block.entity.SignBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.border.WorldBorder;
+import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.dimension.LevelStem;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.portal.PortalInfo;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
+import org.apache.commons.lang3.mutable.MutableObject;
 import org.slf4j.Logger;
 import net.minecraft.world.Container;
 import net.minecraft.world.InteractionHand;
@@ -2930,6 +2935,38 @@ public class ServerPlayer extends Player {
         return bukkitPlayer.hasSuCraftResourcePack();
     }
 
+    public void resendInventory() {
+        this.getBukkitEntity().updateInventory();
+    }
+
+    public void resendAllSentChunks() {
+        if (!this.isAlive()) {
+            // Chunks cannot be untracked or tracked while dead
+            return;
+        }
+        net.minecraft.server.level.ChunkMap chunkMap = this.getLevel().getChunkSource().chunkMap;
+        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this);
+        LongSet sentTrackChunks = data.getSentChunks(true);
+        LongSet sentSeeChunks = data.getSentChunks(false);
+        // For all chunk keys, we will naively untrack and track the chunks all at once (bypassing the entire network-constrained chunk sending system, which would normally also call the untrackand track methods at the right times)
+        for (long chunkKey : sentSeeChunks) {
+            ChunkPos chunkPos = new ChunkPos(chunkKey);
+            int chunkX = chunkPos.x;
+            int chunkZ = chunkPos.z;
+            boolean concernsTracking = sentTrackChunks.contains(chunkKey);
+            // Untrack the chunk
+            this.untrackChunk(chunkPos, concernsTracking);
+            // Track the chunk (note that this will send a network-constrained chunk sending fake keep-alive packet too, and thereby increase the number of packets in transit according to that system, which should cause the network-constrained chunk sending system to wait appropriately for enough of these packets to arrive before sending any more)
+            // ChunkMap.playerLoadedChunk is basically ServerPlayer.trackChunk in this scenario, but it re-computes the chunk data to send based on the resource pack status
+            LevelChunk chunk = chunkMap.level.getChunkIfLoaded(chunkX, chunkZ);
+            // We don't want to suddenly load a chunk here, so we simply ignore this chunk if it is somehow not loaded anymore - too bad, but this should never happen or be so rare it is not significant
+            if (chunk == null) {
+                continue;
+            }
+            chunkMap.playerLoadedChunk(this, new MutableObject<>(), chunk, concernsTracking);
+        }
+    }
+
     // Martijn end - custom blocks and items
 
 }
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 96c59ed95385a41c9133dfbec170291d65283172..33e0da585eec446a6095b511d137ba79e9c0381a 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -1991,7 +1991,24 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
         }
         // Paper start
         PlayerResourcePackStatusEvent.Status packStatus = PlayerResourcePackStatusEvent.Status.values()[packet.action.ordinal()];
+
+        // Martijn start - custom blocks and items
+
+        @Nullable PlayerResourcePackStatusEvent.Status oldPackStatus = this.player.getBukkitEntity().getResourcePackStatus();
+
+        // Update the player's packet status before resending anything, so that it can be used by for example ChunkMap.playerLoadedChunk to correctly compute the chunk data to send
         player.getBukkitEntity().setResourcePackStatus(packStatus);
+
+        if ((oldPackStatus == PlayerResourcePackStatusEvent.Status.ACCEPTED || oldPackStatus == PlayerResourcePackStatusEvent.Status.SUCCESSFULLY_LOADED) && (packStatus == PlayerResourcePackStatusEvent.Status.DECLINED || packStatus == PlayerResourcePackStatusEvent.Status.FAILED_DOWNLOAD)) {
+            // Resend most of the potentially already sent data if we previously thought the player had accepted the resource pack, but now they no longer do
+            this.player.resendInventory();
+            this.player.resendAllSentChunks();
+        } else if (oldPackStatus == null && (packStatus == PlayerResourcePackStatusEvent.Status.ACCEPTED || packStatus == PlayerResourcePackStatusEvent.Status.SUCCESSFULLY_LOADED)) {
+            // Resend their inventory (we have not sent any chunks yet if this is true, so we do not need to resend any)
+            this.player.resendInventory();
+        }
+        // Martijn end - custom blocks and items
+
         this.cserver.getPluginManager().callEvent(new PlayerResourcePackStatusEvent(this.getCraftPlayer(), packStatus)); // CraftBukkit
         // Paper end
     }
diff --git a/src/main/java/net/minecraft/world/entity/monster/Silverfish.java b/src/main/java/net/minecraft/world/entity/monster/Silverfish.java
index 2dcda3b03796655da443e1b3dd68c6f6bca20d21..75f071fbeea888d2f37e3fa9f8801d6faa2e2951 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Silverfish.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Silverfish.java
@@ -4,6 +4,7 @@ import java.util.EnumSet;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.util.RandomSource;
diff --git a/src/main/java/net/minecraft/world/level/block/InfestedBlock.java b/src/main/java/net/minecraft/world/level/block/InfestedBlock.java
index f33033c99ac52e2c64adeb8c58ae87625e92b299..423e5bcd3ea481f20abac1ddc5d2aaad730da4d4 100644
--- a/src/main/java/net/minecraft/world/level/block/InfestedBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/InfestedBlock.java
@@ -5,6 +5,7 @@ import java.util.Iterator;
 import java.util.Map;
 import java.util.function.Supplier;
 import net.minecraft.core.BlockPos;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.monster.Silverfish;
@@ -25,7 +26,13 @@ public class InfestedBlock extends Block {
     private static final Map<BlockState, BlockState> INFESTED_TO_HOST_STATES = Maps.newIdentityHashMap();
 
     public InfestedBlock(Block regularBlock, BlockBehaviour.Properties settings) {
-        super(settings.destroyTime(regularBlock.defaultDestroyTime() / 2.0F).explosionResistance(0.75F));
+        // Martijn start - custom block and items
+        this(regularBlock, settings, true);
+    }
+
+    public InfestedBlock(Block regularBlock, BlockBehaviour.Properties settings, boolean halveDestroyTime) { // If we create infested blocks from custom blocks, it may be that their destroy time was already halved (due to being observable as an infested block by players) in which case we can set the halveDestroyTime flag to false, to prevent repeated halving
+        super(settings.destroyTime(halveDestroyTime ? regularBlock.defaultDestroyTime() / 2.0F : regularBlock.defaultDestroyTime()).explosionResistance(0.75F));
+        // Martijn end - custom block and items
         this.hostBlock = regularBlock;
         InfestedBlock.BLOCK_BY_HOST_BLOCK.put(regularBlock, this);
     }
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/BlockReplacementRule.java b/src/main/java/nl/martijnmuijsers/paper/block/BlockReplacementRule.java
index d4743a096630929c3d3c96cf2a1a4c4857973776..e5db89b035d12c6873484add9c8dc1ffa0e00f6c 100644
--- a/src/main/java/nl/martijnmuijsers/paper/block/BlockReplacementRule.java
+++ b/src/main/java/nl/martijnmuijsers/paper/block/BlockReplacementRule.java
@@ -176,6 +176,10 @@ public interface BlockReplacementRule {
                 return this;
             }
 
+            public @NotNull StatelessBlockReplacementRule.Builder withModelSameAsStatelessBlock(@NotNull Block block) {
+                return this.withModel(((StatelessBlockReplacementRule) block.replacementRule).model);
+            }
+
             public @NotNull StatelessBlockReplacementRule.Builder withHostReplacingItem(@NotNull Supplier<@NotNull Item> hostReplacingItemSupplier) {
                 this.hostReplacingItemSupplier = hostReplacingItemSupplier;
                 return this;
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlockLoot.java b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlockLoot.java
index fe98b46de9806d8892f40cea6a925875206d3a10..d27461e4193d3c3c759428c5f007244cb2f93de5 100644
--- a/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlockLoot.java
+++ b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlockLoot.java
@@ -30,4 +30,8 @@ public final class SuCraftBlockLoot {
         return blockLoot.createSingleItemTable(drop).build();
     }
 
+    public static @NotNull LootTable dropSingleItemWhenSilkTouch(ItemLike drop) {
+        return blockLoot.createSilkTouchOnlyTable(drop).build();
+    }
+
 }
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlocks.java b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlocks.java
index 88c4c7cc606c6e65714d57e4af634504389443b2..4ad2e577fc950fcc7b847fb26984c3f547f64794 100644
--- a/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlocks.java
+++ b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlocks.java
@@ -6,10 +6,12 @@ import net.minecraft.core.Registry;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.InfestedBlock;
 import net.minecraft.world.level.block.state.BlockBehaviour;
 import net.minecraft.world.level.material.Material;
 import net.minecraft.world.level.storage.loot.LootTable;
 import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
+import nl.martijnmuijsers.paper.blockanditemdata.model.ModelContent;
 import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIntention;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
@@ -58,6 +60,24 @@ public class SuCraftBlocks {
         SuCraftBlockLoot::dropSelf
     );
 
+    /**
+     * Based on {@link Blocks#INFESTED_STONE_BRICKS} and {@link #SNOWY_STONE_BRICKS}
+     */
+    public static final Block INFESTED_SNOWY_STONE_BRICKS = register(
+        "infested_snowy_stone_bricks",
+        BlockReplacementRule.stateless()
+            .withHost(Blocks.INFESTED_STONE_BRICKS)
+            .withHostReplacement(Blocks.STONE_BRICKS)
+            .withFullBlockBoundingBoxHostItem()
+            .withFallback(Blocks.STONE_BRICKS)
+            .withFallbackBlockAsFallbackItem()
+            .withHostReplacingItemFromHostBlock()
+            .withHostReplacingItemReplacementFromHostReplacementBlock()
+            .withModelSameAsStatelessBlock(SNOWY_STONE_BRICKS),
+        new InfestedBlock(SNOWY_STONE_BRICKS, BlockBehaviour.Properties.of(Material.CLAY), false),
+        block -> SuCraftBlockLoot.dropSingleItemWhenSilkTouch(SNOWY_STONE_BRICKS)
+    );
+
     private static @NotNull Block register(@NotNull String id, @NotNull BlockReplacementRule.Builder<?> replacementRuleBuilder, @NotNull Block block, @Nullable Supplier<@Nullable LootTable> lootTableSupplier) {
         return register(id, replacementRuleBuilder, block, lootTableSupplier == null ? null : ($ -> lootTableSupplier.get()));
     }
diff --git a/src/main/java/nl/martijnmuijsers/paper/item/SuCraftItems.java b/src/main/java/nl/martijnmuijsers/paper/item/SuCraftItems.java
index 50d5036c273b87a0b3d19a777c97f8a3591c1c17..c8719f129cc0d7d463f6e6e40c009ef8aae6a3e9 100644
--- a/src/main/java/nl/martijnmuijsers/paper/item/SuCraftItems.java
+++ b/src/main/java/nl/martijnmuijsers/paper/item/SuCraftItems.java
@@ -30,10 +30,15 @@ public class SuCraftItems {
     public static final Item SNOWY_STONE_BRICKS = registerBlock(SuCraftBlocks.SNOWY_STONE_BRICKS, "Snowy Stone Bricks", CreativeModeTab.TAB_BUILDING_BLOCKS);
 
     /**
-     * Based on {@link Items#STONE_BRICKS}
+     * Based on {@link #SNOWY_STONE_BRICKS}
      */
     public static final Item DIRTY_STONE_BRICKS = registerBlock(SuCraftBlocks.DIRTY_STONE_BRICKS, "Dirty Stone Bricks", CreativeModeTab.TAB_BUILDING_BLOCKS);
 
+    /**
+     * Based on {@link Items#INFESTED_STONE_BRICKS} and {@link #SNOWY_STONE_BRICKS}
+     */
+    public static final Item INFESTED_SNOWY_STONE_BRICKS = registerBlock(SuCraftBlocks.INFESTED_SNOWY_STONE_BRICKS, "Infested Snowy Stone Bricks", CreativeModeTab.TAB_DECORATIONS);
+
     public static Item registerBlock(Block block, String displayName, CreativeModeTab group) {
         Item registeredItem = Items.registerBlock(block, group);
         block.customItemForBlock = registeredItem;
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/sucraft/CreateSuCraftResourcePack.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/sucraft/CreateSuCraftResourcePack.java
index 9ce50547a445a5fb161e0082a373ff1feaad465d..d28cfffa6c6fea196b5ee66ee9501ae9424f5158 100644
--- a/src/main/java/nl/martijnmuijsers/paper/resourcepack/sucraft/CreateSuCraftResourcePack.java
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/sucraft/CreateSuCraftResourcePack.java
@@ -36,7 +36,7 @@ public final class CreateSuCraftResourcePack {
 
     private CreateSuCraftResourcePack() {}
 
-    private static final int currentResourcePackVersion = 3;
+    private static final int currentResourcePackVersion = 4;
 
     public static final int RESOURCE_PACK_FORMAT = 9;
 
