From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Tue, 12 Jul 2022 16:44:18 +0200
Subject: [PATCH] Make section updates smooth


diff --git a/src/main/java/net/minecraft/network/Connection.java b/src/main/java/net/minecraft/network/Connection.java
index 07d14bf204eb04ad7430885e6d8cb0ed928fdf89..5cc3bd7cd71a13c88be0c1795cd481110a7b2fb0 100644
--- a/src/main/java/net/minecraft/network/Connection.java
+++ b/src/main/java/net/minecraft/network/Connection.java
@@ -29,18 +29,26 @@ import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
+import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.Collections;
+import java.util.List;
 import java.util.Queue;
 import java.util.UUID;
 import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.locks.ReentrantLock;
 import javax.annotation.Nullable;
 
 import io.papermc.paper.util.CoordinateUtils;
+import it.unimi.dsi.fastutil.longs.Long2BooleanMap;
+import it.unimi.dsi.fastutil.longs.Long2BooleanOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2IntMap;
 import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongArrayFIFOQueue;
+import it.unimi.dsi.fastutil.longs.LongArrayList;
+import it.unimi.dsi.fastutil.longs.LongList;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import net.minecraft.Util;
@@ -73,6 +81,7 @@ import net.minecraft.world.entity.EquipmentSlot;
 import net.minecraft.world.entity.decoration.ArmorStand;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.entity.EntityAccess;
 import net.minecraft.world.phys.Vec3;
 import nl.martijnmuijsers.paper.resourcepack.asset.model.ResourcePackModel;
@@ -150,6 +159,10 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
      */
     private final @NotNull Long2ObjectMap<LongSet> blockEntityBlockPosKeysPerChunkSectionKey = new Long2ObjectOpenHashMap<>(0);
 
+    public @Nullable LongSet getBlockEntityBlockPosKeysForChunkSectionKey(long chunkSectionKey) {
+        return this.blockEntityBlockPosKeysPerChunkSectionKey.get(chunkSectionKey);
+    }
+
     /**
      * Utility function used in {@link #spawnBlockEntity}
      */
@@ -179,18 +192,19 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     }
 
     private void sendSetEquipmentPacket(int entityId, @NotNull SentBlockEntityInformation blockEntityInformationToSend) {
-        MinecraftServer.LOGGER.info("TEMP DEBUG - Sending " + entityId + " equipment: " + blockEntityInformationToSend.blockState + " , " + blockEntityInformationToSend.onPositiveXZCorner + " , " + blockEntityInformationToSend.closebyModel + " = " + blockEntityInformationToSend.blockState().getBlock().replacementRule.getBlockEntityItemStack(blockEntityInformationToSend.blockState(), blockEntityInformationToSend.onPositiveXZCorner, blockEntityInformationToSend.closebyModel).getTag().getInt(CraftMetaItem.CUSTOM_MODEL_DATA.NBT) + " ( " + blockEntityInformationToSend.blockState().getBlock().replacementRule.getBlockEntityItemModel(blockEntityInformationToSend.blockState(), blockEntityInformationToSend.onPositiveXZCorner, blockEntityInformationToSend.closebyModel).getKeyWithIntention() + " using custom model data " + blockEntityInformationToSend.blockState().getBlock().replacementRule.getBlockEntityItemCustomModelData(blockEntityInformationToSend.blockState(), blockEntityInformationToSend.onPositiveXZCorner, blockEntityInformationToSend.closebyModel) + " )");
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Sending " + entityId + " equipment: " + blockEntityInformationToSend.blockState + " , " + blockEntityInformationToSend.onPositiveXZCorner + " , " + blockEntityInformationToSend.closebyModel + " = " + blockEntityInformationToSend.blockState().getBlock().replacementRule.getBlockEntityItemStack(blockEntityInformationToSend.blockState(), blockEntityInformationToSend.onPositiveXZCorner, blockEntityInformationToSend.closebyModel).getTag().getInt(CraftMetaItem.CUSTOM_MODEL_DATA.NBT) + " ( " + blockEntityInformationToSend.blockState().getBlock().replacementRule.getBlockEntityItemModel(blockEntityInformationToSend.blockState(), blockEntityInformationToSend.onPositiveXZCorner, blockEntityInformationToSend.closebyModel).getKeyWithIntention() + " using custom model data " + blockEntityInformationToSend.blockState().getBlock().replacementRule.getBlockEntityItemCustomModelData(blockEntityInformationToSend.blockState(), blockEntityInformationToSend.onPositiveXZCorner, blockEntityInformationToSend.closebyModel) + " )");
         this.send(new ClientboundSetEquipmentPacket(entityId, Collections.singletonList(new Pair<>(EquipmentSlot.HEAD, blockEntityInformationToSend.blockState().getBlock().replacementRule.getBlockEntityItemStack(blockEntityInformationToSend.blockState(), blockEntityInformationToSend.onPositiveXZCorner, blockEntityInformationToSend.closebyModel)))));
     }
 
     private void spawnBlockEntity(@NotNull BlockPos blockPos, @NotNull SentBlockEntityInformation blockEntityInformationToSend) {
 
-        long blockKey = CoordinateUtils.getBlockKey(blockPos);
-        int entityId = blockEntityEntityIdByBlockPosKey.computeIfAbsent(blockKey, $ -> Entity.ENTITY_COUNTER.incrementAndGet());
-        MinecraftServer.LOGGER.info("TEMP DEBUG - Spawning " + entityId + " at " + blockPos.getX() + ", " + blockPos.getY() + ", " + blockPos.getZ());
-        sentBlockEntityInformationByBlockPosKey.put(blockKey, blockEntityInformationToSend);
-        long chunkSectionKey = CoordinateUtils.getChunkSectionKey(blockPos);
-        blockEntityBlockPosKeysPerChunkSectionKey.computeIfAbsent(chunkSectionKey, $ -> new LongOpenHashSet(0)).add(blockKey);
+        long blockKey = blockPos.asLong();
+        int entityId = this.blockEntityEntityIdByBlockPosKey.computeIfAbsent(blockKey, $ -> Entity.ENTITY_COUNTER.incrementAndGet());
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Spawning " + entityId + " at " + blockPos.getX() + ", " + blockPos.getY() + ", " + blockPos.getZ());
+        this.sentBlockEntityInformationByBlockPosKey.put(blockKey, blockEntityInformationToSend);
+        long chunkSectionKey = SectionPos.of(blockPos).asLong();
+        this.blockEntityBlockPosKeysPerChunkSectionKey.computeIfAbsent(chunkSectionKey, $ -> new LongOpenHashSet(1)).add(blockKey);
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Added block key " + BlockPos.of(blockKey).getX() + ", " + BlockPos.of(blockKey).getY() + ", " + BlockPos.of(blockKey).getZ());
         UUID entityUUID = UUID.randomUUID();
 
         // Send the add entity packet
@@ -209,7 +223,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         ));
 
         // Send the set equipment packet
-        sendSetEquipmentPacket(entityId, blockEntityInformationToSend);
+        this.sendSetEquipmentPacket(entityId, blockEntityInformationToSend);
 
         // Send the set entity data packet
         @NotNull ClientboundSetEntityDataPacket setEntityDataPacket = new ClientboundSetEntityDataPacket(entityId);
@@ -217,6 +231,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(Entity.DATA_SHARED_FLAGS_ID, (byte) (1 << Entity.FLAG_INVISIBLE)));
         setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(Entity.DATA_NO_GRAVITY, true));
         setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(Entity.DATA_SILENT, true));
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(Entity.DATA_AIR_SUPPLY_ID, Integer.MAX_VALUE));
         setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(ArmorStand.DATA_CLIENT_FLAGS, (byte) (ArmorStand.CLIENT_FLAG_NO_BASEPLATE | ArmorStand.CLIENT_FLAG_MARKER)));
         setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(ArmorStand.DATA_HEAD_POSE, Rotations.ZERO));
         setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(ArmorStand.DATA_BODY_POSE, Rotations.ZERO));
@@ -229,14 +244,16 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     }
 
     private void despawnBlockEntity(@NotNull BlockPos blockPos, boolean needToRemoveFromPerChunkSectionKey) {
-        long blockKey = CoordinateUtils.getBlockKey(blockPos);
+        long blockKey = blockPos.asLong();
         if (!this.blockEntityEntityIdByBlockPosKey.containsKey(blockKey)) {
+//            MinecraftServer.LOGGER.info("TEMP DEBUG - Tried to despawn at " + blockPos.getX() + ", " + blockPos.getY() + ", " + blockPos.getZ() + " but is no longer there?");
             return;
         }
         int entityId = this.blockEntityEntityIdByBlockPosKey.remove(blockKey);
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Despawning " + entityId + " at " + blockPos.getX() + ", " + blockPos.getY() + ", " + blockPos.getZ());
         this.sentBlockEntityInformationByBlockPosKey.remove(blockKey);
         if (needToRemoveFromPerChunkSectionKey) {
-            long chunkSectionKey = CoordinateUtils.getChunkSectionKey(blockPos);
+            long chunkSectionKey = SectionPos.of(blockPos).asLong();
             this.blockEntityBlockPosKeysPerChunkSectionKey.computeIfPresent(chunkSectionKey, ($, blockPosKeys) -> {
                 blockPosKeys.remove(blockKey);
                 if (blockPosKeys.isEmpty()) {
@@ -253,26 +270,18 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
      * and spawns a new block entity if no such existing sent block entity exists
      */
     private void updateBlockEntityOrSpawnIfNotSent(@NotNull BlockPos blockPos, @NotNull SentBlockEntityInformation blockEntityInformationToSend) {
-        long blockKey = CoordinateUtils.getBlockKey(blockPos);
+        long blockKey = blockPos.asLong();
         @Nullable SentBlockEntityInformation existingSentBlockEntityInformation = this.sentBlockEntityInformationByBlockPosKey.get(blockKey);
-        if (existingSentBlockEntityInformation != null) {
+        tryUpdateExistingBlockEntity: if (existingSentBlockEntityInformation != null) {
+            if (existingSentBlockEntityInformation.onPositiveXZCorner != blockEntityInformationToSend.onPositiveXZCorner) {
+                this.despawnBlockEntity(blockPos, true);
+                break tryUpdateExistingBlockEntity;
+            }
             boolean updated = false;
-            Integer lookedUpEntityId = null;
             if (!existingSentBlockEntityInformation.blockState.equals(blockEntityInformationToSend.blockState) || existingSentBlockEntityInformation.onPositiveXZCorner != blockEntityInformationToSend.onPositiveXZCorner || existingSentBlockEntityInformation.closebyModel != (blockEntityInformationToSend.closebyModel)) {
-                if (lookedUpEntityId == null) {
-                    lookedUpEntityId = this.blockEntityEntityIdByBlockPosKey.get(blockKey);
-                }
+                int entityId = this.blockEntityEntityIdByBlockPosKey.get(blockKey);
                 // Send a set equipment packet to change the observed block state
-                sendSetEquipmentPacket(lookedUpEntityId, blockEntityInformationToSend);
-                updated = true;
-            }
-            if (existingSentBlockEntityInformation.onPositiveXZCorner != blockEntityInformationToSend.onPositiveXZCorner) {
-                if (lookedUpEntityId == null) {
-                    lookedUpEntityId = this.blockEntityEntityIdByBlockPosKey.get(blockKey);
-                }
-                // Send a move packet to change the position
-                short dxz = blockEntityInformationToSend.onPositiveXZCorner ? ResourcePackModel.DOUBLE_BLOCK_ENTITY_ARMOR_STAND_DXZ_AS_POS_MOVE_SHORT : -ResourcePackModel.DOUBLE_BLOCK_ENTITY_ARMOR_STAND_DXZ_AS_POS_MOVE_SHORT;
-                this.send(new ClientboundMoveEntityPacket.Pos(lookedUpEntityId, dxz, (short) 0, dxz, false));
+                sendSetEquipmentPacket(entityId, blockEntityInformationToSend);
                 updated = true;
             }
             if (updated) {
@@ -287,15 +296,17 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
      * Completely updates this player correctly as per the current potential block entity at the given position
      * <br>
      * To be called when a block update for the block is sent to the player
+     *
+     * @param sentBlockEntityBlockPosKeys Will be used to determine if a block entity at the given block position (represented by the block key) was sent to the player before - if null, will be assumed to be an empty set
      */
-    public void updatePotentialBlockEntityAtPosition(@NotNull BlockPos blockPos) {
-        long blockKey = CoordinateUtils.getBlockKey(blockPos);
+    public void updatePotentialBlockEntityAtPosition(@NotNull BlockPos blockPos, boolean useGivenSentBlockEntityBlockPosKeys, @Nullable LongSet sentBlockEntityBlockPosKeys, boolean doDespawns) {
+        long blockKey = blockPos.asLong();
         var player = this.getPlayer();
         var level = player.getLevel();
         @NotNull BlockState state = level.getBlockState(blockPos);
         @Nullable var replacementRule = state.getBlock().replacementRule;
         if (replacementRule == null || !replacementRule.hasAsReal(state.getBlock()) || !replacementRule.rendersAsEntity()) {
-            if (this.blockEntityEntityIdByBlockPosKey.containsKey(blockKey)) {
+            if (doDespawns && (useGivenSentBlockEntityBlockPosKeys ? (sentBlockEntityBlockPosKeys != null && sentBlockEntityBlockPosKeys.contains(blockKey)) : this.blockEntityEntityIdByBlockPosKey.containsKey(blockKey))) {
                 this.despawnBlockEntity(blockPos, true);
             }
             return;
@@ -311,13 +322,172 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
                 onPositiveXZCorner = false;
             }
         }
-        long sectionKey = SectionPos.blockToSection(blockKey);
-        SectionPos playerSectionPos = SectionPos.of((EntityAccess) player);
-        int sectionDX = SectionPos.x(sectionKey) - playerSectionPos.x();
-        int sectionDY = SectionPos.y(sectionKey) - playerSectionPos.y();
-        int sectionDZ = SectionPos.z(sectionKey) - playerSectionPos.z();
+        SectionPos sectionPos = SectionPos.of(blockPos);
+        SectionPos playerSectionPos = SectionPos.of(player);
+        int sectionDX = sectionPos.x() - playerSectionPos.x();
+        int sectionDY = sectionPos.y() - playerSectionPos.y();
+        int sectionDZ = sectionPos.z() - playerSectionPos.z();
         boolean closebyModel = sectionDX >= -1 && sectionDX <= 1 && sectionDY >= -1 && sectionDY <= 1 && sectionDZ >= -1 && sectionDZ <= 1;
-        updateBlockEntityOrSpawnIfNotSent(blockPos, new SentBlockEntityInformation(state, onPositiveXZCorner, closebyModel));
+        this.updateBlockEntityOrSpawnIfNotSent(blockPos, new SentBlockEntityInformation(state, onPositiveXZCorner, closebyModel));
+    }
+
+    private ReentrantLock scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock = new ReentrantLock();
+    private boolean executedUpdatePotentialBlockEntitiesInSectionSpawnNewThisTick = false;
+
+    private @NotNull Long2BooleanMap sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewAndWhetherToUpdateOutsideSectionBounds = new Long2BooleanOpenHashMap(1);
+    private @NotNull LongArrayFIFOQueue sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewList= new LongArrayFIFOQueue(1);
+
+    private void tickUpdatePotentialBlockEntitiesInSectionSpawnNew() {
+        long sectionKey;
+        boolean updateOutsideSectionBounds;
+        boolean needToUnlock = true;
+        try {
+            scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.lock();
+            if (sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewAndWhetherToUpdateOutsideSectionBounds.isEmpty()) {
+                executedUpdatePotentialBlockEntitiesInSectionSpawnNewThisTick = false;
+                scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.unlock();
+                needToUnlock = false;
+                return;
+            }
+            executedUpdatePotentialBlockEntitiesInSectionSpawnNewThisTick = true;
+            sectionKey = sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewList.dequeueLong();
+            updateOutsideSectionBounds = sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewAndWhetherToUpdateOutsideSectionBounds.remove(sectionKey);
+        } finally {
+            if (needToUnlock) {
+                scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.unlock();
+            }
+        }
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Section update new during tick: " + SectionPos.of(sectionKey).x() + ", " + SectionPos.of(sectionKey).y() + ", " + SectionPos.of(sectionKey).z());
+        this.updatePotentialBlockEntitiesInSectionSpawnNew(SectionPos.of(sectionKey), updateOutsideSectionBounds, null);
+    }
+
+    private void scheduleUpdatePotentialBlockEntitiesInSectionSpawnNew(@NotNull SectionPos sectionPos, boolean updateOutsideSectionBounds, @Nullable LevelChunk precomputedChunk) {
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Schedule section update new: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
+        boolean needToUnlock = true;
+        try {
+            scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.lock();
+//            boolean executeRightNow = !executedUpdatePotentialBlockEntitiesInSectionSpawnNewThisTick && sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewList.isEmpty();
+//            if (executeRightNow) {
+//                executedUpdatePotentialBlockEntitiesInSectionSpawnNewThisTick = true;
+//                scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.unlock();
+//                needToUnlock = false;
+//                MinecraftServer.LOGGER.info("TEMP DEBUG - Section update new right now: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
+//                this.updatePotentialBlockEntitiesInSectionSpawnNew(sectionPos, updateOutsideSectionBounds, precomputedChunk);
+//                return;
+//            }
+            long sectionKey = sectionPos.asLong();
+            sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewAndWhetherToUpdateOutsideSectionBounds.compute(sectionKey, ($, existingUpdateOutsideSectionBounds) -> {
+                if (existingUpdateOutsideSectionBounds == null) {
+                    sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewList.enqueue(sectionKey);
+                    return updateOutsideSectionBounds;
+                }
+                return existingUpdateOutsideSectionBounds || updateOutsideSectionBounds;
+            });
+        } finally {
+            if (needToUnlock) {
+                scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.unlock();
+            }
+        }
+    }
+
+    /**
+     * The part of {@link #updatePotentialBlockEntitiesInSection} that spawns new block entities
+     */
+    private void updatePotentialBlockEntitiesInSectionSpawnNew(@NotNull SectionPos sectionPos, boolean updateOutsideSectionBounds, @Nullable LevelChunk precomputedChunk) {
+        var player = this.getPlayer();
+        var level = player.getLevel();
+        @Nullable LevelChunk chunk = precomputedChunk != null ? precomputedChunk : level.getChunkIfLoaded(sectionPos.x(), sectionPos.z());
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Section update new: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
+        if (chunk != null) {
+            var section = chunk.getSection(chunk.getSectionIndexFromSectionY(sectionPos.y()));
+            if (section.potentiallyContainsBlockEntity()) {
+                int minYInSection;
+                int maxYInSection;
+                int minXInSection;
+                int minZInSection;
+                int maxXInSection;
+                int maxZInSection;
+                if (updateOutsideSectionBounds) {
+                    boolean isBottomSection = sectionPos.y() == level.getMinSection();
+                    boolean isTopSection = sectionPos.y() == level.getMaxSection();
+                    boolean isMinXChunkLoaded = chunk.isNeighbourLoaded(-1, 0);
+                    boolean isMinXZChunkLoaded = chunk.isNeighbourLoaded(-1, -1);
+                    boolean isMinZChunkLoaded = chunk.isNeighbourLoaded(0, -1);
+                    boolean isPlusXChunkLoaded = chunk.isNeighbourLoaded(1, 0);
+                    boolean isPlusXZChunkLoaded = chunk.isNeighbourLoaded(1, 1);
+                    boolean isPlusZChunkLoaded = chunk.isNeighbourLoaded(0, 1);
+                    boolean isMinXPlusZChunkLoaded = chunk.isNeighbourLoaded(-1, 1);
+                    boolean isPlusXMinZChunkLoaded = chunk.isNeighbourLoaded(1, -1);
+                    minYInSection = isBottomSection ? 0 : -1;
+                    maxYInSection = isTopSection ? 15 : 16;
+                    minXInSection = isMinXChunkLoaded && isMinXZChunkLoaded && isMinXPlusZChunkLoaded ? -1 : 0;
+                    minZInSection = isMinZChunkLoaded && isMinXZChunkLoaded && isPlusXMinZChunkLoaded ? -1 : 0;
+                    maxXInSection = isPlusXChunkLoaded && isPlusXZChunkLoaded && isPlusXMinZChunkLoaded ? 16 : 15;
+                    maxZInSection = isPlusZChunkLoaded && isPlusXZChunkLoaded && isMinXPlusZChunkLoaded ? 16 : 15;
+                } else {
+                    minYInSection = 0;
+                    maxYInSection = 15;
+                    minXInSection = 0;
+                    minZInSection = 0;
+                    maxXInSection = 15;
+                    maxZInSection = 15;
+                }
+                //                MinecraftServer.LOGGER.info("TEMP DEBUG - Section update loop: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
+                for (int xInSection = minXInSection; xInSection <= maxXInSection; xInSection++) {
+                    for (int yInSection = minYInSection; yInSection <= maxYInSection; yInSection++) {
+                        for (int zInSection = minZInSection; zInSection <= maxZInSection; zInSection++) {
+                            int blockX = sectionPos.minBlockX() + xInSection;
+                            int blockY = sectionPos.minBlockY() + yInSection;
+                            int blockZ = sectionPos.minBlockZ() + zInSection;
+                            this.updatePotentialBlockEntityAtPosition(new BlockPos(blockX, blockY, blockZ), true, null, false);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    public void updatePotentialBlockEntitiesInSection(@NotNull SectionPos sectionPos, boolean updateOutsideSectionBounds, @Nullable LevelChunk precomputedChunk) {
+        var player = this.getPlayer();
+        var level = player.getLevel();
+        @Nullable LevelChunk chunk = precomputedChunk != null ? precomputedChunk : level.getChunkIfLoaded(sectionPos.x(), sectionPos.z());
+        if (chunk != null) {
+//            MinecraftServer.LOGGER.info("TEMP DEBUG - Section update start: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
+            var sectionKey = sectionPos.asLong();
+            // Attempt to despawn any sent block entities where one no longer exists
+            @Nullable LongSet sectionSentBlockKeys = this.getBlockEntityBlockPosKeysForChunkSectionKey(sectionKey);
+            if (sectionSentBlockKeys != null) {
+//                MinecraftServer.LOGGER.info("TEMP DEBUG - Section update old: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
+                @Nullable LongList toRemoveBlockKeys = null;
+                for (long sentBlockKey : sectionSentBlockKeys) {
+                    @NotNull BlockPos blockPos = BlockPos.of(sentBlockKey);
+                    @NotNull BlockState state = level.getBlockState(blockPos);
+                    @Nullable var replacementRule = state.getBlock().replacementRule;
+                    if (replacementRule == null || !replacementRule.hasAsReal(state.getBlock()) || !replacementRule.rendersAsEntity()) {
+                        if (toRemoveBlockKeys == null) {
+                            toRemoveBlockKeys = new LongArrayList(1);
+                        }
+                        toRemoveBlockKeys.add(sentBlockKey);
+                        despawnBlockEntity(blockPos, false);
+                    }
+                }
+//                MinecraftServer.LOGGER.info("TEMP DEBUG - Section update old to remove size is " + (toRemoveBlockKeys == null ? 0 : toRemoveBlockKeys.size()));
+                if (toRemoveBlockKeys != null) {
+                    for (long sentBlockKey : toRemoveBlockKeys) {
+                        sectionSentBlockKeys.remove(sentBlockKey);
+                        if (sectionSentBlockKeys.isEmpty()) {
+                            this.blockEntityBlockPosKeysPerChunkSectionKey.remove(sectionKey);
+                        }
+                    }
+                }
+            }
+            // Attempt to update any block entities derived from the actual world block states
+            var section = chunk.getSection(chunk.getSectionIndexFromSectionY(sectionPos.y()));
+            if (section.potentiallyContainsBlockEntity()) {
+                this.scheduleUpdatePotentialBlockEntitiesInSectionSpawnNew(sectionPos, updateOutsideSectionBounds, chunk);
+//                MinecraftServer.LOGGER.info("TEMP DEBUG - Section update done: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
+            }
+        }
     }
 
     /**
@@ -330,6 +500,8 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         });
     }
 
+    public boolean hasUpdatedBlockEntitiesClosebyModel = false;
+
     /**
      * To be called for every chunk section that the player enters or leaves, or any chunk section right next to a chunk section (at most chunk section chessboard distance 1) the player enters or leaves
      */
@@ -338,7 +510,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         if (blockKeys == null) {
             return;
         }
-        MinecraftServer.LOGGER.info("Updating closeby model for all in section " + SectionPos.x(chunkSectionKey) + ", " + SectionPos.y(chunkSectionKey) + ", " + SectionPos.z(chunkSectionKey));
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Updating closeby model for all in section " + SectionPos.x(chunkSectionKey) + ", " + SectionPos.y(chunkSectionKey) + ", " + SectionPos.z(chunkSectionKey));
         int sectionDX = SectionPos.x(chunkSectionKey) - upToDatePlayerSectionPos.x();
         int sectionDY = SectionPos.y(chunkSectionKey) - upToDatePlayerSectionPos.y();
         int sectionDZ = SectionPos.z(chunkSectionKey) - upToDatePlayerSectionPos.z();
@@ -842,6 +1014,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     private static int joinAttemptsThisTick; // Paper
     private static int currTick; // Paper
     public void tick() {
+        this.tickUpdatePotentialBlockEntitiesInSectionSpawnNew(); // Martijn - custom blocks and items
         this.flushQueue();
         // Paper start
         if (currTick != net.minecraft.server.MinecraftServer.currentTick) {
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockUpdatePacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockUpdatePacket.java
index 12866fc2efc503b222c26a07fe7b95a17dd882e8..ee4b4d93c1814b327a8786829e1b3bcea4fccdfd 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockUpdatePacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockUpdatePacket.java
@@ -97,7 +97,7 @@ public class ClientboundBlockUpdatePacket implements Packet<ClientGamePacketList
                                 int nz = this.pos.getZ() + dz;
                                 BlockPos npos = new BlockPos(nx, ny, nz);
                                 if (level.isLoadedAndInBounds(npos)) {
-                                    connection.updatePotentialBlockEntityAtPosition(npos);
+                                    connection.updatePotentialBlockEntityAtPosition(npos, false, null, true);
                                 }
                             }
                         }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundForgetLevelChunkPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundForgetLevelChunkPacket.java
index de5f8f44ca0be761320484347ca140a2500ad25f..f6bbfbda350086176bf810bf71bbb3887d17bc33 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundForgetLevelChunkPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundForgetLevelChunkPacket.java
@@ -55,7 +55,7 @@ public class ClientboundForgetLevelChunkPacket implements Packet<ClientGamePacke
             if (!future.isCancelled() && future.isSuccess() && connection.isConnected()) {
                 ChunkPos chunkPos = new ChunkPos(x, z);
                 for (int y = connection.getPlayer().getLevel().getMinSection(); y <= connection.getPlayer().getLevel().getMaxSection(); y++) {
-                    connection.despawnBlockEntitiesInChunkSection(CoordinateUtils.getChunkSectionKey(chunkPos, y));
+                    connection.despawnBlockEntitiesInChunkSection(SectionPos.of(chunkPos, y).asLong());
                 }
             }
         };
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
index 7b0d25aa0f0637ecbe9617e7e779ab612579061e..20b3c5a8d163db354acfc63072c2b680c56988ea 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
@@ -5,6 +5,8 @@ import javax.annotation.Nullable;
 
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
+import io.papermc.paper.util.CoordinateUtils;
+import it.unimi.dsi.fastutil.longs.LongSet;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
 import net.minecraft.network.Connection;
@@ -111,20 +113,24 @@ public class ClientboundLevelChunkWithLightPacket implements Packet<ClientGamePa
                     @Nullable LevelChunk chunk = connection.getPlayer().getLevel().getChunkIfLoaded(this.x, this.z);
                     if (chunk != null) {
                         int sectionsCount = chunk.getSectionsCount();
-                        int chunkMinBlockX = chunk.getPos().getMinBlockX();
-                        int chunkMinBlockZ = chunk.getPos().getMinBlockZ();
-                        for (int sectionY = 0; sectionY < sectionsCount; sectionY++) {
-                            var section = chunk.getSection(sectionY);
-                            if (section.potentiallyContainsBlockEntity()) {
-                                var sectionMinBlockY = section.bottomBlockY();
-                                for (int xInSection = 0; xInSection < 16; xInSection++) {
-                                    for (int yInSection = 0; yInSection < 16; yInSection++) {
-                                        for (int zInSection = 0; zInSection < 16; zInSection++) {
-                                            connection.updatePotentialBlockEntityAtPosition(new BlockPos(xInSection + chunkMinBlockX, yInSection + sectionMinBlockY, zInSection + chunkMinBlockZ));
-                                        }
-                                    }
-                                }
-                            }
+//                        int chunkMinBlockX = chunk.getPos().getMinBlockX();
+//                        int chunkMinBlockZ = chunk.getPos().getMinBlockZ();
+                        for (int sectionYIndex = 0; sectionYIndex < sectionsCount; sectionYIndex++) {
+                            SectionPos sectionPos = SectionPos.of(this.x, chunk.getSectionYFromSectionIndex(sectionYIndex), this.z);
+                            connection.updatePotentialBlockEntitiesInSection(sectionPos, false, chunk);
+//                            var section = chunk.getSection(sectionYIndex);
+//                            var sectionKey = CoordinateUtils.getChunkSectionKey();
+//                            @Nullable LongSet sectionSentBlockKeys = connection.getBlockEntityBlockPosKeysForChunkSectionKey(sectionKey);
+//                            if (section.potentiallyContainsBlockEntity()) {
+//                                var sectionMinBlockY = section.bottomBlockY();
+//                                for (int xInSection = 0; xInSection < 16; xInSection++) {
+//                                    for (int yInSection = 0; yInSection < 16; yInSection++) {
+//                                        for (int zInSection = 0; zInSection < 16; zInSection++) {
+//                                            connection.updatePotentialBlockEntityAtPosition(new BlockPos(xInSection + chunkMinBlockX, yInSection + sectionMinBlockY, zInSection + chunkMinBlockZ), true, sectionSentBlockKeys);
+//                                        }
+//                                    }
+//                                }
+//                            }
                         }
                     }
                 } catch (Exception ignored) {}
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
index 27b996c70feb82b79bd4b16f2e24ffdae86a7661..3decb05ab0a4eb8ada98ad8dc852b7278fd910e7 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
@@ -2,6 +2,8 @@ package net.minecraft.network.protocol.game;
 
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
+import io.papermc.paper.util.CoordinateUtils;
+import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.shorts.ShortIterator;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
 
@@ -12,6 +14,7 @@ import net.minecraft.core.SectionPos;
 import net.minecraft.network.Connection;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.LevelChunk;
@@ -156,40 +159,7 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
                 callback.operationComplete(future);
             }
             if (!future.isCancelled() && future.isSuccess() && connection.isConnected()) {
-                var level = connection.getPlayer().getLevel();
-                @Nullable LevelChunk chunk = level.getChunkIfLoaded(this.sectionPos.x(), this.sectionPos.z());
-                if (chunk != null) {
-                    var section = chunk.getSection(chunk.getSectionIndexFromSectionY(this.sectionPos.y()));
-                    if (section.potentiallyContainsBlockEntity()) {
-                        boolean isBottomSection = this.sectionPos.y() == level.getMinSection();
-                        boolean isTopSection = this.sectionPos.y() == level.getMaxSection();
-                        int minYInSection = isBottomSection ? 0 : -1;
-                        int maxYInSection = isTopSection ? 15 : 16;
-                        boolean isMinXChunkLoaded = chunk.isNeighbourLoaded(-1, 0);
-                        boolean isMinXZChunkLoaded = chunk.isNeighbourLoaded(-1, -1);
-                        boolean isMinZChunkLoaded = chunk.isNeighbourLoaded(0, -1);
-                        boolean isPlusXChunkLoaded = chunk.isNeighbourLoaded(1, 0);
-                        boolean isPlusXZChunkLoaded = chunk.isNeighbourLoaded(1, 1);
-                        boolean isPlusZChunkLoaded = chunk.isNeighbourLoaded(0, 1);
-                        boolean isMinXPlusZChunkLoaded = chunk.isNeighbourLoaded(-1, 1);
-                        boolean isPlusXMinZChunkLoaded = chunk.isNeighbourLoaded(1, -1);
-                        int minXInSection = isMinXChunkLoaded && isMinXZChunkLoaded && isMinXPlusZChunkLoaded ? -1 : 0;
-                        int minZInSection = isMinZChunkLoaded && isMinXZChunkLoaded && isPlusXMinZChunkLoaded ? -1 : 0;
-                        int maxXInSection = isPlusXChunkLoaded && isPlusXZChunkLoaded && isPlusXMinZChunkLoaded ? 16 : 15;
-                        int maxZInSection = isPlusZChunkLoaded && isPlusXZChunkLoaded && isMinXPlusZChunkLoaded ? 16 : 15;
-                        for (int xInSection = minXInSection; xInSection <= maxXInSection; xInSection++) {
-                            for (int yInSection = minYInSection; yInSection <= maxYInSection; yInSection++) {
-                                for (int zInSection = minZInSection; zInSection <= maxZInSection; zInSection++) {
-                                    int blockX = sectionPos.minBlockX() + xInSection;
-                                    int blockY = sectionPos.minBlockY() + yInSection;
-                                    int blockZ = sectionPos.minBlockZ() + zInSection;
-                                    connection.updatePotentialBlockEntityAtPosition(new BlockPos(blockX, blockY, blockZ));
-                                    this.sectionPos.blocksInside().forEach(connection::updatePotentialBlockEntityAtPosition);
-                                }
-                            }
-                        }
-                    }
-                }
+                connection.updatePotentialBlockEntitiesInSection(this.sectionPos, true, null);
             }
         };
     }
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 3974f71cff9882111124410a71376609bd33fc73..cac165d14a92b728a7fe6b5e36e1402cfd78cf63 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -2013,12 +2013,13 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         SectionPos sectionposition = player.getLastSectionPos();
         SectionPos sectionposition1 = SectionPos.of((EntityAccess) player);
         // Martijn start - custom blocks and items
-        if (!sectionposition.equals(sectionposition1)) {
-            var connection = player.connection;
-            if (connection != null) {
-                if (!connection.isDisconnected()) {
-                    var connection2 = connection.connection;
-                    if (connection2 != null && connection2.isConnected()) {
+        var connection = player.connection;
+        if (connection != null) {
+            if (!connection.isDisconnected()) {
+                var connection2 = connection.connection;
+                if (connection2 != null && connection2.isConnected()) {
+                    if (!sectionposition.equals(sectionposition1) || !connection2.hasUpdatedBlockEntitiesClosebyModel) {
+                        connection2.hasUpdatedBlockEntitiesClosebyModel = true;
                         LongSet fromAndToSectionsAndChessboardNeighbors = new LongOpenHashSet(108); // (3*3*3) * 2 * 2
                         for (SectionPos oldOrNewSectionPos : new SectionPos[]{sectionposition, sectionposition1}) {
                             for (int dx = -1; dx <= 1; dx++) {
@@ -2030,7 +2031,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                                         if (ny >= level.getMinSection() && ny <= level.getMaxSection()) {
                                             SectionPos neighbor = SectionPos.of(nx, ny, nz);
                                             if (level.isLoadedAndInBounds(new BlockPos(neighbor.minBlockX(), neighbor.minBlockY(), neighbor.minBlockZ()))) {
-                                                fromAndToSectionsAndChessboardNeighbors.add(CoordinateUtils.getChunkSectionKey(neighbor));
+                                                fromAndToSectionsAndChessboardNeighbors.add(neighbor.asLong());
                                             }
                                         }
                                     }
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index f2f73aecb5aee473c8f0709a9f55bf9c53d182d8..695ed363c7e783d696cc2e02956fb7cfbb067d08 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -340,7 +340,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     public static final int FLAG_INVISIBLE = 5;
     protected static final int FLAG_GLOWING = 6;
     protected static final int FLAG_FALL_FLYING = 7;
-    private static final EntityDataAccessor<Integer> DATA_AIR_SUPPLY_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
+    public static final EntityDataAccessor<Integer> DATA_AIR_SUPPLY_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
     private static final EntityDataAccessor<Optional<Component>> DATA_CUSTOM_NAME = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.OPTIONAL_COMPONENT);
     private static final EntityDataAccessor<Boolean> DATA_CUSTOM_NAME_VISIBLE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
     public static final EntityDataAccessor<Boolean> DATA_SILENT = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelContent.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelContent.java
index ef63696155eff6867e4841b7b0e58f6e4bc55fa1..999d3202cd2ed1d2ee4775a2adc542974a76909c 100644
--- a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelContent.java
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelContent.java
@@ -29,7 +29,11 @@ import java.util.function.Supplier;
  */
 public abstract class ModelContent implements ResourcePackAssetDataContent {
 
-    private static final float OUTWARD_EXPANDED_ELEMENT_DISTANCE_CLOSE = 0.0075F;
+    // TODO Use
+    private static final float OUTWARD_EXPANDED_ELEMENT_DISTANCE_NEIGHBOR_BLOCK = 0.005F;
+    private static final float OUTWARD_EXPANDED_ELEMENT_DISTANCE_SAME_CHUNK = 0.015F;
+    private static final float OUTWARD_EXPANDED_ELEMENT_DISTANCE_NEIGHBOR_CHUNK = 0.04F;
+    private static final float OUTWARD_EXPANDED_ELEMENT_DISTANCE_CLOSE = 0.01F; // TODO remove this one
     private static final float OUTWARD_EXPANDED_ELEMENT_DISTANCE_FAR = 0.1F;
 
     protected ModelContent() {}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/sucraft/CreateSuCraftResourcePack.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/sucraft/CreateSuCraftResourcePack.java
index 81eabcc686e0f3b9189eef967b84732783b787b8..64ccd895a3a5a3aaaa36192127280a72a4b92ac9 100644
--- a/src/main/java/nl/martijnmuijsers/paper/resourcepack/sucraft/CreateSuCraftResourcePack.java
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/sucraft/CreateSuCraftResourcePack.java
@@ -36,7 +36,7 @@ public final class CreateSuCraftResourcePack {
 
     private CreateSuCraftResourcePack() {}
 
-    private static final int currentResourcePackVersion = 92;
+    private static final int currentResourcePackVersion = 94;
 
     private static final String RESOURCE_PACK_FOLDER_PATH = "resourcepack";
     private static final String OUTPUT_FOLDER_PATH = RESOURCE_PACK_FOLDER_PATH + "/output";
