From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Mon, 20 Jun 2022 01:43:25 +0200
Subject: [PATCH] Custom stronghold generation


diff --git a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
index 63b344c7bf67bc236f88639ed6bee7d2c451761d..5a54f44db9db8747eaab6ee1a7ec9cfee25f7fd6 100644
--- a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
@@ -260,6 +260,141 @@ public class GlobalConfiguration extends ConfigurationPart {
 
     // Martijn end - network-constrained chunk sending
 
+    // Martijn start - custom strongholds
+
+    public CustomStrongholds customStrongholds;
+
+    public class CustomStrongholds extends ConfigurationPart {
+
+        public PotentialExtraIncreasedY potentialExtraIncreasedY;
+
+        public class PotentialExtraIncreasedY extends ConfigurationPart {
+
+            public int badlands = 0;
+            public int plateau = 0;
+            public int windswept = 0;
+            public int mountain = 0;
+            public int hill = 0;
+            public int all = 0;
+
+        }
+
+        public DecreasedY decreasedY;
+
+        public class DecreasedY extends ConfigurationPart {
+
+            public int always = 0;
+            public int potentialExtra = 0;
+
+        }
+
+        public MinimumPortalRoomYDifference minimumPortalRoomYDifference;
+
+        public class MinimumPortalRoomYDifference extends ConfigurationPart {
+
+            public int min = 0;
+            public int max = 0;
+
+        }
+
+        public double ceilingBlockHoleChance = 0;
+
+        public SlabOrStairsSurfaces slabOrStairsSurfaces;
+
+        public class SlabOrStairsSurfaces extends ConfigurationPart {
+
+            public Floor floor;
+            public Ceiling ceiling;
+
+            public class Floor extends FloorOrCeiling {}
+
+            public class Ceiling extends FloorOrCeiling {}
+
+            public abstract class FloorOrCeiling extends ConfigurationPart {
+
+                public double chance = 0;
+                public double slabRatio = 0.5;
+
+            }
+
+        }
+
+        public WaterAndLavaInCrossings waterAndLavaInCrossings;
+
+        public class WaterAndLavaInCrossings extends ConfigurationPart {
+
+            public double chance = 0;
+            public double waterRatio = 0.5;
+
+            public BlockChances blockChances;
+
+            public class BlockChances extends ConfigurationPart {
+
+                public double water = 0;
+                public double lava = 0;
+
+            }
+
+        }
+
+        public MoreCobwebs moreCobwebs;
+
+        public class MoreCobwebs extends ConfigurationPart {
+
+            public FirstOpportunity firstOpportunity;
+            public SecondOpportunity secondOpportunity;
+            public ThirdOpportunity thirdOpportunity;
+
+            public class FirstOpportunity extends Opportunity {}
+
+            public class SecondOpportunity extends Opportunity {}
+
+            public class ThirdOpportunity extends Opportunity {}
+
+            public abstract class Opportunity extends ConfigurationPart {
+
+                public double chance = 0;
+                public double ratio = 0;
+
+            }
+
+            public Opportunity[] getOpportunities() {
+                return new Opportunity[] { firstOpportunity, secondOpportunity, thirdOpportunity };
+            }
+
+        }
+
+        public AddCandles addCandles;
+
+        public class AddCandles extends ConfigurationPart {
+
+            public FirstOpportunity firstOpportunity;
+            public SecondOpportunity secondOpportunity;
+            public ThirdOpportunity thirdOpportunity;
+
+            public class FirstOpportunity extends Opportunity {}
+
+            public class SecondOpportunity extends Opportunity {}
+
+            public class ThirdOpportunity extends Opportunity {}
+
+            public abstract class Opportunity extends ConfigurationPart {
+
+                public double chance = 0;
+                public double ratio = 0;
+
+            }
+
+            public Opportunity[] getOpportunities() {
+                return new Opportunity[] { firstOpportunity, secondOpportunity, thirdOpportunity };
+            }
+
+        }
+
+    }
+
+    // Martijn end - custom strongholds
+
     public Messages messages;
 
     public class Messages extends ConfigurationPart {
diff --git a/src/main/java/net/minecraft/data/advancements/StoryAdvancements.java b/src/main/java/net/minecraft/data/advancements/StoryAdvancements.java
index 712e249ebe86d9adabf2bb816eea45543061efd3..de8a9a5fae3cfe9941481f1500a9a807220875cc 100644
--- a/src/main/java/net/minecraft/data/advancements/StoryAdvancements.java
+++ b/src/main/java/net/minecraft/data/advancements/StoryAdvancements.java
@@ -21,6 +21,7 @@ import net.minecraft.world.item.Items;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.levelgen.structure.BuiltinStructures;
+import nl.martijnmuijsers.paper.structure.SuCraftBuiltinStructures;
 
 public class StoryAdvancements implements Consumer<Consumer<Advancement>> {
     @Override
@@ -39,7 +40,7 @@ public class StoryAdvancements implements Consumer<Consumer<Advancement>> {
         Advancement.Builder.advancement().parent(advancement6).display(Items.DIAMOND_CHESTPLATE, Component.translatable("advancements.story.shiny_gear.title"), Component.translatable("advancements.story.shiny_gear.description"), (ResourceLocation)null, FrameType.TASK, true, true, false).requirements(RequirementsStrategy.OR).addCriterion("diamond_helmet", InventoryChangeTrigger.TriggerInstance.hasItems(Items.DIAMOND_HELMET)).addCriterion("diamond_chestplate", InventoryChangeTrigger.TriggerInstance.hasItems(Items.DIAMOND_CHESTPLATE)).addCriterion("diamond_leggings", InventoryChangeTrigger.TriggerInstance.hasItems(Items.DIAMOND_LEGGINGS)).addCriterion("diamond_boots", InventoryChangeTrigger.TriggerInstance.hasItems(Items.DIAMOND_BOOTS)).save(consumer, "story/shiny_gear");
         Advancement advancement10 = Advancement.Builder.advancement().parent(advancement9).display(Items.FLINT_AND_STEEL, Component.translatable("advancements.story.enter_the_nether.title"), Component.translatable("advancements.story.enter_the_nether.description"), (ResourceLocation)null, FrameType.TASK, true, true, false).addCriterion("entered_nether", ChangeDimensionTrigger.TriggerInstance.changedDimensionTo(Level.NETHER)).save(consumer, "story/enter_the_nether");
         Advancement.Builder.advancement().parent(advancement10).display(Items.GOLDEN_APPLE, Component.translatable("advancements.story.cure_zombie_villager.title"), Component.translatable("advancements.story.cure_zombie_villager.description"), (ResourceLocation)null, FrameType.GOAL, true, true, false).addCriterion("cured_zombie", CuredZombieVillagerTrigger.TriggerInstance.curedZombieVillager()).save(consumer, "story/cure_zombie_villager");
-        Advancement advancement11 = Advancement.Builder.advancement().parent(advancement10).display(Items.ENDER_EYE, Component.translatable("advancements.story.follow_ender_eye.title"), Component.translatable("advancements.story.follow_ender_eye.description"), (ResourceLocation)null, FrameType.TASK, true, true, false).addCriterion("in_stronghold", PlayerTrigger.TriggerInstance.located(LocationPredicate.inStructure(BuiltinStructures.STRONGHOLD))).save(consumer, "story/follow_ender_eye");
+        Advancement advancement11 = Advancement.Builder.advancement().parent(advancement10).display(Items.ENDER_EYE, Component.translatable("advancements.story.follow_ender_eye.title"), Component.translatable("advancements.story.follow_ender_eye.description"), (ResourceLocation)null, FrameType.TASK, true, true, false).requirements(RequirementsStrategy.OR).addCriterion("in_stronghold", PlayerTrigger.TriggerInstance.located(LocationPredicate.inStructure(BuiltinStructures.STRONGHOLD))).addCriterion("in_stronghold_surface", PlayerTrigger.TriggerInstance.located(LocationPredicate.inStructure(SuCraftBuiltinStructures.STRONGHOLD_SURFACE))).save(consumer, "story/follow_ender_eye"); // Martijn - custom strongholds - surface strongholds
         Advancement.Builder.advancement().parent(advancement11).display(Blocks.END_STONE, Component.translatable("advancements.story.enter_the_end.title"), Component.translatable("advancements.story.enter_the_end.description"), (ResourceLocation)null, FrameType.TASK, true, true, false).addCriterion("entered_end", ChangeDimensionTrigger.TriggerInstance.changedDimensionTo(Level.END)).save(consumer, "story/enter_the_end");
     }
 }
diff --git a/src/main/java/net/minecraft/data/tags/StructureTagsProvider.java b/src/main/java/net/minecraft/data/tags/StructureTagsProvider.java
index 0e79ec93eb84cc1b62c4048c204b97c8020967bf..d7fa20ed673c96c9cda352ae5025c0581c538b21 100644
--- a/src/main/java/net/minecraft/data/tags/StructureTagsProvider.java
+++ b/src/main/java/net/minecraft/data/tags/StructureTagsProvider.java
@@ -5,6 +5,7 @@ import net.minecraft.data.DataGenerator;
 import net.minecraft.tags.StructureTags;
 import net.minecraft.world.level.levelgen.structure.BuiltinStructures;
 import net.minecraft.world.level.levelgen.structure.Structure;
+import nl.martijnmuijsers.paper.structure.SuCraftBuiltinStructures;
 
 public class StructureTagsProvider extends TagsProvider<Structure> {
     public StructureTagsProvider(DataGenerator dataGenerator) {
@@ -20,7 +21,7 @@ public class StructureTagsProvider extends TagsProvider<Structure> {
         this.tag(StructureTags.RUINED_PORTAL).add(BuiltinStructures.RUINED_PORTAL_DESERT).add(BuiltinStructures.RUINED_PORTAL_JUNGLE).add(BuiltinStructures.RUINED_PORTAL_MOUNTAIN).add(BuiltinStructures.RUINED_PORTAL_NETHER).add(BuiltinStructures.RUINED_PORTAL_OCEAN).add(BuiltinStructures.RUINED_PORTAL_STANDARD).add(BuiltinStructures.RUINED_PORTAL_SWAMP);
         this.tag(StructureTags.CATS_SPAWN_IN).add(BuiltinStructures.SWAMP_HUT);
         this.tag(StructureTags.CATS_SPAWN_AS_BLACK).add(BuiltinStructures.SWAMP_HUT);
-        this.tag(StructureTags.EYE_OF_ENDER_LOCATED).add(BuiltinStructures.STRONGHOLD);
+        this.tag(StructureTags.EYE_OF_ENDER_LOCATED).add(BuiltinStructures.STRONGHOLD).add(SuCraftBuiltinStructures.STRONGHOLD_SURFACE); // Martijn - custom strongholds - surface strongholds
         this.tag(StructureTags.DOLPHIN_LOCATED).addTag(StructureTags.OCEAN_RUIN).addTag(StructureTags.SHIPWRECK);
         this.tag(StructureTags.ON_WOODLAND_EXPLORER_MAPS).add(BuiltinStructures.WOODLAND_MANSION);
         this.tag(StructureTags.ON_OCEAN_EXPLORER_MAPS).add(BuiltinStructures.OCEAN_MONUMENT);
diff --git a/src/main/java/net/minecraft/data/worldgen/StructureSets.java b/src/main/java/net/minecraft/data/worldgen/StructureSets.java
index ef50bc6a61c074c9b9f6a12dc465d407aec95d19..e497632891b5534b76943d9a4a24bf2d4e591ae2 100644
--- a/src/main/java/net/minecraft/data/worldgen/StructureSets.java
+++ b/src/main/java/net/minecraft/data/worldgen/StructureSets.java
@@ -2,6 +2,8 @@ package net.minecraft.data.worldgen;
 
 import java.util.List;
 import java.util.Optional;
+
+import io.papermc.paper.configuration.GlobalConfiguration;
 import net.minecraft.core.Holder;
 import net.minecraft.core.Registry;
 import net.minecraft.core.Vec3i;
@@ -15,6 +17,7 @@ import net.minecraft.world.level.levelgen.structure.placement.ConcentricRingsStr
 import net.minecraft.world.level.levelgen.structure.placement.RandomSpreadStructurePlacement;
 import net.minecraft.world.level.levelgen.structure.placement.RandomSpreadType;
 import net.minecraft.world.level.levelgen.structure.placement.StructurePlacement;
+import nl.martijnmuijsers.paper.structure.SuCraftStructures;
 
 public interface StructureSets {
     Holder<StructureSet> VILLAGES = register(BuiltinStructureSets.VILLAGES, new StructureSet(List.of(StructureSet.entry(Structures.VILLAGE_PLAINS), StructureSet.entry(Structures.VILLAGE_DESERT), StructureSet.entry(Structures.VILLAGE_SAVANNA), StructureSet.entry(Structures.VILLAGE_SNOWY), StructureSet.entry(Structures.VILLAGE_TAIGA)), new RandomSpreadStructurePlacement(34, 8, RandomSpreadType.LINEAR, 10387312)));
@@ -34,7 +37,7 @@ public interface StructureSets {
     Holder<StructureSet> NETHER_COMPLEXES = register(BuiltinStructureSets.NETHER_COMPLEXES, new StructureSet(List.of(StructureSet.entry(Structures.FORTRESS, 2), StructureSet.entry(Structures.BASTION_REMNANT, 3)), new RandomSpreadStructurePlacement(27, 4, RandomSpreadType.LINEAR, 30084232)));
     Holder<StructureSet> NETHER_FOSSILS = register(BuiltinStructureSets.NETHER_FOSSILS, Structures.NETHER_FOSSIL, new RandomSpreadStructurePlacement(2, 1, RandomSpreadType.LINEAR, 14357921));
     Holder<StructureSet> END_CITIES = register(BuiltinStructureSets.END_CITIES, Structures.END_CITY, new RandomSpreadStructurePlacement(20, 11, RandomSpreadType.TRIANGULAR, 10387313));
-    Holder<StructureSet> STRONGHOLDS = register(BuiltinStructureSets.STRONGHOLDS, Structures.STRONGHOLD, new ConcentricRingsStructurePlacement(32, 3, 128, BuiltinRegistries.BIOME.getOrCreateTag(BiomeTags.STRONGHOLD_BIASED_TO)));
+    Holder<StructureSet> STRONGHOLDS = register(BuiltinStructureSets.STRONGHOLDS, new StructureSet(List.of(StructureSet.entry(Structures.STRONGHOLD, 1), StructureSet.entry(SuCraftStructures.STRONGHOLD_SURFACE, 100)), new ConcentricRingsStructurePlacement(32, 3, 128, BuiltinRegistries.BIOME.getOrCreateTag(BiomeTags.STRONGHOLD_BIASED_TO)))); // Martijn - custom strongholds - surface strongholds
 
     static Holder<StructureSet> bootstrap(Registry<StructureSet> registry) {
         return registry.holders().iterator().next();
diff --git a/src/main/java/net/minecraft/data/worldgen/Structures.java b/src/main/java/net/minecraft/data/worldgen/Structures.java
index bfcf01afe4cb1fb2c5462dd19261d9388439f179..b6a009b48874d7db4ac373f4192a83d212592ff9 100644
--- a/src/main/java/net/minecraft/data/worldgen/Structures.java
+++ b/src/main/java/net/minecraft/data/worldgen/Structures.java
@@ -56,7 +56,7 @@ public class Structures {
     public static final Holder<Structure> SHIPWRECK = register(BuiltinStructures.SHIPWRECK, new ShipwreckStructure(structure(BiomeTags.HAS_SHIPWRECK, TerrainAdjustment.NONE), false));
     public static final Holder<Structure> SHIPWRECK_BEACHED = register(BuiltinStructures.SHIPWRECK_BEACHED, new ShipwreckStructure(structure(BiomeTags.HAS_SHIPWRECK_BEACHED, TerrainAdjustment.NONE), true));
     public static final Holder<Structure> SWAMP_HUT = register(BuiltinStructures.SWAMP_HUT, new SwampHutStructure(structure(BiomeTags.HAS_SWAMP_HUT, Map.of(MobCategory.MONSTER, new StructureSpawnOverride(StructureSpawnOverride.BoundingBoxType.PIECE, WeightedRandomList.create(new MobSpawnSettings.SpawnerData(EntityType.WITCH, 1, 1, 1))), MobCategory.CREATURE, new StructureSpawnOverride(StructureSpawnOverride.BoundingBoxType.PIECE, WeightedRandomList.create(new MobSpawnSettings.SpawnerData(EntityType.CAT, 1, 1, 1)))), GenerationStep.Decoration.SURFACE_STRUCTURES, TerrainAdjustment.NONE)));
-    public static final Holder<Structure> STRONGHOLD = register(BuiltinStructures.STRONGHOLD, new StrongholdStructure(structure(BiomeTags.HAS_STRONGHOLD, TerrainAdjustment.BURY)));
+    public static final Holder<Structure> STRONGHOLD = register(BuiltinStructures.STRONGHOLD, new StrongholdStructure(structure(BiomeTags.HAS_STRONGHOLD, TerrainAdjustment.BURY), false)); // Martijn - custom strongholds - surface strongholds
     public static final Holder<Structure> OCEAN_MONUMENT = register(BuiltinStructures.OCEAN_MONUMENT, new OceanMonumentStructure(structure(BiomeTags.HAS_OCEAN_MONUMENT, Map.of(MobCategory.MONSTER, new StructureSpawnOverride(StructureSpawnOverride.BoundingBoxType.STRUCTURE, WeightedRandomList.create(new MobSpawnSettings.SpawnerData(EntityType.GUARDIAN, 1, 2, 4))), MobCategory.UNDERGROUND_WATER_CREATURE, new StructureSpawnOverride(StructureSpawnOverride.BoundingBoxType.STRUCTURE, MobSpawnSettings.EMPTY_MOB_LIST), MobCategory.AXOLOTLS, new StructureSpawnOverride(StructureSpawnOverride.BoundingBoxType.STRUCTURE, MobSpawnSettings.EMPTY_MOB_LIST)), GenerationStep.Decoration.SURFACE_STRUCTURES, TerrainAdjustment.NONE)));
     public static final Holder<Structure> OCEAN_RUIN_COLD = register(BuiltinStructures.OCEAN_RUIN_COLD, new OceanRuinStructure(structure(BiomeTags.HAS_OCEAN_RUIN_COLD, TerrainAdjustment.NONE), OceanRuinStructure.Type.COLD, 0.3F, 0.9F));
     public static final Holder<Structure> OCEAN_RUIN_WARM = register(BuiltinStructures.OCEAN_RUIN_WARM, new OceanRuinStructure(structure(BiomeTags.HAS_OCEAN_RUIN_WARM, TerrainAdjustment.NONE), OceanRuinStructure.Type.WARM, 0.3F, 0.9F));
diff --git a/src/main/java/net/minecraft/server/ServerAdvancementManager.java b/src/main/java/net/minecraft/server/ServerAdvancementManager.java
index 902f179e4e997829d9f2143ba358dd16d2303829..3e86f9d07a6c252558138ef26175ff6e01536bac 100644
--- a/src/main/java/net/minecraft/server/ServerAdvancementManager.java
+++ b/src/main/java/net/minecraft/server/ServerAdvancementManager.java
@@ -13,14 +13,20 @@ import java.util.Map;
 import javax.annotation.Nullable;
 import net.minecraft.advancements.Advancement;
 import net.minecraft.advancements.AdvancementList;
+import net.minecraft.advancements.RequirementsStrategy;
 import net.minecraft.advancements.TreeNodePosition;
 import net.minecraft.advancements.critereon.DeserializationContext;
+import net.minecraft.advancements.critereon.LocationPredicate;
+import net.minecraft.advancements.critereon.PlayerTrigger;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.packs.resources.ResourceManager;
 import net.minecraft.server.packs.resources.SimpleJsonResourceReloadListener;
 import net.minecraft.util.GsonHelper;
 import net.minecraft.util.profiling.ProfilerFiller;
+import net.minecraft.world.level.levelgen.structure.BuiltinStructures;
 import net.minecraft.world.level.storage.loot.PredicateManager;
+import nl.martijnmuijsers.paper.structure.SuCraftBuiltinStructures;
+import org.bukkit.Bukkit;
 import org.slf4j.Logger;
 
 public class ServerAdvancementManager extends SimpleJsonResourceReloadListener {
@@ -49,6 +55,17 @@ public class ServerAdvancementManager extends SimpleJsonResourceReloadListener {
                 JsonObject jsonobject = GsonHelper.convertToJsonObject(jsonelement, "advancement");
                 Advancement.Builder advancement_serializedadvancement = Advancement.Builder.fromJson(jsonobject, new DeserializationContext(minecraftkey, this.predicateManager));
 
+                // Martijn start - custom strongholds - surface strongholds
+                if (minecraftkey.toString().equals("minecraft:story/follow_ender_eye")) {
+                    advancement_serializedadvancement.getCriteria().clear(); // A bit hacky, but hey, if it works
+                    advancement_serializedadvancement = advancement_serializedadvancement
+                        .requirements(RequirementsStrategy.OR)
+                        .addCriterion("in_stronghold", PlayerTrigger.TriggerInstance.located(LocationPredicate.inStructure(BuiltinStructures.STRONGHOLD)))
+                        .addCriterion("in_stronghold_surface", PlayerTrigger.TriggerInstance.located(LocationPredicate.inStructure(SuCraftBuiltinStructures.STRONGHOLD_SURFACE)))
+                        .requirements(new String[][] {{"in_stronghold", "in_stronghold_surface"}});
+                }
+                // Martijn end - custom strongholds - surface strongholds
+
                 map1.put(minecraftkey, advancement_serializedadvancement);
             } catch (Exception exception) {
                 ServerAdvancementManager.LOGGER.error("Parsing error loading custom advancement {}: {}", minecraftkey, exception.getMessage());
diff --git a/src/main/java/net/minecraft/server/level/WorldGenRegion.java b/src/main/java/net/minecraft/server/level/WorldGenRegion.java
index f000c822ed4563b5b840936852bc7d8e030763e3..7aa5c20d52deb6a66fcf0dce0514f7d6013f0ea1 100644
--- a/src/main/java/net/minecraft/server/level/WorldGenRegion.java
+++ b/src/main/java/net/minecraft/server/level/WorldGenRegion.java
@@ -295,7 +295,7 @@ public class WorldGenRegion implements WorldGenLevel {
         } else {
             // Paper start
             if (!hasSetFarWarned) {
-            Util.logAndPauseIfInIde("Detected setBlock in a far chunk [" + i + ", " + j + "], pos: " + pos + ", status: " + this.generatingStatus + (this.currentlyGenerating == null ? "" : ", currently generating: " + (String) this.currentlyGenerating.get()));
+            Util.logAndPauseIfInIde("Detected setBlock in a far chunk [" + i + ", " + j + "], pos: " + pos + ", intended center chunk: [" + chunkcoordintpair.x + ", " + chunkcoordintpair.z + "], writeRadiusCutoff: " + this.writeRadiusCutoff + ", status: " + this.generatingStatus + (this.currentlyGenerating == null ? "" : ", currently generating: " + (String) this.currentlyGenerating.get())); // Martijn - custom strongholds - debug errors
             hasSetFarWarned = true;
             if (this.getServer() != null && this.getServer().isDebugging()) {
                 io.papermc.paper.util.TraceUtil.dumpTraceForThread("far setBlock call");
diff --git a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
index 477f7db7d9f237a7b37610462c86b2a22c01c2a6..3db0baaeba47cce086f1b39025304744e0d134fc 100644
--- a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
+++ b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
@@ -42,6 +42,7 @@ import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.LevelReader;
 import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.EntityBlock;
 import net.minecraft.world.level.block.Mirror;
 import net.minecraft.world.level.block.RenderShape;
@@ -678,14 +679,29 @@ public abstract class BlockBehaviour {
 
     public abstract static class BlockStateBase extends StateHolder<Block, BlockState> {
 
-        private final int lightEmission; public final int getEmittedLight() { return this.lightEmission; } // Paper - OBFHELPER
-        private final boolean useShapeForLightOcclusion; public final boolean isTransparentOnSomeFaces() { return this.useShapeForLightOcclusion; } // Paper - OBFHELPER
+        private final int lightEmission;
+
+        public final int getEmittedLight() {
+            return this.lightEmission;
+        } // Paper - OBFHELPER
+
+        private final boolean useShapeForLightOcclusion;
+
+        public final boolean isTransparentOnSomeFaces() {
+            return this.useShapeForLightOcclusion;
+        } // Paper - OBFHELPER
+
         private final boolean isAir;
         private final Material material;
         private final MaterialColor materialColor;
         public final float destroySpeed;
         private final boolean requiresCorrectToolForDrops;
-        private final boolean canOcclude; public final boolean isOpaque() { return this.canOcclude; } // Paper - OBFHELPER
+        private final boolean canOcclude;
+
+        public final boolean isOpaque() {
+            return this.canOcclude;
+        } // Paper - OBFHELPER
+
         private final BlockBehaviour.StatePredicate isRedstoneConductor;
         private final BlockBehaviour.StatePredicate isSuffocating;
         private final BlockBehaviour.StatePredicate isViewBlocking;
@@ -715,20 +731,24 @@ public abstract class BlockBehaviour {
             this.offsetType = (BlockBehaviour.OffsetType) blockbase_info.offsetType.apply(this.asState());
             this.conditionallyFullOpaque = this.isOpaque() & this.isTransparentOnSomeFaces(); // Paper
         }
+
         // Paper start - impl cached craft block data, lazy load to fix issue with loading at the wrong time
         private org.bukkit.craftbukkit.block.data.CraftBlockData cachedCraftBlockData;
 
         public org.bukkit.craftbukkit.block.data.CraftBlockData createCraftBlockData() {
-            if (cachedCraftBlockData == null) cachedCraftBlockData = org.bukkit.craftbukkit.block.data.CraftBlockData.createData(asState());
+            if (cachedCraftBlockData == null)
+                cachedCraftBlockData = org.bukkit.craftbukkit.block.data.CraftBlockData.createData(asState());
             return (org.bukkit.craftbukkit.block.data.CraftBlockData) cachedCraftBlockData.clone();
         }
         // Paper end
 
         // Paper start
         protected boolean shapeExceedsCube = true;
+
         public final boolean shapeExceedsCube() {
             return this.shapeExceedsCube;
         }
+
         // Paper end
         // Paper start
         protected boolean isTicking;
@@ -736,15 +756,18 @@ public abstract class BlockBehaviour {
         // Paper end
         // Paper start
         protected int opacityIfCached = -1;
+
         // ret -1 if opacity is dynamic, or -1 if the block is conditionally full opaque, else return opacity in [0, 15]
         public final int getOpacityIfCached() {
             return this.opacityIfCached;
         }
 
         protected final boolean conditionallyFullOpaque;
+
         public final boolean isConditionallyFullOpaque() {
             return this.conditionallyFullOpaque;
         }
+
         // Paper end
         // Paper start
         private long blockCollisionBehavior = io.papermc.paper.util.CollisionUtil.KNOWN_SPECIAL_BLOCK;
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java b/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
index e6240f891e396d91e31b02fdf3084be77e9d6697..a25908423b187aaeca19300b677bd3283e5c4063 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
@@ -30,6 +30,7 @@ import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemp
 public class ChunkStatus {
 
     public static final int MAX_STRUCTURE_DISTANCE = 8;
+    public static final int CHUNK_STATUS_TASK_MARGIN = 8; // Vanilla is 8 // Martijn - custom strongholds - bigger strongholds
     private static final EnumSet<Heightmap.Types> PRE_FEATURES = EnumSet.of(Heightmap.Types.OCEAN_FLOOR_WG, Heightmap.Types.WORLD_SURFACE_WG);
     public static final EnumSet<Heightmap.Types> POST_FEATURES = EnumSet.of(Heightmap.Types.OCEAN_FLOOR, Heightmap.Types.WORLD_SURFACE, Heightmap.Types.MOTION_BLOCKING, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES);
     private static final ChunkStatus.LoadingTask PASSTHROUGH_LOAD_TASK = (chunkstatus, worldserver, structuretemplatemanager, lightenginethreaded, function, ichunkaccess) -> {
@@ -74,12 +75,12 @@ public class ChunkStatus {
 
         return CompletableFuture.completedFuture(Either.left(ichunkaccess));
     });
-    public static final ChunkStatus STRUCTURE_REFERENCES = ChunkStatus.registerSimple("structure_references", ChunkStatus.STRUCTURE_STARTS, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+    public static final ChunkStatus STRUCTURE_REFERENCES = ChunkStatus.registerSimple("structure_references", ChunkStatus.STRUCTURE_STARTS, CHUNK_STATUS_TASK_MARGIN, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> { // Martijn - custom strongholds - bigger strongholds
         WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, -1);
 
         chunkgenerator.createReferences(regionlimitedworldaccess, worldserver.structureManager().forWorldGenRegion(regionlimitedworldaccess), ichunkaccess);
     });
-    public static final ChunkStatus BIOMES = ChunkStatus.register("biomes", ChunkStatus.STRUCTURE_REFERENCES, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess, flag) -> {
+    public static final ChunkStatus BIOMES = ChunkStatus.register("biomes", ChunkStatus.STRUCTURE_REFERENCES, CHUNK_STATUS_TASK_MARGIN, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess, flag) -> { // Martijn - custom strongholds - bigger strongholds
         if (!flag && ichunkaccess.getStatus().isOrAfter(chunkstatus)) {
             return CompletableFuture.completedFuture(Either.left(ichunkaccess));
         } else {
@@ -94,7 +95,7 @@ public class ChunkStatus {
             });
         }
     });
-    public static final ChunkStatus NOISE = ChunkStatus.register("noise", ChunkStatus.BIOMES, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess, flag) -> {
+    public static final ChunkStatus NOISE = ChunkStatus.register("noise", ChunkStatus.BIOMES, CHUNK_STATUS_TASK_MARGIN, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess, flag) -> { // Martijn - custom strongholds - bigger strongholds
         if (!flag && ichunkaccess.getStatus().isOrAfter(chunkstatus)) {
             return CompletableFuture.completedFuture(Either.left(ichunkaccess));
         } else {
@@ -119,12 +120,12 @@ public class ChunkStatus {
             });
         }
     });
-    public static final ChunkStatus SURFACE = ChunkStatus.registerSimple("surface", ChunkStatus.NOISE, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+    public static final ChunkStatus SURFACE = ChunkStatus.registerSimple("surface", ChunkStatus.NOISE, CHUNK_STATUS_TASK_MARGIN, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> { // Martijn - custom strongholds - bigger strongholds
         WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, 0);
 
         chunkgenerator.buildSurface(regionlimitedworldaccess, worldserver.structureManager().forWorldGenRegion(regionlimitedworldaccess), worldserver.getChunkSource().randomState(), ichunkaccess);
     });
-    public static final ChunkStatus CARVERS = ChunkStatus.registerSimple("carvers", ChunkStatus.SURFACE, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+    public static final ChunkStatus CARVERS = ChunkStatus.registerSimple("carvers", ChunkStatus.SURFACE, CHUNK_STATUS_TASK_MARGIN, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> { // Martijn - custom strongholds - bigger strongholds
         WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, 0);
 
         if (ichunkaccess instanceof ProtoChunk) {
@@ -135,15 +136,15 @@ public class ChunkStatus {
 
         chunkgenerator.applyCarvers(regionlimitedworldaccess, worldserver.getSeed(), worldserver.getChunkSource().randomState(), worldserver.getBiomeManager(), worldserver.structureManager().forWorldGenRegion(regionlimitedworldaccess), ichunkaccess, GenerationStep.Carving.AIR);
     });
-    public static final ChunkStatus LIQUID_CARVERS = ChunkStatus.registerSimple("liquid_carvers", ChunkStatus.CARVERS, 8, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+    public static final ChunkStatus LIQUID_CARVERS = ChunkStatus.registerSimple("liquid_carvers", ChunkStatus.CARVERS, CHUNK_STATUS_TASK_MARGIN, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> { // Martijn - custom strongholds - bigger strongholds
     });
-    public static final ChunkStatus FEATURES = ChunkStatus.register("features", ChunkStatus.LIQUID_CARVERS, 8, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess, flag) -> {
+    public static final ChunkStatus FEATURES = ChunkStatus.register("features", ChunkStatus.LIQUID_CARVERS, CHUNK_STATUS_TASK_MARGIN, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess, flag) -> { // Martijn start - custom strongholds - bigger strongholds
         ProtoChunk protochunk = (ProtoChunk) ichunkaccess;
 
         protochunk.setLightEngine(lightenginethreaded);
         if (flag || !ichunkaccess.getStatus().isOrAfter(chunkstatus)) {
             Heightmap.primeHeightmaps(ichunkaccess, EnumSet.of(Heightmap.Types.MOTION_BLOCKING, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES, Heightmap.Types.OCEAN_FLOOR, Heightmap.Types.WORLD_SURFACE));
-            WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, 1);
+            WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, 1); // Default placementRadius is 1 // Martijn - custom strongholds - bigger strongholds
 
             chunkgenerator.applyBiomeDecoration(regionlimitedworldaccess, ichunkaccess, worldserver.structureManager().forWorldGenRegion(regionlimitedworldaccess));
             Blender.generateBorderTicks(regionlimitedworldaccess, ichunkaccess);
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/StructurePiece.java b/src/main/java/net/minecraft/world/level/levelgen/structure/StructurePiece.java
index eb0ad03943c9afb22907f984cbc923453c820d40..5a01e7b0004aba3fb56a63a28afa25829780ce45 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/StructurePiece.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/StructurePiece.java
@@ -3,15 +3,20 @@ package net.minecraft.world.level.levelgen.structure;
 import com.google.common.collect.ImmutableSet;
 import com.mojang.logging.LogUtils;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
+import java.util.function.Predicate;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.configuration.GlobalConfiguration;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Registry;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtOps;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.tags.BlockTags;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.ChunkPos;
@@ -29,6 +34,10 @@ import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.entity.ChestBlockEntity;
 import net.minecraft.world.level.block.entity.DispenserBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import net.minecraft.world.level.block.state.properties.Half;
+import net.minecraft.world.level.block.state.properties.SlabType;
+import net.minecraft.world.level.block.state.properties.StairsShape;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.levelgen.Heightmap;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePieceSerializationContext;
@@ -36,7 +45,9 @@ import net.minecraft.world.level.levelgen.structure.pieces.StructurePieceType;
 import net.minecraft.world.level.material.FluidState;
 import nl.martijnmuijsers.paper.structure.CraftWorldStructure;
 import nl.martijnmuijsers.paper.structure.CraftWorldStructurePiece;
-import org.bukkit.craftbukkit.CraftWorld;
+import org.apache.commons.lang3.tuple.ImmutableTriple;
+import org.apache.commons.lang3.tuple.Triple;
+import org.apache.logging.log4j.util.TriConsumer;
 import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 
@@ -50,7 +61,7 @@ public abstract class StructurePiece {
     private Rotation rotation;
     protected int genDepth;
     private final StructurePieceType type;
-    private static final Set<Block> SHAPE_CHECK_BLOCKS = ImmutableSet.<Block>builder().add(Blocks.NETHER_BRICK_FENCE).add(Blocks.TORCH).add(Blocks.WALL_TORCH).add(Blocks.OAK_FENCE).add(Blocks.SPRUCE_FENCE).add(Blocks.DARK_OAK_FENCE).add(Blocks.ACACIA_FENCE).add(Blocks.BIRCH_FENCE).add(Blocks.JUNGLE_FENCE).add(Blocks.LADDER).add(Blocks.IRON_BARS).build();
+    public static final Set<Block> SHAPE_CHECK_BLOCKS = ImmutableSet.<Block>builder().add(Blocks.NETHER_BRICK_FENCE).add(Blocks.TORCH).add(Blocks.WALL_TORCH).add(Blocks.OAK_FENCE).add(Blocks.SPRUCE_FENCE).add(Blocks.DARK_OAK_FENCE).add(Blocks.ACACIA_FENCE).add(Blocks.BIRCH_FENCE).add(Blocks.JUNGLE_FENCE).add(Blocks.LADDER).add(Blocks.IRON_BARS).build(); // Martijn - custom strongholds - surface strongholds
 
     // Martijn start - structure API
 
@@ -175,31 +186,300 @@ public abstract class StructurePiece {
         }
     }
 
+    // Martijn start - custom strongholds - conditional placements
+
+    public static final Direction[] besideOrAboveDirections = { Direction.EAST, Direction.WEST, Direction.NORTH, Direction.SOUTH, Direction.UP };
+
+    public static final Direction[] besideDirections = { Direction.EAST, Direction.WEST, Direction.NORTH, Direction.SOUTH };
+
+    public static boolean countsAsSolid(BlockGetter world, BlockPos pos, Direction inDirection) {
+        return countsAsSolid(world, pos, world.getBlockState(pos), inDirection);
+    }
+
+    public static boolean countsAsSolid(BlockGetter world, BlockPos pos, BlockState block, Direction inDirection) {
+        return !block.isAir() && !block.getMaterial().isLiquid() && block.isFaceSturdy(world, pos, inDirection);
+    }
+
+    public static boolean hasRelativeSolid(BlockGetter world, BlockPos pos, Direction direction) {
+        return countsAsSolid(world, pos.relative(direction), direction.getOpposite());
+    }
+
+    public static boolean hasAnyRelativeSolid(BlockGetter world, BlockPos pos, Direction[] directions) {
+        for (Direction direction : directions) {
+            if (hasRelativeSolid(world, pos, direction)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public static boolean anyHasRelativeSolid(BlockGetter world, BlockPos[] poss, Direction direction) {
+        for (BlockPos pos : poss) {
+            if (hasRelativeSolid(world, pos, direction)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public static boolean anyHasAnyRelativeSolid(BlockGetter world, BlockPos[] poss, Direction[] directions) {
+        for (BlockPos pos : poss) {
+            if (hasAnyRelativeSolid(world, pos, directions)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public static boolean canBeFilledUpByWaterSourceIfWaterFlowsIn(BlockState state) {
+        return state.isAir() || state.is(BlockTags.BUTTONS) || state.is(Blocks.TORCH) || state.is(Blocks.WALL_TORCH) || state.is(Blocks.LEVER) || state.is(Blocks.COBWEB);
+    }
+
+    public static @Nullable BlockState getRelativeLiquidDefaultBlockState(BlockGetter world, BlockPos pos, Direction direction) {
+        BlockState block = world.getBlockState(pos);
+        Optional<Boolean> blockWaterlogged = block.getOptionalValue(BlockStateProperties.WATERLOGGED);
+        if (!(block.getMaterial().isLiquid() || (blockWaterlogged.isPresent() && blockWaterlogged.get()))) {
+            BlockState relativeBlock = world.getBlockState(pos.relative(direction));
+            Optional<Boolean> relativeBlockWaterlogged = relativeBlock.getOptionalValue(BlockStateProperties.WATERLOGGED);
+            if (relativeBlock.getMaterial().isLiquid() || (relativeBlockWaterlogged.isPresent() && relativeBlockWaterlogged.get())) {
+                if (canBeFilledUpByWaterSourceIfWaterFlowsIn(block)) {
+                    return Blocks.WATER.defaultBlockState();
+                } else if (blockWaterlogged.isPresent()) {
+                    return block.getBlock().withPropertiesOf(block).setValue(BlockStateProperties.WATERLOGGED, true);
+                }
+            }
+        }
+        return null;
+    }
+
+    public static @Nullable BlockState getAnyRelativeLiquidDefaultBlockState(BlockGetter world, BlockPos pos, Direction[] directions) {
+        for (Direction direction : directions) {
+            @Nullable BlockState forDirection = getRelativeLiquidDefaultBlockState(world, pos, direction);
+            if (forDirection != null) {
+                return forDirection;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @param cantReplaceAir If true, the block will not be placed if the existing block is air.
+     * @param cantReplaceLiquid If true, the block will not be placed if the existing block is liquid.
+     * @param requireSolidBelow If true, the block will not be placed if the existing block below is air or liquid.
+     * @param requireSolidBelowOrBeside If true, the block will not be placed if among the existing blocks either below or horizontally besides this block, none are something other than air or liquid.
+     * @param requireSolidAdjacent If true, the block will not be placed if among the existing blocks adjacent to this block in any of the 6 orthogonal directions, none are something other than air or liquid.
+     */
+    protected boolean placeBlockConditionally(WorldGenLevel world, BlockState block, int x, int y, int z, BoundingBox box, boolean cantReplaceAir, boolean cantReplaceLiquid, boolean requireSolidBelow, boolean requireSolidBelowOrBeside, boolean requireSolidAdjacent) {
+
+        BlockPos pos = this.getWorldPos(x, y, z);
+
+        // If the block is air, we can always replace other air
+        if (block.isAir()) {
+            cantReplaceAir = false;
+        }
+
+        // If the block is air or liquid, it does not need any support
+        if (block.isAir() || block.getMaterial().isLiquid()) {
+            requireSolidBelow = false;
+            requireSolidBelowOrBeside = false;
+            requireSolidAdjacent = false;
+        }
+
+        // If we are trying to place air, but there is liquid above or beside, place that liquid type instead
+        if (block.isAir()) {
+            BlockState adjacentLiquidDefaultState = getAnyRelativeLiquidDefaultBlockState(world, pos, besideOrAboveDirections);
+            if (adjacentLiquidDefaultState != null) {
+                block = adjacentLiquidDefaultState;
+            }
+        }
+
+        // If we are trying to place a waterloggable block, and there is water above or beside, place the waterlogged version instead
+        Optional<Boolean> waterlogged = block.getOptionalValue(BlockStateProperties.WATERLOGGED);
+        if (waterlogged.isPresent() && !waterlogged.get()) {
+            BlockState blockAbove = world.getBlockState(pos.above());
+            Optional<Boolean> blockAboveWaterlogged = blockAbove.getOptionalValue(BlockStateProperties.WATERLOGGED);
+            if ((blockAboveWaterlogged.isPresent() && blockAboveWaterlogged.get()) || blockAbove.is(Blocks.WATER)) {
+                block = block.getBlock().withPropertiesOf(block).setValue(BlockStateProperties.WATERLOGGED, true);
+            }
+        }
+
+        // Check for illegal replacement of air
+        if (cantReplaceAir) {
+            if (world.getBlockState(pos).isAir()) {
+                return false;
+            }
+        }
+
+        // Check for illegal replacement of water
+        if (cantReplaceLiquid) {
+            if (world.getBlockState(pos).getMaterial().isLiquid()) {
+                return false;
+            }
+        }
+
+        // Check for missing support from surroundings
+        if (requireSolidBelow || requireSolidBelowOrBeside || requireSolidAdjacent) {
+            if (!hasRelativeSolid(world, pos, Direction.DOWN)) {
+                if (requireSolidBelow) {
+                    return false;
+                }
+                if (!hasAnyRelativeSolid(world, pos, besideDirections)) {
+                    if (requireSolidBelowOrBeside) {
+                        return false;
+                    }
+                    if (!hasRelativeSolid(world, pos, Direction.UP)) {
+                        return false;
+                    }
+                }
+            }
+        }
+
+        // We can place the block
+        return this.placeBlockUnconditionally(world, block, x, y, z, box);
+
+    }
+
+    /**
+     * The same as {@link StructurePiece#placeBlockConditionally(WorldGenLevel, BlockState, int, int, int, BoundingBox, boolean, boolean, boolean, boolean, boolean)},
+     * but requires no adjacent solid blocks.
+     */
+    protected boolean placeBlockConditionally(WorldGenLevel world, BlockState block, int x, int y, int z, BoundingBox box, boolean cantReplaceAir, boolean cantReplaceLiquid) {
+        return this.placeBlockConditionally(world, block, x, y, z, box, cantReplaceAir, cantReplaceLiquid, false, false, false);
+    }
+
+    protected boolean generateBoxConditionally(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceAir, boolean cantReplaceLiquid, boolean requireSolidBelow, boolean requireSolidBelowOrBeside, boolean requireSolidAdjacent, RandomSource random, StructurePiece.BlockSelector randomizer) {
+
+        // Try placing blocks in the box repeatedly
+        boolean changesAtAll = false;
+        int maxCycles = 100;
+        while (maxCycles-->0) {
+            boolean changesThisCycle = false;
+            for (int i = minY; i <= maxY; ++i) {
+                for (int j = minX; j <= maxX; ++j) {
+                    for (int k = minZ; k <= maxZ; ++k) {
+                        if ((!cantReplaceAir || !this.getBlock(world, j, i, k, box).isAir()) && (!cantReplaceLiquid || !this.getBlock(world, j, i, k, box).getMaterial().isLiquid())) {
+                            randomizer.next(random, j, i, k, i == minY || i == maxY || j == minX || j == maxX || k == minZ || k == maxZ);
+                            changesThisCycle |= this.placeBlockConditionally(world, randomizer.getNext(), j, i, k, box, cantReplaceAir, cantReplaceLiquid, requireSolidBelow, requireSolidBelowOrBeside, requireSolidAdjacent);
+                        }
+                    }
+                }
+            }
+            changesAtAll |= changesThisCycle;
+            if (!changesThisCycle) {
+                break;
+            }
+        }
+        return changesAtAll;
+    }
+
+    /**
+     * @param cantReplaceAir If true, some block will not be placed if the existing block is air.
+     * @param cantReplaceLiquid If true, some block will not be placed if the existing block is liquid.
+     * @param requireSolidBelow If true, the box as a whole will not be generated if there is no existing block below any block in this box that is air or liquid.
+     * @param requireSolidBelowOrBeside If true, the box as a whole will not be generated if among the existing blocks either below or horizontally besides any block in this box, none are something other than air or liquid.
+     * @param requireSolidAdjacent If true, the box is a whole will not be generated if among the existing blocks adjacent to any block in this box in any of the 6 orthogonal directions, none are something other than air or liquid.
+     */
+    protected boolean generateBoxConditionally(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState outline, BlockState inside, boolean cantReplaceAir, boolean cantReplaceLiquid, boolean requireSolidBelow, boolean requireSolidBelowOrBeside, boolean requireSolidAdjacent) {
+
+        // Try placing blocks in the box repeatedly
+        boolean changesAtAll = false;
+        int maxCycles = 100;
+        while (maxCycles-->0) {
+            boolean changesThisCycle = false;
+            for (int i = minY; i <= maxY; ++i) {
+                for (int j = minX; j <= maxX; ++j) {
+                    for (int k = minZ; k <= maxZ; ++k) {
+                        if ((!cantReplaceAir || !this.getBlock(world, j, i, k, box).isAir()) && (!cantReplaceLiquid || !this.getBlock(world, j, i, k, box).getMaterial().isLiquid())) {
+                            if (i != minY && i != maxY && j != minX && j != maxX && k != minZ && k != maxZ) {
+                                changesThisCycle |= this.placeBlockConditionally(world, inside, j, i, k, box, cantReplaceAir, cantReplaceLiquid, requireSolidBelow, requireSolidBelowOrBeside, requireSolidAdjacent); // Martijn - custom strongholds - surface strongholds
+                            } else {
+                                changesThisCycle |= this.placeBlockConditionally(world, outline, j, i, k, box, cantReplaceAir, cantReplaceLiquid, requireSolidBelow, requireSolidBelowOrBeside, requireSolidAdjacent); // Martijn - custom strongholds - surface strongholds
+                            }
+                        }
+                    }
+                }
+            }
+            changesAtAll |= changesThisCycle;
+            if (!changesThisCycle) {
+                break;
+            }
+        }
+        return changesAtAll;
+//
+//        // Check for missing support from surroundings
+//        if (requireSolidBelow || requireSolidBelowOrBeside || requireSolidAdjacent) {
+//            BlockPos[] poss = new BlockPos[(maxY - minY + 1) * (maxX - minX + 1) * (maxZ - minZ + 1)];
+//            int possIndex = 0;
+//            for(int i = minY; i <= maxY; ++i) {
+//                for (int j = minX; j <= maxX; ++j) {
+//                    for (int k = minZ; k <= maxZ; ++k) {
+//                        poss[possIndex] = this.getWorldPos(j, i, k);
+//                        possIndex++;
+//                    }
+//                }
+//            }
+//            if (!anyHasRelativeSolid(world, poss, Direction.DOWN)) {
+//                if (requireSolidBelow) {
+//                    return;
+//                }
+//                if (!anyHasAnyRelativeSolid(world, poss, besideDirections)) {
+//                    if (requireSolidBelowOrBeside) {
+//                        return;
+//                    }
+//                    if (!anyHasRelativeSolid(world, poss, Direction.UP)) {
+//                        return;
+//                    }
+//                }
+//            }
+//        }
+//
+//        // We can generate the box
+//        this.generateBox(world, box, minX, minY, minZ, maxX, maxY, maxZ, outline, inside, cantReplaceAir, cantReplaceLiquid);
+
+    }
+
     protected void placeBlock(WorldGenLevel world, BlockState block, int x, int y, int z, BoundingBox box) {
+        this.placeBlockUnconditionally(world, block, x, y, z, box);
+    }
+    // Martijn start - custom strongholds - surface strongholds
+    protected boolean placeBlockUnconditionally(WorldGenLevel world, BlockState block, int x, int y, int z, BoundingBox box) {
         BlockPos blockPos = this.getWorldPos(x, y, z);
         if (box.isInside(blockPos)) {
             if (this.canBeReplaced(world, x, y, z, box)) {
-                if (this.mirror != Mirror.NONE) {
-                    block = block.mirror(this.mirror);
-                }
+                return this.placeBlockUnconditionallyWorldCoordinates(world, block, blockPos, box);
+            }
+        }
+        return false;
+    }
+    protected boolean placeBlockUnconditionallyWorldCoordinates(WorldGenLevel world, BlockState block, BlockPos blockPos, BoundingBox box) {
+        // Martijn end - custom strongholds - conditional placements
+        if (box.isInside(blockPos)) {
+            if (this.mirror != Mirror.NONE) {
+                block = block.mirror(this.mirror);
+            }
 
-                if (this.rotation != Rotation.NONE) {
-                    block = block.rotate(this.rotation);
-                }
+            if (this.rotation != Rotation.NONE) {
+                block = block.rotate(this.rotation);
+            }
 
-                world.setBlock(blockPos, block, 2);
-                FluidState fluidState = world.getFluidState(blockPos);
-                if (!fluidState.isEmpty()) {
-                    world.scheduleTick(blockPos, fluidState.getType(), 0);
-                }
+            if (world.getBlockState(blockPos).equals(block)) {
+                return false;
+            }
 
-                if (SHAPE_CHECK_BLOCKS.contains(block.getBlock())) {
-                    world.getChunk(blockPos).markPosForPostprocessing(blockPos);
-                }
+            world.setBlock(blockPos, block, 2);
+            FluidState fluidState = world.getFluidState(blockPos);
+            if (!fluidState.isEmpty()) {
+                world.scheduleTick(blockPos, fluidState.getType(), 0);
+            }
 
+            if (SHAPE_CHECK_BLOCKS.contains(block.getBlock())) {
+                world.getChunk(blockPos).markPosForPostprocessing(blockPos);
             }
+            return true;
         }
+        return false;
     }
+    // Martijn end - custom strongholds - surface strongholds
 
     protected boolean canBeReplaced(LevelReader world, int x, int y, int z, BoundingBox box) {
         return true;
@@ -219,6 +499,22 @@ public abstract class StructurePiece {
         }
     }
 
+    // Martijn start - custom strongholds - surface strongholds
+
+    protected void generateAirBox(WorldGenLevel world, BoundingBox bounds, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceLiquid) {
+        for(int i = minY; i <= maxY; ++i) {
+            for(int j = minX; j <= maxX; ++j) {
+                for(int k = minZ; k <= maxZ; ++k) {
+                    if (!cantReplaceLiquid || !this.getBlock(world, j, i, k, bounds).getMaterial().isLiquid()) {
+                        this.placeBlock(world, Blocks.AIR.defaultBlockState(), j, i, k, bounds);
+                    }
+                }
+            }
+        }
+    }
+
+    // Martijn end - custom strongholds - surface strongholds
+
     protected void generateAirBox(WorldGenLevel world, BoundingBox bounds, int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {
         for(int i = minY; i <= maxY; ++i) {
             for(int j = minX; j <= maxX; ++j) {
@@ -230,15 +526,35 @@ public abstract class StructurePiece {
 
     }
 
+    // Martijn start - custom strongholds - surface strongholds
+
+    protected void generateBox(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState outline, BlockState inside, boolean cantReplaceAir, boolean cantReplaceLiquid) {
+        for(int i = minY; i <= maxY; ++i) {
+            for(int j = minX; j <= maxX; ++j) {
+                for(int k = minZ; k <= maxZ; ++k) {
+                    if ((!cantReplaceAir || !this.getBlock(world, j, i, k, box).isAir()) && (!cantReplaceLiquid || !this.getBlock(world, j, i, k, box).getMaterial().isLiquid())) {
+                        if (i != minY && i != maxY && j != minX && j != maxX && k != minZ && k != maxZ) {
+                            this.placeBlockUnconditionally(world, inside, j, i, k, box); // Martijn - custom strongholds - surface strongholds
+                        } else {
+                            this.placeBlockUnconditionally(world, outline, j, i, k, box); // Martijn - custom strongholds - surface strongholds
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    // Martijn end - custom strongholds - surface strongholds
+
     protected void generateBox(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState outline, BlockState inside, boolean cantReplaceAir) {
         for(int i = minY; i <= maxY; ++i) {
             for(int j = minX; j <= maxX; ++j) {
                 for(int k = minZ; k <= maxZ; ++k) {
                     if (!cantReplaceAir || !this.getBlock(world, j, i, k, box).isAir()) {
                         if (i != minY && i != maxY && j != minX && j != maxX && k != minZ && k != maxZ) {
-                            this.placeBlock(world, inside, j, i, k, box);
+                            this.placeBlockUnconditionally(world, inside, j, i, k, box); // Martijn - custom strongholds - surface strongholds
                         } else {
-                            this.placeBlock(world, outline, j, i, k, box);
+                            this.placeBlockUnconditionally(world, outline, j, i, k, box); // Martijn - custom strongholds - surface strongholds
                         }
                     }
                 }
@@ -247,10 +563,35 @@ public abstract class StructurePiece {
 
     }
 
+    // Martijn start - custom strongholds - surface strongholds
+
+    protected void generateBox(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, BlockState outline, BlockState inside, boolean cantReplaceAir, boolean cantReplaceLiquid) {
+        this.generateBox(world, box, fillBox.minX(), fillBox.minY(), fillBox.minZ(), fillBox.maxX(), fillBox.maxY(), fillBox.maxZ(), outline, inside, cantReplaceAir, cantReplaceLiquid);
+    }
+
+    // Martijn end - custom strongholds - surface strongholds
+
     protected void generateBox(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, BlockState outline, BlockState inside, boolean cantReplaceAir) {
         this.generateBox(world, box, fillBox.minX(), fillBox.minY(), fillBox.minZ(), fillBox.maxX(), fillBox.maxY(), fillBox.maxZ(), outline, inside, cantReplaceAir);
     }
 
+    // Martijn start - custom strongholds - surface strongholds
+
+    protected void generateBox(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceAir, boolean cantReplaceLiquid, RandomSource random, StructurePiece.BlockSelector randomizer) {
+        for(int i = minY; i <= maxY; ++i) {
+            for(int j = minX; j <= maxX; ++j) {
+                for(int k = minZ; k <= maxZ; ++k) {
+                    if ((!cantReplaceAir || !this.getBlock(world, j, i, k, box).isAir()) && (!cantReplaceLiquid || !this.getBlock(world, j, i, k, box).getMaterial().isLiquid())) {
+                        randomizer.next(random, j, i, k, i == minY || i == maxY || j == minX || j == maxX || k == minZ || k == maxZ);
+                        this.placeBlock(world, randomizer.getNext(), j, i, k, box);
+                    }
+                }
+            }
+        }
+    }
+
+    // Martijn end - custom strongholds - surface strongholds
+
     protected void generateBox(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer) {
         for(int i = minY; i <= maxY; ++i) {
             for(int j = minX; j <= maxX; ++j) {
@@ -265,10 +606,104 @@ public abstract class StructurePiece {
 
     }
 
+    // Martijn start - custom strongholds - surface strongholds
+
+    protected void generateBox(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, boolean cantReplaceAir, boolean cantReplaceLiquid, RandomSource random, StructurePiece.BlockSelector randomizer) {
+        this.generateBox(world, box, fillBox.minX(), fillBox.minY(), fillBox.minZ(), fillBox.maxX(), fillBox.maxY(), fillBox.maxZ(), cantReplaceAir, cantReplaceLiquid, random, randomizer);
+    }
+
+    // Martijn end - custom strongholds - surface strongholds
+
     protected void generateBox(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer) {
         this.generateBox(world, box, fillBox.minX(), fillBox.minY(), fillBox.minZ(), fillBox.maxX(), fillBox.maxY(), fillBox.maxZ(), cantReplaceAir, random, randomizer);
     }
 
+    // Martijn start - custom strongholds - surface strongholds
+
+    // Martijn start - custom strongholds - holes in stronghold parts
+
+    protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceAir, boolean cantReplaceLiquid, RandomSource random, StructurePiece.BlockSelector randomizer, BlockState newAir) {
+        for(int i = minY; i <= maxY; ++i) {
+            for(int j = minX; j <= maxX; ++j) {
+                for(int k = minZ; k <= maxZ; ++k) {
+                    if ((!cantReplaceAir || !this.getBlock(world, j, i, k, box).isAir()) && (!cantReplaceLiquid || !this.getBlock(world, j, i, k, box).getMaterial().isLiquid())) {
+                        randomizer.next(random, j, i, k, i == minY || i == maxY || j == minX || j == maxX || k == minZ || k == maxZ);
+                        BlockState newState = randomizer.getNext();
+                        // If the block is on the floor or ceiling, there is a chance we use a bottom or top slab or stairs
+                        if ((i == minY || i == maxY) && !(j == minX || j == maxX || k == minZ || k == maxZ) && newState.is(BlockTags.STONE_BRICKS)) {
+                            GlobalConfiguration.CustomStrongholds.SlabOrStairsSurfaces config = GlobalConfiguration.get().customStrongholds.slabOrStairsSurfaces;
+                            GlobalConfiguration.CustomStrongholds.SlabOrStairsSurfaces.FloorOrCeiling surfaceConfig = i == minY ? config.floor : config.ceiling;
+                            if (random.nextFloat() < surfaceConfig.chance) {
+                                if (random.nextFloat() < surfaceConfig.slabRatio) {
+                                    newState = Blocks.STONE_BRICK_SLAB.defaultBlockState().setValue(BlockStateProperties.SLAB_TYPE, i == minY ? SlabType.BOTTOM : SlabType.TOP);
+                                } else {
+                                    newState = Blocks.STONE_BRICK_STAIRS.defaultBlockState().setValue(BlockStateProperties.STAIRS_SHAPE, StairsShape.values()[random.nextInt(StairsShape.values().length)]).setValue(BlockStateProperties.HALF, i == minY ? Half.BOTTOM : Half.TOP);
+                                }
+                            }
+                        }
+                        // If the block on top is actually air, there is a chance we use air
+                        if (world.getBlockState(this.getWorldPos(j, i + 1, k)).isAir() && random.nextFloat() < GlobalConfiguration.get().customStrongholds.ceilingBlockHoleChance) {
+                            newState = newAir;
+                        }
+                        // If the block on top is actually water, there is a chance we use water
+                        if (world.getBlockState(this.getWorldPos(j, i + 1, k)).getMaterial().isLiquid() && random.nextFloat() < GlobalConfiguration.get().customStrongholds.ceilingBlockHoleChance) {
+                            newState = Blocks.WATER.defaultBlockState();
+                        }
+                        this.placeBlockUnconditionally(world, newState, j, i, k, box);
+                    }
+                }
+            }
+        }
+    }
+
+    protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer, BlockState newAir) {
+        generateBoxWithPartiallyOpenCeiling(world, box, minX, minY, minZ, maxX, maxY, maxZ, cantReplaceAir, false, random, randomizer, newAir);
+    }
+
+    protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, boolean cantReplaceAir, boolean cantReplaceLiquid, RandomSource random, StructurePiece.BlockSelector randomizer, BlockState newAir) {
+        this.generateBoxWithPartiallyOpenCeiling(world, box, fillBox.minX(), fillBox.minY(), fillBox.minZ(), fillBox.maxX(), fillBox.maxY(), fillBox.maxZ(), cantReplaceAir, cantReplaceLiquid, random, randomizer, newAir);
+    }
+
+    protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer, BlockState newAir) {
+        this.generateBoxWithPartiallyOpenCeiling(world, box, fillBox, cantReplaceAir, false, random, randomizer, newAir);
+    }
+
+    protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceAir, boolean cantReplaceLiquid, RandomSource random, StructurePiece.BlockSelector randomizer) {
+        this.generateBoxWithPartiallyOpenCeiling(world, box, minX, minY, minZ, maxX, maxY, maxZ, cantReplaceAir, cantReplaceLiquid, random, randomizer, Blocks.CAVE_AIR.defaultBlockState());
+    }
+
+    protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer) {
+        this.generateBoxWithPartiallyOpenCeiling(world, box, minX, minY, minZ, maxX, maxY, maxZ, cantReplaceAir, random, randomizer, Blocks.CAVE_AIR.defaultBlockState());
+    }
+
+    protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, boolean cantReplaceAir, boolean cantReplaceLiquid, RandomSource random, StructurePiece.BlockSelector randomizer) {
+        this.generateBoxWithPartiallyOpenCeiling(world, box, fillBox, cantReplaceAir, cantReplaceLiquid, random, randomizer, Blocks.CAVE_AIR.defaultBlockState());
+    }
+
+    protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer) {
+        this.generateBoxWithPartiallyOpenCeiling(world, box, fillBox, cantReplaceAir, random, randomizer, Blocks.CAVE_AIR.defaultBlockState());
+    }
+
+    // Martijn end - custom strongholds - holes in stronghold parts
+
+    protected void generateMaybeBox(WorldGenLevel world, BoundingBox box, RandomSource random, float blockChance, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState outline, BlockState inside, boolean cantReplaceAir, boolean cantReplaceLiquid, boolean stayBelowSeaLevel) {
+        for(int i = minY; i <= maxY; ++i) {
+            for(int j = minX; j <= maxX; ++j) {
+                for(int k = minZ; k <= maxZ; ++k) {
+                    if (!(random.nextFloat() > blockChance) && (!cantReplaceAir || !this.getBlock(world, j, i, k, box).isAir()) && (!cantReplaceLiquid || !this.getBlock(world, j, i, k, box).getMaterial().isLiquid()) && (!stayBelowSeaLevel || this.isInterior(world, j, i, k, box))) {
+                        if (i != minY && i != maxY && j != minX && j != maxX && k != minZ && k != maxZ) {
+                            this.placeBlock(world, inside, j, i, k, box);
+                        } else {
+                            this.placeBlock(world, outline, j, i, k, box);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    // Martijn end - custom strongholds - surface strongholds
+
     protected void generateMaybeBox(WorldGenLevel world, BoundingBox box, RandomSource random, float blockChance, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState outline, BlockState inside, boolean cantReplaceAir, boolean stayBelowSeaLevel) {
         for(int i = minY; i <= maxY; ++i) {
             for(int j = minX; j <= maxX; ++j) {
@@ -293,7 +728,9 @@ public abstract class StructurePiece {
 
     }
 
-    protected void generateUpperHalfSphere(WorldGenLevel world, BoundingBox bounds, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState block, boolean cantReplaceAir) {
+    // Martijn start - custom strongholds - surface strongholds
+
+    protected void generateUpperHalfSphere(WorldGenLevel world, BoundingBox bounds, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState block, boolean cantReplaceAir, boolean cantReplaceLiquid) {
         float f = (float)(maxX - minX + 1);
         float g = (float)(maxY - minY + 1);
         float h = (float)(maxZ - minZ + 1);
@@ -308,7 +745,7 @@ public abstract class StructurePiece {
 
                 for(int o = minZ; o <= maxZ; ++o) {
                     float p = ((float)o - j) / (h * 0.5F);
-                    if (!cantReplaceAir || !this.getBlock(world, m, k, o, bounds).isAir()) {
+                    if ((!cantReplaceAir || !this.getBlock(world, m, k, o, bounds).isAir()) && (!cantReplaceLiquid || !this.getBlock(world, m, k, o, bounds).getMaterial().isLiquid())) {
                         float q = n * n + l * l + p * p;
                         if (q <= 1.05F) {
                             this.placeBlock(world, block, m, k, o, bounds);
@@ -320,6 +757,12 @@ public abstract class StructurePiece {
 
     }
 
+    protected void generateUpperHalfSphere(WorldGenLevel world, BoundingBox bounds, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState block, boolean cantReplaceAir) {
+        generateUpperHalfSphere(world, bounds, minX, minY, minZ, maxX, maxY, maxZ, block, cantReplaceAir, false);
+    }
+
+    // Martijn end - custom strongholds - surface strongholds
+
     protected void fillColumnDown(WorldGenLevel world, BlockState state, int x, int y, int z, BoundingBox box) {
         BlockPos.MutableBlockPos mutableBlockPos = this.getWorldPos(x, y, z);
         if (box.isInside(mutableBlockPos)) {
@@ -339,6 +782,14 @@ public abstract class StructurePiece {
         return this.createChest(world, boundingBox, random, this.getWorldPos(x, y, z), lootTableId, (BlockState)null);
     }
 
+    // Martijn start - custom strongholds - surface strongholds
+
+    protected boolean createChest(WorldGenLevel world, BoundingBox boundingBox, RandomSource random, int x, int y, int z, ResourceLocation lootTableId, boolean requireSolidBelow) {
+        return this.createChest(world, boundingBox, random, this.getWorldPos(x, y, z), lootTableId, (BlockState)null, requireSolidBelow);
+    }
+
+    // Martijn end - custom strongholds - surface strongholds
+
     public static BlockState reorient(BlockGetter world, BlockPos pos, BlockState state) {
         Direction direction = null;
 
@@ -384,7 +835,13 @@ public abstract class StructurePiece {
     }
 
     protected boolean createChest(ServerLevelAccessor world, BoundingBox boundingBox, RandomSource random, BlockPos pos, ResourceLocation lootTableId, @Nullable BlockState block) {
-        if (boundingBox.isInside(pos) && !world.getBlockState(pos).is(Blocks.CHEST)) {
+        // Martijn start - custom strongholds - surface strongholds
+        return this.createChest(world, boundingBox, random, pos, lootTableId, block, false);
+    }
+
+    protected boolean createChest(ServerLevelAccessor world, BoundingBox boundingBox, RandomSource random, BlockPos pos, ResourceLocation lootTableId, @Nullable BlockState block, boolean requireSolidBelow) {
+        if (boundingBox.isInside(pos) && !world.getBlockState(pos).is(Blocks.CHEST) && (!requireSolidBelow || hasRelativeSolid(world, pos, Direction.DOWN))) {
+            // Martijn end - custom strongholds - surface strongholds
             if (block == null) {
                 block = reorient(world, pos, Blocks.CHEST.defaultBlockState());
             }
@@ -420,6 +877,65 @@ public abstract class StructurePiece {
         this.boundingBox.move(x, y, z);
     }
 
+    // Martijn start - custom strongholds - surface strongholds
+
+    public void replace(WorldGenLevel world, BoundingBox boundingBox, Block oldBlock, BlockState newBlock) {
+        this.replace(world, boundingBox, oldBlock, newBlock, null);
+    }
+
+    public void replace(WorldGenLevel world, BoundingBox boundingBox, Block oldBlock, BlockState newBlock, @Nullable Predicate<Triple<Integer, Integer, Integer>> positionPredicate) {
+        this.replace(world, boundingBox, oldBlock, newBlock, null, 1, positionPredicate);
+    }
+
+    public void replace(WorldGenLevel world, BoundingBox boundingBox, Block oldBlock, BlockState newBlock, @Nullable RandomSource random, double chance) {
+        this.replace(world, boundingBox, oldBlock, newBlock, random, chance, null);
+    }
+
+    public void replace(WorldGenLevel world, BoundingBox boundingBox, Block oldBlock, BlockState newBlock, @Nullable RandomSource random, double chance, @Nullable Predicate<Triple<Integer, Integer, Integer>> positionPredicate) {
+        this.replace(world, boundingBox, oldBlock, newBlock, random, chance, false, false, false, positionPredicate);
+    }
+
+    public void replace(WorldGenLevel world, BoundingBox boundingBox, Block oldBlock, BlockState newBlock, @Nullable RandomSource random, double chance, boolean requireSolidBelow, boolean requireSolidBelowOrBeside, boolean requireSolidAdjacent) {
+        this.replace(world, boundingBox, oldBlock, newBlock, random, chance, requireSolidBelow, requireSolidBelowOrBeside, requireSolidAdjacent, null);
+    }
+
+    public void replace(WorldGenLevel world, BoundingBox boundingBox, Block oldBlock, BlockState newBlock, @Nullable RandomSource random, double chance, boolean requireSolidBelow, boolean requireSolidBelowOrBeside, boolean requireSolidAdjacent, @Nullable Predicate<Triple<Integer, Integer, Integer>> positionPredicate) {
+        for (int x = boundingBox.minX(); x <= boundingBox.maxX(); x++) {
+            for (int y = boundingBox.minY(); y <= boundingBox.maxY(); y++) {
+                for (int z = boundingBox.minZ(); z <= boundingBox.maxZ(); z++) {
+                    if (positionPredicate != null && !positionPredicate.test(new ImmutableTriple<>(x, y, z))) {
+                        continue;
+                    }
+                    BlockPos pos = new BlockPos(x, y, z);
+                    if (world.getBlockState(pos).is(oldBlock)) {
+                        if (random == null || (double) random.nextFloat() < chance) {
+                            boolean hasSupport = true;
+                            // Check for missing support from surroundings
+                            if (requireSolidBelow || requireSolidBelowOrBeside || requireSolidAdjacent) {
+                                if (!hasRelativeSolid(world, pos, Direction.DOWN)) {
+                                    if (requireSolidBelow) {
+                                        hasSupport = false;
+                                    } else if (!hasAnyRelativeSolid(world, pos, besideDirections)) {
+                                        if (requireSolidBelowOrBeside) {
+                                            hasSupport = false;
+                                        } else if (!hasRelativeSolid(world, pos, Direction.UP)) {
+                                            hasSupport = false;
+                                        }
+                                    }
+                                }
+                            }
+                            if (hasSupport) {
+                                this.placeBlockUnconditionallyWorldCoordinates(world, newBlock, pos, boundingBox);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    // Martijn end - custom strongholds - surface strongholds
+
     public static BoundingBox createBoundingBox(Stream<StructurePiece> pieces) {
         return BoundingBox.encapsulatingBoxes(pieces.map(StructurePiece::getBoundingBox)::iterator).orElseThrow(() -> {
             return new IllegalStateException("Unable to calculate boundingbox without pieces");
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/structures/StrongholdPieces.java b/src/main/java/net/minecraft/world/level/levelgen/structure/structures/StrongholdPieces.java
index 0a17765680e28961ac7bf5cb04cf52d8dba86eb0..e083196321f8ecd792951021a47cc2368d5b124b 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/structures/StrongholdPieces.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/structures/StrongholdPieces.java
@@ -1,18 +1,27 @@
 package net.minecraft.world.level.levelgen.structure.structures;
 
 import com.google.common.collect.Lists;
+
+import java.util.ArrayList;
 import java.util.List;
-import javax.annotation.Nullable;
+import java.util.Optional;
+
+import io.papermc.paper.configuration.GlobalConfiguration;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.nbt.CompoundTag;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.tags.BlockTags;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.ServerLevelAccessor;
 import net.minecraft.world.level.StructureManager;
 import net.minecraft.world.level.WorldGenLevel;
+import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.ButtonBlock;
+import net.minecraft.world.level.block.CandleBlock;
 import net.minecraft.world.level.block.DoorBlock;
 import net.minecraft.world.level.block.EndPortalFrameBlock;
 import net.minecraft.world.level.block.FenceBlock;
@@ -24,6 +33,7 @@ import net.minecraft.world.level.block.WallTorchBlock;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.entity.SpawnerBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.block.state.properties.DoubleBlockHalf;
 import net.minecraft.world.level.block.state.properties.SlabType;
 import net.minecraft.world.level.chunk.ChunkGenerator;
@@ -32,30 +42,58 @@ import net.minecraft.world.level.levelgen.structure.StructurePiece;
 import net.minecraft.world.level.levelgen.structure.StructurePieceAccessor;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePieceSerializationContext;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePieceType;
+import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.level.storage.loot.BuiltInLootTables;
+import org.bukkit.Bukkit;
+import org.bukkit.Tag;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
 public class StrongholdPieces {
     private static final int SMALL_DOOR_WIDTH = 3;
     private static final int SMALL_DOOR_HEIGHT = 3;
-    private static final int MAX_DEPTH = 50;
+    // Martijn - custom strongholds - strongholds can reach lower
+    private static final int MAX_DEPTH = 60;
+    private static final int MAX_DEPTH_SURFACE = 100;
+    // Martijn - custom strongholds - strongholds can reach lower
     private static final int LOWEST_Y_POSITION = 10;
     private static final boolean CHECK_AIR = true;
     public static final int MAGIC_START_Y = 64;
-    private static final StrongholdPieces.PieceWeight[] STRONGHOLD_PIECE_WEIGHTS = new StrongholdPieces.PieceWeight[]{new StrongholdPieces.PieceWeight(StrongholdPieces.Straight.class, 40, 0), new StrongholdPieces.PieceWeight(StrongholdPieces.PrisonHall.class, 5, 5), new StrongholdPieces.PieceWeight(StrongholdPieces.LeftTurn.class, 20, 0), new StrongholdPieces.PieceWeight(StrongholdPieces.RightTurn.class, 20, 0), new StrongholdPieces.PieceWeight(StrongholdPieces.RoomCrossing.class, 10, 6), new StrongholdPieces.PieceWeight(StrongholdPieces.StraightStairsDown.class, 5, 5), new StrongholdPieces.PieceWeight(StrongholdPieces.StairsDown.class, 5, 5), new StrongholdPieces.PieceWeight(StrongholdPieces.FiveCrossing.class, 5, 4), new StrongholdPieces.PieceWeight(StrongholdPieces.ChestCorridor.class, 5, 4), new StrongholdPieces.PieceWeight(StrongholdPieces.Library.class, 10, 2) {
+    // Martijn start - custom strongholds - bigger strongholds
+    public static final int MAX_CHAIN_LENGTH = 50; // Default is 50
+    public static final int MAX_PLANAR_DISTANCE = 112; // Default is 112
+    public static final int MINIMUM_LIBRARY_CHAIN_LENGTH = 5; // Default is 4
+    public static final int MINIMUM_PORTAL_ROOM_CHAIN_LENGTH = 6; // Default is 5
+    public static final int MAX_LIBRARY_AMOUNT = 2; // Default is 2
+    // Martijn start - custom strongholds - surface strongholds
+    public static final int MAX_CHAIN_LENGTH_SURFACE = 115;
+    public static final int MAX_PLANAR_DISTANCE_SURFACE = 112;
+    public static final int MINIMUM_LIBRARY_CHAIN_LENGTH_SURFACE = 8;
+    public static final int MINIMUM_PORTAL_ROOM_CHAIN_LENGTH_SURFACE = 14;
+    public static final int MAX_LIBRARY_AMOUNT_SURFACE = 3;
+    public static final double DEFAULT_MAX_PLACE_COUNT_SURFACE_FACTOR = 2.5; // 1.0 would mean: no difference between surface and non-surface
+    // Martijn end - custom strongholds - surface strongholds
+    // Martijn end - custom strongholds - bigger strongholds
+    private static final StrongholdPieces.PieceWeight[] STRONGHOLD_PIECE_WEIGHTS = new StrongholdPieces.PieceWeight[]{new StrongholdPieces.PieceWeight(StrongholdPieces.Straight.class, 40, 0), new StrongholdPieces.PieceWeight(StrongholdPieces.PrisonHall.class, 5, 5), new StrongholdPieces.PieceWeight(StrongholdPieces.LeftTurn.class, 20, 0), new StrongholdPieces.PieceWeight(StrongholdPieces.RightTurn.class, 20, 0), new StrongholdPieces.PieceWeight(StrongholdPieces.RoomCrossing.class, 10, 10, 6, 20), new StrongholdPieces.PieceWeight(StrongholdPieces.StraightStairsDown.class, 5, 10, 5, 0), new StrongholdPieces.PieceWeight(StrongholdPieces.StairsDown.class, 5, 8, 5, 0), new StrongholdPieces.PieceWeight(StrongholdPieces.FiveCrossing.class, 5, 4), new StrongholdPieces.PieceWeight(StrongholdPieces.ChestCorridor.class, 5, 5, 4, 6), new StrongholdPieces.PieceWeight(StrongholdPieces.Library.class, 10, 10, MAX_LIBRARY_AMOUNT, MAX_LIBRARY_AMOUNT_SURFACE) { // Martijn - custom strongholds - bigger strongholds, surface strongholds
         @Override
-        public boolean doPlace(int chainLength) {
-            return super.doPlace(chainLength) && chainLength > 4;
+        // Martijn start - custom strongholds - surface strongholds, bigger strongholds
+        public boolean doPlace(int chainLength, boolean isSurface) {
+            return super.doPlace(chainLength, isSurface) && chainLength > (isSurface ? MINIMUM_LIBRARY_CHAIN_LENGTH_SURFACE : MINIMUM_LIBRARY_CHAIN_LENGTH);
+            // Martijn end - custom strongholds - surface strongholds, bigger strongholds
         }
-    }, new StrongholdPieces.PieceWeight(StrongholdPieces.PortalRoom.class, 20, 1) {
+    }, new StrongholdPieces.PieceWeight(StrongholdPieces.PortalRoom.class, 20, 20, 1, 1) {
         @Override
-        public boolean doPlace(int chainLength) {
-            return super.doPlace(chainLength) && chainLength > 5;
+        // Martijn start - custom strongholds - surface strongholds, bigger strongholds
+        public boolean doPlace(int chainLength, boolean isSurface) {
+            return super.doPlace(chainLength, isSurface) && chainLength > (isSurface ? MINIMUM_PORTAL_ROOM_CHAIN_LENGTH_SURFACE : MINIMUM_PORTAL_ROOM_CHAIN_LENGTH);
+            // Martijn end - custom strongholds - surface strongholds, bigger strongholds
         }
     }};
     private static List<StrongholdPieces.PieceWeight> currentPieces;
     static Class<? extends StrongholdPieces.StrongholdPiece> imposedPiece;
     private static int totalWeight;
     static final StrongholdPieces.SmoothStoneSelector SMOOTH_STONE_SELECTOR = new StrongholdPieces.SmoothStoneSelector();
+    static final StrongholdPieces.SmoothStoneSelectorOrTemporary SMOOTH_STONE_SELECTOR_OR_TEMPORARY = new StrongholdPieces.SmoothStoneSelectorOrTemporary(); // Martijn - custom strongholds - surface strongholds
 
     public static void resetPieces() {
         currentPieces = Lists.newArrayList();
@@ -68,56 +106,60 @@ public class StrongholdPieces {
         imposedPiece = null;
     }
 
-    private static boolean updatePieceWeight() {
+    private static boolean updatePieceWeight(boolean isSurface) { // Martijn - custom strongholds - bigger strongholds, surface strongholds
         boolean bl = false;
         totalWeight = 0;
 
         for(StrongholdPieces.PieceWeight pieceWeight : currentPieces) {
-            if (pieceWeight.maxPlaceCount > 0 && pieceWeight.placeCount < pieceWeight.maxPlaceCount) {
+            if (pieceWeight.getEffectiveMaxPlaceCount(isSurface) > 0 && pieceWeight.placeCount < pieceWeight.getEffectiveMaxPlaceCount(isSurface)) { // Martijn - custom strongholds - bigger strongholds, surface strongholds
                 bl = true;
             }
 
-            totalWeight += pieceWeight.weight;
+            totalWeight += pieceWeight.getEffectiveWeight(isSurface); // Martijn - custom strongholds - bigger strongholds, surface strongholds
         }
 
         return bl;
     }
 
-    private static StrongholdPieces.StrongholdPiece findAndCreatePieceFactory(Class<? extends StrongholdPieces.StrongholdPiece> pieceType, StructurePieceAccessor holder, RandomSource random, int x, int y, int z, @Nullable Direction orientation, int chainLength) {
+    // Martijn start - custom strongholds - surface strongholds
+    private static StrongholdPieces.StrongholdPiece findAndCreatePieceFactory(Class<? extends StrongholdPieces.StrongholdPiece> pieceType, StructurePieceAccessor holder, RandomSource random, int x, int y, int z, @Nullable Direction orientation, int chainLength, boolean isSurface) {
         StrongholdPieces.StrongholdPiece strongholdPiece = null;
         if (pieceType == StrongholdPieces.Straight.class) {
-            strongholdPiece = StrongholdPieces.Straight.createPiece(holder, random, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.Straight.createPiece(holder, random, x, y, z, orientation, chainLength, isSurface);
         } else if (pieceType == StrongholdPieces.PrisonHall.class) {
-            strongholdPiece = StrongholdPieces.PrisonHall.createPiece(holder, random, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.PrisonHall.createPiece(holder, random, x, y, z, orientation, chainLength, isSurface);
         } else if (pieceType == StrongholdPieces.LeftTurn.class) {
-            strongholdPiece = StrongholdPieces.LeftTurn.createPiece(holder, random, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.LeftTurn.createPiece(holder, random, x, y, z, orientation, chainLength, isSurface);
         } else if (pieceType == StrongholdPieces.RightTurn.class) {
-            strongholdPiece = StrongholdPieces.RightTurn.createPiece(holder, random, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.RightTurn.createPiece(holder, random, x, y, z, orientation, chainLength, isSurface);
         } else if (pieceType == StrongholdPieces.RoomCrossing.class) {
-            strongholdPiece = StrongholdPieces.RoomCrossing.createPiece(holder, random, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.RoomCrossing.createPiece(holder, random, x, y, z, orientation, chainLength, isSurface);
         } else if (pieceType == StrongholdPieces.StraightStairsDown.class) {
-            strongholdPiece = StrongholdPieces.StraightStairsDown.createPiece(holder, random, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.StraightStairsDown.createPiece(holder, random, x, y, z, orientation, chainLength, isSurface);
         } else if (pieceType == StrongholdPieces.StairsDown.class) {
-            strongholdPiece = StrongholdPieces.StairsDown.createPiece(holder, random, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.StairsDown.createPiece(holder, random, x, y, z, orientation, chainLength, isSurface);
         } else if (pieceType == StrongholdPieces.FiveCrossing.class) {
-            strongholdPiece = StrongholdPieces.FiveCrossing.createPiece(holder, random, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.FiveCrossing.createPiece(holder, random, x, y, z, orientation, chainLength, isSurface);
         } else if (pieceType == StrongholdPieces.ChestCorridor.class) {
-            strongholdPiece = StrongholdPieces.ChestCorridor.createPiece(holder, random, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.ChestCorridor.createPiece(holder, random, x, y, z, orientation, chainLength, isSurface);
         } else if (pieceType == StrongholdPieces.Library.class) {
-            strongholdPiece = StrongholdPieces.Library.createPiece(holder, random, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.Library.createPiece(holder, random, x, y, z, orientation, chainLength, isSurface);
         } else if (pieceType == StrongholdPieces.PortalRoom.class) {
-            strongholdPiece = StrongholdPieces.PortalRoom.createPiece(holder, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.PortalRoom.createPiece(holder, x, y, z, orientation, chainLength, isSurface);
         }
+        // Martijn end - custom strongholds - surface strongholds
 
         return strongholdPiece;
     }
 
-    private static StrongholdPieces.StrongholdPiece generatePieceFromSmallDoor(StrongholdPieces.StartPiece start, StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength) {
-        if (!updatePieceWeight()) {
+    // Martijn start - custom strongholds - surface strongholds
+    private static StrongholdPieces.StrongholdPiece generatePieceFromSmallDoor(StrongholdPieces.StartPiece start, StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) {
+        if (!updatePieceWeight(isSurface)) { // Martijn - custom strongholds - bigger strongholds
+            // Martijn end - custom strongholds - surface strongholds
             return null;
         } else {
             if (imposedPiece != null) {
-                StrongholdPieces.StrongholdPiece strongholdPiece = findAndCreatePieceFactory(imposedPiece, holder, random, x, y, z, orientation, chainLength);
+                StrongholdPieces.StrongholdPiece strongholdPiece = findAndCreatePieceFactory(imposedPiece, holder, random, x, y, z, orientation, chainLength, isSurface); // Martijn - custom strongholds - surface strongholds
                 imposedPiece = null;
                 if (strongholdPiece != null) {
                     return strongholdPiece;
@@ -131,17 +173,17 @@ public class StrongholdPieces {
                 int j = random.nextInt(totalWeight);
 
                 for(StrongholdPieces.PieceWeight pieceWeight : currentPieces) {
-                    j -= pieceWeight.weight;
+                    j -= pieceWeight.getEffectiveWeight(isSurface); // Martijn - custom strongholds - bigger strongholds, surface strongholds
                     if (j < 0) {
-                        if (!pieceWeight.doPlace(chainLength) || pieceWeight == start.previousPiece) {
+                        if (!pieceWeight.doPlace(chainLength, isSurface) || pieceWeight == start.previousPiece) { // Martijn - custom strongholds - surface strongholds, bigger strongholds
                             break;
                         }
 
-                        StrongholdPieces.StrongholdPiece strongholdPiece2 = findAndCreatePieceFactory(pieceWeight.pieceClass, holder, random, x, y, z, orientation, chainLength);
+                        StrongholdPieces.StrongholdPiece strongholdPiece2 = findAndCreatePieceFactory(pieceWeight.pieceClass, holder, random, x, y, z, orientation, chainLength, isSurface); // Martijn - custom strongholds - surface strongholds
                         if (strongholdPiece2 != null) {
                             ++pieceWeight.placeCount;
                             start.previousPiece = pieceWeight;
-                            if (!pieceWeight.isValid()) {
+                            if (!pieceWeight.isValid(isSurface)) { // Martijn - custom strongholds - surface strongholds, bigger strongholds
                                 currentPieces.remove(pieceWeight);
                             }
 
@@ -152,15 +194,15 @@ public class StrongholdPieces {
             }
 
             BoundingBox boundingBox = StrongholdPieces.FillerCorridor.findPieceBox(holder, random, x, y, z, orientation);
-            return boundingBox != null && boundingBox.minY() > 1 ? new StrongholdPieces.FillerCorridor(chainLength, boundingBox, orientation) : null;
+            return boundingBox != null && boundingBox.minY() > 1 ? new StrongholdPieces.FillerCorridor(chainLength, boundingBox, orientation, isSurface) : null; // Martijn - custom strongholds - surface strongholds
         }
     }
 
-    static StructurePiece generateAndAddPiece(StrongholdPieces.StartPiece start, StructurePieceAccessor holder, RandomSource random, int x, int y, int z, @Nullable Direction orientation, int chainLength) {
-        if (chainLength > 50) {
+    static StructurePiece generateAndAddPiece(StrongholdPieces.StartPiece start, StructurePieceAccessor holder, RandomSource random, int x, int y, int z, @Nullable Direction orientation, int chainLength, boolean isSurface) { // Martijn - custom strongholds - surface strongholds
+        if (chainLength > (isSurface ? MAX_CHAIN_LENGTH_SURFACE : MAX_CHAIN_LENGTH)) { // Martijn - custom strongholds - bigger strongholds
             return null;
-        } else if (Math.abs(x - start.getBoundingBox().minX()) <= 112 && Math.abs(z - start.getBoundingBox().minZ()) <= 112) {
-            StructurePiece structurePiece = generatePieceFromSmallDoor(start, holder, random, x, y, z, orientation, chainLength + 1);
+        } else if (Math.abs(x - start.getBoundingBox().minX()) <= (isSurface ? MAX_PLANAR_DISTANCE_SURFACE : MAX_PLANAR_DISTANCE) && Math.abs(z - start.getBoundingBox().minZ()) <= (isSurface ? MAX_PLANAR_DISTANCE_SURFACE : MAX_PLANAR_DISTANCE)) { // Martijn - custom strongholds - bigger strongholds
+            StructurePiece structurePiece = generatePieceFromSmallDoor(start, holder, random, x, y, z, orientation, chainLength + 1, isSurface); // Martijn - custom strongholds - surface strongholds
             if (structurePiece != null) {
                 holder.addPiece(structurePiece);
                 start.pendingChildren.add(structurePiece);
@@ -178,8 +220,10 @@ public class StrongholdPieces {
         private static final int DEPTH = 7;
         private boolean hasPlacedChest;
 
-        public ChestCorridor(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_CHEST_CORRIDOR, chainLength, boundingBox);
+        // Martijn start - custom strongholds - surface strongholds
+        public ChestCorridor(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_CHEST_CORRIDOR, chainLength, boundingBox, isSurface);
+            // Martijn end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
             this.entryDoor = this.randomSmallDoor(random);
         }
@@ -200,17 +244,20 @@ public class StrongholdPieces {
             this.generateSmallDoorChildForward((StrongholdPieces.StartPiece)start, holder, random, 1, 1);
         }
 
-        public static StrongholdPieces.ChestCorridor createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainlength) {
+        public static StrongholdPieces.ChestCorridor createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainlength, boolean isSurface) {// Martijn - custom strongholds - surface strongholds
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -1, -1, 0, 5, 5, 7, orientation);
-            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.ChestCorridor(chainlength, random, boundingBox, orientation) : null;
+            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.ChestCorridor(chainlength, random, boundingBox, orientation, isSurface) : null; // Martijn - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
-            this.generateBox(world, chunkBox, 0, 0, 0, 4, 4, 6, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+        // Martijn start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Martijn end - custom strongholds - surface strongholds
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 4, 4, 6, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR); // Martijn - custom strongholds - holes in stronghold parts
             this.generateSmallDoor(world, random, chunkBox, this.entryDoor, 1, 1, 0);
             this.generateSmallDoor(world, random, chunkBox, StrongholdPieces.StrongholdPiece.SmallDoorType.OPENING, 1, 1, 6);
-            this.generateBox(world, chunkBox, 3, 1, 2, 3, 1, 4, Blocks.STONE_BRICKS.defaultBlockState(), Blocks.STONE_BRICKS.defaultBlockState(), false);
+            this.generateBox(world, chunkBox, 3, 1, 2, 3, 1, 4, Blocks.STONE_BRICKS.defaultBlockState(), Blocks.STONE_BRICKS.defaultBlockState(), this.isSurface); // Martijn - custom strongholds - surface strongholds
             this.placeBlock(world, Blocks.STONE_BRICK_SLAB.defaultBlockState(), 3, 1, 1, chunkBox);
             this.placeBlock(world, Blocks.STONE_BRICK_SLAB.defaultBlockState(), 3, 1, 5, chunkBox);
             this.placeBlock(world, Blocks.STONE_BRICK_SLAB.defaultBlockState(), 3, 2, 2, chunkBox);
@@ -231,8 +278,10 @@ public class StrongholdPieces {
     public static class FillerCorridor extends StrongholdPieces.StrongholdPiece {
         private final int steps;
 
-        public FillerCorridor(int chainLength, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_FILLER_CORRIDOR, chainLength, boundingBox);
+        // Martijn start - custom strongholds - surface strongholds
+        public FillerCorridor(int chainLength, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_FILLER_CORRIDOR, chainLength, boundingBox, isSurface);
+            // Martijn end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
             this.steps = orientation != Direction.NORTH && orientation != Direction.SOUTH ? boundingBox.getXSpan() : boundingBox.getZSpan();
         }
@@ -269,7 +318,10 @@ public class StrongholdPieces {
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+        // Martijn start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Martijn end - custom strongholds - surface strongholds
             for(int i = 0; i < this.steps; ++i) {
                 this.placeBlock(world, Blocks.STONE_BRICKS.defaultBlockState(), 0, 0, i, chunkBox);
                 this.placeBlock(world, Blocks.STONE_BRICKS.defaultBlockState(), 1, 0, i, chunkBox);
@@ -304,8 +356,10 @@ public class StrongholdPieces {
         private final boolean rightLow;
         private final boolean rightHigh;
 
-        public FiveCrossing(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_FIVE_CROSSING, chainLength, boundingBox);
+        // Martijn start - custom strongholds - surface strongholds
+        public FiveCrossing(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_FIVE_CROSSING, chainLength, boundingBox, isSurface);
+            // Martijn end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
             this.entryDoor = this.randomSmallDoor(random);
             this.leftLow = random.nextBoolean();
@@ -360,52 +414,59 @@ public class StrongholdPieces {
 
         }
 
-        public static StrongholdPieces.FiveCrossing createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength) {
+        public static StrongholdPieces.FiveCrossing createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) { // Martijn - custom strongholds - surface strongholds
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -4, -3, 0, 10, 9, 11, orientation);
-            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.FiveCrossing(chainLength, random, boundingBox, orientation) : null;
+            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.FiveCrossing(chainLength, random, boundingBox, orientation, isSurface) : null; // Martijn - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
-            this.generateBox(world, chunkBox, 0, 0, 0, 9, 8, 10, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+        // Martijn start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Martijn end - custom strongholds - surface strongholds
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 9, 8, 10, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR_OR_TEMPORARY); // Martijn - custom strongholds - holes in stronghold parts
             this.generateSmallDoor(world, random, chunkBox, this.entryDoor, 4, 3, 0);
             if (this.leftLow) {
-                this.generateBox(world, chunkBox, 0, 3, 1, 0, 5, 3, CAVE_AIR, CAVE_AIR, false);
+                this.generateBox(world, chunkBox, 0, 3, 1, 0, 5, 3, SmoothStoneSelectorOrTemporary.TEMPORARY.defaultBlockState(), SmoothStoneSelectorOrTemporary.TEMPORARY.defaultBlockState(), this.isSurface); // Martijn - custom strongholds - surface strongholds
             }
 
             if (this.rightLow) {
-                this.generateBox(world, chunkBox, 9, 3, 1, 9, 5, 3, CAVE_AIR, CAVE_AIR, false);
+                this.generateBox(world, chunkBox, 9, 3, 1, 9, 5, 3, SmoothStoneSelectorOrTemporary.TEMPORARY.defaultBlockState(), SmoothStoneSelectorOrTemporary.TEMPORARY.defaultBlockState(), this.isSurface); // Martijn - custom strongholds - surface strongholds
             }
 
             if (this.leftHigh) {
-                this.generateBox(world, chunkBox, 0, 5, 7, 0, 7, 9, CAVE_AIR, CAVE_AIR, false);
+                this.generateBox(world, chunkBox, 0, 5, 7, 0, 7, 9, SmoothStoneSelectorOrTemporary.TEMPORARY.defaultBlockState(), SmoothStoneSelectorOrTemporary.TEMPORARY.defaultBlockState(), this.isSurface); // Martijn - custom strongholds - surface strongholds
             }
 
             if (this.rightHigh) {
-                this.generateBox(world, chunkBox, 9, 5, 7, 9, 7, 9, CAVE_AIR, CAVE_AIR, false);
+                this.generateBox(world, chunkBox, 9, 5, 7, 9, 7, 9, SmoothStoneSelectorOrTemporary.TEMPORARY.defaultBlockState(), SmoothStoneSelectorOrTemporary.TEMPORARY.defaultBlockState(), this.isSurface); // Martijn - custom strongholds - surface strongholds
             }
 
-            this.generateBox(world, chunkBox, 5, 1, 10, 7, 3, 10, CAVE_AIR, CAVE_AIR, false);
-            this.generateBox(world, chunkBox, 1, 2, 1, 8, 2, 6, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
-            this.generateBox(world, chunkBox, 4, 1, 5, 4, 4, 9, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
-            this.generateBox(world, chunkBox, 8, 1, 5, 8, 4, 9, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
-            this.generateBox(world, chunkBox, 1, 4, 7, 3, 4, 9, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
-            this.generateBox(world, chunkBox, 1, 3, 5, 3, 3, 6, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
-            this.generateBox(world, chunkBox, 1, 3, 4, 3, 3, 4, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), false);
-            this.generateBox(world, chunkBox, 1, 4, 6, 3, 4, 6, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), false);
-            this.generateBox(world, chunkBox, 5, 1, 7, 7, 1, 8, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
-            this.generateBox(world, chunkBox, 5, 1, 9, 7, 1, 9, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), false);
-            this.generateBox(world, chunkBox, 5, 2, 7, 7, 2, 7, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), false);
-            this.generateBox(world, chunkBox, 4, 5, 7, 4, 5, 9, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), false);
-            this.generateBox(world, chunkBox, 8, 5, 7, 8, 5, 9, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), false);
-            this.generateBox(world, chunkBox, 5, 5, 7, 7, 5, 9, Blocks.SMOOTH_STONE_SLAB.defaultBlockState().setValue(SlabBlock.TYPE, SlabType.DOUBLE), Blocks.SMOOTH_STONE_SLAB.defaultBlockState().setValue(SlabBlock.TYPE, SlabType.DOUBLE), false);
+            // Martijn start- custom strongholds - surface strongholds
+            this.generateBox(world, chunkBox, 5, 1, 10, 7, 3, 10, SmoothStoneSelectorOrTemporary.TEMPORARY.defaultBlockState(), SmoothStoneSelectorOrTemporary.TEMPORARY.defaultBlockState(), this.isSurface);
+            this.generateBoxConditionally(world, chunkBox, 1, 2, 1, 8, 2, 6, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+            this.generateBoxConditionally(world, chunkBox, 4, 1, 5, 4, 4, 9, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+            this.generateBoxConditionally(world, chunkBox, 8, 1, 5, 8, 4, 9, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+            this.generateBoxConditionally(world, chunkBox, 1, 4, 7, 3, 4, 9, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+            this.generateBoxConditionally(world, chunkBox, 1, 3, 5, 3, 3, 6, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+            this.generateBoxConditionally(world, chunkBox, 1, 3, 4, 3, 3, 4, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState());
+            this.generateBoxConditionally(world, chunkBox, 1, 4, 6, 3, 4, 6, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState());
+            this.generateBoxConditionally(world, chunkBox, 5, 1, 7, 7, 1, 8, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+            this.generateBoxConditionally(world, chunkBox, 5, 1, 9, 7, 1, 9, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState());
+            this.generateBoxConditionally(world, chunkBox, 5, 2, 7, 7, 2, 7, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState());
+            this.generateBoxConditionally(world, chunkBox, 4, 5, 7, 4, 5, 9, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState());
+            this.generateBoxConditionally(world, chunkBox, 8, 5, 7, 8, 5, 9, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState());
+            this.generateBoxConditionally(world, chunkBox, 5, 5, 7, 7, 5, 9, Blocks.SMOOTH_STONE_SLAB.defaultBlockState().setValue(SlabBlock.TYPE, SlabType.DOUBLE), Blocks.SMOOTH_STONE_SLAB.defaultBlockState().setValue(SlabBlock.TYPE, SlabType.DOUBLE));
+            // Martijn end - custom strongholds - surface strongholds
             this.placeBlock(world, Blocks.WALL_TORCH.defaultBlockState().setValue(WallTorchBlock.FACING, Direction.SOUTH), 6, 5, 6, chunkBox);
         }
     }
 
     public static class LeftTurn extends StrongholdPieces.Turn {
-        public LeftTurn(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_LEFT_TURN, chainLength, boundingBox);
+        // Martijn start - custom strongholds - surface strongholds
+        public LeftTurn(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_LEFT_TURN, chainLength, boundingBox, isSurface);
+            // Martijn end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
             this.entryDoor = this.randomSmallDoor(random);
         }
@@ -425,20 +486,23 @@ public class StrongholdPieces {
 
         }
 
-        public static StrongholdPieces.LeftTurn createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength) {
+        public static StrongholdPieces.LeftTurn createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) { // Martijn - custom strongholds - surface strongholds
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -1, -1, 0, 5, 5, 5, orientation);
-            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.LeftTurn(chainLength, random, boundingBox, orientation) : null;
+            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.LeftTurn(chainLength, random, boundingBox, orientation, isSurface) : null; // Martijn - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
-            this.generateBox(world, chunkBox, 0, 0, 0, 4, 4, 4, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+        // Martijn start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Martijn end - custom strongholds - surface strongholds
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 4, 4, 4, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR); // Martijn - custom strongholds - holes in stronghold parts
             this.generateSmallDoor(world, random, chunkBox, this.entryDoor, 1, 1, 0);
             Direction direction = this.getOrientation();
             if (direction != Direction.NORTH && direction != Direction.EAST) {
-                this.generateBox(world, chunkBox, 4, 1, 1, 4, 3, 3, CAVE_AIR, CAVE_AIR, false);
+                this.generateBox(world, chunkBox, 4, 1, 1, 4, 3, 3, CAVE_AIR, CAVE_AIR, this.isSurface); // Martijn - custom strongholds - surface strongholds
             } else {
-                this.generateBox(world, chunkBox, 0, 1, 1, 0, 3, 3, CAVE_AIR, CAVE_AIR, false);
+                this.generateBox(world, chunkBox, 0, 1, 1, 0, 3, 3, CAVE_AIR, CAVE_AIR, this.isSurface); // Martijn - custom strongholds - surface strongholds
             }
 
         }
@@ -451,8 +515,10 @@ public class StrongholdPieces {
         protected static final int DEPTH = 15;
         private final boolean isTall;
 
-        public Library(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_LIBRARY, chainLength, boundingBox);
+        // Martijn start - custom strongholds - surface strongholds
+        public Library(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_LIBRARY, chainLength, boundingBox, isSurface);
+            // Martijn end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
             this.entryDoor = this.randomSmallDoor(random);
             this.isTall = boundingBox.getYSpan() > 6;
@@ -469,7 +535,7 @@ public class StrongholdPieces {
             nbt.putBoolean("Tall", this.isTall);
         }
 
-        public static StrongholdPieces.Library createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength) {
+        public static StrongholdPieces.Library createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) { // Martijn - custom strongholds - surface strongholds
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -4, -1, 0, 14, 11, 15, orientation);
             if (!isOkBox(boundingBox) || holder.findCollisionPiece(boundingBox) != null) {
                 boundingBox = BoundingBox.orientBox(x, y, z, -4, -1, 0, 14, 6, 15, orientation);
@@ -478,62 +544,67 @@ public class StrongholdPieces {
                 }
             }
 
-            return new StrongholdPieces.Library(chainLength, random, boundingBox, orientation);
+            return new StrongholdPieces.Library(chainLength, random, boundingBox, orientation, isSurface); // Martijn - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+        // Martijn start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Martijn end - custom strongholds - surface strongholds
             int i = 11;
             if (!this.isTall) {
                 i = 6;
             }
 
-            this.generateBox(world, chunkBox, 0, 0, 0, 13, i - 1, 14, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 13, i - 1, 14, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR_OR_TEMPORARY); // Martijn - custom strongholds - holes in stronghold parts, surface strongholds
             this.generateSmallDoor(world, random, chunkBox, this.entryDoor, 4, 1, 0);
-            this.generateMaybeBox(world, chunkBox, random, 0.07F, 2, 1, 1, 11, 4, 13, Blocks.COBWEB.defaultBlockState(), Blocks.COBWEB.defaultBlockState(), false, false);
+            this.generateMaybeBox(world, chunkBox, random, 0.07F, 2, 1, 1, 11, 4, 13, Blocks.COBWEB.defaultBlockState(), Blocks.COBWEB.defaultBlockState(), this.isSurface, false); // Martijn - custom strongholds - surface strongholds
             int j = 1;
             int k = 12;
 
             for(int l = 1; l <= 13; ++l) {
                 if ((l - 1) % 4 == 0) {
-                    this.generateBox(world, chunkBox, 1, 1, l, 1, 4, l, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), false);
-                    this.generateBox(world, chunkBox, 12, 1, l, 12, 4, l, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), false);
+                    // Martijn start - custom strongholds - surface strongholds
+                    this.generateBox(world, chunkBox, 1, 1, l, 1, 4, l, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), this.isSurface);
+                    this.generateBox(world, chunkBox, 12, 1, l, 12, 4, l, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), this.isSurface);
+                    // Martijn end - custom strongholds - surface strongholds
                     this.placeBlock(world, Blocks.WALL_TORCH.defaultBlockState().setValue(WallTorchBlock.FACING, Direction.EAST), 2, 3, l, chunkBox);
                     this.placeBlock(world, Blocks.WALL_TORCH.defaultBlockState().setValue(WallTorchBlock.FACING, Direction.WEST), 11, 3, l, chunkBox);
-                    if (this.isTall) {
-                        this.generateBox(world, chunkBox, 1, 6, l, 1, 9, l, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), false);
-                        this.generateBox(world, chunkBox, 12, 6, l, 12, 9, l, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), false);
-                    }
                 } else {
-                    this.generateBox(world, chunkBox, 1, 1, l, 1, 4, l, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false);
-                    this.generateBox(world, chunkBox, 12, 1, l, 12, 4, l, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false);
-                    if (this.isTall) {
-                        this.generateBox(world, chunkBox, 1, 6, l, 1, 9, l, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false);
-                        this.generateBox(world, chunkBox, 12, 6, l, 12, 9, l, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false);
-                    }
+                    // Martijn start - custom strongholds - surface strongholds
+                    this.generateBoxConditionally(world, chunkBox, 1, 1, l, 1, 4, l, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false, false, true, false, false);
+                    this.generateBoxConditionally(world, chunkBox, 12, 1, l, 12, 4, l, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false, false, true, false, false);
+                    // Martijn end - custom strongholds - surface strongholds
                 }
             }
 
             for(int m = 3; m < 12; m += 2) {
-                this.generateBox(world, chunkBox, 3, 1, m, 4, 3, m, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false);
-                this.generateBox(world, chunkBox, 6, 1, m, 7, 3, m, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false);
-                this.generateBox(world, chunkBox, 9, 1, m, 10, 3, m, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false);
+                // Martijn start - custom strongholds - surface strongholds
+                this.generateBoxConditionally(world, chunkBox, 3, 1, m, 4, 3, m, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false, false, true, false, false);
+                this.generateBoxConditionally(world, chunkBox, 6, 1, m, 7, 3, m, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false, false, true, false, false);
+                this.generateBoxConditionally(world, chunkBox, 9, 1, m, 10, 3, m, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false, false, true, false, false);
+                // Martijn end - custom strongholds - surface strongholds
             }
 
             if (this.isTall) {
-                this.generateBox(world, chunkBox, 1, 5, 1, 3, 5, 13, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), false);
-                this.generateBox(world, chunkBox, 10, 5, 1, 12, 5, 13, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), false);
-                this.generateBox(world, chunkBox, 4, 5, 1, 9, 5, 2, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), false);
-                this.generateBox(world, chunkBox, 4, 5, 12, 9, 5, 13, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), false);
+                // Martijn start - custom strongholds - surface strongholds
+                this.generateBox(world, chunkBox, 1, 5, 1, 3, 5, 13, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), this.isSurface);
+                this.generateBox(world, chunkBox, 10, 5, 1, 12, 5, 13, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), this.isSurface);
+                this.generateBox(world, chunkBox, 4, 5, 1, 9, 5, 2, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), this.isSurface);
+                this.generateBox(world, chunkBox, 4, 5, 12, 9, 5, 13, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), this.isSurface);
+                // Martijn end - custom strongholds - surface strongholds
                 this.placeBlock(world, Blocks.OAK_PLANKS.defaultBlockState(), 9, 5, 11, chunkBox);
                 this.placeBlock(world, Blocks.OAK_PLANKS.defaultBlockState(), 8, 5, 11, chunkBox);
                 this.placeBlock(world, Blocks.OAK_PLANKS.defaultBlockState(), 9, 5, 10, chunkBox);
                 BlockState blockState = Blocks.OAK_FENCE.defaultBlockState().setValue(FenceBlock.WEST, Boolean.valueOf(true)).setValue(FenceBlock.EAST, Boolean.valueOf(true));
                 BlockState blockState2 = Blocks.OAK_FENCE.defaultBlockState().setValue(FenceBlock.NORTH, Boolean.valueOf(true)).setValue(FenceBlock.SOUTH, Boolean.valueOf(true));
-                this.generateBox(world, chunkBox, 3, 6, 3, 3, 6, 11, blockState2, blockState2, false);
-                this.generateBox(world, chunkBox, 10, 6, 3, 10, 6, 9, blockState2, blockState2, false);
-                this.generateBox(world, chunkBox, 4, 6, 2, 9, 6, 2, blockState, blockState, false);
-                this.generateBox(world, chunkBox, 4, 6, 12, 7, 6, 12, blockState, blockState, false);
+                // Martijn start - custom strongholds - surface strongholds
+                this.generateBox(world, chunkBox, 3, 6, 3, 3, 6, 11, blockState2, blockState2, this.isSurface);
+                this.generateBox(world, chunkBox, 10, 6, 3, 10, 6, 9, blockState2, blockState2, this.isSurface);
+                this.generateBox(world, chunkBox, 4, 6, 2, 9, 6, 2, blockState, blockState, this.isSurface);
+                this.generateBox(world, chunkBox, 4, 6, 12, 7, 6, 12, blockState, blockState, this.isSurface);
+                // Martijn end - custom strongholds - surface strongholds
                 this.placeBlock(world, Blocks.OAK_FENCE.defaultBlockState().setValue(FenceBlock.NORTH, Boolean.valueOf(true)).setValue(FenceBlock.EAST, Boolean.valueOf(true)), 3, 6, 2, chunkBox);
                 this.placeBlock(world, Blocks.OAK_FENCE.defaultBlockState().setValue(FenceBlock.SOUTH, Boolean.valueOf(true)).setValue(FenceBlock.EAST, Boolean.valueOf(true)), 3, 6, 12, chunkBox);
                 this.placeBlock(world, Blocks.OAK_FENCE.defaultBlockState().setValue(FenceBlock.NORTH, Boolean.valueOf(true)).setValue(FenceBlock.WEST, Boolean.valueOf(true)), 10, 6, 2, chunkBox);
@@ -577,6 +648,18 @@ public class StrongholdPieces {
                 this.placeBlock(world, blockState7, 6, 8, 8, chunkBox);
                 this.placeBlock(world, blockState7, 7, 8, 6, chunkBox);
                 this.placeBlock(world, blockState7, 7, 8, 8, chunkBox);
+                // Martijn start - custom strongholds - surface strongholds
+                for(int l = 1; l <= 13; ++l) {
+                    if ((l - 1) % 4 == 0) {
+                        this.generateBox(world, chunkBox, 1, 6, l, 1, 9, l, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), this.isSurface);
+                        this.generateBox(world, chunkBox, 12, 6, l, 12, 9, l, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), this.isSurface);
+                    } else {
+                        // Martijn start - custom strongholds - surface strongholds
+                        this.generateBoxConditionally(world, chunkBox, 1, 6, l, 1, 9, l, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false, false, true, false, false);
+                        this.generateBoxConditionally(world, chunkBox, 12, 6, l, 12, 9, l, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false, false, true, false, false);
+                    }
+                }
+                // Martijn end - custom strongholds - surface strongholds
             }
 
             this.createChest(world, chunkBox, random, 3, 3, 5, BuiltInLootTables.STRONGHOLD_LIBRARY);
@@ -586,6 +669,16 @@ public class StrongholdPieces {
             }
 
         }
+
+        // Martijn start - custom strongholds - more things
+
+        @Override
+        public boolean areAddedCandlesLit() {
+            return true;
+        }
+
+        // Martijn end - custom strongholds - more things
+
     }
 
     static class PieceWeight {
@@ -593,19 +686,43 @@ public class StrongholdPieces {
         public final int weight;
         public int placeCount;
         public final int maxPlaceCount;
+        // Martijn start - custom strongholds - surface strongholds, bigger strongholds
+        public final int weightSurface;
+        public final int maxPlaceCountSurface;
 
-        public PieceWeight(Class<? extends StrongholdPieces.StrongholdPiece> pieceType, int weight, int limit) {
+        public int getEffectiveWeight(boolean isSurface) {
+            return isSurface ? weightSurface : weight;
+        }
+
+        public int getEffectiveMaxPlaceCount(boolean isSurface) {
+            return isSurface ? maxPlaceCountSurface : maxPlaceCount;
+        }
+
+        public PieceWeight(Class<? extends StrongholdPieces.StrongholdPiece> pieceType, int weight, int weightSurface, int limit, int limitSurface) {
+            // Martijn end - custom strongholds - surface strongholds, bigger strongholds
             this.pieceClass = pieceType;
             this.weight = weight;
             this.maxPlaceCount = limit;
+            // Martijn start - custom strongholds - surface strongholds, bigger strongholds
+            this.weightSurface = weightSurface;
+            this.maxPlaceCountSurface = limitSurface;
+            // Martijn end - custom strongholds - surface strongholds, bigger strongholds
         }
 
-        public boolean doPlace(int chainLength) {
-            return this.maxPlaceCount == 0 || this.placeCount < this.maxPlaceCount;
+        public PieceWeight(Class<? extends StrongholdPieces.StrongholdPiece> pieceType, int weight, int limit) {
+            this(pieceType, weight, weight, limit, limit == 0 ? 0 : (int) Math.ceil(limit * DEFAULT_MAX_PLACE_COUNT_SURFACE_FACTOR)); // Martijn - custom strongholds - surface strongholds, bigger strongholds
+        }
+
+        // Martijn start - custom strongholds - surface strongholds, bigger strongholds
+        public boolean doPlace(int chainLength, boolean isSurface) {
+            return this.getEffectiveMaxPlaceCount(isSurface) == 0 || this.placeCount < this.getEffectiveMaxPlaceCount(isSurface);
+            // Martijn end - custom strongholds - surface strongholds, bigger strongholds
         }
 
-        public boolean isValid() {
-            return this.maxPlaceCount == 0 || this.placeCount < this.maxPlaceCount;
+        // Martijn start - custom strongholds - surface strongholds, bigger strongholds
+        public boolean isValid(boolean isSurface) {
+            return this.getEffectiveMaxPlaceCount(isSurface) == 0 || this.placeCount < this.getEffectiveMaxPlaceCount(isSurface);
+            // Martijn end - custom strongholds - surface strongholds, bigger strongholds
         }
     }
 
@@ -615,8 +732,10 @@ public class StrongholdPieces {
         protected static final int DEPTH = 16;
         private boolean hasPlacedSpawner;
 
-        public PortalRoom(int chainLength, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_PORTAL_ROOM, chainLength, boundingBox);
+        // Martijn start - custom strongholds - surface strongholds
+        public PortalRoom(int chainLength, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_PORTAL_ROOM, chainLength, boundingBox, isSurface);
+            // Martijn end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
         }
 
@@ -639,14 +758,17 @@ public class StrongholdPieces {
 
         }
 
-        public static StrongholdPieces.PortalRoom createPiece(StructurePieceAccessor holder, int x, int y, int z, Direction orientation, int chainLength) {
+        public static StrongholdPieces.PortalRoom createPiece(StructurePieceAccessor holder, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) {// Martijn - custom strongholds - surface strongholds
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -4, -1, 0, 11, 8, 16, orientation);
-            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.PortalRoom(chainLength, boundingBox, orientation) : null;
+            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.PortalRoom(chainLength, boundingBox, orientation, isSurface) : null; // Martijn - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
-            this.generateBox(world, chunkBox, 0, 0, 0, 10, 7, 15, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+        // Martijn start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Martijn end - custom strongholds - surface strongholds
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 10, 7, 15, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR); // Martijn - custom strongholds - holes in stronghold parts
             this.generateSmallDoor(world, random, chunkBox, StrongholdPieces.StrongholdPiece.SmallDoorType.GRATES, 4, 1, 0);
             int i = 6;
             this.generateBox(world, chunkBox, 1, i, 1, 1, i, 14, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
@@ -694,30 +816,32 @@ public class StrongholdPieces {
                 bl &= bls[m];
             }
 
-            this.placeBlock(world, blockState4.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[0])), 4, 3, 8, chunkBox);
-            this.placeBlock(world, blockState4.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[1])), 5, 3, 8, chunkBox);
-            this.placeBlock(world, blockState4.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[2])), 6, 3, 8, chunkBox);
-            this.placeBlock(world, blockState5.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[3])), 4, 3, 12, chunkBox);
-            this.placeBlock(world, blockState5.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[4])), 5, 3, 12, chunkBox);
-            this.placeBlock(world, blockState5.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[5])), 6, 3, 12, chunkBox);
-            this.placeBlock(world, blockState6.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[6])), 3, 3, 9, chunkBox);
-            this.placeBlock(world, blockState6.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[7])), 3, 3, 10, chunkBox);
-            this.placeBlock(world, blockState6.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[8])), 3, 3, 11, chunkBox);
-            this.placeBlock(world, blockState7.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[9])), 7, 3, 9, chunkBox);
-            this.placeBlock(world, blockState7.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[10])), 7, 3, 10, chunkBox);
-            this.placeBlock(world, blockState7.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[11])), 7, 3, 11, chunkBox);
+            // Martijn start - custom strongholds - conditional placements
+            this.placeBlockUnconditionally(world, blockState4.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[0])), 4, 3, 8, chunkBox);
+            this.placeBlockUnconditionally(world, blockState4.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[1])), 5, 3, 8, chunkBox);
+            this.placeBlockUnconditionally(world, blockState4.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[2])), 6, 3, 8, chunkBox);
+            this.placeBlockUnconditionally(world, blockState5.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[3])), 4, 3, 12, chunkBox);
+            this.placeBlockUnconditionally(world, blockState5.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[4])), 5, 3, 12, chunkBox);
+            this.placeBlockUnconditionally(world, blockState5.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[5])), 6, 3, 12, chunkBox);
+            this.placeBlockUnconditionally(world, blockState6.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[6])), 3, 3, 9, chunkBox);
+            this.placeBlockUnconditionally(world, blockState6.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[7])), 3, 3, 10, chunkBox);
+            this.placeBlockUnconditionally(world, blockState6.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[8])), 3, 3, 11, chunkBox);
+            this.placeBlockUnconditionally(world, blockState7.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[9])), 7, 3, 9, chunkBox);
+            this.placeBlockUnconditionally(world, blockState7.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[10])), 7, 3, 10, chunkBox);
+            this.placeBlockUnconditionally(world, blockState7.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[11])), 7, 3, 11, chunkBox);
             if (bl) {
                 BlockState blockState8 = Blocks.END_PORTAL.defaultBlockState();
-                this.placeBlock(world, blockState8, 4, 3, 9, chunkBox);
-                this.placeBlock(world, blockState8, 5, 3, 9, chunkBox);
-                this.placeBlock(world, blockState8, 6, 3, 9, chunkBox);
-                this.placeBlock(world, blockState8, 4, 3, 10, chunkBox);
-                this.placeBlock(world, blockState8, 5, 3, 10, chunkBox);
-                this.placeBlock(world, blockState8, 6, 3, 10, chunkBox);
-                this.placeBlock(world, blockState8, 4, 3, 11, chunkBox);
-                this.placeBlock(world, blockState8, 5, 3, 11, chunkBox);
-                this.placeBlock(world, blockState8, 6, 3, 11, chunkBox);
+                this.placeBlockUnconditionally(world, blockState8, 4, 3, 9, chunkBox);
+                this.placeBlockUnconditionally(world, blockState8, 5, 3, 9, chunkBox);
+                this.placeBlockUnconditionally(world, blockState8, 6, 3, 9, chunkBox);
+                this.placeBlockUnconditionally(world, blockState8, 4, 3, 10, chunkBox);
+                this.placeBlockUnconditionally(world, blockState8, 5, 3, 10, chunkBox);
+                this.placeBlockUnconditionally(world, blockState8, 6, 3, 10, chunkBox);
+                this.placeBlockUnconditionally(world, blockState8, 4, 3, 11, chunkBox);
+                this.placeBlockUnconditionally(world, blockState8, 5, 3, 11, chunkBox);
+                this.placeBlockUnconditionally(world, blockState8, 6, 3, 11, chunkBox);
             }
+            // Martijn end - custom strongholds - conditional placements
 
             if (!this.hasPlacedSpawner) {
                 BlockPos blockPos = this.getWorldPos(5, 3, 6);
@@ -732,6 +856,16 @@ public class StrongholdPieces {
             }
 
         }
+
+        // Martijn start - custom strongholds - more things
+
+        @Override
+        public boolean areAddedCandlesLit() {
+            return true;
+        }
+
+        // Martijn end - custom strongholds - more things
+
     }
 
     public static class PrisonHall extends StrongholdPieces.StrongholdPiece {
@@ -739,8 +873,10 @@ public class StrongholdPieces {
         protected static final int HEIGHT = 5;
         protected static final int DEPTH = 11;
 
-        public PrisonHall(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_PRISON_HALL, chainLength, boundingBox);
+        // Martijn start - custom strongholds - surface strongholds
+        public PrisonHall(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_PRISON_HALL, chainLength, boundingBox, isSurface);
+            // Martijn end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
             this.entryDoor = this.randomSmallDoor(random);
         }
@@ -754,20 +890,25 @@ public class StrongholdPieces {
             this.generateSmallDoorChildForward((StrongholdPieces.StartPiece)start, holder, random, 1, 1);
         }
 
-        public static StrongholdPieces.PrisonHall createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength) {
+        public static StrongholdPieces.PrisonHall createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) {// Martijn - custom strongholds - surface strongholds
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -1, -1, 0, 9, 5, 11, orientation);
-            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.PrisonHall(chainLength, random, boundingBox, orientation) : null;
+            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.PrisonHall(chainLength, random, boundingBox, orientation, isSurface) : null; // Martijn - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
-            this.generateBox(world, chunkBox, 0, 0, 0, 8, 4, 10, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+        // Martijn start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Martijn end - custom strongholds - surface strongholds
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 8, 4, 10, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR_OR_TEMPORARY); // Martijn - custom strongholds - holes in stronghold parts
             this.generateSmallDoor(world, random, chunkBox, this.entryDoor, 1, 1, 0);
             this.generateBox(world, chunkBox, 1, 1, 10, 3, 3, 10, CAVE_AIR, CAVE_AIR, false);
-            this.generateBox(world, chunkBox, 4, 1, 1, 4, 3, 1, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
-            this.generateBox(world, chunkBox, 4, 1, 3, 4, 3, 3, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
-            this.generateBox(world, chunkBox, 4, 1, 7, 4, 3, 7, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
-            this.generateBox(world, chunkBox, 4, 1, 9, 4, 3, 9, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+            // Martijn start - custom strongholds - surface strongholds
+            this.generateBoxConditionally(world, chunkBox, 4, 1, 1, 4, 3, 1, random, StrongholdPieces.SMOOTH_STONE_SELECTOR_OR_TEMPORARY);
+            this.generateBoxConditionally(world, chunkBox, 4, 1, 3, 4, 3, 3, random, StrongholdPieces.SMOOTH_STONE_SELECTOR_OR_TEMPORARY);
+            this.generateBoxConditionally(world, chunkBox, 4, 1, 7, 4, 3, 7, random, StrongholdPieces.SMOOTH_STONE_SELECTOR_OR_TEMPORARY);
+            this.generateBoxConditionally(world, chunkBox, 4, 1, 9, 4, 3, 9, random, StrongholdPieces.SMOOTH_STONE_SELECTOR_OR_TEMPORARY);
+            // Martijn end - custom strongholds - surface strongholds
 
             for(int i = 1; i <= 3; ++i) {
                 this.placeBlock(world, Blocks.IRON_BARS.defaultBlockState().setValue(IronBarsBlock.NORTH, Boolean.valueOf(true)).setValue(IronBarsBlock.SOUTH, Boolean.valueOf(true)), 4, i, 4, chunkBox);
@@ -790,8 +931,10 @@ public class StrongholdPieces {
     }
 
     public static class RightTurn extends StrongholdPieces.Turn {
-        public RightTurn(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_RIGHT_TURN, chainLength, boundingBox);
+        // Martijn start - custom strongholds - surface strongholds
+        public RightTurn(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_RIGHT_TURN, chainLength, boundingBox, isSurface);
+            // Martijn end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
             this.entryDoor = this.randomSmallDoor(random);
         }
@@ -811,20 +954,23 @@ public class StrongholdPieces {
 
         }
 
-        public static StrongholdPieces.RightTurn createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength) {
+        public static StrongholdPieces.RightTurn createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) { // Martijn - custom strongholds - surface strongholds
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -1, -1, 0, 5, 5, 5, orientation);
-            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.RightTurn(chainLength, random, boundingBox, orientation) : null;
+            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.RightTurn(chainLength, random, boundingBox, orientation, isSurface) : null; // Martijn - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
-            this.generateBox(world, chunkBox, 0, 0, 0, 4, 4, 4, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+        // Martijn start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Martijn end - custom strongholds - surface strongholds
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 4, 4, 4, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR); // Martijn - custom strongholds - holes in stronghold parts
             this.generateSmallDoor(world, random, chunkBox, this.entryDoor, 1, 1, 0);
             Direction direction = this.getOrientation();
             if (direction != Direction.NORTH && direction != Direction.EAST) {
-                this.generateBox(world, chunkBox, 0, 1, 1, 0, 3, 3, CAVE_AIR, CAVE_AIR, false);
+                this.generateBox(world, chunkBox, 0, 1, 1, 0, 3, 3, CAVE_AIR, CAVE_AIR, this.isSurface); // Martijn - custom strongholds - surface strongholds
             } else {
-                this.generateBox(world, chunkBox, 4, 1, 1, 4, 3, 3, CAVE_AIR, CAVE_AIR, false);
+                this.generateBox(world, chunkBox, 4, 1, 1, 4, 3, 3, CAVE_AIR, CAVE_AIR, this.isSurface); // Martijn - custom strongholds - surface strongholds
             }
 
         }
@@ -836,8 +982,10 @@ public class StrongholdPieces {
         protected static final int DEPTH = 11;
         protected final int type;
 
-        public RoomCrossing(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_ROOM_CROSSING, chainLength, boundingBox);
+        // Martijn start - custom strongholds - surface strongholds
+        public RoomCrossing(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_ROOM_CROSSING, chainLength, boundingBox, isSurface);
+            // Martijn end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
             this.entryDoor = this.randomSmallDoor(random);
             this.type = random.nextInt(5);
@@ -861,18 +1009,22 @@ public class StrongholdPieces {
             this.generateSmallDoorChildRight((StrongholdPieces.StartPiece)start, holder, random, 1, 4);
         }
 
-        public static StrongholdPieces.RoomCrossing createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength) {
+        public static StrongholdPieces.RoomCrossing createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) { // Martijn - custom strongholds - surface strongholds
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -4, -1, 0, 11, 7, 11, orientation);
-            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.RoomCrossing(chainLength, random, boundingBox, orientation) : null;
+            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.RoomCrossing(chainLength, random, boundingBox, orientation, isSurface) : null; // Martijn - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
-            this.generateBox(world, chunkBox, 0, 0, 0, 10, 6, 10, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+        // Martijn start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Martijn end - custom strongholds - surface strongholds
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 10, 6, 10, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR); // Martijn - custom strongholds - holes in stronghold parts
             this.generateSmallDoor(world, random, chunkBox, this.entryDoor, 4, 1, 0);
-            this.generateBox(world, chunkBox, 4, 1, 10, 6, 3, 10, CAVE_AIR, CAVE_AIR, false);
-            this.generateBox(world, chunkBox, 0, 1, 4, 0, 3, 6, CAVE_AIR, CAVE_AIR, false);
-            this.generateBox(world, chunkBox, 10, 1, 4, 10, 3, 6, CAVE_AIR, CAVE_AIR, false);
+            // Martijn start - custom strongholds - surface strongholds
+            this.generateBox(world, chunkBox, 4, 1, 10, 6, 3, 10, CAVE_AIR, CAVE_AIR, this.isSurface);
+            this.generateBox(world, chunkBox, 0, 1, 4, 0, 3, 6, CAVE_AIR, CAVE_AIR, this.isSurface);
+            this.generateBox(world, chunkBox, 10, 1, 4, 10, 3, 6, CAVE_AIR, CAVE_AIR, this.isSurface);
             switch (this.type) {
                 case 0:
                     this.placeBlock(world, Blocks.STONE_BRICKS.defaultBlockState(), 5, 1, 5, chunkBox);
@@ -902,27 +1054,27 @@ public class StrongholdPieces {
                     this.placeBlock(world, Blocks.STONE_BRICKS.defaultBlockState(), 5, 1, 5, chunkBox);
                     this.placeBlock(world, Blocks.STONE_BRICKS.defaultBlockState(), 5, 2, 5, chunkBox);
                     this.placeBlock(world, Blocks.STONE_BRICKS.defaultBlockState(), 5, 3, 5, chunkBox);
-                    this.placeBlock(world, Blocks.WATER.defaultBlockState(), 5, 4, 5, chunkBox);
+                    this.placeBlock(world, TEMPORARY_WATER.defaultBlockState(), 5, 4, 5, chunkBox); // Martijn - custom strongholds - strongholds in water
                     break;
                 case 2:
                     for(int j = 1; j <= 9; ++j) {
-                        this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 1, 3, j, chunkBox);
-                        this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 9, 3, j, chunkBox);
+                        this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), 1, 3, j, chunkBox);
+                        this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), 9, 3, j, chunkBox);
                     }
 
                     for(int k = 1; k <= 9; ++k) {
-                        this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), k, 3, 1, chunkBox);
-                        this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), k, 3, 9, chunkBox);
+                        this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), k, 3, 1, chunkBox);
+                        this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), k, 3, 9, chunkBox);
                     }
 
-                    this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 5, 1, 4, chunkBox);
-                    this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 5, 1, 6, chunkBox);
-                    this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 5, 3, 4, chunkBox);
-                    this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 5, 3, 6, chunkBox);
-                    this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 4, 1, 5, chunkBox);
-                    this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 6, 1, 5, chunkBox);
-                    this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 4, 3, 5, chunkBox);
-                    this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 6, 3, 5, chunkBox);
+                    this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), 5, 1, 4, chunkBox);
+                    this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), 5, 1, 6, chunkBox);
+                    this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), 5, 3, 4, chunkBox);
+                    this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), 5, 3, 6, chunkBox);
+                    this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), 4, 1, 5, chunkBox);
+                    this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), 6, 1, 5, chunkBox);
+                    this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), 4, 3, 5, chunkBox);
+                    this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), 6, 3, 5, chunkBox);
 
                     for(int l = 1; l <= 3; ++l) {
                         this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 4, l, 4, chunkBox);
@@ -934,16 +1086,16 @@ public class StrongholdPieces {
                     this.placeBlock(world, Blocks.TORCH.defaultBlockState(), 5, 3, 5, chunkBox);
 
                     for(int m = 2; m <= 8; ++m) {
-                        this.placeBlock(world, Blocks.OAK_PLANKS.defaultBlockState(), 2, 3, m, chunkBox);
-                        this.placeBlock(world, Blocks.OAK_PLANKS.defaultBlockState(), 3, 3, m, chunkBox);
+                        this.placeBlockConditionally(world, Blocks.OAK_PLANKS.defaultBlockState(), 2, 3, m, chunkBox);
+                        this.placeBlockConditionally(world, Blocks.OAK_PLANKS.defaultBlockState(), 3, 3, m, chunkBox);
                         if (m <= 3 || m >= 7) {
-                            this.placeBlock(world, Blocks.OAK_PLANKS.defaultBlockState(), 4, 3, m, chunkBox);
-                            this.placeBlock(world, Blocks.OAK_PLANKS.defaultBlockState(), 5, 3, m, chunkBox);
-                            this.placeBlock(world, Blocks.OAK_PLANKS.defaultBlockState(), 6, 3, m, chunkBox);
+                            this.placeBlockConditionally(world, Blocks.OAK_PLANKS.defaultBlockState(), 4, 3, m, chunkBox);
+                            this.placeBlockConditionally(world, Blocks.OAK_PLANKS.defaultBlockState(), 5, 3, m, chunkBox);
+                            this.placeBlockConditionally(world, Blocks.OAK_PLANKS.defaultBlockState(), 6, 3, m, chunkBox);
                         }
 
-                        this.placeBlock(world, Blocks.OAK_PLANKS.defaultBlockState(), 7, 3, m, chunkBox);
-                        this.placeBlock(world, Blocks.OAK_PLANKS.defaultBlockState(), 8, 3, m, chunkBox);
+                        this.placeBlockConditionally(world, Blocks.OAK_PLANKS.defaultBlockState(), 7, 3, m, chunkBox);
+                        this.placeBlockConditionally(world, Blocks.OAK_PLANKS.defaultBlockState(), 8, 3, m, chunkBox);
                     }
 
                     BlockState blockState = Blocks.LADDER.defaultBlockState().setValue(LadderBlock.FACING, Direction.WEST);
@@ -951,9 +1103,57 @@ public class StrongholdPieces {
                     this.placeBlock(world, blockState, 9, 2, 3, chunkBox);
                     this.placeBlock(world, blockState, 9, 3, 3, chunkBox);
                     this.createChest(world, chunkBox, random, 3, 4, 8, BuiltInLootTables.STRONGHOLD_CROSSING);
+                    break;
             }
+            // Martijn end - custom strongholds - surface strongholds
+
+            // Martijn start - custom strongholds - more things
 
+            // Replace some of the floor by water or lava
+            if (random.nextFloat() < GlobalConfiguration.get().customStrongholds.waterAndLavaInCrossings.chance) {
+                BlockState replacement;
+                double blockChance;
+                if (random.nextFloat() < GlobalConfiguration.get().customStrongholds.waterAndLavaInCrossings.waterRatio) {
+                    replacement = Blocks.WATER.defaultBlockState();
+                    blockChance = GlobalConfiguration.get().customStrongholds.waterAndLavaInCrossings.blockChances.water;
+                } else {
+                    replacement = Blocks.LAVA.defaultBlockState();
+                    blockChance = GlobalConfiguration.get().customStrongholds.waterAndLavaInCrossings.blockChances.lava;
+                }
+                for (int x = chunkBox.minX() + 1; x <= chunkBox.maxX() - 1; x++) {
+                    for (int z = chunkBox.minZ() + 1; z <= chunkBox.maxZ() - 1; z++) {
+                        BlockPos pos = new BlockPos(x, chunkBox.minY(), z);
+                        if (random.nextFloat() < blockChance) {
+                            if (world.getBlockState(pos).is(BlockTags.STONE_BRICKS) && world.getBlockState(pos.above()).isAir()) {
+                                placeBlockUnconditionallyWorldCoordinates(world, replacement, pos, boundingBox);
+                            }
+                        }
+                    }
+                }
+            }
+
+            // Martijn end - custom strongholds - more things
+
+        }
+
+        // Martijn start - custom strongholds - strongholds in water
+
+        public static final Block TEMPORARY_WATER = Blocks.WARPED_WART_BLOCK;
+
+        @Override
+        public void spreadWater(WorldGenLevel world) {
+            BlockPos fountainWaterPos = this.getWorldPos(5, 4, 5);
+            if (world.getBlockState(fountainWaterPos).is(Blocks.WATER)) {
+                this.placeBlockUnconditionally(world, TEMPORARY_WATER.defaultBlockState(), 5, 4, 5, boundingBox);
+            }
+            super.spreadWater(world);
+            if (world.getBlockState(fountainWaterPos).is(TEMPORARY_WATER)) {
+                this.placeBlockUnconditionally(world, Blocks.WATER.defaultBlockState(), 5, 4, 5, boundingBox);
+            }
         }
+
+        // Martijn end - custom strongholds - strongholds in water
+
     }
 
     static class SmoothStoneSelector extends StructurePiece.BlockSelector {
@@ -977,21 +1177,49 @@ public class StrongholdPieces {
         }
     }
 
+    // Martijn start - custom strongholds - surface strongholds
+    static class SmoothStoneSelectorOrTemporary extends StructurePiece.BlockSelector {
+        public static final Block TEMPORARY = Blocks.LIGHT;
+        @Override
+        public void next(RandomSource random, int x, int y, int z, boolean placeBlock) {
+            if (placeBlock) {
+                float f = random.nextFloat();
+                if (f < 0.2F) {
+                    this.next = Blocks.CRACKED_STONE_BRICKS.defaultBlockState();
+                } else if (f < 0.5F) {
+                    this.next = Blocks.MOSSY_STONE_BRICKS.defaultBlockState();
+                } else if (f < 0.55F) {
+                    this.next = Blocks.INFESTED_STONE_BRICKS.defaultBlockState();
+                } else {
+                    this.next = Blocks.STONE_BRICKS.defaultBlockState();
+                }
+            } else {
+                this.next = TEMPORARY.defaultBlockState();
+            }
+
+        }
+    }
+    // Martijn end - custom strongholds - surface strongholds
+
     public static class StairsDown extends StrongholdPieces.StrongholdPiece {
         private static final int WIDTH = 5;
         private static final int HEIGHT = 11;
         private static final int DEPTH = 5;
         private final boolean isSource;
 
-        public StairsDown(StructurePieceType structurePieceType, int chainLength, int x, int z, Direction orientation) {
-            super(structurePieceType, chainLength, makeBoundingBox(x, 64, z, orientation, 5, 11, 5));
+        // Martijn start - custom strongholds - surface strongholds
+        public StairsDown(StructurePieceType structurePieceType, int chainLength, int x, int z, Direction orientation, boolean isSurface) {
+            super(structurePieceType, chainLength, makeBoundingBox(x, 64, z, orientation, 5, 11, 5), isSurface);
+            // Martijn end - custom strongholds - surface strongholds
             this.isSource = true;
             this.setOrientation(orientation);
             this.entryDoor = StrongholdPieces.StrongholdPiece.SmallDoorType.OPENING;
         }
 
-        public StairsDown(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_STAIRS_DOWN, chainLength, boundingBox);
+        // Martijn start - custom strongholds - surface strongholds
+        public StairsDown(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_STAIRS_DOWN, chainLength, boundingBox, isSurface);
+            // Martijn end - custom strongholds - surface strongholds
             this.isSource = false;
             this.setOrientation(orientation);
             this.entryDoor = this.randomSmallDoor(random);
@@ -1021,14 +1249,17 @@ public class StrongholdPieces {
             this.generateSmallDoorChildForward((StrongholdPieces.StartPiece)start, holder, random, 1, 1);
         }
 
-        public static StrongholdPieces.StairsDown createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength) {
+        public static StrongholdPieces.StairsDown createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) { // Martijn - custom strongholds - surface strongholds
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -1, -7, 0, 5, 11, 5, orientation);
-            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.StairsDown(chainLength, random, boundingBox, orientation) : null;
+            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.StairsDown(chainLength, random, boundingBox, orientation, isSurface) : null; // Martijn - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
-            this.generateBox(world, chunkBox, 0, 0, 0, 4, 10, 4, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+        // Martijn start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Martijn end - custom strongholds - surface strongholds
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 4, 10, 4, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR); // Martijn - custom strongholds - holes in stronghold parts
             this.generateSmallDoor(world, random, chunkBox, this.entryDoor, 1, 7, 0);
             this.generateSmallDoor(world, random, chunkBox, StrongholdPieces.StrongholdPiece.SmallDoorType.OPENING, 1, 1, 4);
             this.placeBlock(world, Blocks.STONE_BRICKS.defaultBlockState(), 2, 6, 1, chunkBox);
@@ -1057,8 +1288,10 @@ public class StrongholdPieces {
         public StrongholdPieces.PortalRoom portalRoomPiece;
         public final List<StructurePiece> pendingChildren = Lists.newArrayList();
 
-        public StartPiece(RandomSource random, int i, int j) {
-            super(StructurePieceType.STRONGHOLD_START, 0, i, j, getRandomHorizontalDirection(random));
+        // Martijn start - custom strongholds - surface strongholds
+        public StartPiece(RandomSource random, int i, int j, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_START, 0, i, j, getRandomHorizontalDirection(random), isSurface);
+            // Martijn end - custom strongholds - surface strongholds
         }
 
         public StartPiece(CompoundTag nbt) {
@@ -1078,8 +1311,10 @@ public class StrongholdPieces {
         private final boolean leftChild;
         private final boolean rightChild;
 
-        public Straight(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_STRAIGHT, chainLength, boundingBox);
+        // Martijn start - custom strongholds - surface strongholds
+        public Straight(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_STRAIGHT, chainLength, boundingBox, isSurface);
+            // Martijn end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
             this.entryDoor = this.randomSmallDoor(random);
             this.leftChild = random.nextInt(2) == 0;
@@ -1112,14 +1347,17 @@ public class StrongholdPieces {
 
         }
 
-        public static StrongholdPieces.Straight createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength) {
+        public static StrongholdPieces.Straight createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) {
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -1, -1, 0, 5, 5, 7, orientation);
-            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.Straight(chainLength, random, boundingBox, orientation) : null;
+            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.Straight(chainLength, random, boundingBox, orientation, isSurface) : null; // Martijn - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
-            this.generateBox(world, chunkBox, 0, 0, 0, 4, 4, 6, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+        // Martijn start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Martijn end - custom strongholds - surface strongholds
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 4, 4, 6, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR); // Martijn - custom strongholds - holes in stronghold parts
             this.generateSmallDoor(world, random, chunkBox, this.entryDoor, 1, 1, 0);
             this.generateSmallDoor(world, random, chunkBox, StrongholdPieces.StrongholdPiece.SmallDoorType.OPENING, 1, 1, 6);
             BlockState blockState = Blocks.WALL_TORCH.defaultBlockState().setValue(WallTorchBlock.FACING, Direction.EAST);
@@ -1129,11 +1367,11 @@ public class StrongholdPieces {
             this.maybeGenerateBlock(world, chunkBox, random, 0.1F, 1, 2, 5, blockState);
             this.maybeGenerateBlock(world, chunkBox, random, 0.1F, 3, 2, 5, blockState2);
             if (this.leftChild) {
-                this.generateBox(world, chunkBox, 0, 1, 2, 0, 3, 4, CAVE_AIR, CAVE_AIR, false);
+                this.generateBox(world, chunkBox, 0, 1, 2, 0, 3, 4, CAVE_AIR, CAVE_AIR, this.isSurface); // Martijn - custom strongholds - surface strongholds
             }
 
             if (this.rightChild) {
-                this.generateBox(world, chunkBox, 4, 1, 2, 4, 3, 4, CAVE_AIR, CAVE_AIR, false);
+                this.generateBox(world, chunkBox, 4, 1, 2, 4, 3, 4, CAVE_AIR, CAVE_AIR, this.isSurface); // Martijn - custom strongholds - surface strongholds
             }
 
         }
@@ -1144,8 +1382,10 @@ public class StrongholdPieces {
         private static final int HEIGHT = 11;
         private static final int DEPTH = 8;
 
-        public StraightStairsDown(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_STRAIGHT_STAIRS_DOWN, chainLength, boundingBox);
+        // Martijn start - custom strongholds - surface strongholds
+        public StraightStairsDown(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_STRAIGHT_STAIRS_DOWN, chainLength, boundingBox, isSurface);
+            // Martijn end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
             this.entryDoor = this.randomSmallDoor(random);
         }
@@ -1159,22 +1399,49 @@ public class StrongholdPieces {
             this.generateSmallDoorChildForward((StrongholdPieces.StartPiece)start, holder, random, 1, 1);
         }
 
-        public static StrongholdPieces.StraightStairsDown createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength) {
+        public static StrongholdPieces.StraightStairsDown createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) { // Martijn - custom strongholds - surface strongholds
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -1, -7, 0, 5, 11, 8, orientation);
-            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.StraightStairsDown(chainLength, random, boundingBox, orientation) : null;
+            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.StraightStairsDown(chainLength, random, boundingBox, orientation, isSurface) : null; // Martijn - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
-            this.generateBox(world, chunkBox, 0, 0, 0, 4, 10, 7, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+        // Martijn start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Martijn end - custom strongholds - surface strongholds
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 4, 10, 7, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR); // Martijn - custom strongholds - holes in stronghold parts
             this.generateSmallDoor(world, random, chunkBox, this.entryDoor, 1, 7, 0);
             this.generateSmallDoor(world, random, chunkBox, StrongholdPieces.StrongholdPiece.SmallDoorType.OPENING, 1, 1, 7);
-            BlockState blockState = Blocks.COBBLESTONE_STAIRS.defaultBlockState().setValue(StairBlock.FACING, Direction.SOUTH);
+            // Martijn start - custom strongholds - stairs have more types
+            BlockState blockStateStairs1 = Blocks.COBBLESTONE_STAIRS.defaultBlockState().setValue(StairBlock.FACING, Direction.SOUTH);
+            BlockState blockStateStairs2 = Blocks.STONE_BRICK_STAIRS.defaultBlockState().setValue(StairBlock.FACING, Direction.SOUTH);
+            BlockState blockStateStairs3 = Blocks.STONE_STAIRS.defaultBlockState().setValue(StairBlock.FACING, Direction.SOUTH);
+            BlockState blockStateStairs4 = Blocks.COBBLESTONE_SLAB.defaultBlockState().setValue(SlabBlock.TYPE, SlabType.BOTTOM);
+            BlockState blockStateStairs5 = Blocks.STONE_BRICK_SLAB.defaultBlockState().setValue(SlabBlock.TYPE, SlabType.BOTTOM);
+            BlockState blockStateStairs6 = Blocks.STONE_SLAB.defaultBlockState().setValue(SlabBlock.TYPE, SlabType.BOTTOM);
+            // Martijn end - custom strongholds - stairs have more types
 
             for(int i = 0; i < 6; ++i) {
-                this.placeBlock(world, blockState, 1, 6 - i, 1 + i, chunkBox);
-                this.placeBlock(world, blockState, 2, 6 - i, 1 + i, chunkBox);
-                this.placeBlock(world, blockState, 3, 6 - i, 1 + i, chunkBox);
+                // Martijn start - custom strongholds - stairs have more types
+                for (int stairsX = 1; stairsX <= 3; stairsX++) {
+                    float f = random.nextFloat();
+                    BlockState stairsState;
+                    if (f < 0.55F) {
+                        stairsState = blockStateStairs1;
+                    } else if (f < 0.85F) {
+                        stairsState = blockStateStairs2;
+                    } else if (f < 0.9F) {
+                        stairsState = blockStateStairs3;
+                    } else if (f < 0.95F) {
+                        stairsState = blockStateStairs4;
+                    } else if (f < 0.975F) {
+                        stairsState = blockStateStairs5;
+                    } else {
+                        stairsState = blockStateStairs6;
+                    }
+                    this.placeBlock(world, stairsState, stairsX, 6 - i, 1 + i, chunkBox);
+                }
+                // Martijn end - custom strongholds - stairs have more types
                 if (i < 5) {
                     this.placeBlock(world, Blocks.STONE_BRICKS.defaultBlockState(), 1, 5 - i, 1 + i, chunkBox);
                     this.placeBlock(world, Blocks.STONE_BRICKS.defaultBlockState(), 2, 5 - i, 1 + i, chunkBox);
@@ -1187,25 +1454,155 @@ public class StrongholdPieces {
 
     abstract static class StrongholdPiece extends StructurePiece {
         protected StrongholdPieces.StrongholdPiece.SmallDoorType entryDoor = StrongholdPieces.StrongholdPiece.SmallDoorType.OPENING;
+        protected boolean isSurface = false; // Martijn - custom strongholds - surface strongholds
 
-        protected StrongholdPiece(StructurePieceType type, int length, BoundingBox boundingBox) {
+        protected StrongholdPiece(StructurePieceType type, int length, BoundingBox boundingBox, boolean isSurface) { // Martijn - custom strongholds - surface strongholds
             super(type, length, boundingBox);
+            this.isSurface = isSurface; // Martijn - custom strongholds - surface strongholds
         }
 
         public StrongholdPiece(StructurePieceType type, CompoundTag nbt) {
             super(type, nbt);
             this.entryDoor = StrongholdPieces.StrongholdPiece.SmallDoorType.valueOf(nbt.getString("EntryDoor"));
+            // Martijn start - custom strongholds - surface strongholds
+            if (nbt.contains("IsSurface")) {
+                this.isSurface = nbt.getBoolean("IsSurface");
+            }
+            // Martijn end - custom strongholds - surface strongholds
         }
 
         @Override
         protected void addAdditionalSaveData(StructurePieceSerializationContext context, CompoundTag nbt) {
             nbt.putString("EntryDoor", this.entryDoor.name());
+            nbt.putBoolean("IsSurface", this.isSurface); // Martijn - custom strongholds - surface strongholds
+        }
+
+        // Martijn start - custom strongholds - surface strongholds
+
+        @Override
+        protected void placeBlock(WorldGenLevel world, BlockState block, int x, int y, int z, BoundingBox box) {
+            if (this.isSurface) {
+                this.placeBlockConditionally(world, block, x, y, z, box);
+            } else {
+                super.placeBlock(world, block, x, y, z, box);
+            }
+        }
+
+        protected void placeBlockConditionally(WorldGenLevel world, BlockState block, int x, int y, int z, BoundingBox box) {
+            if (this.isSurface) {
+                this.placeBlockConditionally(world, block, x, y, z, box, false, false, false, false, true);
+            } else {
+                super.placeBlock(world, block, x, y, z, box);
+            }
+        }
+
+        protected void generateBoxConditionally(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState outline, BlockState inside, boolean cantReplaceAir, boolean cantReplaceLiquid) {
+            if (this.isSurface) {
+                this.generateBoxConditionally(world, box, minX, minY, minZ, maxX, maxY, maxZ, outline, inside, cantReplaceAir, cantReplaceLiquid, false, false, true);
+            } else {
+                super.generateBox(world, box, minX, minY, minZ, maxX, maxY, maxZ, outline, inside, cantReplaceAir, cantReplaceLiquid);
+            }
+        }
+
+        protected void generateBoxConditionally(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState outline, BlockState inside, boolean cantReplaceAir) {
+            this.generateBoxConditionally(world, box, minX, minY, minZ, maxX, maxY, maxZ, outline, inside, cantReplaceAir, cantReplaceAir);
+        }
+
+        protected boolean generateBoxConditionally(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, RandomSource random, StructurePiece.BlockSelector randomizer) {
+            // Below is replaced with a dumber version because it seems that otherwise, the server gets stuck in CIRCULAR chunk dependency
+            // ^ Reverted replacement
+            return this.generateBoxConditionally(world, box, minX, minY, minZ, maxX, maxY, maxZ, false, false, false, false, true, random, randomizer);
+//            this.generateBox(world, box, minX, minY, minZ, maxX, maxY, maxZ, this.isSurface, this.isSurface, random, randomizer);
+//            return true; // Meaningless
         }
 
+        protected boolean generateBoxConditionally(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState outline, BlockState inside) {
+            // Below is replaced with a dumber version because it seems that otherwise, the server gets stuck in CIRCULAR chunk dependency
+            // ^ Reverted replacement
+            return this.generateBoxConditionally(world, box, minX, minY, minZ, maxX, maxY, maxZ, outline, inside, false, false, false, false, true);
+//            this.generateBox(world, box, minX, minY, minZ, maxX, maxY, maxZ, outline, inside, this.isSurface, this.isSurface);
+//            return true; // Meaningless
+        }
+
+        @Override
+        protected void generateAirBox(WorldGenLevel world, BoundingBox bounds, int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {
+            this.generateAirBox(world, bounds, minX, minY, minZ, maxX, maxY, maxZ, this.isSurface);
+        }
+
+        @Override
+        protected boolean createChest(WorldGenLevel world, BoundingBox boundingBox, RandomSource random, int x, int y, int z, ResourceLocation lootTableId) {
+            return this.createChest(world, boundingBox, random, x, y, z, lootTableId, true);
+        }
+
+        @Override
+        protected boolean createChest(ServerLevelAccessor world, BoundingBox boundingBox, RandomSource random, BlockPos pos, ResourceLocation lootTableId, @Nullable BlockState block) {
+            return this.createChest(world, boundingBox, random, pos, lootTableId, block, true);
+        }
+
+        // Martijn end - custom strongholds - surface strongholds
+
+        // Martijn start - custom strongholds - strongholds in water
+
+        @Override
+        protected void generateBox(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState outline, BlockState inside, boolean cantReplaceAir) {
+            this.generateBox(world, box, minX, minY, minZ, maxX, maxY, maxZ, outline, inside, cantReplaceAir, cantReplaceAir);
+        }
+
+        @Override
+        protected void generateBox(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, BlockState outline, BlockState inside, boolean cantReplaceAir) {
+            this.generateBox(world, box, fillBox, outline, inside, cantReplaceAir, cantReplaceAir);
+        }
+
+        @Override
+        protected void generateBox(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer) {
+            this.generateBox(world, box, minX, minY, minZ, maxX, maxY, maxZ, cantReplaceAir, cantReplaceAir, random, randomizer);
+        }
+
+        @Override
+        protected void generateBox(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer) {
+            this.generateBox(world, box, fillBox, cantReplaceAir, cantReplaceAir, random, randomizer);
+        }
+
+        // Martijn start - custom strongholds - holes in stronghold parts
+
+        @Override
+        protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer, BlockState newAir) {
+            this.generateBoxWithPartiallyOpenCeiling(world, box, minX, minY, minZ, maxX, maxY, maxZ, cantReplaceAir, cantReplaceAir, random, randomizer, newAir);
+        }
+
+        @Override
+        protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer, BlockState newAir) {
+            this.generateBoxWithPartiallyOpenCeiling(world, box, fillBox, cantReplaceAir, cantReplaceAir, random, randomizer, newAir);
+        }
+
+        @Override
+        protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer) {
+            this.generateBoxWithPartiallyOpenCeiling(world, box, minX, minY, minZ, maxX, maxY, maxZ, cantReplaceAir, random, randomizer, Blocks.CAVE_AIR.defaultBlockState());
+        }
+
+        @Override
+        protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer) {
+            this.generateBoxWithPartiallyOpenCeiling(world, box, fillBox, cantReplaceAir, random, randomizer, Blocks.CAVE_AIR.defaultBlockState());
+        }
+
+        // Martijn end - custom strongholds - holes in stronghold parts
+
+        @Override
+        protected void generateMaybeBox(WorldGenLevel world, BoundingBox box, RandomSource random, float blockChance, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState outline, BlockState inside, boolean cantReplaceAir, boolean stayBelowSeaLevel) {
+            this.generateMaybeBox(world, box, random, blockChance, minX, minY, minZ, maxX, maxY, maxZ, outline, inside, cantReplaceAir, cantReplaceAir, stayBelowSeaLevel);
+        }
+
+        @Override
+        protected void generateUpperHalfSphere(WorldGenLevel world, BoundingBox bounds, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState block, boolean cantReplaceAir) {
+            this.generateUpperHalfSphere(world, bounds, minX, minY, minZ, maxX, maxY, maxZ, block, cantReplaceAir, cantReplaceAir);
+        }
+
+        // Martijn end - custom strongholds - strongholds in water
+
         protected void generateSmallDoor(WorldGenLevel world, RandomSource random, BoundingBox boundingBox, StrongholdPieces.StrongholdPiece.SmallDoorType type, int x, int y, int z) {
             switch (type) {
                 case OPENING:
-                    this.generateBox(world, boundingBox, x, y, z, x + 3 - 1, y + 3 - 1, z, CAVE_AIR, CAVE_AIR, false);
+                    this.generateBox(world, boundingBox, x, y, z, x + 3 - 1, y + 3 - 1, z, CAVE_AIR, CAVE_AIR, this.isSurface); // Martijn - custom strongholds - surface strongholds
                     break;
                 case WOOD_DOOR:
                     this.placeBlock(world, Blocks.STONE_BRICKS.defaultBlockState(), x, y, z, boundingBox);
@@ -1267,13 +1664,13 @@ public class StrongholdPieces {
             if (direction != null) {
                 switch (direction) {
                     case NORTH:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() - 1, direction, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() - 1, direction, this.getGenDepth(), this.isSurface); // Martijn - custom strongholds - surface strongholds
                     case SOUTH:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.maxZ() + 1, direction, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.maxZ() + 1, direction, this.getGenDepth(), this.isSurface); // Martijn - custom strongholds - surface strongholds
                     case WEST:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() - 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, direction, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() - 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, direction, this.getGenDepth(), this.isSurface); // Martijn - custom strongholds - surface strongholds
                     case EAST:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.maxX() + 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, direction, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.maxX() + 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, direction, this.getGenDepth(), this.isSurface); // Martijn - custom strongholds - surface strongholds
                 }
             }
 
@@ -1286,13 +1683,13 @@ public class StrongholdPieces {
             if (direction != null) {
                 switch (direction) {
                     case NORTH:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() - 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, Direction.WEST, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() - 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, Direction.WEST, this.getGenDepth(), this.isSurface); // Martijn - custom strongholds - surface strongholds
                     case SOUTH:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() - 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, Direction.WEST, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() - 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, Direction.WEST, this.getGenDepth(), this.isSurface); // Martijn - custom strongholds - surface strongholds
                     case WEST:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() - 1, Direction.NORTH, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() - 1, Direction.NORTH, this.getGenDepth(), this.isSurface); // Martijn - custom strongholds - surface strongholds
                     case EAST:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() - 1, Direction.NORTH, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() - 1, Direction.NORTH, this.getGenDepth(), this.isSurface); // Martijn - custom strongholds - surface strongholds
                 }
             }
 
@@ -1305,13 +1702,13 @@ public class StrongholdPieces {
             if (direction != null) {
                 switch (direction) {
                     case NORTH:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.maxX() + 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, Direction.EAST, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.maxX() + 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, Direction.EAST, this.getGenDepth(), this.isSurface); // Martijn - custom strongholds - surface strongholds
                     case SOUTH:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.maxX() + 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, Direction.EAST, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.maxX() + 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, Direction.EAST, this.getGenDepth(), this.isSurface); // Martijn - custom strongholds - surface strongholds
                     case WEST:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.maxZ() + 1, Direction.SOUTH, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.maxZ() + 1, Direction.SOUTH, this.getGenDepth(), this.isSurface); // Martijn - custom strongholds - surface strongholds
                     case EAST:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.maxZ() + 1, Direction.SOUTH, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.maxZ() + 1, Direction.SOUTH, this.getGenDepth(), this.isSurface); // Martijn - custom strongholds - surface strongholds
                 }
             }
 
@@ -1328,6 +1725,196 @@ public class StrongholdPieces {
             GRATES,
             IRON_DOOR;
         }
+
+        // Martijn start - custom strongholds - surface strongholds
+
+        protected void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {}
+
+        @Override
+        public final void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            this.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            this.postPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+        }
+
+        // Martijn start - custom strongholds - more things
+
+        public boolean areAddedCandlesLit() {
+            return false;
+        }
+
+        private @NotNull BlockState @Nullable [] addedCandleStates = null;
+
+        public BlockState[] getAddedCandleStates() {
+            if (addedCandleStates == null) {
+                List<BlockState> addedCandleStatesList = new ArrayList<>();
+                for (Block candleBlock : new Block[] {
+                    Blocks.CANDLE, Blocks.CANDLE, Blocks.CANDLE,
+                    Blocks.WHITE_CANDLE,
+                    Blocks.GRAY_CANDLE, Blocks.GRAY_CANDLE,
+                    Blocks.LIGHT_GRAY_CANDLE,
+                    Blocks.BLACK_CANDLE, Blocks.BLACK_CANDLE,
+                    Blocks.BROWN_CANDLE, Blocks.BROWN_CANDLE,
+                    Blocks.GREEN_CANDLE
+                }) {
+                    for (int amount = CandleBlock.MIN_CANDLES; amount <= CandleBlock.MAX_CANDLES; amount++) {
+                        BlockState addedCandleState = candleBlock.defaultBlockState().setValue(BlockStateProperties.WATERLOGGED, false).setValue(BlockStateProperties.LIT, areAddedCandlesLit()).setValue(BlockStateProperties.CANDLES, amount);
+                        for (int timesAdded = 0; timesAdded < (amount == CandleBlock.MIN_CANDLES ? 3 : amount == CandleBlock.MAX_CANDLES ? 1 : 2); timesAdded++) {
+                            addedCandleStatesList.add(addedCandleState);
+                        }
+                    }
+                }
+                addedCandleStates = addedCandleStatesList.toArray(BlockState[]::new);
+            }
+            return addedCandleStates;
+        }
+
+        // Martijn end - custom strongholds - more things
+
+        public final void postPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            // Replace temporary air-representing blocks by air
+            this.replace(world, chunkBox, SmoothStoneSelectorOrTemporary.TEMPORARY, Blocks.CAVE_AIR.defaultBlockState());
+            // Fix blocks being invalid in their location (for example grass unsupported by a block below)
+            for (int x = this.boundingBox.minX(); x <= this.boundingBox.maxX(); x++) {
+                for (int y = this.boundingBox.minY(); y <= this.boundingBox.maxY() + 4/* should need only 2 but taking 4 as extra margin just in case */; y++) {
+                    for (int z = this.boundingBox.minZ(); z <= this.boundingBox.maxZ(); z++) {
+                        BlockPos pos = new BlockPos(x, y, z);
+                        BlockState block = world.getBlockState(pos);
+                        BlockState newBlock = null;
+                        boolean isUnstableAndMustBeRemoved = false;
+                        if (y <= this.boundingBox.maxY()) {
+                            // Remove single door pieces
+                            if (block.is(BlockTags.DOORS)) {
+                                BlockState blockAbove = world.getBlockState(pos.above());
+                                if (!(world.getBlockState(pos.below()).is(BlockTags.DOORS) || blockAbove.is(BlockTags.DOORS))) {
+                                    Optional<Boolean> waterlogged = block.getOptionalValue(BlockStateProperties.WATERLOGGED);
+                                    Optional<Boolean> waterloggedAbove = blockAbove.getOptionalValue(BlockStateProperties.WATERLOGGED);
+                                    if ((waterlogged.isPresent() && waterlogged.get()) || blockAbove.is(Blocks.WATER) || (waterloggedAbove.isPresent() && waterloggedAbove.get())) {
+                                        newBlock = Blocks.WATER.defaultBlockState();
+                                    } else if (blockAbove.is(Blocks.LAVA)) {
+                                        newBlock = Blocks.LAVA.defaultBlockState();
+                                    } else {
+                                        newBlock = Blocks.CAVE_AIR.defaultBlockState();
+                                    }
+                                }
+                            }
+                        }
+                        // Fix floating grass and similar blocks that rely on a supporting solid block on a specific side
+                        if (block.is(BlockTags.TALL_FLOWERS) || block.is(Blocks.TALL_GRASS) || block.is(Blocks.TALL_SEAGRASS) || block.is(Blocks.LARGE_FERN) || block.is(BlockTags.FLOWERS) || block.is(Blocks.GRASS) || block.is(Blocks.SEAGRASS) || block.is(Blocks.FERN) || block.is(Blocks.KELP_PLANT) || block.is(Blocks.KELP) || block.is(Blocks.RED_MUSHROOM) || block.is(Blocks.BROWN_MUSHROOM) || block.is(Blocks.DEAD_BUSH)) {
+                            if (!StructurePiece.hasRelativeSolid(world, pos, Direction.DOWN)) {
+                                isUnstableAndMustBeRemoved = true;
+                            }
+                        } else if (block.is(Blocks.VINE) || block.is(Blocks.GLOW_LICHEN) || block.is(Blocks.SCULK_VEIN)) {
+                            if (block.getValue(BlockStateProperties.UP) && !StructurePiece.hasRelativeSolid(world, pos, Direction.UP)) {
+                                isUnstableAndMustBeRemoved = true;
+                            } else if (!block.is(Blocks.VINE) && block.getValue(BlockStateProperties.DOWN) && !StructurePiece.hasRelativeSolid(world, pos, Direction.DOWN)) {
+                                isUnstableAndMustBeRemoved = true;
+                            } else if (block.getValue(BlockStateProperties.EAST) && !StructurePiece.hasRelativeSolid(world, pos, Direction.EAST)) {
+                                isUnstableAndMustBeRemoved = true;
+                            } else if (block.getValue(BlockStateProperties.WEST) && !StructurePiece.hasRelativeSolid(world, pos, Direction.WEST)) {
+                                isUnstableAndMustBeRemoved = true;
+                            } else if (block.getValue(BlockStateProperties.NORTH) && !StructurePiece.hasRelativeSolid(world, pos, Direction.NORTH)) {
+                                isUnstableAndMustBeRemoved = true;
+                            } else if (block.getValue(BlockStateProperties.SOUTH) && !StructurePiece.hasRelativeSolid(world, pos, Direction.SOUTH)) {
+                                isUnstableAndMustBeRemoved = true;
+                            }
+                        } else if (block.is(Blocks.LADDER) || block.is(Blocks.WALL_TORCH)) {
+                            if (!StructurePiece.hasRelativeSolid(world, pos, block.getValue(BlockStateProperties.HORIZONTAL_FACING))) {
+                                isUnstableAndMustBeRemoved = true;
+                            }
+                        }
+                        if (isUnstableAndMustBeRemoved) {
+                            BlockState blockAbove = world.getBlockState(pos.above());
+                            Optional<Boolean> waterlogged = block.getOptionalValue(BlockStateProperties.WATERLOGGED);
+                            Optional<Boolean> waterloggedAbove = blockAbove.getOptionalValue(BlockStateProperties.WATERLOGGED);
+                            if ((waterlogged.isPresent() && waterlogged.get()) || blockAbove.is(Blocks.WATER) || (waterloggedAbove.isPresent() && waterloggedAbove.get())) {
+                                newBlock = Blocks.WATER.defaultBlockState();
+                            } else if (blockAbove.is(Blocks.LAVA)) {
+                                newBlock = Blocks.LAVA.defaultBlockState();
+                            } else if (y > boundingBox.maxY()) {
+                                newBlock = Blocks.AIR.defaultBlockState();
+                            } else {
+                                newBlock = Blocks.CAVE_AIR.defaultBlockState();
+                            }
+                        }
+                        // Replace the state if needed
+                        if (newBlock != null) {
+                            world.setBlock(pos, newBlock, 2);
+                            FluidState fluidState = world.getFluidState(pos);
+                            if (!fluidState.isEmpty()) {
+                                world.scheduleTick(pos, fluidState.getType(), 0);
+                            }
+
+                            if (StructurePiece.SHAPE_CHECK_BLOCKS.contains(block.getBlock())) {
+                                world.getChunk(pos).markPosForPostprocessing(pos);
+                            }
+                        }
+                    }
+                }
+            }
+            // Spread water
+            this.spreadWater(world); // Martijn - custom strongholds - strongholds in water
+            // Martijn start - custom strongholds - more things
+            // Maybe replace some air around the edges with candles
+            BlockState[] addedCandleStates = getAddedCandleStates();
+            GlobalConfiguration.CustomStrongholds.AddCandles candlesConfig = GlobalConfiguration.get().customStrongholds.addCandles;
+            for (GlobalConfiguration.CustomStrongholds.AddCandles.Opportunity opportunity : candlesConfig.getOpportunities()) {
+                if (random.nextFloat() < opportunity.chance) {
+                    this.replace(world, boundingBox, Blocks.CAVE_AIR, addedCandleStates[random.nextInt(addedCandleStates.length)], random, opportunity.ratio, true, false, false, pos -> (pos.getLeft() == boundingBox.minX() + 1 || pos.getLeft() == boundingBox.maxX() - 1) && (pos.getRight() == boundingBox.minZ() + 1 || pos.getRight() == boundingBox.maxZ() - 1));
+                    break;
+                }
+            }
+            // Maybe replace some air with cobwebs
+            GlobalConfiguration.CustomStrongholds.MoreCobwebs cobwebConfig = GlobalConfiguration.get().customStrongholds.moreCobwebs;
+            for (GlobalConfiguration.CustomStrongholds.MoreCobwebs.Opportunity opportunity : cobwebConfig.getOpportunities()) {
+                if (random.nextFloat() < opportunity.chance) {
+                    this.replace(world, boundingBox, Blocks.CAVE_AIR, Blocks.COBWEB.defaultBlockState(), random, opportunity.ratio, false, false, true);
+                    break;
+                }
+            }
+            // Martijn end - custom strongholds - more things
+        }
+
+        // Martijn end - custom strongholds - surface strongholds
+
+        // Martijn start - custom strongholds - strongholds in water
+
+        public void spreadWater(WorldGenLevel world) {
+            // Spread water horizontally and downwards
+            int maxCycles = 100;
+            while (maxCycles-->0) {
+                boolean changesThisCycle = false;
+                for (int x = this.boundingBox.minX(); x <= this.boundingBox.maxX(); x++) {
+                    for (int y = this.boundingBox.minY(); y <= this.boundingBox.maxY(); y++) {
+                        for (int z = this.boundingBox.minZ(); z <= this.boundingBox.maxZ(); z++) {
+                            BlockPos pos = new BlockPos(x, y, z);
+                            BlockState block = world.getBlockState(pos);
+                            Optional<Boolean> waterlogged = block.getOptionalValue(BlockStateProperties.WATERLOGGED);
+                            if (canBeFilledUpByWaterSourceIfWaterFlowsIn(block) || (waterlogged.isPresent() && !waterlogged.get())) {
+                                BlockState newBlock = getAnyRelativeLiquidDefaultBlockState(world, pos, besideOrAboveDirections);
+                                if (newBlock != null && !newBlock.equals(block)) {
+                                    changesThisCycle = true;
+                                    world.setBlock(pos, newBlock, 2);
+                                    FluidState fluidState = world.getFluidState(pos);
+                                    if (!fluidState.isEmpty()) {
+                                        world.scheduleTick(pos, fluidState.getType(), 0);
+                                    }
+
+                                    if (StructurePiece.SHAPE_CHECK_BLOCKS.contains(block.getBlock())) {
+                                        world.getChunk(pos).markPosForPostprocessing(pos);
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+                if (!changesThisCycle) {
+                    break;
+                }
+            }
+        }
+
+        // Martijn start - custom strongholds - strongholds in water
+
     }
 
     public abstract static class Turn extends StrongholdPieces.StrongholdPiece {
@@ -1335,8 +1922,10 @@ public class StrongholdPieces {
         protected static final int HEIGHT = 5;
         protected static final int DEPTH = 5;
 
-        protected Turn(StructurePieceType type, int length, BoundingBox boundingBox) {
-            super(type, length, boundingBox);
+        // Martijn start - custom strongholds - surface strongholds
+        protected Turn(StructurePieceType type, int length, BoundingBox boundingBox, boolean isSurface) {
+            super(type, length, boundingBox, isSurface);
+            // Martijn end - custom strongholds - surface strongholds
         }
 
         public Turn(StructurePieceType type, CompoundTag nbt) {
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/structures/StrongholdStructure.java b/src/main/java/net/minecraft/world/level/levelgen/structure/structures/StrongholdStructure.java
index f0bc479d3dfb4df09c61f6bc87f4a124e39c352d..4bd881cf09432ce67519825e5d910010ac7d025a 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/structures/StrongholdStructure.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/structures/StrongholdStructure.java
@@ -1,36 +1,143 @@
 package net.minecraft.world.level.levelgen.structure.structures;
 
 import com.mojang.serialization.Codec;
+
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Optional;
+import java.util.Random;
+
+import com.mojang.serialization.codecs.RecordCodecBuilder;
+import io.papermc.paper.configuration.GlobalConfiguration;
+import io.papermc.paper.world.structure.ConfiguredStructure;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Holder;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.tags.BiomeTags;
+import net.minecraft.util.RandomSource;
+import net.minecraft.util.StringRepresentable;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LevelHeightAccessor;
+import net.minecraft.world.level.StructureManager;
+import net.minecraft.world.level.WorldGenLevel;
+import net.minecraft.world.level.biome.Biome;
+import net.minecraft.world.level.biome.BiomeSource;
+import net.minecraft.world.level.biome.Biomes;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkGenerator;
+import net.minecraft.world.level.levelgen.WorldgenRandom;
+import net.minecraft.world.level.levelgen.structure.BoundingBox;
 import net.minecraft.world.level.levelgen.structure.Structure;
 import net.minecraft.world.level.levelgen.structure.StructurePiece;
 import net.minecraft.world.level.levelgen.structure.StructureType;
+import net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePiecesBuilder;
+import nl.martijnmuijsers.paper.biome.SuCraftBiomeTags;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.Nullable;
 
 public class StrongholdStructure extends Structure {
-    public static final Codec<StrongholdStructure> CODEC = simpleCodec(StrongholdStructure::new);
 
-    public StrongholdStructure(Structure.StructureSettings config) {
+    // Martijn start - custom strongholds - surface strongholds
+
+    public static final Codec<StrongholdStructure> CODEC = RecordCodecBuilder.create(instance ->
+        instance.group(settingsCodec(instance), Codec.BOOL.optionalFieldOf("is_surface").forGetter(structure ->
+            Optional.of(structure.isSurface)
+        )).apply(instance, StrongholdStructure::new)
+    );
+
+    public final boolean isSurface;
+
+    public StrongholdStructure(Structure.StructureSettings config, Optional<Boolean> isSurface) {
+        this(config, isSurface.orElse(false));
+    }
+
+    public StrongholdStructure(Structure.StructureSettings config, boolean isSurface) {
         super(config);
+        this.isSurface = isSurface;
     }
 
+    // Martijn end - custom strongholds - surface strongholds
+
     @Override
     public Optional<Structure.GenerationStub> findGenerationPoint(Structure.GenerationContext context) {
         return Optional.of(new Structure.GenerationStub(context.chunkPos().getWorldPosition(), (collector) -> {
-            generatePieces(collector, context);
+            generatePieces(collector, context, this.isSurface); // Martijn - custom strongholds - surface strongholds
         }));
     }
 
-    private static void generatePieces(StructurePiecesBuilder collector, Structure.GenerationContext context) {
+    // Martijn start - custom strongholds - surface strongholds
+
+    public static @Nullable Holder<Biome> getBiomeDuringGeneration(Structure.GenerationContext context, BlockPos blockPos) {
+        try {
+            return context.biomeSource().getNoiseBiome(blockPos.getX(), blockPos.getY(), blockPos.getZ(), context.randomState().sampler());
+        } catch (Exception e) {}
+        return null;
+    }
+
+    public static @Nullable Holder<Biome> getBiomeDuringGeneration(Structure.GenerationContext context) {
+        Holder<Biome> biome = null;
+        try {
+            return getBiomeDuringGeneration(context, context.chunkPos().getMiddleBlockPosition(context.chunkGenerator().getSeaLevel()));
+        } catch (Exception e) {}
+        return null;
+    }
+
+    // Martijn end - custom strongholds - surface strongholds
+
+    private static void generatePieces(StructurePiecesBuilder collector, Structure.GenerationContext context, boolean isSurface) { // Martijn - custom strongholds - surface strongholds
         int i = 0;
 
+        // Martijn start - custom strongholds - surface strongholds
+
+        // We determine a possible block amount to vertically raise the stronghold by
+        // (or null if we do not move this stronghold to the surface)
+        Integer potentialExtraIncreasedY = 0;
+        RandomSource surfaceStrongholdRandom = context.random().fork();
+        if (isSurface/*surfaceStrongholdRandom.nextDouble() < GlobalConfiguration.get().customStrongholds.moveToSurfaceChance*/) {
+            @Nullable Holder<Biome> biome = getBiomeDuringGeneration(context);
+            // Only move strongholds to the surface in some biomes (particularly excluding otherworldly or watery biomes)
+            if (biome != null) {
+                if (!(biome.is(BiomeTags.IS_BEACH) || biome.is(BiomeTags.IS_OCEAN) || biome.is(BiomeTags.IS_DEEP_OCEAN) || biome.is(BiomeTags.IS_NETHER) || biome.is(BiomeTags.IS_END) || biome.is(BiomeTags.HAS_SHIPWRECK) || biome.is(BiomeTags.HAS_SHIPWRECK_BEACHED) || biome.is(BiomeTags.HAS_OCEAN_MONUMENT) || biome.is(BiomeTags.HAS_OCEAN_RUIN_COLD) || biome.is(BiomeTags.HAS_OCEAN_RUIN_WARM) || biome.is(BiomeTags.HAS_RUINED_PORTAL_OCEAN) || biome.is(BiomeTags.IS_RIVER))) {
+                    // Potentially move the stronghold vertically up some extra
+                    potentialExtraIncreasedY = GlobalConfiguration.get().customStrongholds.potentialExtraIncreasedY.all;
+                    if (biome.is(Biomes.BADLANDS) || biome.is(Biomes.ERODED_BADLANDS) || biome.is(Biomes.WOODED_BADLANDS)) {
+                        potentialExtraIncreasedY = Math.max(potentialExtraIncreasedY, GlobalConfiguration.get().customStrongholds.potentialExtraIncreasedY.badlands);
+                    }
+                    if (biome.is(Biomes.SAVANNA_PLATEAU)) {
+                        potentialExtraIncreasedY = Math.max(potentialExtraIncreasedY, GlobalConfiguration.get().customStrongholds.potentialExtraIncreasedY.plateau);
+                    }
+                    if (biome.is(Biomes.WINDSWEPT_FOREST) || biome.is(Biomes.WINDSWEPT_HILLS) || biome.is(Biomes.WINDSWEPT_GRAVELLY_HILLS) || biome.is(Biomes.WINDSWEPT_SAVANNA)) {
+                        potentialExtraIncreasedY = Math.max(potentialExtraIncreasedY, GlobalConfiguration.get().customStrongholds.potentialExtraIncreasedY.windswept);
+                    }
+                    if (biome.is(BiomeTags.IS_MOUNTAIN)) {
+                        potentialExtraIncreasedY = Math.max(potentialExtraIncreasedY, GlobalConfiguration.get().customStrongholds.potentialExtraIncreasedY.mountain);
+                    }
+                    if (biome.is(BiomeTags.IS_HILL)) {
+                        potentialExtraIncreasedY = Math.max(potentialExtraIncreasedY, GlobalConfiguration.get().customStrongholds.potentialExtraIncreasedY.hill);
+                    }
+                }
+            }
+        }
+
+        // Martijn end - custom strongholds - surface strongholds
+
+        final int minYDifferenceBetweenPortalRoomAndStartPiece = context.random().nextIntBetweenInclusive(
+            GlobalConfiguration.get().customStrongholds.minimumPortalRoomYDifference.min,
+            GlobalConfiguration.get().customStrongholds.minimumPortalRoomYDifference.max
+        );
+
         StrongholdPieces.StartPiece startPiece;
-        do {
+        // Martijn start - custom strongholds - surface strongholds
+        int maxCyclesBeforeAllowEndPortalInWrongBiome = 1000;
+        int maxCyclesBeforeAllowHighEndPortal = 2000;
+        for (int cycle = 0;; cycle++) {
+            // Martijn end - custom strongholds - surface strongholds
             collector.clear();
             context.random().setLargeFeatureSeed(context.seed() + (long)(i++), context.chunkPos().x, context.chunkPos().z);
             StrongholdPieces.resetPieces();
-            startPiece = new StrongholdPieces.StartPiece(context.random(), context.chunkPos().getBlockX(2), context.chunkPos().getBlockZ(2));
+            startPiece = new StrongholdPieces.StartPiece(context.random(), context.chunkPos().getBlockX(2), context.chunkPos().getBlockZ(2), isSurface);
             collector.addPiece(startPiece);
             startPiece.addChildren(startPiece, collector, context.random());
             List<StructurePiece> list = startPiece.pendingChildren;
@@ -41,13 +148,120 @@ public class StrongholdStructure extends Structure {
                 structurePiece.addChildren(startPiece, collector, context.random());
             }
 
+            // Martijn start - custom strongholds - bigger strongholds
+            if (collector.isEmpty()) {
+                Bukkit.getLogger().info("Failed a stronghold generation (isSurface = " + isSurface + "): pieces empty");
+                continue;
+            } else if (startPiece.portalRoomPiece == null) {
+                Bukkit.getLogger().info("Failed a stronghold generation (isSurface = " + isSurface + "): no end portal");
+                continue;
+                // Martijn start - custom strongholds - surface strongholds
+            } else if (cycle < maxCyclesBeforeAllowHighEndPortal && isSurface && startPiece.portalRoomPiece.getBoundingBox().getCenter().getY() >= startPiece.getBoundingBox().getCenter().getY() - minYDifferenceBetweenPortalRoomAndStartPiece) {
+                Bukkit.getLogger().info("Failed a stronghold generation (isSurface = " + isSurface + "): end portal not low enough");
+                continue;
+            }
+            boolean isPortalRoomValidBiome;
+            if (isSurface) {
+                boolean[] areAllPortalRoomCornersValidBiome = {true}; // Use an array so we can modify it inside the lambda function below
+                final StrongholdPieces.StartPiece finalStartPiece = startPiece;
+                final BoundingBox portalRoomBoundingBox = startPiece.portalRoomPiece.getBoundingBox();
+                portalRoomBoundingBox.forAllCorners(cornerPos -> {
+                    if (!areAllPortalRoomCornersValidBiome[0]) { // Skip the other corners if we already know another corner is in an invalid biome
+                        return;
+                    }
+                    @Nullable Holder<Biome> biome = getBiomeDuringGeneration(context, cornerPos);
+                    if (biome == null) {
+                        return; // We don't know, and we probably won't ever find out, so we just have to assume it will be fine
+                    }
+                    if (!biome.is(SuCraftBiomeTags.HAS_STRONGHOLD_SURFACE)) {
+                        areAllPortalRoomCornersValidBiome[0] = false;
+                    }
+                });
+                isPortalRoomValidBiome = areAllPortalRoomCornersValidBiome[0];
+//                if (isPortalRoomValidBiome) {
+//                    if (context.heightAccessor() instanceof ChunkAccess chunkAccess) {
+//                        int waterAmount = 0;
+//                        for (int x = portalRoomBoundingBox.minX(); x <= portalRoomBoundingBox.maxX(); x++) {
+//                            for (int z = portalRoomBoundingBox.minZ(); z <= portalRoomBoundingBox.maxZ(); z++) {
+//                                chunkAccess.getBlockState(x, 61, z)
+//                            }
+//                        }
+//                    }
+//                }
+            } else {
+                isPortalRoomValidBiome = true;
+            }
+            if (!isPortalRoomValidBiome) {
+                if (cycle < maxCyclesBeforeAllowEndPortalInWrongBiome) {
+                    Bukkit.getLogger().info("Failed a stronghold generation (isSurface = " + isSurface + "): end portal not in right biome");
+                    continue;
+                }
+                potentialExtraIncreasedY = null; // Move the stronghold down after all
+            }
+            break;
+        }
+        // Martijn end - custom strongholds - bigger strongholds
+
+        // Martijn start - custom strongholds - surface strongholds
+
+        if (isSurface && potentialExtraIncreasedY != null) {
+            int standardDecreasedY = GlobalConfiguration.get().customStrongholds.decreasedY.always;
+            int potentialExtraDecreasedY = GlobalConfiguration.get().customStrongholds.decreasedY.potentialExtra;
+            int extraIncreasedY = surfaceStrongholdRandom.nextInt(potentialExtraIncreasedY + 1) - standardDecreasedY - surfaceStrongholdRandom.nextInt(potentialExtraDecreasedY + 1);
+            Bukkit.getLogger().info("To create more surface strongholds, vertically offsetting stronghold at block " + context.chunkPos().getBlockX(2) + " , " + context.chunkPos().getBlockZ(2) + " by " + extraIncreasedY + " and not moving it downwards on purpose");
+            collector.offsetPiecesVertically(extraIncreasedY);
+        } else {
             collector.moveBelowSeaLevel(context.chunkGenerator().getSeaLevel(), context.chunkGenerator().getMinY(), context.random(), 10);
-        } while(collector.isEmpty() || startPiece.portalRoomPiece == null);
+        }
+
+        // Martijn end - custom strongholds - surface strongholds
 
     }
 
+    // Martijn start - custom strongholds - surface strongholds
+
     @Override
     public StructureType<?> type() {
         return StructureType.STRONGHOLD;
     }
+
+    public static enum Type implements StringRepresentable {
+        WARM("is_surface"),
+        COLD("cold");
+
+        public static final Codec<OceanRuinStructure.Type> CODEC = StringRepresentable.fromEnum(OceanRuinStructure.Type::values);
+        private final String name;
+
+        private Type(String name) {
+            this.name = name;
+        }
+
+        public String getName() {
+            return this.name;
+        }
+
+        @Override
+        public String getSerializedName() {
+            return this.name;
+        }
+    }
+
+    // Martijn end - custom strongholds - surface strongholds
+
+    // Martijn start - custom strongholds - strongholds in water
+
+    @Override
+    public void afterPlace(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox box, ChunkPos chunkPos, PiecesContainer pieces) {
+        super.afterPlace(world, structureAccessor, chunkGenerator, random, box, chunkPos, pieces);
+        pieces.pieces().forEach(piece -> {
+            if (piece instanceof StrongholdPieces.StrongholdPiece strongholdPiece) {
+                if (piece.getBoundingBox().intersects(box)) {
+                    strongholdPiece.spreadWater(world);
+                }
+            }
+        });
+    }
+
+    // Martijn end - custom strongholds - strongholds in water
+
 }
diff --git a/src/main/java/nl/martijnmuijsers/paper/biome/SuCraftBiomeTags.java b/src/main/java/nl/martijnmuijsers/paper/biome/SuCraftBiomeTags.java
index bde00c76313a1794edf0f353b93187ce3a3541b5..7f81a0060fa8ab72b71ac60e7f9c4a66429f048d 100644
--- a/src/main/java/nl/martijnmuijsers/paper/biome/SuCraftBiomeTags.java
+++ b/src/main/java/nl/martijnmuijsers/paper/biome/SuCraftBiomeTags.java
@@ -12,6 +12,8 @@ import net.minecraft.world.level.biome.Biome;
  */
 public class SuCraftBiomeTags {
 
+    public static final TagKey<Biome> HAS_STRONGHOLD_SURFACE = create("has_structure/stronghold_surface"); // Martijn - custom strongholds - surface strongholds
+
     private static TagKey<Biome> create(String id) {
         return TagKey.create(Registry.BIOME_REGISTRY, ResourceLocation.sucraft(id));
     }
diff --git a/src/main/java/nl/martijnmuijsers/paper/biome/SuCraftBiomeTagsProvider.java b/src/main/java/nl/martijnmuijsers/paper/biome/SuCraftBiomeTagsProvider.java
index 4c122f0086b8112837d33a9870a56d58da7fa05e..a59f91e402852038d3ecef4b9b7899641e1bd31d 100644
--- a/src/main/java/nl/martijnmuijsers/paper/biome/SuCraftBiomeTagsProvider.java
+++ b/src/main/java/nl/martijnmuijsers/paper/biome/SuCraftBiomeTagsProvider.java
@@ -5,7 +5,9 @@ package nl.martijnmuijsers.paper.biome;
 import net.minecraft.data.BuiltinRegistries;
 import net.minecraft.data.DataGenerator;
 import net.minecraft.data.tags.TagsProvider;
+import net.minecraft.tags.BiomeTags;
 import net.minecraft.world.level.biome.Biome;
+import net.minecraft.world.level.biome.Biomes;
 
 /**
  * Based on {@link net.minecraft.data.tags.BiomeTagsProvider}
@@ -17,6 +19,8 @@ public class SuCraftBiomeTagsProvider extends TagsProvider<Biome> {
     }
 
     @Override
-    protected void addTags() {}
+    protected void addTags() {
+        this.tag(SuCraftBiomeTags.HAS_STRONGHOLD_SURFACE).add(Biomes.PLAINS).add(Biomes.SUNFLOWER_PLAINS).add(Biomes.SNOWY_PLAINS).add(Biomes.ICE_SPIKES).add(Biomes.DESERT).add(Biomes.FOREST).add(Biomes.FLOWER_FOREST).add(Biomes.BIRCH_FOREST).add(Biomes.DARK_FOREST).add(Biomes.OLD_GROWTH_BIRCH_FOREST).add(Biomes.OLD_GROWTH_PINE_TAIGA).add(Biomes.OLD_GROWTH_SPRUCE_TAIGA).add(Biomes.TAIGA).add(Biomes.SNOWY_TAIGA).add(Biomes.SAVANNA).add(Biomes.SAVANNA_PLATEAU).add(Biomes.WINDSWEPT_HILLS).add(Biomes.WINDSWEPT_GRAVELLY_HILLS).add(Biomes.WINDSWEPT_FOREST).add(Biomes.WINDSWEPT_SAVANNA).add(Biomes.JUNGLE).add(Biomes.SPARSE_JUNGLE).add(Biomes.BAMBOO_JUNGLE).add(Biomes.BADLANDS).add(Biomes.ERODED_BADLANDS).add(Biomes.WOODED_BADLANDS).add(Biomes.MEADOW).add(Biomes.GROVE).add(Biomes.SNOWY_SLOPES).add(Biomes.FROZEN_PEAKS).add(Biomes.JAGGED_PEAKS).add(Biomes.STONY_PEAKS).add(Biomes.MUSHROOM_FIELDS); // Martijn - custom strongholds - surface strongholds
+    }
 
 }
diff --git a/src/main/java/nl/martijnmuijsers/paper/structure/SuCraftBuiltinStructures.java b/src/main/java/nl/martijnmuijsers/paper/structure/SuCraftBuiltinStructures.java
index d81b5b97f24c4ebb73f10cdab99a07fa2ba9ead0..1b890f788d0e93647424de2671e8c9e16ac6840c 100644
--- a/src/main/java/nl/martijnmuijsers/paper/structure/SuCraftBuiltinStructures.java
+++ b/src/main/java/nl/martijnmuijsers/paper/structure/SuCraftBuiltinStructures.java
@@ -12,6 +12,8 @@ import net.minecraft.world.level.levelgen.structure.Structure;
  */
 public interface SuCraftBuiltinStructures {
 
+    ResourceKey<Structure> STRONGHOLD_SURFACE = createKey("stronghold_surface"); // Martijn - custom strongholds - surface strongholds
+
     private static ResourceKey<Structure> createKey(String id) {
         return ResourceKey.create(Registry.STRUCTURE_REGISTRY, ResourceLocation.sucraft(id));
     }
diff --git a/src/main/java/nl/martijnmuijsers/paper/structure/SuCraftStructures.java b/src/main/java/nl/martijnmuijsers/paper/structure/SuCraftStructures.java
index a289e4af5fa742e25d79aad5bcaa3d3fb54649a0..68696426152f5f3e9a665c0e9461064b0987ed2c 100644
--- a/src/main/java/nl/martijnmuijsers/paper/structure/SuCraftStructures.java
+++ b/src/main/java/nl/martijnmuijsers/paper/structure/SuCraftStructures.java
@@ -8,13 +8,17 @@ import net.minecraft.core.Registry;
 import net.minecraft.data.BuiltinRegistries;
 import net.minecraft.data.worldgen.Structures;
 import net.minecraft.resources.ResourceKey;
+import net.minecraft.tags.BiomeTags;
 import net.minecraft.tags.TagKey;
 import net.minecraft.world.entity.MobCategory;
 import net.minecraft.world.level.biome.Biome;
 import net.minecraft.world.level.levelgen.GenerationStep;
+import net.minecraft.world.level.levelgen.structure.BuiltinStructures;
 import net.minecraft.world.level.levelgen.structure.Structure;
 import net.minecraft.world.level.levelgen.structure.StructureSpawnOverride;
 import net.minecraft.world.level.levelgen.structure.TerrainAdjustment;
+import net.minecraft.world.level.levelgen.structure.structures.StrongholdStructure;
+import nl.martijnmuijsers.paper.biome.SuCraftBiomeTags;
 
 import java.util.Map;
 
@@ -23,6 +27,8 @@ import java.util.Map;
  */
 public class SuCraftStructures {
 
+    public static final Holder<Structure> STRONGHOLD_SURFACE = register(SuCraftBuiltinStructures.STRONGHOLD_SURFACE, new StrongholdStructure(structure(SuCraftBiomeTags.HAS_STRONGHOLD_SURFACE, TerrainAdjustment.NONE), true));
+
     public static Structure.StructureSettings structure(TagKey<Biome> biomeTag, Map<MobCategory, StructureSpawnOverride> spawns, GenerationStep.Decoration featureStep, TerrainAdjustment terrainAdaptation) {
         return Structures.structure(biomeTag, spawns, featureStep, terrainAdaptation);
     }
