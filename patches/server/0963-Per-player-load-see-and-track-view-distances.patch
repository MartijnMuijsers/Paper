From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Thu, 27 Jan 2022 00:10:19 +0100
Subject: [PATCH] Per-player load, see and track view distances


diff --git a/src/main/java/co/aikar/timings/TimingsExport.java b/src/main/java/co/aikar/timings/TimingsExport.java
index a5e4467382422df6cff2b9f61f44feabfe7084f3..39cfba9841f17203a6ba9597bee6a30343d0d842 100644
--- a/src/main/java/co/aikar/timings/TimingsExport.java
+++ b/src/main/java/co/aikar/timings/TimingsExport.java
@@ -161,8 +161,11 @@ public class TimingsExport extends Thread {
                 })),
                 // Paper start - replace chunk loader system
                 pair("ticking-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance()),
-                pair("no-ticking-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetNoTickViewDistance()),
-                pair("sending-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance())
+                // Martijn start - per-player track and see view distance
+                pair("max-track-distance", world.paperConfig.getMaxTrackViewDistance()),
+                pair("max-see-distance", world.paperConfig.getMaxSeeViewDistance()),
+                pair("max-load-distance", world.paperConfig.getMaxLoadViewDistance())
+                // Martijn end - per-player track and see view distance
                 // Paper end - replace chunk loader system
             ));
         }));
diff --git a/src/main/java/co/aikar/timings/WorldTimingsHandler.java b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
index fe79c0add4f7cb18d487c5bb9415c40c5b551ea2..dc4f52c99466302345f2818c12d0760733f5fe9b 100644
--- a/src/main/java/co/aikar/timings/WorldTimingsHandler.java
+++ b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
@@ -44,6 +44,24 @@ public class WorldTimingsHandler {
     public final Timing broadcastChunkUpdates;
     public final Timing countNaturalMobs;
 
+    // Martijn start - per-player view distance
+//    public final Timing getPlayersNearChunkForSending;
+    public final Timing chunkMapPlayerMove;
+//    public final Timing chunkMapPlayerMoveUpdatePos;
+//    public final Timing chunkMapPlayerMoveUpdateDistanceManager;
+//    public final Timing chunkMapPlayerMoveUpdatePlayerMap;
+//    public final Timing chunkMapUpdatePlayerMaps;
+    public final Timing playerChunkLoaderUpdate;
+//    public final Timing chunkMapPlayerMoveUpdateChunkTrackingOrSeeing;
+//    public final Timing chunkMapPlayerMoveSortChunksForTrackAndSee;
+    public final Timing computeTrackViewDistance;
+    public final Timing computeSeeViewDistance;
+    public final Timing computeLoadViewDistance;
+    public final Timing trackViewDistanceMayHaveChanged;
+    public final Timing seeViewDistanceMayHaveChanged;
+    public final Timing loadViewDistanceMayHaveChanged;
+    // Martijn end - per-player view distance
+
     public final Timing chunkLoad;
     public final Timing chunkLoadPopulate;
     public final Timing syncChunkLoad;
@@ -119,6 +137,23 @@ public class WorldTimingsHandler {
         broadcastChunkUpdates = Timings.ofSafe(name + "Broadcast chunk updates");
         countNaturalMobs = Timings.ofSafe(name + "Count natural mobs");
 
+        // Martijn start - per-player view distance
+//        getPlayersNearChunkForSending = Timings.ofSafe("Get players near chunk for sending");
+        chunkMapPlayerMove = Timings.ofSafe("Chunk map player move");
+//        chunkMapPlayerMoveUpdatePos = Timings.ofSafe("Chunk map player move - update pos");
+//        chunkMapPlayerMoveUpdateDistanceManager = Timings.ofSafe("Chunk map player move - update distance manager");
+//        chunkMapPlayerMoveUpdatePlayerMap = Timings.ofSafe("Chunk map player move - update player map");
+//        chunkMapUpdatePlayerMaps = Timings.ofSafe("Chunk map update player maps");
+        playerChunkLoaderUpdate = Timings.ofSafe("Player chunk loader update");
+//        chunkMapPlayerMoveUpdateChunkTrackingOrSeeing = Timings.ofSafe("Chunk map player move - update chunk tracking or seeing");
+//        chunkMapPlayerMoveSortChunksForTrackAndSee = Timings.ofSafe("Chunk map player move - sort chunks for track and see");
+        computeTrackViewDistance = Timings.ofSafe("Compute track view distance");
+        computeSeeViewDistance = Timings.ofSafe("Compute see view distance");
+        computeLoadViewDistance = Timings.ofSafe("Compute load view distance");
+        trackViewDistanceMayHaveChanged = Timings.ofSafe("Track view distance may have changed");
+        seeViewDistanceMayHaveChanged = Timings.ofSafe("See view distance may have changed");
+        loadViewDistanceMayHaveChanged = Timings.ofSafe("Load view distance may have changed");
+        // Martijn end - per-player view distance
 
         miscMobSpawning = Timings.ofSafe(name + "Mob spawning - Misc");
 
diff --git a/src/main/java/com/destroystokyo/paper/PaperConfig.java b/src/main/java/com/destroystokyo/paper/PaperConfig.java
index 61262e8113cc0bbb6a7bb22bf64d99d6f0add521..0936b3fdeec3198b72eefd12ff4dfac5c79b54eb 100644
--- a/src/main/java/com/destroystokyo/paper/PaperConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperConfig.java
@@ -19,6 +19,7 @@ import java.util.regex.Pattern;
 
 import com.google.common.collect.Lists;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
 import org.bukkit.Bukkit;
 import org.bukkit.ChatColor;
 import org.bukkit.command.Command;
@@ -27,6 +28,7 @@ import org.bukkit.configuration.InvalidConfigurationException;
 import org.bukkit.configuration.file.YamlConfiguration;
 import co.aikar.timings.Timings;
 import co.aikar.timings.TimingsManager;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.spigotmc.SpigotConfig;
 import org.spigotmc.WatchdogThread;
 
@@ -140,6 +142,64 @@ public class PaperConfig {
 
     // Martijn end - configurable proportion of skipped active entities
 
+    // Martijn start - per-player track and see view distance
+
+    public static boolean sendChunkRefreshToPlayersWhoAreSeeingButNotTracking = true;
+    private static void sendChunkRefreshToPlayersWhoAreSeeingButNotTracking() {
+        sendChunkRefreshToPlayersWhoAreSeeingButNotTracking = getBoolean("settings.view-distances.track-and-see-view-distance.if-can-see-but-not-tracking.send-chunk-refresh", sendChunkRefreshToPlayersWhoAreSeeingButNotTracking);
+    }
+
+    public static boolean sendWitherSpawnSoundToPlayersWhoAreSeeingButNotTracking = true;
+    private static void sendWitherSpawnSoundToPlayersWhoAreSeeingButNotTracking() {
+        sendWitherSpawnSoundToPlayersWhoAreSeeingButNotTracking = getBoolean("settings.view-distances.track-and-see-view-distance.if-can-see-but-not-tracking.send-wither-spawn-sound", sendWitherSpawnSoundToPlayersWhoAreSeeingButNotTracking);
+    }
+
+    public static boolean sendEnderDragonSpawnSoundToPlayersWhoAreSeeingButNotTracking = true;
+    private static void sendEnderDragonSpawnSoundToPlayersWhoAreSeeingButNotTracking() {
+        sendEnderDragonSpawnSoundToPlayersWhoAreSeeingButNotTracking = getBoolean("settings.view-distances.track-and-see-view-distance.if-can-see-but-not-tracking.send-ender-dragon-spawn-sound", sendEnderDragonSpawnSoundToPlayersWhoAreSeeingButNotTracking);
+    }
+
+    public static boolean sendEndPortalFillSoundToPlayersWhoAreSeeingButNotTracking = true;
+    private static void sendEndPortalFillSoundToPlayersWhoAreSeeingButNotTracking() {
+        sendEndPortalFillSoundToPlayersWhoAreSeeingButNotTracking = getBoolean("settings.view-distances.track-and-see-view-distance.if-can-see-but-not-tracking.send-ender-portal-fill-sound", sendEndPortalFillSoundToPlayersWhoAreSeeingButNotTracking);
+    }
+
+    /**
+     * -1 indicates no limit
+     */
+    public static int maxTotalTrackedChunks = -1;
+    private static void maxTotalTrackChunks() {
+        maxTotalTrackedChunks = getInt("settings.view-distances.track-view-distance.max-total", maxTotalTrackedChunks);
+    }
+    public static int getMaxTotalTrackedChunks() {
+        return maxTotalTrackedChunks;
+    }
+    public static void setMaxTotalTrackedChunks(int maxTotalTrackedChunks) {
+        if (PaperConfig.maxTotalTrackedChunks != maxTotalTrackedChunks) {
+            PaperConfig.maxTotalTrackedChunks = maxTotalTrackedChunks;
+            ServerPlayer.maxTrackViewDistanceDueToTotalTrackedChunksMayHaveChanged();
+        }
+    }
+
+    /**
+     * -1 indicates no limit
+     */
+    public static int maxTotalSeenChunks = -1;
+    private static void maxTotalSeeChunks() {
+        maxTotalSeenChunks = getInt("settings.view-distances.see-view-distance.max-total", maxTotalSeenChunks);
+    }
+    public static int getMaxTotalSeenChunks() {
+        return maxTotalSeenChunks;
+    }
+    public static void setMaxTotalSeenChunks(int maxTotalSeenChunks) {
+        if (PaperConfig.maxTotalSeenChunks != maxTotalSeenChunks) {
+            PaperConfig.maxTotalSeenChunks = maxTotalSeenChunks;
+            ServerPlayer.maxSeeViewDistanceDueToTotalSeenChunksMayHaveChanged();
+        }
+    }
+
+    // Martijn end - per-player track and see view distance
+
     // Martijn start - configurable keepalive
 
     /**
diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index 6fb0b8f3f1046c3563300b4bd25e9addd475ea4e..575b2c1eb57e4eeec7e8c620bb49cfbb9975de96 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -14,6 +14,7 @@ import java.util.Map;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.ConfigurationSection;
 import org.bukkit.configuration.file.YamlConfiguration;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.spigotmc.SpigotWorldConfig;
 
 import static com.destroystokyo.paper.PaperConfig.log;
@@ -72,6 +73,176 @@ public class PaperWorldConfig {
         }
     }
 
+    // Martijn start - per-player track view distance
+
+    private boolean perPlayerTrackViewDistance = false;
+    private void perPlayerTrackViewDistance() {
+        this.perPlayerTrackViewDistance = getBoolean("view-distances.track-view-distance.per-player", this.perPlayerTrackViewDistance);
+    }
+    public boolean getPerPlayerTrackViewDistance() {
+        return this.perPlayerTrackViewDistance;
+    }
+
+    /**
+     * This is only used if perPlayerTrackViewDistance is true
+     * -1 indicates no limit (it is still limited by the Bukkit world view distance)
+     * Valid values are -1 or an integer in the range [2, 32]
+     */
+    private int maxTrackViewDistance = -1;
+    private void maxTrackViewDistance() {
+        this.maxTrackViewDistance = getInt("view-distances.track-view-distance.max", this.maxTrackViewDistance);
+    }
+    public int getMaxTrackViewDistance() {
+        return this.maxTrackViewDistance;
+    }
+    public void setMaxTrackViewDistance(int maxTrackViewDistance) {
+        this.maxTrackViewDistance = maxTrackViewDistance;
+        Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().trackViewDistanceMayHaveChanged());
+    }
+
+    private boolean limitTrackViewDistanceByClientViewDistance = false;
+    private void limitTrackViewDistanceByClientViewDistance() {
+        setLimitTrackViewDistanceByClientViewDistance(getBoolean("view-distances.track-view-distance.limit-by-client-view-distance", this.limitTrackViewDistanceByClientViewDistance));
+    }
+    public boolean getLimitTrackViewDistanceByClientViewDistance() {
+        return this.limitTrackViewDistanceByClientViewDistance;
+    }
+    public void setLimitTrackViewDistanceByClientViewDistance(boolean limitTrackViewDistanceByClientViewDistance) {
+        this.limitTrackViewDistanceByClientViewDistance = limitTrackViewDistanceByClientViewDistance;
+        Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().trackViewDistanceMayHaveChanged());
+    }
+
+    // Martijn end - per-player track view distance
+
+    // Martijn start - per-player see view distance
+
+    private boolean perPlayerSeeViewDistance = false;
+    private void perPlayerSeeViewDistance() {
+        this.perPlayerSeeViewDistance = getBoolean("view-distances.see-view-distance.per-player", this.perPlayerSeeViewDistance);
+    }
+    public boolean getPerPlayerSeeViewDistance() {
+        return this.perPlayerSeeViewDistance;
+    }
+
+    /**
+     * This is only used if perPlayerSeeViewDistance is true
+     * -1 indicates no limit (it is still limited by the Bukkit world view distance)
+     * Valid values are -1 or an integer in the range [2, 32]
+     */
+    private int maxSeeViewDistance = -1;
+    private void maxSeeViewDistance() {
+        this.maxSeeViewDistance = getInt("view-distances.see-view-distance.max", this.maxSeeViewDistance);
+    }
+    public int getMaxSeeViewDistance() {
+        return this.maxSeeViewDistance;
+    }
+    public void setMaxSeeViewDistance(int maxSeeViewDistance) {
+        this.maxSeeViewDistance = maxSeeViewDistance;
+        Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().seeViewDistanceMayHaveChanged());
+    }
+
+    private boolean limitSeeViewDistanceByClientViewDistance = false;
+    private void limitSeeViewDistanceByClientViewDistance() {
+        setLimitSeeViewDistanceByClientViewDistance(getBoolean("view-distances.see-view-distance.limit-by-client-view-distance", this.limitSeeViewDistanceByClientViewDistance));
+    }
+    public boolean getLimitSeeViewDistanceByClientViewDistance() {
+        return this.limitSeeViewDistanceByClientViewDistance;
+    }
+    public void setLimitSeeViewDistanceByClientViewDistance(boolean limitSeeViewDistanceByClientViewDistance) {
+        this.limitSeeViewDistanceByClientViewDistance = limitSeeViewDistanceByClientViewDistance;
+        Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().seeViewDistanceMayHaveChanged());
+    }
+
+    // Martijn end - per-player see view distance
+
+    // Martijn start - per-player load view distance
+
+    private boolean perPlayerLoadViewDistance = false;
+    private void perPlayerLoadViewDistance() {
+        this.perPlayerLoadViewDistance = getBoolean("view-distances.load-view-distance.per-player", this.perPlayerLoadViewDistance);
+    }
+    public boolean getPerPlayerLoadViewDistance() {
+        return this.perPlayerLoadViewDistance;
+    }
+
+    /**
+     * This is only used if perPlayerLoadViewDistance is true
+     * -1 indicates no limit (it is still limited by the Bukkit world view distance)
+     * Valid values are -1 or an integer in the range [3, 33]
+     */
+    private int maxLoadViewDistance = -1;
+    private void maxLoadViewDistance() {
+        this.maxLoadViewDistance = getInt("view-distances.load-view-distance.max", this.maxLoadViewDistance);
+    }
+    public int getMaxLoadViewDistance() {
+        return this.maxLoadViewDistance;
+    }
+    public void setMaxLoadViewDistance(int maxLoadViewDistance) {
+        this.maxLoadViewDistance = maxLoadViewDistance;
+        Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().loadViewDistanceMayHaveChanged());
+    }
+
+    private boolean limitLoadViewDistanceBySeeViewDistance = false;
+    private void limitLoadViewDistanceBySeeViewDistance() {
+        setLimitLoadViewDistanceBySeeViewDistance(getBoolean("view-distances.load-view-distance.limit-by-see-distance", this.limitLoadViewDistanceBySeeViewDistance));
+    }
+    public boolean getLimitLoadViewDistanceBySeeViewDistance() {
+        return this.limitLoadViewDistanceBySeeViewDistance;
+    }
+    public void setLimitLoadViewDistanceBySeeViewDistance(boolean limitLoadViewDistanceBySeeViewDistance) {
+        this.limitLoadViewDistanceBySeeViewDistance = limitLoadViewDistanceBySeeViewDistance;
+        Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().loadViewDistanceMayHaveChanged());
+    }
+
+    private boolean limitLoadViewDistanceByClientViewDistance = false;
+    private void limitLoadViewDistanceByClientViewDistance() {
+        setLimitLoadViewDistanceByClientViewDistance(getBoolean("view-distances.load-view-distance.limit-by-client-view-distance", this.limitLoadViewDistanceByClientViewDistance));
+    }
+    public boolean getLimitLoadViewDistanceByClientViewDistance() {
+        return this.limitLoadViewDistanceByClientViewDistance;
+    }
+    public void setLimitLoadViewDistanceByClientViewDistance(boolean limitLoadViewDistanceByClientViewDistance) {
+        this.limitLoadViewDistanceByClientViewDistance = limitLoadViewDistanceByClientViewDistance;
+        Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().loadViewDistanceMayHaveChanged());
+    }
+
+    /**
+     * In ticks
+     * A nonpositive integer disables this feature
+     */
+    public int printLoadedChunksInterval = -1;
+    private void printLoadedChunksInterval() {
+        printLoadedChunksInterval = getInt("view-distances.load-view-distance.print-loaded-chunks-interval", this.printLoadedChunksInterval);
+    }
+
+    // Martijn end - per-player load view distance
+
+    // Martijn start - sort chunks by distance
+
+    // Replaced because of the similar sorting of send queues as determined by PlayerChunkLoader.createSendQueue()
+//    public boolean trackAndSeeChunksInSpiralOrderWhenChangingWorld = false;
+//    private void trackAndSeeChunksInSpiralOrderWhenChangingWorld() {
+//        this.trackAndSeeChunksInSpiralOrderWhenChangingWorld = getBoolean("view-distances.track-and-see-view-distance.track-and-see-chunks-in-spiral-order-when-changing-world", this.trackAndSeeChunksInSpiralOrderWhenChangingWorld);
+//    }
+//
+//    public boolean trackAndSeeChunksInOrderOfDistanceWhenChangingViewDistance = false;
+//    private void trackAndSeeChunksInOrderOfDistanceWhenChangingViewDistance() {
+//        this.trackAndSeeChunksInOrderOfDistanceWhenChangingViewDistance = getBoolean("view-distances.track-and-see-view-distance.track-and-see-chunks-in-order-of-distance-when-changing-view-distance", this.trackAndSeeChunksInOrderOfDistanceWhenChangingViewDistance);
+//    }
+//
+//    public boolean trackAndSeeChunksInOrderOfDistanceWhenMoving = false;
+//    private void trackAndSeeChunksInOrderOfDistanceWhenMoving() {
+//        this.trackAndSeeChunksInOrderOfDistanceWhenMoving = getBoolean("view-distances.track-and-see-view-distance.track-and-see-chunks-in-order-of-distance-when-moving", this.trackAndSeeChunksInOrderOfDistanceWhenMoving);
+//    }
+
+    // Not necessary anymore, because the chunks will end up in a send queue, which will be sorted similarly as determined by PlayerChunkLoader.createSendQueue()
+//    public boolean processChunksInOrderOfDistanceAfterLoad = false;
+//    private void processChunksInOrderOfDistanceAfterLoad() {
+//        this.processChunksInOrderOfDistanceAfterLoad = getBoolean("view-distances.load-view-distance.process-chunks-in-order-of-distance-after-load", this.processChunksInOrderOfDistanceAfterLoad);
+//    }
+
+    // Martijn end - sort chunks by distance
+
     public boolean zombiesTargetTurtleEggs = true;
     private void zombiesTargetTurtleEggs() {
         zombiesTargetTurtleEggs = getBoolean("zombies-target-turtle-eggs", zombiesTargetTurtleEggs);
diff --git a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
index 12bcf96ec1ba4314c7ea2eab9f3d140559f1dc08..d6008e88f0bf3152daf109d886e54cd26ce38b1f 100644
--- a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
@@ -24,6 +24,7 @@ import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.entity.Player;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
 import java.util.TreeSet;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -49,31 +50,33 @@ public final class PlayerChunkLoader {
         return data.getTargetTickViewDistance();
     }
 
-    public static int getLoadViewDistance(final Player player) {
-        return getLoadViewDistance(((CraftPlayer)player).getHandle());
-    }
-
-    public static int getLoadViewDistance(final ServerPlayer player) {
-        final ServerLevel level = (ServerLevel)player.level;
-        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
-        if (data == null) {
-            return level.chunkSource.chunkMap.playerChunkManager.getLoadDistance();
-        }
-        return data.getLoadDistance();
-    }
-
-    public static int getSendViewDistance(final Player player) {
-        return getSendViewDistance(((CraftPlayer)player).getHandle());
-    }
-
-    public static int getSendViewDistance(final ServerPlayer player) {
-        final ServerLevel level = (ServerLevel)player.level;
-        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
-        if (data == null) {
-            return level.chunkSource.chunkMap.playerChunkManager.getTargetSendDistance();
-        }
-        return data.getTargetSendViewDistance();
-    }
+    // Martijn start - per-player view distance
+//    public static int getLoadViewDistance(final Player player) {
+//        return getLoadViewDistance(((CraftPlayer)player).getHandle());
+//    }
+//
+//    public static int getLoadViewDistance(final ServerPlayer player) {
+//        final ServerLevel level = (ServerLevel)player.level;
+//        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
+//        if (data == null) {
+//            return level.chunkSource.chunkMap.playerChunkManager.getLoadDistance();
+//        }
+//        return data.getLoadDistance();
+//    }
+
+//    public static int getSendViewDistance(final Player player) {
+//        return getSendViewDistance(((CraftPlayer)player).getHandle());
+//    }
+//
+//    public static int getSendViewDistance(final ServerPlayer player) {
+//        final ServerLevel level = (ServerLevel)player.level;
+//        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
+//        if (data == null) {
+//            return level.chunkSource.chunkMap.playerChunkManager.getTargetSendDistance();
+//        }
+//        return data.getTargetSendViewDistance();
+//    }
+    // Martijn end - per-player view distance
 
     protected final ChunkMap chunkMap;
     protected final Reference2ObjectLinkedOpenHashMap<ServerPlayer, PlayerLoaderData> playerMap = new Reference2ObjectLinkedOpenHashMap<>(512, 0.7f);
@@ -135,7 +138,15 @@ public final class PlayerChunkLoader {
     /**
      * The chunks to be sent to players, provided they're send-ready. Send-ready means the chunk and its 1 radius neighbours are loaded.
      */
-    public final PlayerAreaMap broadcastMap;
+    // Martijn start - per-player track and see view distance
+    public final PlayerAreaMap broadcastMapForTracking;
+    public final PlayerAreaMap broadcastMapForSeeing;
+
+    public PlayerAreaMap getBroadcastMap(final boolean concernsTracking) {
+        return concernsTracking ? this.broadcastMapForTracking : this.broadcastMapForSeeing;
+    }
+
+    // Martijn end - per-player track and see view distance
 
     /**
      * The chunks to be brought up to send-ready status. Send-ready means the chunk and its 1 radius neighbours are loaded.
@@ -153,15 +164,17 @@ public final class PlayerChunkLoader {
      */
     public final PlayerAreaMap tickMap;
 
-    /**
-     * -1 if defaulting to [load distance], else always in [2, load distance]
-     */
-    protected int rawSendDistance = -1;
-
-    /**
-     * -1 if defaulting to [tick view distance + 1], else always in [tick view distance + 1, 32 + 1]
-     */
-    protected int rawLoadDistance = -1;
+    // Martijn start - per-player view distance
+//    /**
+//     * -1 if defaulting to [load distance], else always in [2, load distance]
+//     */
+//    protected int rawSendDistance = -1;
+//
+//    /**
+//     * -1 if defaulting to [tick view distance + 1], else always in [tick view distance + 1, 32 + 1]
+//     */
+//    protected int rawLoadDistance = -1;
+    // Martijn end - per-player view distance
 
     /**
      * Never -1, always in [2, 32]
@@ -178,47 +191,49 @@ public final class PlayerChunkLoader {
         this.setTickDistance(distance);
     }
 
-    public int getTargetNoTickViewDistance() {
-        return this.getLoadDistance() - 1;
-    }
-
-    public void setTargetNoTickViewDistance(final int distance) {
-        this.setLoadDistance(distance == -1 ? -1 : distance + 1);
-    }
-
-    public int getTargetSendDistance() {
-        return this.rawSendDistance == -1 ? this.getLoadDistance() : this.rawSendDistance;
-    }
-
-    public void setTargetSendDistance(final int distance) {
-        this.setSendDistance(distance);
-    }
-
-    // internal methods
-
-    public int getSendDistance() {
-        final int loadDistance = this.getLoadDistance();
-        return this.rawSendDistance == -1 ? loadDistance : Math.min(this.rawSendDistance, loadDistance);
-    }
-
-    public void setSendDistance(final int distance) {
-        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
-            throw new IllegalArgumentException("Send distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + ", or -1, got: " + distance);
-        }
-        this.rawSendDistance = distance;
-    }
-
-    public int getLoadDistance() {
-        final int tickDistance = this.getTickDistance();
-        return this.rawLoadDistance == -1 ? tickDistance + 1 : Math.max(tickDistance + 1, this.rawLoadDistance);
-    }
-
-    public void setLoadDistance(final int distance) {
-        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
-            throw new IllegalArgumentException("Load distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + ", or -1, got: " + distance);
-        }
-        this.rawLoadDistance = distance;
-    }
+    // Martijn start - per-player view distance
+//    public int getTargetNoTickViewDistance() {
+//        return this.getLoadDistance() - 1;
+//    }
+//
+//    public void setTargetNoTickViewDistance(final int distance) {
+//        this.setLoadDistance(distance == -1 ? -1 : distance + 1);
+//    }
+//
+//    public int getTargetSendDistance() {
+//        return this.rawSendDistance == -1 ? this.getLoadDistance() : this.rawSendDistance;
+//    }
+//
+//    public void setTargetSendDistance(final int distance) {
+//        this.setSendDistance(distance);
+//    }
+//
+//    // internal methods
+//
+//    public int getSendDistance() {
+//        final int loadDistance = this.getLoadDistance();
+//        return this.rawSendDistance == -1 ? loadDistance : Math.min(this.rawSendDistance, loadDistance);
+//    }
+//
+//    public void setSendDistance(final int distance) {
+//        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
+//            throw new IllegalArgumentException("Send distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + ", or -1, got: " + distance);
+//        }
+//        this.rawSendDistance = distance;
+//    }
+//
+//    public int getLoadDistance() {
+//        final int tickDistance = this.getTickDistance();
+//        return this.rawLoadDistance == -1 ? tickDistance + 1 : Math.max(tickDistance + 1, this.rawLoadDistance);
+//    }
+//
+//    public void setLoadDistance(final int distance) {
+//        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
+//            throw new IllegalArgumentException("Load distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + ", or -1, got: " + distance);
+//        }
+//        this.rawLoadDistance = distance;
+//    }
+    // Martijn end - per-player view distance
 
     public int getTickDistance() {
         return this.rawTickDistance;
@@ -256,12 +271,20 @@ public final class PlayerChunkLoader {
 
     public PlayerChunkLoader(final ChunkMap chunkMap, final PooledLinkedHashSets<ServerPlayer> pooledHashSets) {
         this.chunkMap = chunkMap;
-        this.broadcastMap = new PlayerAreaMap(pooledHashSets,
+        // Martijn start - player track and see view distance
+        this.broadcastMapForTracking = new PlayerAreaMap(pooledHashSets,
+                null,
+                (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                    PlayerChunkLoader.this.onChunkLeave(player, rangeX, rangeZ, true);
+                });
+        this.broadcastMapForSeeing = new PlayerAreaMap(pooledHashSets,
                 null,
                 (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
                  com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
-                    PlayerChunkLoader.this.onChunkLeave(player, rangeX, rangeZ);
+                    PlayerChunkLoader.this.onChunkLeave(player, rangeX, rangeZ, false);
                 });
+        // Martijn end - player track and see view distance
         this.loadMap = new PlayerAreaMap(pooledHashSets,
                 null,
                 (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
@@ -311,12 +334,16 @@ public final class PlayerChunkLoader {
     protected final LongOpenHashSet isTargetedForPlayerLoad = new LongOpenHashSet();
     protected final LongOpenHashSet chunkTicketTracker = new LongOpenHashSet();
 
-    public boolean isChunkNearPlayers(final int chunkX, final int chunkZ) {
-        final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.broadcastMap.getObjectsInRange(chunkX, chunkZ);
+    // Martijn start - per-player track and see view distance
+
+    public boolean isChunkNearPlayers(final int chunkX, final int chunkZ, boolean concernsTracking) {
+        final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.getBroadcastMap(concernsTracking).getObjectsInRange(chunkX, chunkZ);
 
         return playersInSendRange != null;
     }
 
+    // Martijn end - per-player track and see view distance
+
     public void onChunkPostProcessing(final int chunkX, final int chunkZ) {
         this.onChunkSendReady(chunkX, chunkZ);
     }
@@ -348,34 +375,38 @@ public final class PlayerChunkLoader {
         return levelChunk != null && levelChunk.isPostProcessingDone && this.isTargetedForPlayerLoad.contains(key);
     }
 
-    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean borderOnly) {
-        return borderOnly ? this.isChunkSentBorderOnly(player, chunkX, chunkZ) : this.isChunkSent(player, chunkX, chunkZ);
+    // Martijn start - per-player track and see view distance
+
+    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean borderOnly, final boolean concernsTracking) {
+        return borderOnly ? this.isChunkSentBorderOnly(player, chunkX, chunkZ, concernsTracking) : this.isChunkSent(player, chunkX, chunkZ, concernsTracking);
     }
 
-    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) {
         final PlayerLoaderData data = this.playerMap.get(player);
         if (data == null) {
             return false;
         }
 
-        return data.hasSentChunk(chunkX, chunkZ);
+        return data.hasSentChunk(chunkX, chunkZ, concernsTracking);
     }
 
-    public boolean isChunkSentBorderOnly(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public boolean isChunkSentBorderOnly(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) {
         final PlayerLoaderData data = this.playerMap.get(player);
         if (data == null) {
             return false;
         }
 
-        final boolean center = data.hasSentChunk(chunkX, chunkZ);
+        final boolean center = data.hasSentChunk(chunkX, chunkZ, concernsTracking);
         if (!center) {
             return false;
         }
 
-        return !(data.hasSentChunk(chunkX - 1, chunkZ) && data.hasSentChunk(chunkX + 1, chunkZ) &&
-            data.hasSentChunk(chunkX, chunkZ - 1) && data.hasSentChunk(chunkX, chunkZ + 1));
+        return !(data.hasSentChunk(chunkX - 1, chunkZ, concernsTracking) && data.hasSentChunk(chunkX + 1, chunkZ, concernsTracking) &&
+            data.hasSentChunk(chunkX, chunkZ - 1, concernsTracking) && data.hasSentChunk(chunkX, chunkZ + 1, concernsTracking));
     }
 
+    // Martijn end - per-player track and see view distance
+
     protected int getMaxConcurrentChunkSends() {
         return PaperConfig.playerMaxConcurrentChunkSends;
     }
@@ -400,47 +431,55 @@ public final class PlayerChunkLoader {
     }
 
     public void onChunkSendReady(final int chunkX, final int chunkZ) {
-        final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.broadcastMap.getObjectsInRange(chunkX, chunkZ);
 
-        if (playersInSendRange == null) {
-            return;
-        }
+        // Martijn start - per-player track and see view distance
 
-        final Object[] rawData = playersInSendRange.getBackingSet();
-        for (int i = 0, len = rawData.length; i < len; ++i) {
-            final Object raw = rawData[i];
+        for (boolean concernsTracking : new boolean[] {false, true}) {
+            final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.getBroadcastMap(concernsTracking).getObjectsInRange(chunkX, chunkZ);
 
-            if (!(raw instanceof ServerPlayer)) {
-                continue;
+            if (playersInSendRange == null) {
+                return;
+            }
+
+            final Object[] rawData = playersInSendRange.getBackingSet();
+            for (int i = 0, len = rawData.length; i < len; ++i) {
+                final Object raw = rawData[i];
+
+                if (!(raw instanceof ServerPlayer)) {
+                    continue;
+                }
+                this.onChunkSendReady((ServerPlayer) raw, chunkX, chunkZ, concernsTracking);
             }
-            this.onChunkSendReady((ServerPlayer)raw, chunkX, chunkZ);
         }
+
+        // Martijn end - per-player track and see view distance
+
     }
 
-    public void onChunkSendReady(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public void onChunkSendReady(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) { // Martijn - per-player track and see view distance
         final PlayerLoaderData data = this.playerMap.get(player);
 
         if (data == null) {
             return;
         }
 
-        if (data.hasSentChunk(chunkX, chunkZ) || !this.isChunkPlayerLoaded(chunkX, chunkZ)) {
+        if (data.hasSentChunk(chunkX, chunkZ, concernsTracking) || !this.isChunkPlayerLoaded(chunkX, chunkZ)) { // Martijn - per-player track and see view distance
             // if we don't have player tickets, then the load logic will pick this up and queue to send
             return;
         }
 
-        if (!data.chunksToBeSent.remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
+        if (!data.getChunksToBeSent(concernsTracking).remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) { // Martijn - per-player track and see view distance
             // don't queue to send, we don't want the chunk
             return;
         }
 
-        final long playerPos = this.broadcastMap.getLastCoordinate(player);
+        final long playerPos = this.broadcastMapForSeeing.getLastCoordinate(player); // Martijn - per-player track and see view distance
         final int playerChunkX = CoordinateUtils.getChunkX(playerPos);
         final int playerChunkZ = CoordinateUtils.getChunkZ(playerPos);
         final int manhattanDistance = Math.abs(playerChunkX - chunkX) + Math.abs(playerChunkZ - chunkZ);
 
         final ChunkPriorityHolder holder = new ChunkPriorityHolder(chunkX, chunkZ, manhattanDistance, 0.0);
-        data.sendQueue.add(holder);
+        data.getSendQueue(concernsTracking).add(holder); // Martijn - per-player track and see view distance
     }
 
     public void onChunkLoad(final int chunkX, final int chunkZ) {
@@ -449,14 +488,14 @@ public final class PlayerChunkLoader {
         }
     }
 
-    public void onChunkLeave(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public void onChunkLeave(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) { // Martijn - per-player track and see view distance
         final PlayerLoaderData data = this.playerMap.get(player);
 
         if (data == null) {
             return;
         }
 
-        data.unloadChunk(chunkX, chunkZ);
+        data.unloadChunk(chunkX, chunkZ, concernsTracking); // Martijn - per-player track and see view distance
     }
 
     public void addPlayer(final ServerPlayer player) {
@@ -559,7 +598,14 @@ public final class PlayerChunkLoader {
 
             final PlayerLoaderData data = this.chunkSendQueue.removeFirst();
 
-            final ChunkPriorityHolder queuedSend = data.sendQueue.pollFirst();
+            // Martijn start - per-player track and see view distance
+            ChunkPriorityHolder queuedSend = data.getSendQueue(true).pollFirst();
+            boolean concernsTracking = true;
+            if (queuedSend == null) {
+                queuedSend = data.getSendQueue(false).pollFirst();
+                concernsTracking = false;
+            }
+            // Martijn end - per-player track and see view distance
             if (queuedSend == null) {
                 concurrentChunkSends.getAndDecrement(); // we never sent, so decrease
                 // stop iterating over players who have nothing to send
@@ -596,7 +642,7 @@ public final class PlayerChunkLoader {
                 }
 
                 concurrentChunkSends.getAndDecrement();
-            });
+            }, concernsTracking);
 
             nextChunkSend = this.getMaxSendAddend() + time;
             if (time < nextChunkSend) {
@@ -776,7 +822,10 @@ public final class PlayerChunkLoader {
         // this is corrected so that 0 is along the positive x-axis
         protected float lastYaw = Float.NEGATIVE_INFINITY;
 
-        protected int lastSendDistance = Integer.MIN_VALUE;
+        // Martijn start - per-player track and see view distance
+        protected int lastTrackDistance = Integer.MIN_VALUE;
+        protected int lastSeeDistance = Integer.MIN_VALUE;
+        // Martijn end - per-player track and see view distance
         protected int lastLoadDistance = Integer.MIN_VALUE;
         protected int lastTickDistance = Integer.MIN_VALUE;
         protected boolean usingLookingPriority;
@@ -787,28 +836,29 @@ public final class PlayerChunkLoader {
         // warning: modifications of this field must be aware that the loadQueue inside PlayerChunkLoader uses this field
         // in a comparator!
         protected final ArrayDeque<ChunkPriorityHolder> loadQueue = new ArrayDeque<>();
-        protected final LongOpenHashSet sentChunks = new LongOpenHashSet();
-        protected final LongOpenHashSet chunksToBeSent = new LongOpenHashSet();
 
-        protected final TreeSet<ChunkPriorityHolder> sendQueue = new TreeSet<>((final ChunkPriorityHolder p1, final ChunkPriorityHolder p2) -> {
-            final int distanceCompare = Integer.compare(p1.manhattanDistanceToPlayer, p2.manhattanDistanceToPlayer);
-            if (distanceCompare != 0) {
-                return distanceCompare;
-            }
+        // Martijn start - per-player view distance
 
-            final int coordinateXCompare = Integer.compare(p1.chunkX, p2.chunkX);
-            if (coordinateXCompare != 0) {
-                return coordinateXCompare;
-            }
+        protected final LongOpenHashSet sentChunksForTracking = new LongOpenHashSet();
+        protected final LongOpenHashSet chunksToBeSentForTracking = new LongOpenHashSet();
 
-            return Integer.compare(p1.chunkZ, p2.chunkZ);
-        });
+        protected final LongOpenHashSet sentChunksForSeeing = new LongOpenHashSet();
+        protected final LongOpenHashSet chunksToBeSentForSeeing = new LongOpenHashSet();
 
-        protected int sendViewDistance = -1;
-        protected int loadViewDistance = -1;
-        protected int tickViewDistance = -1;
+        private TreeSet<ChunkPriorityHolder> createSendQueue() {
+            return new TreeSet<>((final ChunkPriorityHolder p1, final ChunkPriorityHolder p2) -> {
+                final int distanceCompare = Integer.compare(p1.manhattanDistanceToPlayer, p2.manhattanDistanceToPlayer);
+                if (distanceCompare != 0) {
+                    return distanceCompare;
+                }
 
-        protected long nextChunkSendTarget;
+                final int coordinateXCompare = Integer.compare(p1.chunkX, p2.chunkX);
+                if (coordinateXCompare != 0) {
+                    return coordinateXCompare;
+                }
+                return Integer.compare(p1.chunkZ, p2.chunkZ);
+            });
+        }
 
         // this interval prevents bursting a lot of chunk loads
         protected final IntervalledCounter ticketAdditionCounterShort = new IntervalledCounter((long)(1.0e6 * 50.0)); // 50ms
@@ -822,35 +872,59 @@ public final class PlayerChunkLoader {
             this.loader = loader;
         }
 
-        // these view distance methods are for api
-        public int getTargetSendViewDistance() {
-            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
-            final int loadViewDistance = Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
-            final int clientViewDistance = this.getClientViewDistance();
-            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!PaperConfig.playerAutoConfigureSendViewDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
-            return sendViewDistance;
-        }
+        protected final TreeSet<ChunkPriorityHolder> sendQueueForTracking = createSendQueue();
+        protected final TreeSet<ChunkPriorityHolder> sendQueueForSeeing = createSendQueue();
 
-        public void setTargetSendViewDistance(final int distance) {
-            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
-                throw new IllegalArgumentException("Send view distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + " or -1, got: " + distance);
-            }
-            this.sendViewDistance = distance;
+        protected LongOpenHashSet getSentChunks(final boolean concernsTracking) {
+            return concernsTracking ? this.sentChunksForTracking : this.sentChunksForSeeing;
         }
-
-        public int getTargetNoTickViewDistance() {
-            return (this.loadViewDistance == -1 ? this.getLoadDistance() : this.loadViewDistance) - 1;
+        protected LongOpenHashSet getChunksToBeSent(final boolean concernsTracking) {
+            return concernsTracking ? this.chunksToBeSentForTracking : this.chunksToBeSentForSeeing;
         }
 
-        public void setTargetNoTickViewDistance(final int distance) {
-            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE)) {
-                throw new IllegalArgumentException("Simulation distance must be a number between " + MIN_VIEW_DISTANCE + " and " + MAX_VIEW_DISTANCE + " or -1, got: " + distance);
-            }
-            this.loadViewDistance = distance == -1 ? -1 : distance + 1;
+        protected TreeSet<ChunkPriorityHolder> getSendQueue(final boolean concernsTracking) {
+            return concernsTracking ? this.sendQueueForTracking : this.sendQueueForSeeing;
         }
 
+//        protected int sendViewDistance = -1;
+//        protected int loadViewDistance = -1;
+        public int tickViewDistance = -1;
+
+        // Martijn end - per-player view distance
+
+        protected long nextChunkSendTarget;
+
+//        // these view distance methods are for api
+//        public int getTargetSendViewDistance() {
+//            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+//            final int loadViewDistance = Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
+//            final int clientViewDistance = this.getClientViewDistance();
+//            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!PaperConfig.playerAutoConfigureSendViewDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
+//            return sendViewDistance;
+//        }
+//
+//        public void setTargetSendViewDistance(final int distance) {
+//            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
+//                throw new IllegalArgumentException("Send view distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + " or -1, got: " + distance);
+//            }
+//            this.sendViewDistance = distance;
+//        }
+//
+//        public int getTargetNoTickViewDistance() {
+//            return (this.loadViewDistance == -1 ? this.getLoadDistance() : this.loadViewDistance) - 1;
+//        }
+//
+//        public void setTargetNoTickViewDistance(final int distance) {
+//            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE)) {
+//                throw new IllegalArgumentException("Simulation distance must be a number between " + MIN_VIEW_DISTANCE + " and " + MAX_VIEW_DISTANCE + " or -1, got: " + distance);
+//            }
+//            this.loadViewDistance = distance == -1 ? -1 : distance + 1;
+//        }
+
         public int getTargetTickViewDistance() {
-            return this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+            // Martijn start - per-player load distance
+            return player.getTickingViewDistance();
+            // Martijn end - per-player load distance
         }
 
         public void setTargetTickViewDistance(final int distance) {
@@ -860,33 +934,37 @@ public final class PlayerChunkLoader {
             this.tickViewDistance = distance;
         }
 
-        protected int getLoadDistance() {
-            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+//        protected int getLoadDistance() {
+//            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+//
+//            return Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
+//        }
 
-            return Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
-        }
+        // Martijn start - per-player view distance
 
-        public boolean hasSentChunk(final int chunkX, final int chunkZ) {
-            return this.sentChunks.contains(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+        public boolean hasSentChunk(final int chunkX, final int chunkZ, final boolean concernsTracking) {
+            return this.getSentChunks(concernsTracking).contains(CoordinateUtils.getChunkKey(chunkX, chunkZ));
         }
 
-        public void sendChunk(final int chunkX, final int chunkZ, final Runnable onChunkSend) {
-            if (this.sentChunks.add(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
+        public void sendChunk(final int chunkX, final int chunkZ, final Runnable onChunkSend, final boolean concernsTracking) {
+            if (this.getSentChunks(concernsTracking).add(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
                 this.player.getLevel().getChunkSource().chunkMap.updateChunkTracking(this.player,
-                        new ChunkPos(chunkX, chunkZ), new MutableObject<>(), false, true); // unloaded, loaded
+                        new ChunkPos(chunkX, chunkZ), new MutableObject<>(), false, true, concernsTracking); // unloaded, loaded
                 this.player.connection.connection.execute(onChunkSend);
             } else {
                 throw new IllegalStateException();
             }
         }
 
-        public void unloadChunk(final int chunkX, final int chunkZ) {
-            if (this.sentChunks.remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
+        public void unloadChunk(final int chunkX, final int chunkZ, final boolean concernsTracking) {
+            if (this.getSentChunks(concernsTracking).remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
                 this.player.getLevel().getChunkSource().chunkMap.updateChunkTracking(this.player,
-                        new ChunkPos(chunkX, chunkZ), null, true, false); // unloaded, loaded
+                        new ChunkPos(chunkX, chunkZ), null, true, false, concernsTracking); // unloaded, loaded
             }
         }
 
+        // Martijn end - per-player view distance
+
         protected static boolean wantChunkLoaded(final int centerX, final int centerZ, final int chunkX, final int chunkZ,
                                                  final int sendRadius) {
             // expect sendRadius to be = 1 + target viewable radius
@@ -928,7 +1006,10 @@ public final class PlayerChunkLoader {
         }
 
         public void remove() {
-            this.loader.broadcastMap.remove(this.player);
+            // Martijn start - per-player track and see view distance
+            this.loader.getBroadcastMap(false).remove(this.player);
+            this.loader.getBroadcastMap(true).remove(this.player);
+            // Martijn end - per-player track and see view distance
             this.loader.loadMap.remove(this.player);
             this.loader.loadTicketCleanup.remove(this.player);
             this.loader.tickMap.remove(this.player);
@@ -939,12 +1020,17 @@ public final class PlayerChunkLoader {
         }
 
         public void update() {
-            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+            // Martijn start - per-player view distance
+            this.player.level.timings.playerChunkLoaderUpdate.startTiming();
+            final int loadViewDistance = this.player.getLoadViewDistance();
             // load view cannot be less-than tick view + 1
-            final int loadViewDistance = Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
+            final int tickViewDistance = this.player.getTickingViewDistance();
             // send view cannot be greater-than load view
             final int clientViewDistance = this.getClientViewDistance();
-            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!PaperConfig.playerAutoConfigureSendViewDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
+//            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!PaperConfig.playerAutoConfigureSendViewDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
+            final int trackViewDistance = this.player.getTrackViewDistance();
+            final int seeViewDistance = this.player.getSeeViewDistance();
+            // Martijn end - per-player view distance
 
             final double posX = this.player.getX();
             final double posZ = this.player.getZ();
@@ -959,7 +1045,7 @@ public final class PlayerChunkLoader {
 
             if (
                 // has view distance stayed the same?
-                    sendViewDistance == this.lastSendDistance
+                    trackViewDistance == this.lastTrackDistance && seeViewDistance == this.lastSeeDistance // Martijn - per-player track and see view distance
                             && loadViewDistance == this.lastLoadDistance
                             && tickViewDistance == this.lastTickDistance
 
@@ -980,6 +1066,7 @@ public final class PlayerChunkLoader {
                             && (!this.usingLookingPriority || Math.abs(yaw - this.lastYaw) <= LOOK_PRIORITY_YAW_DELTA_RECALC_THRESHOLD)
             ) {
                 // nothing we care about changed, so we're not re-calculating
+                this.player.level.timings.playerChunkLoaderUpdate.stopTiming(); // Martijn - per-player view distance
                 return;
             }
 
@@ -987,16 +1074,20 @@ public final class PlayerChunkLoader {
             final int centerChunkZ = Mth.floor(posZ) >> 4;
 
             final boolean needsChunkCenterUpdate = (centerChunkX != this.lastChunkX) || (centerChunkZ != this.lastChunkZ);
-            this.loader.broadcastMap.addOrUpdate(this.player, centerChunkX, centerChunkZ, sendViewDistance);
+
+            // Martijn start - per-player track and see view distance
+            this.loader.getBroadcastMap(false).addOrUpdate(this.player, centerChunkX, centerChunkZ, seeViewDistance);
+            this.loader.getBroadcastMap(true).addOrUpdate(this.player, centerChunkX, centerChunkZ, trackViewDistance);
+            // Martijn end - per-player track and see view distance
             this.loader.loadMap.addOrUpdate(this.player, centerChunkX, centerChunkZ, loadViewDistance);
             this.loader.loadTicketCleanup.addOrUpdate(this.player, centerChunkX, centerChunkZ, loadViewDistance + 1);
             this.loader.tickMap.addOrUpdate(this.player, centerChunkX, centerChunkZ, tickViewDistance);
 
-            if (sendViewDistance != this.lastSendDistance) {
+            if (seeViewDistance != this.lastSeeDistance) { // Martijn - per-player track and see view distance
                 // update the view radius for client
                 // note that this should be after the map calls because the client wont expect unload calls not in its VD
                 // and it's possible we decreased VD here
-                this.player.connection.send(new ClientboundSetChunkCacheRadiusPacket(sendViewDistance));
+                this.player.connection.send(new ClientboundSetChunkCacheRadiusPacket(seeViewDistance)); // Martijn - per-player track and see view distance
             }
             if (tickViewDistance != this.lastTickDistance) {
                 this.player.connection.send(new ClientboundSetSimulationDistancePacket(tickViewDistance));
@@ -1005,7 +1096,10 @@ public final class PlayerChunkLoader {
             this.lastLocX = posX;
             this.lastLocZ = posZ;
             this.lastYaw = yaw;
-            this.lastSendDistance = sendViewDistance;
+            // Martijn start - per-player track and see view distance
+            this.lastTrackDistance = trackViewDistance;
+            this.lastSeeDistance = seeViewDistance;
+            // Martijn start - per-player track and see view distance
             this.lastLoadDistance = loadViewDistance;
             this.lastTickDistance = tickViewDistance;
             this.usingLookingPriority = useLookPriority;
@@ -1035,76 +1129,87 @@ public final class PlayerChunkLoader {
 
             final List<ChunkPriorityHolder> loadQueue = new ArrayList<>();
 
+            // Martijn start - per-player track and see view distance
+
             // clear send queue, we are re-sorting
-            this.sendQueue.clear();
+            this.getSendQueue(false).clear();
+            this.getSendQueue(true).clear();
             // clear chunk want set, vd/position might have changed
-            this.chunksToBeSent.clear();
-
-            final int searchViewDistance = Math.max(loadViewDistance, sendViewDistance);
-
-            for (int dx = -searchViewDistance; dx <= searchViewDistance; ++dx) {
-                for (int dz = -searchViewDistance; dz <= searchViewDistance; ++dz) {
-                    final int chunkX = dx + centerChunkX;
-                    final int chunkZ = dz + centerChunkZ;
-                    final int squareDistance = Math.max(Math.abs(dx), Math.abs(dz));
-                    final boolean sendChunk = squareDistance <= sendViewDistance && wantChunkLoaded(centerChunkX, centerChunkZ, chunkX, chunkZ, sendViewDistance);
-
-                    if (this.hasSentChunk(chunkX, chunkZ)) {
-                        // already sent (which means it is also loaded)
-                        if (!sendChunk) {
-                            // have sent the chunk, but don't want it anymore
-                            // unload it now
-                            this.unloadChunk(chunkX, chunkZ);
+            this.getChunksToBeSent(false).clear();
+            this.getChunksToBeSent(true).clear();
+
+            for (boolean concernsTracking : new boolean[] {false, true}) {
+
+                final int sendViewDistance = concernsTracking ? trackViewDistance : seeViewDistance;
+
+                final int searchViewDistance = Math.max(loadViewDistance, sendViewDistance);
+
+                for (int dx = -searchViewDistance; dx <= searchViewDistance; ++dx) {
+                    for (int dz = -searchViewDistance; dz <= searchViewDistance; ++dz) {
+                        final int chunkX = dx + centerChunkX;
+                        final int chunkZ = dz + centerChunkZ;
+                        final int squareDistance = Math.max(Math.abs(dx), Math.abs(dz));
+                        final boolean sendChunk = squareDistance <= sendViewDistance && wantChunkLoaded(centerChunkX, centerChunkZ, chunkX, chunkZ, sendViewDistance);
+
+                        if (this.hasSentChunk(chunkX, chunkZ, concernsTracking)) {
+                            // already sent (which means it is also loaded)
+                            if (!sendChunk) {
+                                // have sent the chunk, but don't want it anymore
+                                // unload it now
+                                this.unloadChunk(chunkX, chunkZ, concernsTracking);
+                            }
+                            continue;
                         }
-                        continue;
-                    }
 
-                    final boolean loadChunk = squareDistance <= loadViewDistance;
+                        final boolean loadChunk = squareDistance <= loadViewDistance;
 
-                    final boolean prioritised = useLookPriority && triangleIntersects(
+                        final boolean prioritised = useLookPriority && triangleIntersects(
                             // prioritisation triangle
                             p1x, p1z, p2x, p2z, p3x, p3z,
 
                             // center of chunk
-                            (double)((chunkX << 4) | 8), (double)((chunkZ << 4) | 8)
-                    );
+                            (double) ((chunkX << 4) | 8), (double) ((chunkZ << 4) | 8)
+                        );
 
-                    final int manhattanDistance = Math.abs(dx) + Math.abs(dz);
+                        final int manhattanDistance = Math.abs(dx) + Math.abs(dz);
 
-                    final double priority;
+                        final double priority;
 
-                    if (squareDistance <= PaperConfig.playerMinChunkLoadRadius) {
-                        // priority should be negative, and we also want to order it from center outwards
-                        // so we want (0,0) to be the smallest, and (minLoadedRadius,minLoadedRadius) to be the greatest
-                        priority = -((2 * PaperConfig.playerMinChunkLoadRadius + 1) - manhattanDistance);
-                    } else {
-                        if (prioritised) {
-                            // we don't prioritise these chunks above others because we also want to make sure some chunks
-                            // will be loaded if the player changes direction
-                            priority = (double)manhattanDistance / 6.0;
+                        if (squareDistance <= PaperConfig.playerMinChunkLoadRadius) {
+                            // priority should be negative, and we also want to order it from center outwards
+                            // so we want (0,0) to be the smallest, and (minLoadedRadius,minLoadedRadius) to be the greatest
+                            priority = -((2 * PaperConfig.playerMinChunkLoadRadius + 1) - manhattanDistance);
                         } else {
-                            priority = (double)manhattanDistance;
+                            if (prioritised) {
+                                // we don't prioritise these chunks above others because we also want to make sure some chunks
+                                // will be loaded if the player changes direction
+                                priority = (double) manhattanDistance / 6.0;
+                            } else {
+                                priority = (double) manhattanDistance;
+                            }
                         }
-                    }
 
-                    final ChunkPriorityHolder holder = new ChunkPriorityHolder(chunkX, chunkZ, manhattanDistance, priority);
+                        final ChunkPriorityHolder holder = new ChunkPriorityHolder(chunkX, chunkZ, manhattanDistance, priority);
 
-                    if (!this.loader.isChunkPlayerLoaded(chunkX, chunkZ)) {
-                        if (loadChunk) {
-                            loadQueue.add(holder);
+                        if (!this.loader.isChunkPlayerLoaded(chunkX, chunkZ)) {
+                            if (loadChunk) {
+                                loadQueue.add(holder);
+                                if (sendChunk) {
+                                    this.getChunksToBeSent(concernsTracking).add(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+                                }
+                            }
+                        } else {
+                            // loaded but not sent: so queue it!
                             if (sendChunk) {
-                                this.chunksToBeSent.add(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+                                this.getSendQueue(concernsTracking).add(holder);
                             }
                         }
-                    } else {
-                        // loaded but not sent: so queue it!
-                        if (sendChunk) {
-                            this.sendQueue.add(holder);
-                        }
                     }
                 }
             }
 
+            // Martijn end - per-player track and see view distance
+
             loadQueue.sort((final ChunkPriorityHolder p1, final ChunkPriorityHolder p2) -> {
                 return Double.compare(p1.priority, p2.priority);
             });
@@ -1123,6 +1228,9 @@ public final class PlayerChunkLoader {
             if (needsChunkCenterUpdate) {
                 this.player.connection.send(new ClientboundSetChunkCacheCenterPacket(centerChunkX, centerChunkZ));
             }
+
+            this.player.level.timings.playerChunkLoaderUpdate.stopTiming(); // Martijn - per-player view distance
+
         }
     }
 }
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index e8e49e1bdf1ff4ea60a4feb6ec52d999cbced256..e1a0fdb8a28d13722e41d7ef8620bfcdd7a3f748 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -647,7 +647,12 @@ public final class MCUtil {
             });
 
             worldData.addProperty("name", world.getWorld().getName());
-            worldData.addProperty("view-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetNoTickViewDistance()); // Paper - replace chunk loader system
+            // Martijn start - per-player view distance
+            worldData.addProperty("view-distance", world.getChunkSource().chunkMap.getVanillaWorldViewDistance()); // Paper - replace chunk loader system
+            worldData.addProperty("max-track-view-distance", world.paperConfig.getMaxTrackViewDistance());
+            worldData.addProperty("max-see-view-distance", world.paperConfig.getMaxSeeViewDistance());
+            worldData.addProperty("max-load-view-distance", world.paperConfig.getMaxLoadViewDistance());
+            // Martijn end - per-player view distance
             worldData.addProperty("tick-view-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance()); // Paper - replace chunk loader system
             worldData.addProperty("keep-spawn-loaded", world.keepSpawnInMemory);
             worldData.addProperty("keep-spawn-loaded-range", world.paperConfig.keepLoadedRange);
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index 2ebaff03052d800d3dad05bbf67729b02bd3262a..6ef905a85cce7d12af64b665aed631f70e7ddfac 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -404,7 +404,7 @@ public class ChunkHolder {
         // Paper start - per player view distance
         // there can be potential desync with player's last mapped section and the view distance map, so use the
         // view distance map here.
-        com.destroystokyo.paper.util.misc.PlayerAreaMap viewDistanceMap = this.chunkMap.playerChunkManager.broadcastMap; // Paper - replace old player chunk manager
+        com.destroystokyo.paper.util.misc.PlayerAreaMap viewDistanceMap = this.chunkMap.playerChunkManager.broadcastMapForTracking; // Paper - replace old player chunk manager // Martijn - per-player track and see view distance
         com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> players = viewDistanceMap.getObjectsInRange(this.pos);
         if (players == null) {
             return;
@@ -417,7 +417,7 @@ public class ChunkHolder {
                 continue;
             }
             ServerPlayer player = (ServerPlayer)temp;
-            if (!this.chunkMap.playerChunkManager.isChunkSent(player, this.pos.x, this.pos.z, onlyOnWatchDistanceEdge)) {
+            if (!this.chunkMap.playerChunkManager.isChunkSent(player, this.pos.x, this.pos.z, onlyOnWatchDistanceEdge, true)) { // Martijn - per-player track and see view distance
                 continue;
             }
             player.connection.send(packet);
@@ -848,7 +848,8 @@ public class ChunkHolder {
 
     public interface PlayerProvider {
 
-        List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge);
+        List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge, boolean concernsTracking); // Martijn - per-player track and see view distance
+
     }
 
     private static final class ChunkSaveDebug {
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 797672bdad1745eba537f5b1ae3db4d2d25457a8..d2d0530f506e09f2d46eb4058a6b3deda1928488 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -5,10 +5,7 @@ import com.destroystokyo.paper.PaperWorldConfig; // Paper
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableList.Builder;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.ComparisonChain; // Paper
 import com.google.common.collect.Lists;
-import com.google.common.collect.Queues;
-import com.google.common.collect.Sets;
 import com.google.gson.JsonElement;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Either;
@@ -35,11 +32,8 @@ import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.Comparator;
-import java.util.HashMap; // Paper
-import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map; // Paper
 import java.util.Objects;
 import java.util.Optional;
 import java.util.Queue;
@@ -71,7 +65,6 @@ import net.minecraft.core.SectionPos;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
-import net.minecraft.network.protocol.game.ClientboundSetChunkCacheCenterPacket;
 import net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket;
 import net.minecraft.network.protocol.game.ClientboundSetPassengersPacket;
 import net.minecraft.network.protocol.game.DebugPackets;
@@ -109,12 +102,10 @@ import net.minecraft.world.level.levelgen.structure.StructureStart;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureManager;
 import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelStorageSource;
-import net.minecraft.world.phys.Vec3;
 import it.unimi.dsi.fastutil.objects.ObjectRBTreeSet; // Paper
 import org.apache.commons.lang3.mutable.MutableBoolean;
 import org.apache.commons.lang3.mutable.MutableObject;
 import org.slf4j.Logger;
-import org.bukkit.entity.Player;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
 
@@ -166,7 +157,10 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     private final Long2ByteMap chunkTypeCache;
     private final Long2LongMap chunkSaveCooldowns;
     private final Queue<Runnable> unloadQueue;
-    int viewDistance;
+    // Martijn start- per-player view distance
+    // This value is the intended world send view distance + 1
+    private int vanillaWorldViewDistancePlusOne;
+    // Martijn end - per-player view distance
     public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerMobDistanceMap; // Paper
     public final ReferenceOpenHashSet<ChunkHolder> needsChangeBroadcasting = new ReferenceOpenHashSet<>();
 
@@ -251,7 +245,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
             int trackRange = this.entityTrackerTrackRanges[i];
 
-            trackMap.add(player, chunkX, chunkZ, Math.min(trackRange, io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player))); // Paper - per player view distances
+            trackMap.add(player, chunkX, chunkZ, Math.min(trackRange, player.getTrackViewDistance())); // Paper - per player view distances // Martijn - per-player track view distance
         }
         // Paper end - use distance map to optimise entity tracker
         // Note: players need to be explicitly added to distance maps before they can be updated
@@ -293,7 +287,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
             int trackRange = this.entityTrackerTrackRanges[i];
 
-            trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player))); // Paper - per player view distances
+            trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, player.getTrackViewDistance())); // Paper - per player view distances // Martijn - per-player track view distance
         }
         // Paper end - use distance map to optimise entity tracker
         this.playerChunkTickRangeMap.update(player, chunkX, chunkZ, DistanceManager.MOB_SPAWN_RANGE); // Paper - optimise ChunkMap#anyPlayerCloseEnoughForSpawning
@@ -470,7 +464,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // Martijn end - sort chunks by distance
 
     boolean unloadingPlayerChunk = false; // Paper - do not allow ticket level changes while unloading chunks
-    public ChunkMap(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureManager structureManager, Executor executor, BlockableEventLoop<Runnable> mainThreadExecutor, LightChunkGetter chunkProvider, ChunkGenerator chunkGenerator, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory, int viewDistance, boolean dsync) {
+    public ChunkMap(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureManager structureManager, Executor executor, BlockableEventLoop<Runnable> mainThreadExecutor, LightChunkGetter chunkProvider, ChunkGenerator chunkGenerator, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory, int vanillaWorldViewDistance, boolean dsync) { // Martijn - per-player view distance
         super(session.getDimensionPath(world.dimension()).resolve("region"), dataFixer, dsync);
         // Paper - don't copy
         this.pendingUnloads = new Long2ObjectLinkedOpenHashMap();
@@ -515,7 +509,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         this.distanceManager = new ChunkMap.ChunkDistanceManager(executor, mainThreadExecutor);
         this.overworldDataStorage = persistentStateManagerFactory;
         this.poiManager = new PoiManager(path.resolve("poi"), dataFixer, dsync, world);
-        this.setViewDistance(viewDistance);
+        this.setVanillaWorldViewDistance(vanillaWorldViewDistance); // Martijn - per-player view distance
         // Paper start
         this.dataRegionManager = new io.papermc.paper.chunk.SingleThreadChunkRegionManager(this.level, 2, (1.0 / 3.0), 1, 6, "Data", DataRegionData::new, DataRegionSectionData::new);
         this.regionManagers.add(this.dataRegionManager);
@@ -759,13 +753,15 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
     }
 
+    // Martijn start - per-player view distance
     // Paper start
-    public final int getEffectiveViewDistance() {
+    public final int getVanillaWorldViewDistance() {
         // TODO this needs to be checked on update
         // Mojang currently sets it to +1 of the configured view distance. So subtract one to get the one we really want.
-        return this.viewDistance - 1;
+        return this.vanillaWorldViewDistancePlusOne - 1;
     }
     // Paper end
+    // Martijn end - per-player view distance
 
     private CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> getChunkRangeFuture(ChunkPos centerChunk, int margin, IntFunction<ChunkStatus> distanceToStatus) {
         List<CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> list = new ArrayList();
@@ -1650,17 +1646,20 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
     }
 
-    public void setViewDistance(int watchDistance) {
-        int j = Mth.clamp(watchDistance + 1, (int) 3, (int) 33);
+    // Martijn start - per-player view distance
+    public void setVanillaWorldViewDistance(int vanillaWorldViewDistance) {
+        int newVanillaWorldViewDistancePlusOne = Mth.clamp(vanillaWorldViewDistance + 1, (int) 3, (int) 33);
 
-        if (j != this.viewDistance) {
-            int k = this.viewDistance;
+        if (newVanillaWorldViewDistancePlusOne != this.vanillaWorldViewDistancePlusOne) {
+            int k = this.vanillaWorldViewDistancePlusOne;
 
-            this.viewDistance = j;
-            this.playerChunkManager.setLoadDistance(this.viewDistance); // Paper - replace player loader system
+            this.vanillaWorldViewDistancePlusOne = newVanillaWorldViewDistancePlusOne;
+            // No longer needed since PlayerChunkLoader.update() will pull the most current load view distance when it executes
+//            this.playerChunkManager.setLoadDistance(Mth.clamp(this.vanillaWorldViewDistancePlusOne, 2, 32)); // Paper - replace player loader system
         }
 
     }
+    // Martijn end - per-player view distance
 
     // Paper start - replace player loader system
     public void setTickViewDistance(int distance) {
@@ -1668,7 +1667,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
     // Paper end - replace player loader system
 
-    public void updateChunkTracking(ServerPlayer player, ChunkPos pos, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> packet, boolean oldWithinViewDistance, boolean newWithinViewDistance) { // Paper - Anti-Xray - Bypass // Paper - public
+    public void updateChunkTracking(ServerPlayer player, ChunkPos pos, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> packet, boolean oldWithinViewDistance, boolean newWithinViewDistance, boolean concernsTracking) { // Paper - Anti-Xray - Bypass // Paper - public // Martijn - per-player track and see view distance
         if (player.level == this.level) {
             if (newWithinViewDistance && !oldWithinViewDistance) {
                 ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos.toLong());
@@ -1677,7 +1676,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                     LevelChunk chunk = playerchunk.getSendingChunk(); // Paper - replace chunk loader system
 
                     if (chunk != null) {
-                        this.playerLoadedChunk(player, packet, chunk);
+                        this.playerLoadedChunk(player, packet, chunk, concernsTracking); // Martijn - per-player track and see view distance
                     }
 
                     DebugPackets.sendPoiPacketsForChunk(this.level, pos);
@@ -1685,7 +1684,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
 
             if (!newWithinViewDistance && oldWithinViewDistance) {
-                player.untrackChunk(pos);
+                player.untrackChunk(pos, concernsTracking); // Martijn - per-player track and see view distance
             }
 
         }
@@ -1953,6 +1952,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public void move(ServerPlayer player) {
         // Paper - delay this logic for the entity tracker tick, no need to duplicate it
 
+        this.level.timings.chunkMapPlayerMove.startTiming(); // Martijn - per-player view distance
+
         int i = SectionPos.blockToSectionCoord(player.getBlockX());
         int j = SectionPos.blockToSectionCoord(player.getBlockZ());
         SectionPos sectionposition = player.getLastSectionPos();
@@ -1965,6 +1966,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
         if (flag2 || flag != flag1) {
             this.updatePlayerPos(player);
+
             if (!flag) {
                 this.distanceManager.removePlayer(sectionposition, player);
             }
@@ -1996,16 +1998,18 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         this.updateMaps(player); // Paper - distance maps
         this.playerChunkManager.updatePlayer(player); // Paper - respond to movement immediately
 
+        this.level.timings.chunkMapPlayerMove.stopTiming(); // Martijn - per-player view distance
+
     }
 
     @Override
-    public List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge) {
+    public List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge, boolean concernsTracking) { // Martijn - per-player track and see view distance
         // Paper start - per player view distance
         // there can be potential desync with player's last mapped section and the view distance map, so use the
         // view distance map here.
         List<ServerPlayer> ret = new java.util.ArrayList<>(4);
 
-        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> players = this.playerChunkManager.broadcastMap.getObjectsInRange(chunkPos);
+        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> players = this.playerChunkManager.getBroadcastMap(concernsTracking).getObjectsInRange(chunkPos); // Martijn - per-player track and see view distance
         if (players == null) {
             return ret;
         }
@@ -2122,6 +2126,13 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // Paper end - optimised tracker
 
     protected void tick() {
+
+        // Martijn start - temporary debug message containing the number of loaded chunks
+        if (this.level.paperConfig.printLoadedChunksInterval > 0 && Math.random() < 1.0 / this.level.paperConfig.printLoadedChunksInterval) {
+            org.bukkit.Bukkit.getLogger().info("Number of loaded chunks in " + this.level.getWorld().getName() + ": " + this.level.getWorld().getLoadedChunks().length);
+        }
+        // Martijn end - temporary debug message containing the number of loaded chunks
+
         // Paper start - optimized tracker
         if (true) {
             this.processTrackQueue();
@@ -2190,7 +2201,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     // Paper start - Anti-Xray - Bypass
-    private void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk) {
+    private void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk, boolean concernsTracking) { // Martijn - per-player track and see view distance
         if (cachedDataPackets.getValue() == null) {
             cachedDataPackets.setValue(new java.util.HashMap<>());
         }
@@ -2198,58 +2209,66 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
         player.trackChunk(chunk.getPos(), cachedDataPackets.getValue().computeIfAbsent(shouldModify, (s) -> {
             return new ClientboundLevelChunkWithLightPacket(chunk, this.lightEngine, (BitSet) null, (BitSet) null, true, (Boolean) s);
-        }));
+        }), concernsTracking);
         // Paper end
         DebugPackets.sendPoiPacketsForChunk(this.level, chunk.getPos());
-        List<Entity> list = Lists.newArrayList();
-        List<Entity> list1 = Lists.newArrayList();
-        // Paper start - optimise entity tracker
-        // use the chunk entity list, not the whole trackedEntities map...
-        Entity[] entities = chunk.entities.getRawData();
-        for (int i = 0, size = chunk.entities.size(); i < size; ++i) {
-            Entity entity = entities[i];
-            if (entity == player) {
-                continue;
-            }
-            ChunkMap.TrackedEntity tracker = this.entityMap.get(entity.getId());
-            if (tracker != null) { // dumb plugins... move on...
-                tracker.updatePlayer(player);
-            }
 
-            // keep the vanilla logic here - this is REQUIRED or else passengers and their vehicles disappear!
-            // (and god knows what the leash thing is)
+        // Martijn start - per-player track and see view distance
+        if (concernsTracking) {
+
+            List<Entity> list = Lists.newArrayList();
+            List<Entity> list1 = Lists.newArrayList();
+            // Paper start - optimise entity tracker
+            // use the chunk entity list, not the whole trackedEntities map...
+            Entity[] entities = chunk.entities.getRawData();
+            for (int i = 0, size = chunk.entities.size(); i < size; ++i) {
+                Entity entity = entities[i];
+                if (entity == player) {
+                    continue;
+                }
+                ChunkMap.TrackedEntity tracker = this.entityMap.get(entity.getId());
+                if (tracker != null) { // dumb plugins... move on...
+                    tracker.updatePlayer(player);
+                }
+
+                // keep the vanilla logic here - this is REQUIRED or else passengers and their vehicles disappear!
+                // (and god knows what the leash thing is)
 
-            if (entity instanceof Mob && ((Mob)entity).getLeashHolder() != null) {
-                list.add(entity);
-            }
+                if (entity instanceof Mob && ((Mob) entity).getLeashHolder() != null) {
+                    list.add(entity);
+                }
 
-            if (!entity.getPassengers().isEmpty()) {
-                list1.add(entity);
+                if (!entity.getPassengers().isEmpty()) {
+                    list1.add(entity);
+                }
             }
-        }
-        // Paper end - optimise entity tracker
+            // Paper end - optimise entity tracker
 
-        Iterator iterator;
-        Entity entity1;
+            Iterator iterator;
+            Entity entity1;
 
-        if (!list.isEmpty()) {
-            iterator = list.iterator();
+            if (!list.isEmpty()) {
+                iterator = list.iterator();
 
-            while (iterator.hasNext()) {
-                entity1 = (Entity) iterator.next();
-                player.connection.send(new ClientboundSetEntityLinkPacket(entity1, ((Mob) entity1).getLeashHolder()));
+                while (iterator.hasNext()) {
+                    entity1 = (Entity) iterator.next();
+                    player.connection.send(new ClientboundSetEntityLinkPacket(entity1, ((Mob) entity1).getLeashHolder()));
+                }
             }
-        }
 
-        if (!list1.isEmpty()) {
-            iterator = list1.iterator();
+            if (!list1.isEmpty()) {
+                iterator = list1.iterator();
 
-            while (iterator.hasNext()) {
-                entity1 = (Entity) iterator.next();
-                player.connection.send(new ClientboundSetPassengersPacket(entity1));
+                while (iterator.hasNext()) {
+                    entity1 = (Entity) iterator.next();
+                    player.connection.send(new ClientboundSetPassengersPacket(entity1));
+                }
             }
+
         }
 
+        // Martijn end - per-player track and see view distance
+
     }
 
     public PoiManager getPoiManager() {
@@ -2393,7 +2412,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 double vec3d_dx = player.getX() - this.entity.getX();
                 double vec3d_dz = player.getZ() - this.entity.getZ();
                 // Paper end - remove allocation of Vec3D here
-                double d0 = (double) Math.min(this.getEffectiveRange(), io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player) * 16); // Paper - per player view distance
+                double d0 = (double) Math.min(this.getEffectiveRange(), player.getTrackViewDistance() * 16); // Paper - per player view distance // Martijn - per-player track view distance
                 double d1 = vec3d_dx * vec3d_dx + vec3d_dz * vec3d_dz; // Paper
                 double d2 = d0 * d0;
                 boolean flag = d1 <= d2 && this.entity.broadcastToPlayer(player);
diff --git a/src/main/java/net/minecraft/server/level/DistanceManager.java b/src/main/java/net/minecraft/server/level/DistanceManager.java
index 2c5cf08e16669d5be8ba7d6e3f9282c74f9ea295..3470f3583ef1e6511d22ae3cc08ce66e1d99cb78 100644
--- a/src/main/java/net/minecraft/server/level/DistanceManager.java
+++ b/src/main/java/net/minecraft/server/level/DistanceManager.java
@@ -548,9 +548,12 @@ public abstract class DistanceManager {
         return arraysetsorted != null && !arraysetsorted.isEmpty() ? ((Ticket) arraysetsorted.first()).toString() : "no_ticket";
     }
 
-    protected void updatePlayerTickets(int viewDistance) {
-        this.chunkMap.playerChunkManager.setTargetNoTickViewDistance(viewDistance); // Paper - route to player chunk manager
-    }
+    // Martijn start - per-player load view distance
+    // No longer needed since PlayerChunkLoader.update() will pull the most current load view distance when it executes
+//    protected void updatePlayerTickets(int viewDistance) {
+//        this.chunkMap.playerChunkManager.setTargetNoTickViewDistance(viewDistance); // Paper - route to player chunk manager
+//    }
+    // Martijn end - per-player load view distance
 
     public void updateSimulationDistance(int simulationDistance) {
         this.chunkMap.playerChunkManager.setTargetTickViewDistance(simulationDistance); // Paper - route to player chunk manager
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index b42e32bd1a6a669f498b577ec04661c4ba651198..04329f3651a1f0464f85a42bc44239ecf7f56bfc 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -937,7 +937,7 @@ public class ServerChunkCache extends ChunkSource {
                     continue;
                 }
 
-                int viewDistance = this.chunkMap.getEffectiveViewDistance();
+                int viewDistance = this.chunkMap.getVanillaWorldViewDistance(); // Martijn - per-player view distance
 
                 // copied and modified from isOutisdeRange
                 int chunkRange = level.spigotConfig.mobSpawnRange;
@@ -1206,9 +1206,11 @@ public class ServerChunkCache extends ChunkSource {
         this.chunkMap.broadcast(entity, packet);
     }
 
-    public void setViewDistance(int watchDistance) {
-        this.chunkMap.setViewDistance(watchDistance);
+    // Martijn start - per-player view distance
+    public void setVanillaWorldViewDistance(int vanillaWorldViewDistance) {
+        this.chunkMap.setVanillaWorldViewDistance(vanillaWorldViewDistance);
     }
+    // Martijn end - per-player view distance
 
     public void setSimulationDistance(int simulationDistance) {
         this.distanceManager.updateSimulationDistance(simulationDistance);
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 6efe4ccdfc6ca148ae1cb96a5cdf723a3882fd60..8efa634ca8121c7f6da7a6e9b575f6cd126dd6dd 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -8,8 +8,6 @@ import com.mojang.datafixers.util.Either;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.DataResult;
 
-import java.util.ArrayDeque;
-import java.util.BitSet;
 import java.util.Collection;
 import java.util.Comparator;
 import java.util.Iterator;
@@ -22,12 +20,9 @@ import java.util.UUID;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 
+import io.papermc.paper.chunk.PlayerChunkLoader;
 import it.unimi.dsi.fastutil.Pair;
 import it.unimi.dsi.fastutil.ints.IntIntPair;
-import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import it.unimi.dsi.fastutil.longs.LongSet;
-import it.unimi.dsi.fastutil.objects.Object2ObjectMap;
-import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectObjectImmutablePair;
 import net.minecraft.BlockUtil;
 import net.minecraft.ChatFormatting;
@@ -65,8 +60,6 @@ import net.minecraft.network.protocol.game.ClientboundEntityEventPacket;
 import net.minecraft.network.protocol.game.ClientboundForgetLevelChunkPacket;
 import net.minecraft.network.protocol.game.ClientboundGameEventPacket;
 import net.minecraft.network.protocol.game.ClientboundHorseScreenOpenPacket;
-import net.minecraft.network.protocol.game.ClientboundKeepAlivePacket;
-import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
 import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
 import net.minecraft.network.protocol.game.ClientboundMerchantOffersPacket;
 import net.minecraft.network.protocol.game.ClientboundOpenBookPacket;
@@ -81,13 +74,10 @@ import net.minecraft.network.protocol.game.ClientboundRemoveMobEffectPacket;
 import net.minecraft.network.protocol.game.ClientboundResourcePackPacket;
 import net.minecraft.network.protocol.game.ClientboundRespawnPacket;
 import net.minecraft.network.protocol.game.ClientboundSetCameraPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket;
 import net.minecraft.network.protocol.game.ClientboundSetExperiencePacket;
 import net.minecraft.network.protocol.game.ClientboundSetHealthPacket;
-import net.minecraft.network.protocol.game.ClientboundSetPassengersPacket;
 import net.minecraft.network.protocol.game.ClientboundSoundPacket;
 import net.minecraft.network.protocol.game.ClientboundUpdateMobEffectPacket;
-import net.minecraft.network.protocol.game.DebugPackets;
 import net.minecraft.network.protocol.game.ServerboundClientInformationPacket;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
@@ -151,7 +141,6 @@ import net.minecraft.world.level.block.entity.CommandBlockEntity;
 import net.minecraft.world.level.block.entity.SignBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.border.WorldBorder;
-import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.dimension.LevelStem;
 import net.minecraft.world.level.portal.PortalInfo;
 import net.minecraft.world.phys.AABB;
@@ -185,11 +174,280 @@ import org.bukkit.event.player.PlayerPortalEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 import org.bukkit.inventory.MainHand;
+import org.jetbrains.annotations.NotNull;
 // CraftBukkit end
 
 public class ServerPlayer extends Player {
 
     private static final Logger LOGGER = LogUtils.getLogger();
+
+    // Martijn start - per-player view distance
+
+    private static int[] maxViewDistanceDueToTotalViewedChunks = {32, 32};
+
+    /**
+     * Does not change any state
+     * Is called only from ServerPlayer.maxViewDistanceDueToTotalViewedChunksMayHaveChanged(type)
+     */
+    private static int computeMaxViewDistanceDueToTotalViewedChunks(int type) {
+        int maxTotalChunks = (type == 0) ? PaperConfig.maxTotalTrackedChunks : PaperConfig.maxTotalSeenChunks;
+        if (maxTotalChunks == -1) return -1;
+        int candidateViewDistance = maxViewDistanceDueToTotalViewedChunks[type];
+        int[] playerViewDistances = new int[MinecraftServer.getServer().getPlayerCount()];
+        int playerI = 0;
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().players) {
+            playerViewDistances[playerI] = player.getViewDistance(type);
+            playerI++;
+        }
+        for (boolean increase : new boolean[] {false, true}) {
+            int chunks = 0;
+            for (int playerViewDistance : playerViewDistances) {
+                // We assume the worst: that if the player's view distance is equal to the current limit, that it will definitely grow to the new limit
+                int playerViewDistanceUnderCandidateAssumption = playerViewDistance >= ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type] ? candidateViewDistance : Math.min(candidateViewDistance, playerViewDistance);
+                int playerViewDimensionUnderCandidateAssumption = playerViewDistanceUnderCandidateAssumption * 2 + 1;
+                chunks += playerViewDimensionUnderCandidateAssumption * playerViewDimensionUnderCandidateAssumption;
+            }
+            if (candidateViewDistance > 2 && (chunks > maxTotalChunks || candidateViewDistance > 32)) {
+                candidateViewDistance--;
+                if (increase) {
+                    continue;
+                }
+            } else {
+                candidateViewDistance++;
+                if (!increase) {
+                    continue;
+                }
+            }
+        }
+        return candidateViewDistance;
+    }
+
+    /**
+     * Is called only from ServerPlayer.maxViewDistanceDueToTotalViewedChunksMayHaveChanged(type)
+     */
+    private static void processMaxViewDistanceDueToTotalViewedChunksChange(int oldMaxViewDistanceDueToTotalViewedChunks, int type) {
+        if (oldMaxViewDistanceDueToTotalViewedChunks == ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type]) return;
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().players) {
+            player.viewDistanceMayHaveChanged(type);
+        }
+    }
+
+    public static void maxTrackViewDistanceDueToTotalTrackedChunksMayHaveChanged() {
+        ServerPlayer.maxViewDistanceDueToTotalViewedChunksMayHaveChanged(0);
+    }
+
+    public static void maxSeeViewDistanceDueToTotalSeenChunksMayHaveChanged() {
+        ServerPlayer.maxViewDistanceDueToTotalViewedChunksMayHaveChanged(1);
+    }
+
+    /**
+     * Is called only from ServerPlayer.processViewDistanceChange(type)
+     */
+    private static void maxViewDistanceDueToTotalViewedChunksMayHaveChanged(int type) {
+        int oldMaxViewDistanceDueToTotalViewedChunks = ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type];
+        ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type] = ServerPlayer.computeMaxViewDistanceDueToTotalViewedChunks(type);
+        ServerPlayer.processMaxViewDistanceDueToTotalViewedChunksChange(oldMaxViewDistanceDueToTotalViewedChunks, type);
+    }
+
+    private final int getWorldSeeViewDistance() { return this.getLevel().getChunkSource().chunkMap.getVanillaWorldViewDistance() - 1; } // Paper - placeholder
+
+    private final int getWorldTrackViewDistance() {
+        return this.getWorldSeeViewDistance();
+    }
+
+    private final int getWorldLoadViewDistance() {
+        return this.getWorldSeeViewDistance() + 1;
+    }
+
+    private final int getWorldViewDistance(int type) {
+        switch (type) {
+            case 0: return this.getWorldTrackViewDistance();
+            case 1: return this.getWorldSeeViewDistance();
+            case 2: return this.getWorldLoadViewDistance();
+        }
+        throw new IllegalArgumentException();
+    }
+
+    private @Nullable Integer @NotNull [] viewDistances = {null, null, null};
+
+    public final int getTrackViewDistance() {
+        return this.getViewDistance(0);
+    }
+
+    public final int getSeeViewDistance() {
+        return this.getViewDistance(1);
+    }
+
+    public final int getLoadViewDistance() {
+        return this.getViewDistance(2);
+    }
+    
+    public final int getTickingViewDistance() {
+        int loadViewDistanceMinusOne = this.getLoadViewDistance() - 1;
+        ServerLevel level = this.getLevel();
+        if (level != null) {
+            PlayerChunkLoader playerChunkLoader = level.getChunkSource().chunkMap.playerChunkManager;
+            PlayerChunkLoader.PlayerLoaderData data = playerChunkLoader.getData(this);
+            if (data != null && data.tickViewDistance != -1) {
+                return Math.min(loadViewDistanceMinusOne, data.tickViewDistance);
+            }
+            return Math.min(loadViewDistanceMinusOne, playerChunkLoader.getTickDistance());
+        }
+        return loadViewDistanceMinusOne;
+    }
+
+    private final int getViewDistance(int type) {
+        if (this.viewDistances[type] == null) {
+            this.viewDistanceMayHaveChanged(type);
+        }
+        return this.viewDistances[type];
+    }
+
+    public final void trackViewDistanceMayHaveChanged() {
+        this.viewDistanceMayHaveChanged(0);
+    }
+
+    public final void seeViewDistanceMayHaveChanged() {
+        this.viewDistanceMayHaveChanged(1);
+    }
+
+    public final void loadViewDistanceMayHaveChanged() {
+        this.viewDistanceMayHaveChanged(2);
+    }
+
+    /**
+     * Does not change any state
+     * Is called only from ServerPlayer.viewDistanceMayHaveChanged(type)
+     */
+    private final int computeViewDistance(int type) {
+        switch (type) {
+            case 0: {
+                this.level.timings.computeTrackViewDistance.startTiming();
+
+                // Limit by world view distance
+                int trackViewDistance = this.getWorldTrackViewDistance();
+                // Limit by see view distance
+                trackViewDistance = Math.min(trackViewDistance, this.getSeeViewDistance());
+                if (this.getLevel().paperConfig.getPerPlayerTrackViewDistance()) {
+                    // Limit by world max track view distance
+                    int levelMaxTrackViewDistance = this.getLevel().paperConfig.getMaxTrackViewDistance();
+                    if (levelMaxTrackViewDistance != -1) {
+                        trackViewDistance = Math.min(trackViewDistance, levelMaxTrackViewDistance);
+                    }
+                    // Limit by client view distance
+                    if (this.getLevel().paperConfig.getLimitTrackViewDistanceByClientViewDistance()) {
+                        if (this.clientViewDistance != null && this.clientViewDistance >= 1) {
+                            trackViewDistance = Math.min(trackViewDistance, this.clientViewDistance + 1);
+                        }
+                    }
+                }
+                // Limit by max total tracked chunks
+                if (ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type] != -1) {
+                    trackViewDistance = Math.min(trackViewDistance, ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type]);
+                }
+                // Clamp to possible values
+                trackViewDistance = Mth.clamp(trackViewDistance, 2, 32);
+
+                this.level.timings.computeTrackViewDistance.stopTiming();
+
+                return trackViewDistance;
+            }
+            case 1: {
+                this.level.timings.computeSeeViewDistance.startTiming();
+
+                // Limit by world view distance
+                int seeViewDistance = this.getWorldSeeViewDistance();
+                if (this.getLevel().paperConfig.getPerPlayerSeeViewDistance()) {
+                    // Limit by world max see view distance
+                    int levelMaxSeeViewDistance = this.getLevel().paperConfig.getMaxSeeViewDistance();
+                    if (levelMaxSeeViewDistance != -1) {
+                        seeViewDistance = Math.min(seeViewDistance, levelMaxSeeViewDistance);
+                    }
+                    // Limit by client view distance
+                    if (this.getLevel().paperConfig.getLimitSeeViewDistanceByClientViewDistance()) {
+                        if (this.clientViewDistance != null && this.clientViewDistance >= 1) {
+                            seeViewDistance = Math.min(seeViewDistance, this.clientViewDistance + 1);
+                        }
+                    }
+                }
+                // Limit by max total seen chunks
+                if (ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type] != -1) {
+                    seeViewDistance = Math.min(seeViewDistance, ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type]);
+                }
+                // Clamp to possible values
+                seeViewDistance = Mth.clamp(seeViewDistance, 2, 32);
+
+                this.level.timings.computeSeeViewDistance.stopTiming();
+
+                return seeViewDistance;
+            }
+            case 2: {
+                this.level.timings.computeLoadViewDistance.startTiming();
+
+                // Limit by world view distance
+                int loadViewDistance = this.getWorldLoadViewDistance();
+                if (this.getLevel().paperConfig.getPerPlayerLoadViewDistance()) {
+                    // Limit by world max load view distance
+                    int levelMaxLoadViewDistance = this.getLevel().paperConfig.getMaxLoadViewDistance();
+                    if (levelMaxLoadViewDistance != -1) {
+                        loadViewDistance = Math.min(loadViewDistance, levelMaxLoadViewDistance);
+                    }
+                    // Limit by see view distance
+                    if (this.getLevel().paperConfig.getLimitLoadViewDistanceBySeeViewDistance()) {
+                        loadViewDistance = Math.min(loadViewDistance, this.getSeeViewDistance() + 1);
+                    }
+                    // Limit by client view distance
+                    if (this.getLevel().paperConfig.getLimitLoadViewDistanceByClientViewDistance()) {
+                        if (this.clientViewDistance != null && this.clientViewDistance >= 1) {
+                            loadViewDistance = Math.min(loadViewDistance, this.clientViewDistance + 2);
+                        }
+                    }
+                }
+                // Clamp to possible values
+                loadViewDistance = Mth.clamp(loadViewDistance, 3, 33);
+
+                this.level.timings.computeLoadViewDistance.stopTiming();
+
+                return loadViewDistance;
+            }
+        }
+        throw new IllegalArgumentException();
+    }
+
+    /**
+     * Is called only from ServerPlayer.viewDistanceMayHaveChanged(type)
+     */
+    private final void processViewDistanceChange(@Nullable Integer oldViewDistance, int type) {
+
+        int newViewDistance = this.viewDistances[type];
+        if (oldViewDistance != null && oldViewDistance == newViewDistance) return;
+
+        switch (type) {
+            case 0: {
+                // Update track view distance of other players
+                maxViewDistanceDueToTotalViewedChunksMayHaveChanged(type);
+                break;
+            }
+            case 1: {
+                // Update track view distance
+                this.trackViewDistanceMayHaveChanged();
+                // Update load view distance
+                this.loadViewDistanceMayHaveChanged();
+                // Update see view distance of other players
+                maxViewDistanceDueToTotalViewedChunksMayHaveChanged(type);
+                break;
+            }
+        }
+    }
+
+    private final void viewDistanceMayHaveChanged(int type) {
+        Integer oldViewDistance = this.viewDistances[type];
+        this.viewDistances[type] = this.computeViewDistance(type);
+        this.processViewDistanceChange(oldViewDistance, type);
+    }
+
+    // Martijn end - per-player view distance
+
     public long lastSave = MinecraftServer.currentTick; // Paper
     private static final int NEUTRAL_MOB_DEATH_NOTIFICATION_RADII_XZ = 32;
     private static final int NEUTRAL_MOB_DEATH_NOTIFICATION_RADII_Y = 10;
@@ -1952,6 +2210,11 @@ public class ServerPlayer extends Player {
         this.connection.connection.channel.attr(PaperAdventure.LOCALE_ATTRIBUTE).set(this.adventure$locale);
         // Paper end
         this.clientViewDistance = packet.viewDistance;
+        // Martijn start - per-player view distance
+        this.trackViewDistanceMayHaveChanged();
+        this.seeViewDistanceMayHaveChanged();
+        this.loadViewDistanceMayHaveChanged();
+        // Martijn end - per-player view distance
         // CraftBukkit end
         this.chatVisibility = packet.chatVisibility();
         this.canChatColor = packet.chatColors();
@@ -2212,27 +2475,37 @@ public class ServerPlayer extends Player {
         return true; // Paper
     }
 
-    public void trackChunk(ChunkPos chunkPos, Packet<?> chunkDataPacket) {
+    // Martijn start - per-player track and see view distance
+
+    public void trackChunk(ChunkPos chunkPos, Packet<?> chunkDataPacket, boolean concernsTracking) {
         this.connection.send(chunkDataPacket);
-        // Paper start
-        if(io.papermc.paper.event.packet.PlayerChunkLoadEvent.getHandlerList().getRegisteredListeners().length > 0){
-            new io.papermc.paper.event.packet.PlayerChunkLoadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+        if (concernsTracking) {
+            // Paper start
+            if (io.papermc.paper.event.packet.PlayerChunkLoadEvent.getHandlerList().getRegisteredListeners().length > 0) {
+                new io.papermc.paper.event.packet.PlayerChunkLoadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+            }
+            // Paper end
         }
-        // Paper end
     }
 
-    public void untrackChunk(ChunkPos chunkPos) {
+    public void untrackChunk(ChunkPos chunkPos, boolean concernsTracking) {
         if (this.isAlive()) {
-            this.connection.send(new ClientboundForgetLevelChunkPacket(chunkPos.x, chunkPos.z));
-            // Paper start
-            if(io.papermc.paper.event.packet.PlayerChunkUnloadEvent.getHandlerList().getRegisteredListeners().length > 0){
-                new io.papermc.paper.event.packet.PlayerChunkUnloadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+            if (!concernsTracking) {
+                this.connection.send(new ClientboundForgetLevelChunkPacket(chunkPos.x, chunkPos.z));
+            }
+            if (concernsTracking) {
+                // Paper start
+                if (io.papermc.paper.event.packet.PlayerChunkUnloadEvent.getHandlerList().getRegisteredListeners().length > 0) {
+                    new io.papermc.paper.event.packet.PlayerChunkUnloadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+                }
+                // Paper end
             }
-            // Paper end
         }
 
     }
 
+    // Martijn end - per-player track and see view distance
+
     public SectionPos getLastSectionPos() {
         return this.lastSectionPos;
     }
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 624946f48f0811c94d05174f28d0b1fc6d5e6a00..cab33cedbfa47a2be7f343de7c7603ee749b5336 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -38,7 +38,6 @@ import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.TranslatableComponent;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientboundChangeDifficultyPacket;
-import net.minecraft.network.protocol.game.ClientboundChatPacket;
 import net.minecraft.network.protocol.game.ClientboundCustomPayloadPacket;
 import net.minecraft.network.protocol.game.ClientboundDisconnectPacket;
 import net.minecraft.network.protocol.game.ClientboundEntityEventPacket;
@@ -95,7 +94,6 @@ import net.minecraft.world.scores.Team;
 import org.slf4j.Logger;
 
 // CraftBukkit start
-import io.papermc.paper.adventure.PaperAdventure; // Paper
 import com.google.common.base.Predicate;
 import java.util.stream.Collectors;
 import net.minecraft.server.dedicated.DedicatedServer;
@@ -111,7 +109,6 @@ import org.bukkit.Location;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
-import org.bukkit.craftbukkit.util.CraftChatMessage;
 import org.bukkit.entity.Player;
 import org.bukkit.event.player.PlayerChangedWorldEvent;
 import org.bukkit.event.player.PlayerJoinEvent;
@@ -271,7 +268,7 @@ public abstract class PlayerList {
         boolean flag1 = gamerules.getBoolean(GameRules.RULE_REDUCEDDEBUGINFO);
 
         // Spigot - view distance
-        playerconnection.send(new ClientboundLoginPacket(player.getId(), worlddata.isHardcore(), player.gameMode.getGameModeForPlayer(), player.gameMode.getPreviousGameModeForPlayer(), this.server.levelKeys(), this.registryHolder, worldserver1.dimensionTypeRegistration(), worldserver1.dimension(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), this.getMaxPlayers(), worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance(), worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance(), flag1, !flag, worldserver1.isDebug(), worldserver1.isFlat())); // Paper - replace old player chunk management
+        playerconnection.send(new ClientboundLoginPacket(player.getId(), worlddata.isHardcore(), player.gameMode.getGameModeForPlayer(), player.gameMode.getPreviousGameModeForPlayer(), this.server.levelKeys(), this.registryHolder, worldserver1.dimensionTypeRegistration(), worldserver1.dimension(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), this.getMaxPlayers(), player.getSeeViewDistance(), worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance(), flag1, !flag, worldserver1.isDebug(), worldserver1.isFlat())); // Paper - replace old player chunk management // Martijn - per-player view distance
         player.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         playerconnection.send(new ClientboundCustomPayloadPacket(ClientboundCustomPayloadPacket.BRAND, (new FriendlyByteBuf(Unpooled.buffer())).writeUtf(this.getServer().getServerModName())));
         playerconnection.send(new ClientboundChangeDifficultyPacket(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
@@ -949,7 +946,7 @@ public abstract class PlayerList {
         // CraftBukkit start
         LevelData worlddata = worldserver1.getLevelData();
         entityplayer1.connection.send(new ClientboundRespawnPacket(worldserver1.dimensionTypeRegistration(), worldserver1.dimension(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), entityplayer1.gameMode.getGameModeForPlayer(), entityplayer1.gameMode.getPreviousGameModeForPlayer(), worldserver1.isDebug(), worldserver1.isFlat(), flag));
-        entityplayer1.connection.send(new ClientboundSetChunkCacheRadiusPacket(worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance())); // Spigot // Paper - replace old player chunk management
+        entityplayer1.connection.send(new ClientboundSetChunkCacheRadiusPacket(entityplayer1.getSeeViewDistance())); // Spigot // Paper - replace old player chunk management // Martijn - per-player see view distance
         entityplayer1.connection.send(new ClientboundSetSimulationDistancePacket(worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance())); // Spigot // Paper - replace old player chunk management
         entityplayer1.spawnIn(worldserver1);
         entityplayer1.unsetRemoved();
@@ -1467,7 +1464,7 @@ public abstract class PlayerList {
             ServerLevel worldserver = (ServerLevel) iterator.next();
 
             if (worldserver != null) {
-                worldserver.getChunkSource().setViewDistance(viewDistance);
+                worldserver.getChunkSource().setVanillaWorldViewDistance(viewDistance); // Martijn - per-player view distance
             }
         }
 
diff --git a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
index 8c4db2f0e5158872879da52a96bc592145e52e13..0b67c6567c0140938235d030ed8631de857899e6 100644
--- a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
+++ b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
@@ -661,7 +661,7 @@ public class EnderDragon extends Mob implements Enemy {
                 // this.world.b(1028, this.getChunkCoordinates(), 0);
                 //int viewDistance = ((WorldServer) this.world).getServer().getViewDistance() * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
                 for (net.minecraft.server.level.ServerPlayer player : (List<net.minecraft.server.level.ServerPlayer>) ((ServerLevel)level).players()) {
-                    final int viewDistance = io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player); // Paper - route to player chunk loader
+                    final int viewDistance = com.destroystokyo.paper.PaperConfig.sendEnderDragonSpawnSoundToPlayersWhoAreSeeingButNotTracking ? player.getSeeViewDistance() : player.getTrackViewDistance(); // Paper - route to player chunk loader // Martijn - per-player track and see view distance
                     double deltaX = this.getX() - player.getX();
                     double deltaZ = this.getZ() - player.getZ();
                     double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
index 0bf896d6dfb67e655771a6f64ecf56c31fff8e78..c8b0de1bed79f3384ddcd4f16902f45fa105815a 100644
--- a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
+++ b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
@@ -47,9 +47,7 @@ import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
 import net.minecraft.network.syncher.EntityDataAccessor;
 import net.minecraft.network.syncher.EntityDataSerializers;
 import net.minecraft.network.syncher.SynchedEntityData;
-import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerBossEvent;
-import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
@@ -278,7 +276,7 @@ public class WitherBoss extends Monster implements PowerableMob, RangedAttackMob
                     // this.world.globalLevelEvent(1023, new BlockPosition(this), 0);
                     //int viewDistance = ((ServerLevel) this.level).getCraftServer().getViewDistance() * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
                     for (ServerPlayer player : (List<ServerPlayer>)this.level.players()) { // Paper
-                        final int viewDistance = io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player); // Paper - route to player chunk loader
+                        final int viewDistance = com.destroystokyo.paper.PaperConfig.sendWitherSpawnSoundToPlayersWhoAreSeeingButNotTracking ? player.getSeeViewDistance() : player.getTrackViewDistance(); // Paper - route to player chunk loader // Martijn - per-player track and see view distance
                         double deltaX = this.getX() - player.getX();
                         double deltaZ = this.getZ() - player.getZ();
                         double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/net/minecraft/world/item/EnderEyeItem.java b/src/main/java/net/minecraft/world/item/EnderEyeItem.java
index c624a2cb0f4c9d7e12387ece574c1f9f74528b0c..2024dd4d6fef55072ca6ca09a36c3120a02f3338 100644
--- a/src/main/java/net/minecraft/world/item/EnderEyeItem.java
+++ b/src/main/java/net/minecraft/world/item/EnderEyeItem.java
@@ -63,7 +63,7 @@ public class EnderEyeItem extends Item {
                     //int viewDistance = world.getCraftServer().getViewDistance() * 16; // Paper - apply view distance patch
                     BlockPos soundPos = blockposition1.offset(1, 0, 1);
                     for (ServerPlayer player : world.getServer().getPlayerList().players) {
-                        final int viewDistance = io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player); // Paper - apply view distance patch
+                        final int viewDistance = com.destroystokyo.paper.PaperConfig.sendEndPortalFillSoundToPlayersWhoAreSeeingButNotTracking ? player.getSeeViewDistance() : player.getTrackViewDistance(); // Paper - apply view distance patch // Martijn - per-player track and see view distance
                         double deltaX = soundPos.getX() - player.getX();
                         double deltaZ = soundPos.getZ() - player.getZ();
                         double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 285fb20519d2041b2064baacdf1b5df6cb887778..38fffb7f442db9be1e165f3ad6f47a87542aaed8 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -715,7 +715,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
                 this.sendBlockUpdated(blockposition, iblockdata1, iblockdata, i);
                 // Paper start - per player view distance - allow block updates for non-ticking chunks in player view distance
                 // if copied from above
-            } else if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || ((ServerLevel)this).getChunkSource().chunkMap.playerChunkManager.broadcastMap.getObjectsInRange(MCUtil.getCoordinateKey(blockposition)) != null)) { // Paper - replace old player chunk management
+            } else if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || ((ServerLevel)this).getChunkSource().chunkMap.playerChunkManager.getBroadcastMap(true).getObjectsInRange(MCUtil.getCoordinateKey(blockposition)) != null)) { // Paper - replace old player chunk management // Martijn - per-player track and see view distance
                 ((ServerLevel)this).getChunkSource().blockChanged(blockposition);
                 // Paper end - per player view distance
             }
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index ec727ff5318f90e6241dc423a3156504c6e20c1d..fe603419cf414f2c9db863cce234ee908b736974 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -224,7 +224,7 @@ public class LevelChunk extends ChunkAccess {
         // this code handles the chunk sending
         if (!areNeighboursLoaded(bitsetBefore, 1) && areNeighboursLoaded(bitsetAfter, 1)) {
             // Paper start - replace old player chunk loading system
-            if (chunkMap.playerChunkManager.isChunkNearPlayers(this.chunkPos.x, this.chunkPos.z)) {
+            if (chunkMap.playerChunkManager.isChunkNearPlayers(this.chunkPos.x, this.chunkPos.z, false)) { // Martijn - per-player track and see view distance
                 // the post processing is expensive, so we don't want to run it unless we're actually near
                 // a player.
                 chunkProviderServer.mainThreadProcessor.execute(() -> {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index ebc9fc46eed80b9d9d3b5e0fd13efc78dde302df..212259499e1ee1db024fe0f0c6891869a4810d1b 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -508,7 +508,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
         playerChunk.getTickingChunkFuture().thenAccept(either -> {
             either.left().ifPresent(chunk -> {
-                List<ServerPlayer> playersInRange = playerChunk.playerProvider.getPlayers(playerChunk.getPos(), false);
+                List<ServerPlayer> playersInRange = playerChunk.playerProvider.getPlayers(playerChunk.getPos(), false, !com.destroystokyo.paper.PaperConfig.sendChunkRefreshToPlayersWhoAreSeeingButNotTracking); // Martijn - per-player track and see view distance
                 if (playersInRange.isEmpty()) return;
 
                 ClientboundLevelChunkWithLightPacket refreshPacket = new ClientboundLevelChunkWithLightPacket(chunk, this.world.getLightEngine(), null, null, true);
@@ -2236,7 +2236,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     // Spigot start
     @Override
     public int getViewDistance() {
-        return getHandle().getChunkSource().chunkMap.playerChunkManager.getTargetNoTickViewDistance(); // Paper - replace old player chunk management
+        return getHandle().getChunkSource().chunkMap.getVanillaWorldViewDistance(); // Paper - replace old player chunk management // Martijn - per-player view distance
     }
 
     @Override
@@ -2252,7 +2252,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
             throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
         }
         net.minecraft.server.level.ChunkMap chunkMap = getHandle().getChunkSource().chunkMap;
-        chunkMap.setViewDistance(viewDistance);
+        chunkMap.setVanillaWorldViewDistance(viewDistance); // Martijn - per-player view distance
         // Paper end - replace old player chunk management
     }
 
@@ -2268,25 +2268,27 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     }
     // Paper end - replace old player chunk management
 
-    @Override
-    public int getNoTickViewDistance() {
-        return this.getViewDistance(); // Paper - replace old player chunk management
-    }
-
-    @Override
-    public void setNoTickViewDistance(int viewDistance) {
-        this.setViewDistance(viewDistance); // Paper - replace old player chunk management
-    }
-
-    @Override
-    public int getSendViewDistance() {
-        return getHandle().getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance(); // Paper - replace old player chunk management
-    }
-
-    @Override
-    public void setSendViewDistance(int viewDistance) {
-        getHandle().getChunkSource().chunkMap.playerChunkManager.setSendDistance(viewDistance); // Paper - replace old player chunk management
-    }
+    // Martijn start - per-player view distance
+//    @Override
+//    public int getNoTickViewDistance() {
+//        return this.getViewDistance(); // Paper - replace old player chunk management
+//    }
+//
+//    @Override
+//    public void setNoTickViewDistance(int viewDistance) {
+//        this.setViewDistance(viewDistance); // Paper - replace old player chunk management
+//    }
+//
+//    @Override
+//    public int getSendViewDistance() {
+//        return getHandle().getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance(); // Paper - replace old player chunk management
+//    }
+//
+//    @Override
+//    public void setSendViewDistance(int viewDistance) {
+//        getHandle().getChunkSource().chunkMap.playerChunkManager.setSendDistance(viewDistance); // Paper - replace old player chunk management
+//    }
+    // Martijn end - per-player view distance
     // Paper end - view distance api
 
     // Spigot start
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 3b7530408afad6a08b7880f87bab8ece7f6ff724..a82459be9490df56c101f9edeca86c8b8bdca1c8 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -538,80 +538,82 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         }
     }
 
-    // Paper start - implement view distances
-    @Override
-    public int getViewDistance() {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            return chunkMap.playerChunkManager.getTargetNoTickViewDistance();
-        }
-        return data.getTargetNoTickViewDistance();
-    }
-
-    @Override
-    public void setViewDistance(int viewDistance) {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            throw new IllegalStateException("Player is not attached to world");
-        }
-
-        data.setTargetNoTickViewDistance(viewDistance);
-    }
-
-    @Override
-    public int getSimulationDistance() {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            return chunkMap.playerChunkManager.getTargetTickViewDistance();
-        }
-        return data.getTargetTickViewDistance();
-    }
-
-    @Override
-    public void setSimulationDistance(int simulationDistance) {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            throw new IllegalStateException("Player is not attached to world");
-        }
-
-        data.setTargetTickViewDistance(simulationDistance);
-    }
-
-    @Override
-    public int getNoTickViewDistance() {
-        return this.getViewDistance();
-    }
-
-    @Override
-    public void setNoTickViewDistance(int viewDistance) {
-        this.setViewDistance(viewDistance);
-    }
-
-    @Override
-    public int getSendViewDistance() {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            return chunkMap.playerChunkManager.getTargetSendDistance();
-        }
-        return data.getTargetSendViewDistance();
-    }
-
-    @Override
-    public void setSendViewDistance(int viewDistance) {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            throw new IllegalStateException("Player is not attached to world");
-        }
-
-        data.setTargetSendViewDistance(viewDistance);
-    }
-    // Paper end - implement view distances
+    // Martijn start - per-player view distance
+//    // Paper start - implement view distances
+//    @Override
+//    public int getViewDistance() {
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            return chunkMap.playerChunkManager.getTargetNoTickViewDistance();
+//        }
+//        return data.getTargetNoTickViewDistance();
+//    }
+//
+//    @Override
+//    public void setViewDistance(int viewDistance) {
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            throw new IllegalStateException("Player is not attached to world");
+//        }
+//
+//        data.setTargetNoTickViewDistance(viewDistance);
+//    }
+//
+//    @Override
+//    public int getSimulationDistance() {
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            return chunkMap.playerChunkManager.getTargetTickViewDistance();
+//        }
+//        return data.getTargetTickViewDistance();
+//    }
+//
+//    @Override
+//    public void setSimulationDistance(int simulationDistance) {
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            throw new IllegalStateException("Player is not attached to world");
+//        }
+//
+//        data.setTargetTickViewDistance(simulationDistance);
+//    }
+//
+//    @Override
+//    public int getNoTickViewDistance() {
+//        return this.getViewDistance();
+//    }
+//
+//    @Override
+//    public void setNoTickViewDistance(int viewDistance) {
+//        this.setViewDistance(viewDistance);
+//    }
+//
+//    @Override
+//    public int getSendViewDistance() {
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            return chunkMap.playerChunkManager.getTargetSendDistance();
+//        }
+//        return data.getTargetSendViewDistance();
+//    }
+//
+//    @Override
+//    public void setSendViewDistance(int viewDistance) {
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            throw new IllegalStateException("Player is not attached to world");
+//        }
+//
+//        data.setTargetSendViewDistance(viewDistance);
+//    }
+//    // Paper end - implement view distances
+    // Martijn end - per-player view distance
 
     @Override
     public <T> T getClientOption(com.destroystokyo.paper.ClientOption<T> type) {
