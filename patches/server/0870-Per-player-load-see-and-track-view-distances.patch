From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Mon, 17 Jan 2022 17:09:22 +0100
Subject: [PATCH] Per-player load, see and track view distances


diff --git a/src/main/java/co/aikar/timings/TimingsExport.java b/src/main/java/co/aikar/timings/TimingsExport.java
index 5e3b7fb2e0b7608610555cd23e7ad25a05883181..85de61e7731ee2dbd52c64d6cafe2bb30e087e85 100644
--- a/src/main/java/co/aikar/timings/TimingsExport.java
+++ b/src/main/java/co/aikar/timings/TimingsExport.java
@@ -152,7 +152,7 @@ public class TimingsExport extends Thread {
                 pair("gamerules", toObjectMapper(world.getWorld().getGameRules(), rule -> {
                     return pair(rule, world.getWorld().getGameRuleValue(rule));
                 })),
-                pair("ticking-distance", world.getChunkSource().chunkMap.getEffectiveViewDistance())
+                pair("ticking-distance", world.getChunkSource().chunkMap.getEffectiveWorldViewDistance())
             ));
         }));
 
diff --git a/src/main/java/co/aikar/timings/WorldTimingsHandler.java b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
index fe79c0add4f7cb18d487c5bb9415c40c5b551ea2..43bdbc81fa60d233ea8b1ecd97740fcb314fba57 100644
--- a/src/main/java/co/aikar/timings/WorldTimingsHandler.java
+++ b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
@@ -44,6 +44,23 @@ public class WorldTimingsHandler {
     public final Timing broadcastChunkUpdates;
     public final Timing countNaturalMobs;
 
+    // Martijn start
+    public final Timing getPlayersNearChunkForSending;
+    public final Timing chunkMapPlayerMove;
+    public final Timing chunkMapPlayerMoveUpdatePos;
+    public final Timing chunkMapPlayerMoveUpdateDistanceManager;
+    public final Timing chunkMapPlayerMoveUpdatePlayerMap;
+    public final Timing chunkMapUpdatePlayerMaps;
+    public final Timing chunkMapPlayerMoveUpdateChunkTrackingOrSeeing;
+    public final Timing chunkMapPlayerMoveSortChunksForTrackAndSee;
+    public final Timing getTrackViewDistance;
+    public final Timing getSeeViewDistance;
+    public final Timing getLoadViewDistance;
+    public final Timing trackViewDistanceMayHaveChanged;
+    public final Timing seeViewDistanceMayHaveChanged;
+    public final Timing loadViewDistanceMayHaveChanged;
+    // Martijn end
+
     public final Timing chunkLoad;
     public final Timing chunkLoadPopulate;
     public final Timing syncChunkLoad;
@@ -119,6 +136,22 @@ public class WorldTimingsHandler {
         broadcastChunkUpdates = Timings.ofSafe(name + "Broadcast chunk updates");
         countNaturalMobs = Timings.ofSafe(name + "Count natural mobs");
 
+        // Martijn start
+        getPlayersNearChunkForSending = Timings.ofSafe("Get players near chunk for sending");
+        chunkMapPlayerMove = Timings.ofSafe("Chunk map player move");
+        chunkMapPlayerMoveUpdatePos = Timings.ofSafe("Chunk map player move - update pos");
+        chunkMapPlayerMoveUpdateDistanceManager = Timings.ofSafe("Chunk map player move - update distance manager");
+        chunkMapPlayerMoveUpdatePlayerMap = Timings.ofSafe("Chunk map player move - update player map");
+        chunkMapUpdatePlayerMaps = Timings.ofSafe("Chunk map update player maps");
+        chunkMapPlayerMoveUpdateChunkTrackingOrSeeing = Timings.ofSafe("Chunk map player move - update chunk tracking or seeing");
+        chunkMapPlayerMoveSortChunksForTrackAndSee = Timings.ofSafe("Chunk map player move - sort chunks for track and see");
+        getTrackViewDistance = Timings.ofSafe("Get track view distance");
+        getSeeViewDistance = Timings.ofSafe("Get see view distance");
+        getLoadViewDistance = Timings.ofSafe("Get load view distance");
+        trackViewDistanceMayHaveChanged = Timings.ofSafe("Track view distance may have changed");
+        seeViewDistanceMayHaveChanged = Timings.ofSafe("See view distance may have changed");
+        loadViewDistanceMayHaveChanged = Timings.ofSafe("Load view distance may have changed");
+        // Martijn end
 
         miscMobSpawning = Timings.ofSafe(name + "Mob spawning - Misc");
 
diff --git a/src/main/java/com/destroystokyo/paper/PaperConfig.java b/src/main/java/com/destroystokyo/paper/PaperConfig.java
index 952c1f6278cea1dd01f5851e6fe34fac3ff17e2a..c3a9a04867d56d853e31620b6b4ef5ac19aaa8cd 100644
--- a/src/main/java/com/destroystokyo/paper/PaperConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperConfig.java
@@ -19,6 +19,7 @@ import java.util.regex.Pattern;
 
 import com.google.common.collect.Lists;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
 import org.bukkit.Bukkit;
 import org.bukkit.ChatColor;
 import org.bukkit.command.Command;
@@ -27,6 +28,7 @@ import org.bukkit.configuration.InvalidConfigurationException;
 import org.bukkit.configuration.file.YamlConfiguration;
 import co.aikar.timings.Timings;
 import co.aikar.timings.TimingsManager;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.spigotmc.SpigotConfig;
 import org.spigotmc.WatchdogThread;
 
@@ -91,6 +93,61 @@ public class PaperConfig {
         }
     }
 
+    // Martijn start - per-player track and see view distance
+
+    public static boolean sendChunkRefreshToPlayersWhoAreSeeingButNotTracking = true;
+    private static void sendChunkRefreshToPlayersWhoAreSeeingButNotTracking() {
+        sendChunkRefreshToPlayersWhoAreSeeingButNotTracking = getBoolean("settings.view-distances.track-and-see-view-distance.if-can-see-but-not-tracking.send-chunk-refresh", sendChunkRefreshToPlayersWhoAreSeeingButNotTracking);
+    }
+
+    public static boolean sendWitherSpawnSoundToPlayersWhoAreSeeingButNotTracking = true;
+    private static void sendWitherSpawnSoundToPlayersWhoAreSeeingButNotTracking() {
+        sendWitherSpawnSoundToPlayersWhoAreSeeingButNotTracking = getBoolean("settings.view-distances.track-and-see-view-distance.if-can-see-but-not-tracking.send-wither-spawn-sound", sendWitherSpawnSoundToPlayersWhoAreSeeingButNotTracking);
+    }
+
+    public static boolean sendEnderDragonSpawnSoundToPlayersWhoAreSeeingButNotTracking = true;
+    private static void sendEnderDragonSpawnSoundToPlayersWhoAreSeeingButNotTracking() {
+        sendEnderDragonSpawnSoundToPlayersWhoAreSeeingButNotTracking = getBoolean("settings.view-distances.track-and-see-view-distance.if-can-see-but-not-tracking.send-ender-dragon-spawn-sound", sendEnderDragonSpawnSoundToPlayersWhoAreSeeingButNotTracking);
+    }
+
+    /**
+     * -1 indicates no limit
+     */
+    public static int maxTotalTrackedChunks = -1;
+    private static void maxTotalTrackChunks() {
+        maxTotalTrackedChunks = getInt("settings.view-distances.track-view-distance.max-total", maxTotalTrackedChunks);
+    }
+    public static int getMaxTotalTrackedChunks() {
+        return maxTotalTrackedChunks;
+    }
+    public static void setMaxTotalTrackedChunks(int maxTotalTrackedChunks) {
+        if (PaperConfig.maxTotalTrackedChunks != maxTotalTrackedChunks) {
+            PaperConfig.maxTotalTrackedChunks = maxTotalTrackedChunks;
+            int precomputedMaxTrackViewDistanceDueToMaxTotalTrackedChunks = ServerPlayer.computeMaxTrackViewDistanceDueToMaxTotalTrackedChunks();
+            Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().trackViewDistanceMayHaveChanged(precomputedMaxTrackViewDistanceDueToMaxTotalTrackedChunks, true));
+        }
+    }
+
+    /**
+     * -1 indicates no limit
+     */
+    public static int maxTotalSeenChunks = -1;
+    private static void maxTotalSeeChunks() {
+        maxTotalSeenChunks = getInt("settings.view-distances.see-view-distance.max-total", maxTotalSeenChunks);
+    }
+    public static int getMaxTotalSeenChunks() {
+        return maxTotalSeenChunks;
+    }
+    public static void setMaxTotalSeenChunks(int maxTotalSeenChunks) {
+        if (PaperConfig.maxTotalSeenChunks != maxTotalSeenChunks) {
+            PaperConfig.maxTotalSeenChunks = maxTotalSeenChunks;
+            int precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks = ServerPlayer.computeMaxSeeViewDistanceDueToMaxTotalSeenChunks();
+            Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().seeViewDistanceMayHaveChanged(precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks, true));
+        }
+    }
+
+    // Martijn end - per-player track and see view distance
+
     // Martijn start - configurable keepalive
 
     /**
diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index d7dcf36c8c972e30320c56e447822cf26f6d5fb3..57f9976da6b91470e81dda368470870176bc9922 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -14,6 +14,7 @@ import java.util.Map;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.ConfigurationSection;
 import org.bukkit.configuration.file.YamlConfiguration;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.spigotmc.SpigotWorldConfig;
 
 import static com.destroystokyo.paper.PaperConfig.log;
@@ -67,6 +68,165 @@ public class PaperWorldConfig {
         }
     }
 
+    // Martijn start - per-player track view distance
+
+    private boolean perPlayerTrackViewDistance = false;
+    private void perPlayerTrackViewDistance() {
+        this.perPlayerTrackViewDistance = getBoolean("view-distances.track-view-distance.per-player", this.perPlayerTrackViewDistance);
+    }
+    public boolean getPerPlayerTrackViewDistance() {
+        return this.perPlayerTrackViewDistance;
+    }
+
+    /**
+     * This is only used if perPlayerTrackViewDistance is true
+     * -1 indicates no limit (it is still limited by the Bukkit world view distance)
+     * Valid values are -1 or an integer in the range [2, 32]
+     */
+    private int maxTrackViewDistance = -1;
+    private void maxTrackViewDistance() {
+        this.maxTrackViewDistance = getInt("view-distances.track-view-distance.max", this.maxTrackViewDistance);
+    }
+    public int getMaxTrackViewDistance() {
+        return this.maxTrackViewDistance;
+    }
+    public void setMaxTrackViewDistance(int maxTrackViewDistance) {
+        this.maxTrackViewDistance = maxTrackViewDistance;
+        Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().trackViewDistanceMayHaveChanged());
+    }
+
+    private boolean limitTrackViewDistanceByClientViewDistance = false;
+    private void limitTrackViewDistanceByClientViewDistance() {
+        setLimitTrackViewDistanceByClientViewDistance(getBoolean("view-distances.track-view-distance.limit-by-client-view-distance", this.limitTrackViewDistanceByClientViewDistance));
+    }
+    public boolean getLimitTrackViewDistanceByClientViewDistance() {
+        return this.limitTrackViewDistanceByClientViewDistance;
+    }
+    public void setLimitTrackViewDistanceByClientViewDistance(boolean limitTrackViewDistanceByClientViewDistance) {
+        this.limitTrackViewDistanceByClientViewDistance = limitTrackViewDistanceByClientViewDistance;
+        Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().trackViewDistanceMayHaveChanged());
+    }
+
+    // Martijn end - per-player track view distance
+
+    // Martijn start - per-player see view distance
+
+    private boolean perPlayerSeeViewDistance = false;
+    private void perPlayerSeeViewDistance() {
+        this.perPlayerSeeViewDistance = getBoolean("view-distances.see-view-distance.per-player", this.perPlayerSeeViewDistance);
+    }
+    public boolean getPerPlayerSeeViewDistance() {
+        return this.perPlayerSeeViewDistance;
+    }
+
+    /**
+     * This is only used if perPlayerSeeViewDistance is true
+     * -1 indicates no limit (it is still limited by the Bukkit world view distance)
+     * Valid values are -1 or an integer in the range [2, 32]
+     */
+    private int maxSeeViewDistance = -1;
+    private void maxSeeViewDistance() {
+        this.maxSeeViewDistance = getInt("view-distances.see-view-distance.max", this.maxSeeViewDistance);
+    }
+    public int getMaxSeeViewDistance() {
+        return this.maxSeeViewDistance;
+    }
+    public void setMaxSeeViewDistance(int maxSeeViewDistance) {
+        this.maxSeeViewDistance = maxSeeViewDistance;
+        Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().seeViewDistanceMayHaveChanged());
+    }
+
+    private boolean limitSeeViewDistanceByClientViewDistance = false;
+    private void limitSeeViewDistanceByClientViewDistance() {
+        setLimitSeeViewDistanceByClientViewDistance(getBoolean("view-distances.see-view-distance.limit-by-client-view-distance", this.limitSeeViewDistanceByClientViewDistance));
+    }
+    public boolean getLimitSeeViewDistanceByClientViewDistance() {
+        return this.limitSeeViewDistanceByClientViewDistance;
+    }
+    public void setLimitSeeViewDistanceByClientViewDistance(boolean limitSeeViewDistanceByClientViewDistance) {
+        this.limitSeeViewDistanceByClientViewDistance = limitSeeViewDistanceByClientViewDistance;
+        Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().seeViewDistanceMayHaveChanged());
+    }
+
+    // Martijn end - per-player see view distance
+
+    // Martijn start - per-player load view distance
+
+    private boolean perPlayerLoadViewDistance = false;
+    private void perPlayerLoadViewDistance() {
+        this.perPlayerLoadViewDistance = getBoolean("view-distances.load-view-distance.per-player", this.perPlayerLoadViewDistance);
+    }
+    public boolean getPerPlayerLoadViewDistance() {
+        return this.perPlayerLoadViewDistance;
+    }
+
+    /**
+     * This is only used if perPlayerLoadViewDistance is true
+     * -1 indicates no limit (it is still limited by the Bukkit world view distance)
+     * Valid values are -1 or an integer in the range [3, 33]
+     */
+    private int maxLoadViewDistance = -1;
+    private void maxLoadViewDistance() {
+        this.maxLoadViewDistance = getInt("view-distances.load-view-distance.max", this.maxLoadViewDistance);
+    }
+    public int getMaxLoadViewDistance() {
+        return this.maxLoadViewDistance;
+    }
+    public void setMaxLoadViewDistance(int maxLoadViewDistance) {
+        this.maxLoadViewDistance = maxLoadViewDistance;
+        Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().loadViewDistanceMayHaveChanged());
+    }
+
+    private boolean limitLoadViewDistanceBySeeViewDistance = false;
+    private void limitLoadViewDistanceBySeeViewDistance() {
+        setLimitLoadViewDistanceBySeeViewDistance(getBoolean("view-distances.load-view-distance.limit-by-see-distance", this.limitLoadViewDistanceBySeeViewDistance));
+    }
+    public boolean getLimitLoadViewDistanceBySeeViewDistance() {
+        return this.limitLoadViewDistanceBySeeViewDistance;
+    }
+    public void setLimitLoadViewDistanceBySeeViewDistance(boolean limitLoadViewDistanceBySeeViewDistance) {
+        this.limitLoadViewDistanceBySeeViewDistance = limitLoadViewDistanceBySeeViewDistance;
+        Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().loadViewDistanceMayHaveChanged());
+    }
+
+    private boolean limitLoadViewDistanceByClientViewDistance = false;
+    private void limitLoadViewDistanceByClientViewDistance() {
+        setLimitLoadViewDistanceByClientViewDistance(getBoolean("view-distances.load-view-distance.limit-by-client-view-distance", this.limitLoadViewDistanceByClientViewDistance));
+    }
+    public boolean getLimitLoadViewDistanceByClientViewDistance() {
+        return this.limitLoadViewDistanceByClientViewDistance;
+    }
+    public void setLimitLoadViewDistanceByClientViewDistance(boolean limitLoadViewDistanceByClientViewDistance) {
+        this.limitLoadViewDistanceByClientViewDistance = limitLoadViewDistanceByClientViewDistance;
+        Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().loadViewDistanceMayHaveChanged());
+    }
+
+    // Martijn end - per-player load view distance
+
+    // Martijn start - sort chunks by distance
+
+    public boolean trackAndSeeChunksInSpiralOrderWhenChangingWorld = false;
+    private void trackAndSeeChunksInSpiralOrderWhenChangingWorld() {
+        this.trackAndSeeChunksInSpiralOrderWhenChangingWorld = getBoolean("view-distances.track-and-see-view-distance.track-and-see-chunks-in-spiral-order-when-changing-world", this.trackAndSeeChunksInSpiralOrderWhenChangingWorld);
+    }
+
+    public boolean trackAndSeeChunksInOrderOfDistanceWhenChangingViewDistance = false;
+    private void trackAndSeeChunksInOrderOfDistanceWhenChangingViewDistance() {
+        this.trackAndSeeChunksInOrderOfDistanceWhenChangingViewDistance = getBoolean("view-distances.track-and-see-view-distance.track-and-see-chunks-in-order-of-distance-when-changing-view-distance", this.trackAndSeeChunksInOrderOfDistanceWhenChangingViewDistance);
+    }
+
+    public boolean trackAndSeeChunksInOrderOfDistanceWhenMoving = false;
+    private void trackAndSeeChunksInOrderOfDistanceWhenMoving() {
+        this.trackAndSeeChunksInOrderOfDistanceWhenMoving = getBoolean("view-distances.track-and-see-view-distance.track-and-see-chunks-in-order-of-distance-when-moving", this.trackAndSeeChunksInOrderOfDistanceWhenMoving);
+    }
+
+    public boolean processChunksInOrderOfDistanceAfterLoad = false;
+    private void processChunksInOrderOfDistanceAfterLoad() {
+        this.processChunksInOrderOfDistanceAfterLoad = getBoolean("view-distances.load-view-distance.process-chunks-in-order-of-distance-after-load", this.processChunksInOrderOfDistanceAfterLoad);
+    }
+
+    // Martijn end - sort chunks by distance
+
     public boolean zombiesTargetTurtleEggs = true;
     private void zombiesTargetTurtleEggs() {
         zombiesTargetTurtleEggs = getBoolean("zombies-target-turtle-eggs", zombiesTargetTurtleEggs);
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index d271871563fa883efb77b35ec3b1dfbba87f0b62..e8aec6972def3c6e4f7daedcc387d48c1f34be6e 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -342,7 +342,9 @@ public class ChunkHolder {
     }
 
     public void broadcast(Packet<?> packet, boolean onlyOnWatchDistanceEdge) {
-        this.playerProvider.getPlayers(this.pos, onlyOnWatchDistanceEdge).forEach((entityplayer) -> {
+        LevelChunk chunk = this.getTickingChunk(); // Will be null if not present
+        if (chunk == null) return;
+        this.playerProvider.getPlayersNearChunkForSending(this.pos, onlyOnWatchDistanceEdge, true).forEach((entityplayer) -> { // Martijn - per-player send distance
             entityplayer.connection.send(packet);
         });
     }
@@ -755,7 +757,7 @@ public class ChunkHolder {
 
     public interface PlayerProvider {
 
-        List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge);
+        List<ServerPlayer> getPlayersNearChunkForSending(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge, boolean concernsTracking); // Martijn - per-player track or see view distance
     }
 
     private static final class ChunkSaveDebug {
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 176babda1914b65ec4d05812ce1a8b1d7f558dc9..26fb337dc13885ddd9e2c1ab4e1759f11c2cc584 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -5,17 +5,17 @@ import com.destroystokyo.paper.PaperWorldConfig; // Paper
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableList.Builder;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.ComparisonChain; // Paper
 import com.google.common.collect.Lists;
-import com.google.common.collect.Queues;
-import com.google.common.collect.Sets;
 import com.google.gson.JsonElement;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Either;
 import com.mojang.serialization.DataResult;
 import com.mojang.serialization.JsonOps;
+import it.unimi.dsi.fastutil.Pair;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.ints.IntIntImmutablePair;
+import it.unimi.dsi.fastutil.ints.IntIntPair;
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
@@ -32,9 +32,9 @@ import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.HashMap; // Paper
 import java.util.Collection;
+import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map; // Paper
 import java.util.Objects;
 import java.util.Optional;
 import java.util.Queue;
@@ -46,13 +46,17 @@ import java.util.concurrent.CompletionException;
 import java.util.concurrent.CompletionStage;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.BiConsumer;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
 import java.util.function.IntFunction;
 import java.util.function.IntSupplier;
 import java.util.function.Supplier;
 import java.util.stream.Collectors;
+import java.util.stream.Stream;
 import javax.annotation.Nullable;
+
+import it.unimi.dsi.fastutil.objects.ObjectObjectImmutablePair;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
@@ -63,8 +67,6 @@ import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
 import net.minecraft.network.protocol.game.ClientboundSetChunkCacheCenterPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket;
-import net.minecraft.network.protocol.game.ClientboundSetPassengersPacket;
 import net.minecraft.network.protocol.game.DebugPackets;
 import net.minecraft.server.MCUtil;
 import net.minecraft.server.MinecraftServer;
@@ -100,7 +102,6 @@ import net.minecraft.world.level.levelgen.structure.StructureStart;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureManager;
 import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelStorageSource;
-import net.minecraft.world.phys.Vec3;
 import it.unimi.dsi.fastutil.objects.ObjectRBTreeSet; // Paper
 import org.apache.commons.lang3.mutable.MutableBoolean;
 import org.apache.commons.lang3.mutable.MutableObject;
@@ -129,7 +130,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     private final Long2ObjectLinkedOpenHashMap<ChunkHolder> pendingUnloads;
     public final LongSet entitiesInLevel;
     public final ServerLevel level;
-    private final ThreadedLevelLightEngine lightEngine;
+    public final ThreadedLevelLightEngine lightEngine; // Martijn - allow other classes to construct chunk packets
     public final BlockableEventLoop<Runnable> mainThreadExecutor; // Paper - public
     final java.util.concurrent.Executor mainInvokingExecutor; // Paper
     public ChunkGenerator generator;
@@ -156,7 +157,10 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap;
     private final Long2ByteMap chunkTypeCache;
     private final Queue<Runnable> unloadQueue;
-    int viewDistance;
+    // Martijn start- per-player view distance
+    // This value is the intended world send view distance + 1
+    int worldViewDistance;
+    // Martijn end - per-player view distance
     public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerMobDistanceMap; // Paper
 
     // Paper start - optimise checkDespawn
@@ -238,7 +242,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
             int trackRange = this.entityTrackerTrackRanges[i];
 
-            trackMap.add(player, chunkX, chunkZ, Math.min(trackRange, this.getEffectiveViewDistance()));
+            trackMap.add(player, chunkX, chunkZ, Math.min(trackRange, player.getCachedTrackViewDistance())); // Martijn - per-player track view distance
         }
         // Paper end - use distance map to optimise entity tracker
         // Note: players need to be explicitly added to distance maps before they can be updated
@@ -271,6 +275,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     void updateMaps(ServerPlayer player) {
+        this.level.timings.chunkMapUpdatePlayerMaps.startTiming(); // Martijn
         int chunkX = MCUtil.getChunkCoordinate(player.getX());
         int chunkZ = MCUtil.getChunkCoordinate(player.getZ());
         // Note: players need to be explicitly added to distance maps before they can be updated
@@ -279,7 +284,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
             int trackRange = this.entityTrackerTrackRanges[i];
 
-            trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, this.getEffectiveViewDistance()));
+            trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, player.getCachedTrackViewDistance())); // Martijn - per-player track view distance
         }
         // Paper end - use distance map to optimise entity tracker
         this.playerChunkTickRangeMap.update(player, chunkX, chunkZ, DistanceManager.MOB_SPAWN_RANGE); // Paper - optimise ChunkMap#anyPlayerCloseEnoughForSpawning
@@ -289,6 +294,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             this.playerMobDistanceMap.update(player, chunkX, chunkZ, this.distanceManager.getSimulationDistance());
         }
         // Paper end - per player mob spawning
+        this.level.timings.chunkMapUpdatePlayerMaps.stopTiming(); // Martijn
     }
     // Paper end
     // Paper start
@@ -499,7 +505,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         this.distanceManager = new ChunkMap.ChunkDistanceManager(executor, mainThreadExecutor);
         this.overworldDataStorage = persistentStateManagerFactory;
         this.poiManager = new PoiManager(path.resolve("poi"), dataFixer, dsync, world);
-        this.setViewDistance(viewDistance);
+        this.setWorldViewDistance(viewDistance); // Martijn - per-player view distance
         // Paper start
         this.dataRegionManager = new io.papermc.paper.chunk.SingleThreadChunkRegionManager(this.level, 2, (1.0 / 3.0), 1, 6, "Data", DataRegionData::new, DataRegionSectionData::new);
         this.regionManagers.add(this.dataRegionManager);
@@ -746,11 +752,11 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     // Paper start
-    public final int getEffectiveViewDistance() {
-        // TODO this needs to be checked on update
-        // Mojang currently sets it to +1 of the configured view distance. So subtract one to get the one we really want.
-        return this.viewDistance - 1;
+    // Martijn start - per-player view distance
+    public final int getEffectiveWorldViewDistance() {
+        return this.worldViewDistance - 1;
     }
+    // Martijn start - per-player view distance
     // Paper end
 
     private CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> getChunkRangeFuture(ChunkPos centerChunk, int margin, IntFunction<ChunkStatus> distanceToStatus) {
@@ -1452,10 +1458,13 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             either.ifLeft((chunk) -> {
                 this.tickingGenerated.getAndIncrement();
                 MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> mutableobject = new MutableObject<>(); // Paper - Anti-Xray - Bypass
-
-                this.getPlayers(chunkcoordintpair, false).forEach((entityplayer) -> {
-                    this.playerLoadedChunk(entityplayer, mutableobject, chunk);
-                });
+                // Martijn start - per-player track and see distance
+                for (boolean track : new boolean[] {true, false}) {
+                    this.getPlayersNearChunkForSending(chunkcoordintpair, false, track).forEach((entityplayer) -> {
+                        entityplayer.trackOrSeeChunk(chunk, entityplayer.getClientboundChunkInitializationPacket(chunk), track);
+                    });
+                }
+                // Martijn end - per-player track and see distance
             });
         }, (runnable) -> {
             this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(holder, runnable));
@@ -1605,35 +1614,71 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
     }
 
-    public void setViewDistance(int watchDistance) {
-        int j = Mth.clamp(watchDistance + 1, (int) 3, (int) 33);
+    // Martijn start - per-player view distance
+    public void setWorldViewDistance(int watchDistance) {
+        int newWorldViewDistance = Mth.clamp(watchDistance + 1, (int) 3, (int) 33);
 
-        if (j != this.viewDistance) {
-            int k = this.viewDistance;
+        if (newWorldViewDistance != this.worldViewDistance) {
+            this.worldViewDistance = newWorldViewDistance;
+            if (this.distanceManager.perPlayerLoadViewDistance) {
+                this.level.players.forEach(player -> {
+                    player.trackViewDistanceMayHaveChanged();
+                    player.seeViewDistanceMayHaveChanged();
+                    player.loadViewDistanceMayHaveChanged();
+                });
+            } else {
+                this.distanceManager.updatePlayerTicketsForAllPlayersInWorldByWorldViewDistance(this.level, this.worldViewDistance);
+            }
+            // Martijn end - per-player view distance
+        }
 
-            this.viewDistance = j;
-            this.distanceManager.updatePlayerTickets(this.viewDistance + 1);
-            Iterator objectiterator = this.updatingChunks.getVisibleValuesCopy().iterator(); // Paper
+    }
 
-            while (objectiterator.hasNext()) {
-                ChunkHolder playerchunk = (ChunkHolder) objectiterator.next();
-                ChunkPos chunkcoordintpair = playerchunk.getPos();
-                MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> mutableobject = new MutableObject<>(); // Paper - Anti-Xray - Bypass
+    // Martijn start - per-player track and see view distance
+    public void updateChunkTrackingDueToPlayerTrackViewDistanceChange(ServerPlayer player, int oldTrackViewDistance, int newTrackViewDistance) {
+        updateChunkTrackingOrSeeingDueToPlayerTrackOrSeeViewDistanceChange(player, oldTrackViewDistance, newTrackViewDistance, true);
+    }
+
+    public void updateChunkSeeingDueToPlayerSeeViewDistanceChange(ServerPlayer player, int oldSeeViewDistance, int newSeeViewDistance) {
+        updateChunkTrackingOrSeeingDueToPlayerTrackOrSeeViewDistanceChange(player, oldSeeViewDistance, newSeeViewDistance, false);
+    }
 
-                this.getPlayers(chunkcoordintpair, false).forEach((entityplayer) -> {
-                    SectionPos sectionposition = entityplayer.getLastSectionPos();
-                    boolean flag = ChunkMap.isChunkInRange(chunkcoordintpair.x, chunkcoordintpair.z, sectionposition.x(), sectionposition.z(), k);
-                    boolean flag1 = ChunkMap.isChunkInRange(chunkcoordintpair.x, chunkcoordintpair.z, sectionposition.x(), sectionposition.z(), this.viewDistance);
+    private void updateChunkTrackingOrSeeingDueToPlayerTrackOrSeeViewDistanceChange(ServerPlayer player, int oldSendViewDistance, int newSendViewDistance, boolean concernsTracking) {
+        if (this.playerMap.ignoredOrUnknown(player)) return;
 
-                    this.updateChunkTracking(entityplayer, chunkcoordintpair, mutableobject, flag, flag1);
-                });
-            }
+        // Martijn start - sort chunks by distance
+        List<ChunkHolder> objects = this.updatingChunks.getVisibleValuesCopy(); // Paper
+        Iterator objectiterator;
+        if (level.paperConfig.trackAndSeeChunksInOrderOfDistanceWhenChangingViewDistance) {
+            objectiterator = player.getChunkHoldersSortedBySquaredPythagoreanDistance(objects.stream()).iterator();
+        } else {
+            objectiterator = objects.iterator();
         }
+        // Martijn end - sort chunks by distance
+
+        int oldWatchViewDistance = oldSendViewDistance + 1;
+        int newWatchViewDistance = newSendViewDistance + 1;
+        int updateChunkTrackingOrSeeingDistance = Math.max(oldWatchViewDistance, newWatchViewDistance);
+
+        while (objectiterator.hasNext()) {
+            ChunkHolder playerchunk = (ChunkHolder) objectiterator.next();
+            ChunkPos chunkcoordintpair = playerchunk.getPos();
+            MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> mutableobject = new MutableObject<>(); // Paper - Anti-Xray - Bypass
+
+            if (this.isPlayerIncludedInPlayersNearChunkForSending(player, chunkcoordintpair, false, updateChunkTrackingOrSeeingDistance)) {
+                SectionPos sectionposition = player.getLastSectionPos();
+                boolean oldWithinViewDistance = ChunkMap.isChunkInRange(chunkcoordintpair.x, chunkcoordintpair.z, sectionposition.x(), sectionposition.z(), oldWatchViewDistance);
+                boolean newWithinViewDistance = ChunkMap.isChunkInRange(chunkcoordintpair.x, chunkcoordintpair.z, sectionposition.x(), sectionposition.z(), newWatchViewDistance);
 
+                this.updateChunkTrackingOrSeeing(player, chunkcoordintpair, mutableobject, oldWithinViewDistance, newWithinViewDistance, concernsTracking);
+            }
+        }
     }
+    // Martijn end - per-player track and see view distance
 
-    protected void updateChunkTracking(ServerPlayer player, ChunkPos pos, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> mutableobject, boolean oldWithinViewDistance, boolean newWithinViewDistance) { // Paper - Anti-Xray - Bypass
+    protected void updateChunkTrackingOrSeeing(ServerPlayer player, ChunkPos pos, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> mutableobject, boolean oldWithinViewDistance, boolean newWithinViewDistance, boolean concernsTracking) { // Paper - Anti-Xray - Bypass // Martijn - per-player track and see view distance
         if (player.level == this.level) {
+
             if (newWithinViewDistance && !oldWithinViewDistance) {
                 ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos.toLong());
 
@@ -1641,7 +1686,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                     LevelChunk chunk = playerchunk.getTickingChunk();
 
                     if (chunk != null) {
-                        this.playerLoadedChunk(player, mutableobject, chunk);
+                        player.trackOrSeeChunk(chunk, player.getClientboundChunkInitializationPacket(chunk), concernsTracking); // Martijn - per-player track and see view distance
                     }
 
                     DebugPackets.sendPoiPacketsForChunk(this.level, pos);
@@ -1649,7 +1694,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
 
             if (!newWithinViewDistance && oldWithinViewDistance) {
-                player.untrackChunk(pos);
+                player.untrackOrUnseeChunk(pos, concernsTracking);
             }
 
         }
@@ -1897,21 +1942,39 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
             this.playerMap.removePlayer(sectionposition.chunk().toLong(), player);
             if (!flag2) {
-                this.distanceManager.removePlayer(sectionposition, player);
+                this.distanceManager.removePlayer(sectionposition, player, false); // Martijn - per-player load distance
             }
             this.removePlayerFromDistanceMaps(player); // Paper - distance maps
         }
 
-        for (int k = i - this.viewDistance - 1; k <= i + this.viewDistance + 1; ++k) {
-            for (int l = j - this.viewDistance - 1; l <= j + this.viewDistance + 1; ++l) {
-                if (ChunkMap.isChunkInRange(k, l, i, j, this.viewDistance)) {
+        // Martijn start - sort chunks by distance, per-player track and see view distance
+
+        for (boolean track : new boolean[] {true, false}) {
+
+            int viewDistance = (track ? player.getCachedTrackViewDistance() : player.getCachedSeeViewDistance()) + 2;
+            BiConsumer<Integer, Integer> chunkCoordinatesConsumer = (k, l) -> {
+                if (ChunkMap.isChunkInRange(k, l, i, j, viewDistance)) {
+
                     ChunkPos chunkcoordintpair = new ChunkPos(k, l);
 
-                    this.updateChunkTracking(player, chunkcoordintpair, new MutableObject(), !added, added);
+                    this.updateChunkTrackingOrSeeing(player, chunkcoordintpair, new MutableObject(), !added, added, track);
+                }
+            };
+            if (level.paperConfig.trackAndSeeChunksInSpiralOrderWhenChangingWorld) {
+                ChunkMap.evaluateSpiral(i, j, viewDistance + 1, chunkCoordinatesConsumer);
+            } else {
+                for (int k = i - viewDistance - 1; k <= i + viewDistance + 1; ++k) {
+                    for (int l = j - viewDistance - 1; l <= j + viewDistance + 1; ++l) {
+                        chunkCoordinatesConsumer.accept(k, l);
+                    }
                 }
             }
+
         }
 
+        // Martijn end - sort chunks by distance, per-player track and see view distance
+
+
     }
 
     private SectionPos updatePlayerPos(ServerPlayer player) {
@@ -1925,6 +1988,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public void move(ServerPlayer player) {
         // Paper - delay this logic for the entity tracker tick, no need to duplicate it
 
+        this.level.timings.chunkMapPlayerMove.startTiming(); // Martijn
+
         int i = SectionPos.blockToSectionCoord(player.getBlockX());
         int j = SectionPos.blockToSectionCoord(player.getBlockZ());
         SectionPos sectionposition = player.getLastSectionPos();
@@ -1936,15 +2001,20 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         boolean flag2 = sectionposition.asLong() != sectionposition1.asLong();
 
         if (flag2 || flag != flag1) {
+            this.level.timings.chunkMapPlayerMoveUpdatePos.startTiming(); // Martijn
             this.updatePlayerPos(player);
+            this.level.timings.chunkMapPlayerMoveUpdatePos.stopTiming(); // Martijn
+            this.level.timings.chunkMapPlayerMoveUpdateDistanceManager.startTiming(); // Martijn
             if (!flag) {
-                this.distanceManager.removePlayer(sectionposition, player);
+                this.distanceManager.removePlayer(sectionposition, player, !flag1); // Martijn - per-player load distance
             }
 
             if (!flag1) {
                 this.distanceManager.addPlayer(sectionposition1, player);
             }
+            this.level.timings.chunkMapPlayerMoveUpdateDistanceManager.stopTiming(); // Martijn
 
+            this.level.timings.chunkMapPlayerMoveUpdatePlayerMap.startTiming(); // Martijn
             if (!flag && flag1) {
                 this.playerMap.ignorePlayer(player);
             }
@@ -1956,6 +2026,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             if (k != l) {
                 this.playerMap.updatePlayer(k, l, player);
             }
+            this.level.timings.chunkMapPlayerMoveUpdatePlayerMap.stopTiming(); // Martijn
         }
 
         int i1 = sectionposition.x();
@@ -1963,67 +2034,114 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         int k1;
         int l1;
 
-        if (Math.abs(i1 - i) <= this.viewDistance * 2 && Math.abs(j1 - j) <= this.viewDistance * 2) {
-            k1 = Math.min(i, i1) - this.viewDistance - 1;
-            l1 = Math.min(j, j1) - this.viewDistance - 1;
-            int i2 = Math.max(i, i1) + this.viewDistance + 1;
-            int j2 = Math.max(j, j1) + this.viewDistance + 1;
+        // Martijn start - per-player track and see view distance
+
+        for (boolean track : new boolean[] {true, false}) {
+
+            int viewDistance = (track ? player.getCachedTrackViewDistance() : player.getCachedSeeViewDistance()) + 1;
+            if (Math.abs(i1 - i) <= viewDistance * 2 && Math.abs(j1 - j) <= viewDistance * 2) {
+                k1 = Math.min(i, i1) - viewDistance - 1;
+                l1 = Math.min(j, j1) - viewDistance - 1;
+                int i2 = Math.max(i, i1) + viewDistance + 1;
+                int j2 = Math.max(j, j1) + viewDistance + 1;
+
+                // Martijn start - sort chunks by distance
+                BiConsumer<Integer, Integer> chunkCoordinatesConsumer = (k2, l2) -> {
+                    this.level.timings.chunkMapPlayerMoveUpdateChunkTrackingOrSeeing.startTiming(); // Martijn
+                    boolean oldWithinViewDistance = ChunkMap.isChunkInRange(k2, l2, i1, j1, viewDistance);
+                    boolean newWithinViewDistance = ChunkMap.isChunkInRange(k2, l2, i, j, viewDistance);
+
+                    this.updateChunkTrackingOrSeeing(player, new ChunkPos(k2, l2), new MutableObject<>(), oldWithinViewDistance, newWithinViewDistance, track);
+                    this.level.timings.chunkMapPlayerMoveUpdateChunkTrackingOrSeeing.stopTiming(); // Martijn
+                };
+
+                List<IntIntPair> coordinates = level.paperConfig.trackAndSeeChunksInOrderOfDistanceWhenMoving ? new ArrayList<>((i2 - k1 + 1) * (j2 - l1 + 1) + 1) : null;
+                for (int k2 = k1; k2 <= i2; ++k2) {
+                    for (int l2 = l1; l2 <= j2; ++l2) {
+                        if (level.paperConfig.trackAndSeeChunksInOrderOfDistanceWhenMoving) {
+                            coordinates.add(new IntIntImmutablePair(k2, l2));
+                        } else {
+                            chunkCoordinatesConsumer.accept(k2, l2);
+                        }
+                    }
+                }
+
+                if (level.paperConfig.trackAndSeeChunksInOrderOfDistanceWhenMoving) {
 
-            for (int k2 = k1; k2 <= i2; ++k2) {
-                for (int l2 = l1; l2 <= j2; ++l2) {
-                    boolean flag3 = ChunkMap.isChunkInRange(k2, l2, i1, j1, this.viewDistance);
-                    boolean flag4 = ChunkMap.isChunkInRange(k2, l2, i, j, this.viewDistance);
+                    this.level.timings.chunkMapPlayerMoveSortChunksForTrackAndSee.startTiming(); // Martijn
+                    List<IntIntPair> sortedCoordinates = player.getChunkCoordinatesSortedBySquaredPythagoreanDistance(coordinates.stream()).toList();
+                    this.level.timings.chunkMapPlayerMoveSortChunksForTrackAndSee.stopTiming(); // Martijn
 
-                    this.updateChunkTracking(player, new ChunkPos(k2, l2), new MutableObject(), flag3, flag4);
+                    sortedCoordinates.stream().forEach(pair -> chunkCoordinatesConsumer.accept(pair.first(), pair.second()));
                 }
-            }
-        } else {
-            boolean flag5;
-            boolean flag6;
-
-            for (k1 = i1 - this.viewDistance - 1; k1 <= i1 + this.viewDistance + 1; ++k1) {
-                for (l1 = j1 - this.viewDistance - 1; l1 <= j1 + this.viewDistance + 1; ++l1) {
-                    if (ChunkMap.isChunkInRange(k1, l1, i1, j1, this.viewDistance)) {
-                        flag5 = true;
-                        flag6 = false;
-                        this.updateChunkTracking(player, new ChunkPos(k1, l1), new MutableObject(), true, false);
+
+                // Martijn end - sort chunks by distance
+
+            } else {
+
+                // Martijn start - track new chunks before untracking old chunks
+
+                for (k1 = i - viewDistance - 1; k1 <= i + viewDistance + 1; ++k1) {
+                    for (l1 = j - viewDistance - 1; l1 <= j + viewDistance + 1; ++l1) {
+                        if (ChunkMap.isChunkInRange(k1, l1, i, j, viewDistance)) {
+                            this.updateChunkTrackingOrSeeing(player, new ChunkPos(k1, l1), new MutableObject<>(), false, true, track);
+                        }
                     }
                 }
-            }
 
-            for (k1 = i - this.viewDistance - 1; k1 <= i + this.viewDistance + 1; ++k1) {
-                for (l1 = j - this.viewDistance - 1; l1 <= j + this.viewDistance + 1; ++l1) {
-                    if (ChunkMap.isChunkInRange(k1, l1, i, j, this.viewDistance)) {
-                        flag5 = false;
-                        flag6 = true;
-                        this.updateChunkTracking(player, new ChunkPos(k1, l1), new MutableObject(), false, true);
+                for (k1 = i1 - viewDistance - 1; k1 <= i1 + viewDistance + 1; ++k1) {
+                    for (l1 = j1 - viewDistance - 1; l1 <= j1 + viewDistance + 1; ++l1) {
+                        if (ChunkMap.isChunkInRange(k1, l1, i1, j1, viewDistance)) {
+                            this.updateChunkTrackingOrSeeing(player, new ChunkPos(k1, l1), new MutableObject<>(), true, false, track);
+                        }
                     }
                 }
             }
+
         }
 
+        // Martijn end - per-player track and see view distance
+
         this.updateMaps(player); // Paper - distance maps
 
+        this.level.timings.chunkMapPlayerMove.stopTiming(); // Martijn
+
     }
 
     @Override
-    public List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge) {
+    public List<ServerPlayer> getPlayersNearChunkForSending(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge, boolean concernsTracking) { // Martijn - per-player track and see view distance
+        this.level.timings.getPlayersNearChunkForSending.startTiming(); // Martijn - per-player track and see view distance
         Set<ServerPlayer> set = this.playerMap.getPlayers(chunkPos.toLong());
         Builder<ServerPlayer> builder = ImmutableList.builder();
         Iterator iterator = set.iterator();
 
         while (iterator.hasNext()) {
             ServerPlayer entityplayer = (ServerPlayer) iterator.next();
-            SectionPos sectionposition = entityplayer.getLastSectionPos();
 
-            if (onlyOnWatchDistanceEdge && ChunkMap.isChunkOnRangeBorder(chunkPos.x, chunkPos.z, sectionposition.x(), sectionposition.z(), this.viewDistance) || !onlyOnWatchDistanceEdge && ChunkMap.isChunkInRange(chunkPos.x, chunkPos.z, sectionposition.x(), sectionposition.z(), this.viewDistance)) {
+            if (isPlayerIncludedInPlayersNearChunkForSendingBasedOnCurrentViewDistance(entityplayer, chunkPos, onlyOnWatchDistanceEdge, concernsTracking)) { // Martijn - per-player track and see view distance
                 builder.add(entityplayer);
             }
         }
 
-        return builder.build();
+        // Martijn start - per-player track and see view distance
+        ImmutableList<ServerPlayer> result = builder.build();
+        this.level.timings.getPlayersNearChunkForSending.stopTiming();
+        return result;
+        // Martijn end - per-player track and see view distance
+
+    }
+
+    // Martijn start - per-player track and see view distance
+    public boolean isPlayerIncludedInPlayersNearChunkForSendingBasedOnCurrentViewDistance(ServerPlayer player, ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge, boolean concernsTracking) {
+        return isPlayerIncludedInPlayersNearChunkForSending(player, chunkPos, onlyOnWatchDistanceEdge, (concernsTracking ? player.getCachedTrackViewDistance() : player.getCachedSeeViewDistance()) + 1);
     }
 
+    public boolean isPlayerIncludedInPlayersNearChunkForSending(ServerPlayer player, ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge, int distance) {
+        SectionPos sectionposition = player.getLastSectionPos();
+        return onlyOnWatchDistanceEdge && ChunkMap.isChunkOnRangeBorder(chunkPos.x, chunkPos.z, sectionposition.x(), sectionposition.z(), distance) || !onlyOnWatchDistanceEdge && ChunkMap.isChunkInRange(chunkPos.x, chunkPos.z, sectionposition.x(), sectionposition.z(), distance);
+    }
+    // Martijn end - per-player track and see view distance
+
     public void addEntity(Entity entity) {
         org.spigotmc.AsyncCatcher.catchOp("entity track"); // Spigot
         // Paper start - ignore and warn about illegal addEntity calls instead of crashing server
@@ -2119,6 +2237,14 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // Paper end - optimised tracker
 
     protected void tick() {
+
+        // Martijn start - temporary debug message containing the number of loaded chunks
+        // TODO remove this temporary debug message
+        if (Math.random() < 1.0/20/30) {
+            org.bukkit.Bukkit.getLogger().info("Number of loaded chunks in " + this.level.getWorld().getName() + ": " + this.level.getWorld().getLoadedChunks().length);
+        }
+        // Martijn end - temporary debug message containing the number of loaded chunks
+
         // Paper start - optimized tracker
         if (true) {
             this.processTrackQueue();
@@ -2186,68 +2312,68 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
     }
 
-    // Paper start - Anti-Xray - Bypass
-    private void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk) {
-        if (cachedDataPackets.getValue() == null) {
-            cachedDataPackets.setValue(new java.util.HashMap<>());
-        }
-
-        Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
-        player.trackChunk(chunk.getPos(), cachedDataPackets.getValue().computeIfAbsent(shouldModify, (s) -> {
-            return new ClientboundLevelChunkWithLightPacket(chunk, this.lightEngine, (BitSet) null, (BitSet) null, true, (Boolean) s);
-        }));
-        // Paper end
-        DebugPackets.sendPoiPacketsForChunk(this.level, chunk.getPos());
-        List<Entity> list = Lists.newArrayList();
-        List<Entity> list1 = Lists.newArrayList();
-        // Paper start - optimise entity tracker
-        // use the chunk entity list, not the whole trackedEntities map...
-        Entity[] entities = chunk.entities.getRawData();
-        for (int i = 0, size = chunk.entities.size(); i < size; ++i) {
-            Entity entity = entities[i];
-            if (entity == player) {
-                continue;
-            }
-            ChunkMap.TrackedEntity tracker = this.entityMap.get(entity.getId());
-            if (tracker != null) { // dumb plugins... move on...
-                tracker.updatePlayer(player);
-            }
-
-            // keep the vanilla logic here - this is REQUIRED or else passengers and their vehicles disappear!
-            // (and god knows what the leash thing is)
-
-            if (entity instanceof Mob && ((Mob)entity).getLeashHolder() != null) {
-                list.add(entity);
-            }
-
-            if (!entity.getPassengers().isEmpty()) {
-                list1.add(entity);
-            }
-        }
-        // Paper end - optimise entity tracker
-
-        Iterator iterator;
-        Entity entity1;
-
-        if (!list.isEmpty()) {
-            iterator = list.iterator();
-
-            while (iterator.hasNext()) {
-                entity1 = (Entity) iterator.next();
-                player.connection.send(new ClientboundSetEntityLinkPacket(entity1, ((Mob) entity1).getLeashHolder()));
-            }
-        }
-
-        if (!list1.isEmpty()) {
-            iterator = list1.iterator();
-
-            while (iterator.hasNext()) {
-                entity1 = (Entity) iterator.next();
-                player.connection.send(new ClientboundSetPassengersPacket(entity1));
-            }
-        }
-
-    }
+//    // Paper start - Anti-Xray - Bypass
+//    private void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk) {
+//        if (cachedDataPackets.getValue() == null) {
+//            cachedDataPackets.setValue(new java.util.HashMap<>());
+//        }
+//
+//        Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
+//        player.trackChunk(chunk.getPos(), cachedDataPackets.getValue().computeIfAbsent(shouldModify, (s) -> {
+//            return new ClientboundLevelChunkWithLightPacket(chunk, this.lightEngine, (BitSet) null, (BitSet) null, true, (Boolean) s);
+//        }));
+//        // Paper end
+//        DebugPackets.sendPoiPacketsForChunk(this.level, chunk.getPos());
+//        List<Entity> list = Lists.newArrayList();
+//        List<Entity> list1 = Lists.newArrayList();
+//        // Paper start - optimise entity tracker
+//        // use the chunk entity list, not the whole trackedEntities map...
+//        Entity[] entities = chunk.entities.getRawData();
+//        for (int i = 0, size = chunk.entities.size(); i < size; ++i) {
+//            Entity entity = entities[i];
+//            if (entity == player) {
+//                continue;
+//            }
+//            ChunkMap.TrackedEntity tracker = this.entityMap.get(entity.getId());
+//            if (tracker != null) { // dumb plugins... move on...
+//                tracker.updatePlayer(player);
+//            }
+//
+//            // keep the vanilla logic here - this is REQUIRED or else passengers and their vehicles disappear!
+//            // (and god knows what the leash thing is)
+//
+//            if (entity instanceof Mob && ((Mob)entity).getLeashHolder() != null) {
+//                list.add(entity);
+//            }
+//
+//            if (!entity.getPassengers().isEmpty()) {
+//                list1.add(entity);
+//            }
+//        }
+//        // Paper end - optimise entity tracker
+//
+//        Iterator iterator;
+//        Entity entity1;
+//
+//        if (!list.isEmpty()) {
+//            iterator = list.iterator();
+//
+//            while (iterator.hasNext()) {
+//                entity1 = (Entity) iterator.next();
+//                player.connection.send(new ClientboundSetEntityLinkPacket(entity1, ((Mob) entity1).getLeashHolder()));
+//            }
+//        }
+//
+//        if (!list1.isEmpty()) {
+//            iterator = list1.iterator();
+//
+//            while (iterator.hasNext()) {
+//                entity1 = (Entity) iterator.next();
+//                player.connection.send(new ClientboundSetPassengersPacket(entity1));
+//            }
+//        }
+//
+//    }
 
     public PoiManager getPoiManager() {
         return this.poiManager;
@@ -2390,7 +2516,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 double vec3d_dx = player.getX() - this.entity.getX();
                 double vec3d_dz = player.getZ() - this.entity.getZ();
                 // Paper end - remove allocation of Vec3D here
-                double d0 = (double) Math.min(this.getEffectiveRange(), (ChunkMap.this.viewDistance - 1) * 16);
+                double d0 = (double) Math.min(this.getEffectiveRange(), player.getCachedTrackViewDistance() * 16); // Martijn - per-player track view distance
                 double d1 = vec3d_dx * vec3d_dx + vec3d_dz * vec3d_dz; // Paper
                 double d2 = d0 * d0;
                 boolean flag = d1 <= d2 && this.entity.broadcastToPlayer(player);
diff --git a/src/main/java/net/minecraft/server/level/DistanceManager.java b/src/main/java/net/minecraft/server/level/DistanceManager.java
index 1744f4983b24a87f3861ebd5d68120cfce904934..ca8314fc7d35d2fdb6d0a9019ef358f4e70da453 100644
--- a/src/main/java/net/minecraft/server/level/DistanceManager.java
+++ b/src/main/java/net/minecraft/server/level/DistanceManager.java
@@ -1,9 +1,12 @@
 package net.minecraft.server.level;
 
+import com.destroystokyo.paper.PaperWorldConfig;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Sets;
 import com.mojang.datafixers.util.Either;
+import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
+import it.unimi.dsi.fastutil.ints.IntSet;
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2IntMap;
@@ -22,11 +25,17 @@ import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.nio.charset.StandardCharsets;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
+import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
+import java.util.stream.StreamSupport;
 import javax.annotation.Nullable;
 import net.minecraft.core.SectionPos;
 import net.minecraft.util.SortedArraySet;
@@ -36,6 +45,7 @@ import net.minecraft.world.level.chunk.ChunkStatus;
 import net.minecraft.world.level.chunk.LevelChunk;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.jetbrains.annotations.NotNull;
 
 public abstract class DistanceManager {
 
@@ -50,7 +60,13 @@ public abstract class DistanceManager {
     private final DistanceManager.ChunkTicketTracker ticketTracker = new DistanceManager.ChunkTicketTracker();
     public static final int MOB_SPAWN_RANGE = 8; // private final ChunkMapDistance.b f = new ChunkMapDistance.b(8); // Paper - no longer used
     private final TickingTracker tickingTicketsTracker = new TickingTracker();
-    private final DistanceManager.PlayerTicketTracker playerTicketManager = new DistanceManager.PlayerTicketTracker(33);
+    // Martijn start - per-player load distance
+    private static final int maxPlayerTrackerViewDistance = 33;
+    public final boolean perPlayerLoadViewDistance;
+    private final @Nullable Map<UUID, PlayerTicketTracker> playerTicketManagers;
+    private final @Nullable PlayerTicketTracker sharedPlayerTicketManager;
+    private final @NotNull CombinedPlayerTicketTracker combinedPlayerTicketManager;
+    // Martijn end - per-player load distance
     // Paper start use a queue, but still keep unique requirement
     public final java.util.Queue<ChunkHolder> pendingChunkUpdates = new java.util.ArrayDeque<ChunkHolder>() {
         @Override
@@ -80,8 +96,42 @@ public abstract class DistanceManager {
         this.ticketThrottlerReleaser = chunktaskqueuesorter.getReleaseProcessor(mailbox);
         this.mainThreadExecutor = mainThreadExecutor;
         this.chunkMap = chunkMap; // Paper
+        // Martijn start - per-player load distance
+        this.perPlayerLoadViewDistance = this.chunkMap.level.paperConfig.getPerPlayerLoadViewDistance();
+        this.playerTicketManagers = this.perPlayerLoadViewDistance ? new HashMap<>(1) : null;
+        this.sharedPlayerTicketManager = this.perPlayerLoadViewDistance ? null : createNewPlayerTicketManager();
+        this.combinedPlayerTicketManager = new CombinedPlayerTicketTracker();
+        // Martijn end - per-player load distance
     }
 
+    // Martijn start - per-player load distance
+
+    private @NotNull Iterable<@NotNull DistanceManager.PlayerTicketTracker> getPlayerTicketManagers() {
+        return this.perPlayerLoadViewDistance ? this.playerTicketManagers.values() : Collections.singletonList(this.sharedPlayerTicketManager);
+    }
+
+    private @NotNull DistanceManager.PlayerTicketTracker createNewPlayerTicketManager() {
+        return new DistanceManager.PlayerTicketTracker(DistanceManager.maxPlayerTrackerViewDistance);
+    }
+
+    private @NotNull DistanceManager.PlayerTicketTracker getOrCreatePlayerTicketManager(ServerPlayer player) {
+        return this.perPlayerLoadViewDistance ? this.playerTicketManagers.computeIfAbsent(player.getUUID(), it -> {
+            DistanceManager.PlayerTicketTracker tracker = this.createNewPlayerTicketManager();
+            tracker.updateViewDistanceByPlayerLoadDistance(player);
+            return tracker;
+        }) : this.sharedPlayerTicketManager;
+    }
+
+    private @NotNull DistanceManager.PlayerTicketTracker getPlayerTicketManagerIfExists(ServerPlayer player) {
+        return this.perPlayerLoadViewDistance ? this.playerTicketManagers.get(player.getUUID()) : this.sharedPlayerTicketManager;
+    }
+
+    private void removePlayerTicketManager(ServerPlayer player) {
+        if (this.perPlayerLoadViewDistance) this.playerTicketManagers.remove(player.getUUID());
+    }
+
+    // Martijn end - per-player load distance
+
     protected void purgeStaleTickets() {
         ++this.ticketTickCounter;
         ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().fastIterator();
@@ -129,7 +179,7 @@ public abstract class DistanceManager {
         //this.f.a(); // Paper - no longer used
         this.tickingTicketsTracker.runAllUpdates();
         org.spigotmc.AsyncCatcher.catchOp("DistanceManagerTick"); // Paper
-        this.playerTicketManager.runAllUpdates();
+        this.getPlayerTicketManagers().forEach(it -> it.runAllUpdates()); // Martijn - per-player load distance
         int i = Integer.MAX_VALUE - this.ticketTracker.runDistanceUpdates(Integer.MAX_VALUE);
         boolean flag = i != 0;
 
@@ -140,11 +190,20 @@ public abstract class DistanceManager {
         // Paper start
         if (!this.pendingChunkUpdates.isEmpty()) {
             this.pollingPendingChunkUpdates = true; try { // Paper - Chunk priority
-            while(!this.pendingChunkUpdates.isEmpty()) {
-                ChunkHolder remove = this.pendingChunkUpdates.remove();
-                remove.isUpdateQueued = false;
-                remove.updateFutures(chunkStorage, this.mainThreadExecutor);
-            }
+                while(!this.pendingChunkUpdates.isEmpty()) {
+                    // Martijn start - sort chunks by distance
+                    if (this.chunkMap.level.paperConfig.processChunksInOrderOfDistanceAfterLoad) {
+                        List<ChunkHolder> sortedPendingChunkUpdates = this.chunkMap.getChunkHoldersSortedBySquaredPythagoreanDistanceToClosestPlayer(this.pendingChunkUpdates.stream()).toList();
+                        this.pendingChunkUpdates.clear();
+                        this.pendingChunkUpdates.addAll(sortedPendingChunkUpdates);
+                    }
+                    while (!this.pendingChunkUpdates.isEmpty()) {
+                        ChunkHolder remove = this.pendingChunkUpdates.remove();
+                        remove.isUpdateQueued = false;
+                        remove.updateFutures(chunkStorage, this.mainThreadExecutor);
+                    }
+                    // Martijn end - sort chunks by distance
+                }
             } finally { this.pollingPendingChunkUpdates = false; } // Paper - Chunk priority
             // Paper end
             return true;
@@ -406,6 +465,9 @@ public abstract class DistanceManager {
     }
 
     public void addPlayer(SectionPos pos, ServerPlayer player) {
+
+        DistanceManager.PlayerTicketTracker playerTicketManager = this.getOrCreatePlayerTicketManager(player); // Martijn - per-player load distance
+
         ChunkPos chunkcoordintpair = pos.chunk();
         long i = chunkcoordintpair.toLong();
 
@@ -413,11 +475,12 @@ public abstract class DistanceManager {
             return new ObjectOpenHashSet();
         })).add(player);
         //this.f.update(i, 0, true); // Paper - no longer used
-        this.playerTicketManager.update(i, 0, true);
+        playerTicketManager.update(i, 0, true); // Martijn - per-player load distance
         this.tickingTicketsTracker.addTicket(TicketType.PLAYER, chunkcoordintpair, this.getPlayerTicketLevel(), chunkcoordintpair);
+
     }
 
-    public void removePlayer(SectionPos pos, ServerPlayer player) {
+    public void removePlayer(SectionPos pos, ServerPlayer player, boolean keepPlayerTicketManager) { // Martijn - per-player load distance
         ChunkPos chunkcoordintpair = pos.chunk();
         long i = chunkcoordintpair.toLong();
         ObjectSet<ServerPlayer> objectset = (ObjectSet) this.playersPerChunk.get(i);
@@ -427,7 +490,15 @@ public abstract class DistanceManager {
         if (objectset == null || objectset.isEmpty()) { // Paper
             this.playersPerChunk.remove(i);
             //this.f.update(i, Integer.MAX_VALUE, false); // Paper - no longer used
-            this.playerTicketManager.update(i, Integer.MAX_VALUE, false);
+            // Martijn start - per-player load distance
+            DistanceManager.PlayerTicketTracker playerTicketManager = this.getPlayerTicketManagerIfExists(player);
+            if (playerTicketManager != null) {
+                playerTicketManager.update(i, Integer.MAX_VALUE, false);
+            }
+            if (!keepPlayerTicketManager) {
+                removePlayerTicketManager(player);
+            }
+            // Martijn end - per-player load distance
             this.tickingTicketsTracker.removeTicket(TicketType.PLAYER, chunkcoordintpair, this.getPlayerTicketLevel(), chunkcoordintpair);
         }
 
@@ -451,10 +522,22 @@ public abstract class DistanceManager {
         return arraysetsorted != null && !arraysetsorted.isEmpty() ? ((Ticket) arraysetsorted.first()).toString() : "no_ticket";
     }
 
-    protected void updatePlayerTickets(int viewDistance) {
-        this.playerTicketManager.updateViewDistance(viewDistance);
+    // Martijn start - per-player load distance
+    protected void updatePlayerTicketsForAllPlayersInWorldByWorldViewDistance(ServerLevel level, int worldViewDistance) {
+        if (this.perPlayerLoadViewDistance) {
+            throw new IllegalStateException("Cannot call updatePlayerTicketsForAllPlayersInWorldByWorldViewDistance when using per-player load distances, call updatePlayerTicketsByPlayerLoadDistance instead");
+        }
+        this.sharedPlayerTicketManager.updateViewDistanceByWorldViewDistance(worldViewDistance);
     }
 
+    protected void updatePlayerTicketsByPlayerLoadDistance(ServerPlayer player) {
+        if (!this.perPlayerLoadViewDistance) {
+            throw new IllegalStateException("Cannot call updatePlayerTicketsByPlayerLoadDistance when not using per-player load distances, call updatePlayerTicketsForAllPlayersInWorldByWorldViewDistance instead");
+        }
+        this.getOrCreatePlayerTicketManager(player).updateViewDistanceByPlayerLoadDistance(player);
+    }
+    // Martijn end - per-player load distance
+
     public void updateSimulationDistance(int simulationDistance) {
         if (simulationDistance != this.simulationDistance) {
             this.simulationDistance = simulationDistance;
@@ -670,37 +753,36 @@ public abstract class DistanceManager {
         }
     }
 
-    private class PlayerTicketTracker extends DistanceManager.FixedPlayerDistanceChunkTracker {
+    // Martijn start - per-player load distance
+    private class CombinedPlayerTicketTracker {
 
-        private int viewDistance = 0;
-        private final Long2IntMap queueLevels = Long2IntMaps.synchronize(new Long2IntOpenHashMap());
-        private final LongSet toUpdate = new LongOpenHashSet();
-
-        protected PlayerTicketTracker(int i) {
-            super(i);
-            this.queueLevels.defaultReturnValue(i + 2);
+        private boolean haveTicketFor(int distance) {
+            return StreamSupport.stream(DistanceManager.this.getPlayerTicketManagers().spliterator(), false).anyMatch(tracker -> tracker.haveTicketFor(distance));
         }
 
-        @Override
-        protected void onLevelChange(long pos, int oldDistance, int distance) {
-            this.toUpdate.add(pos);
+        private int getLevel(long id) {
+            return StreamSupport.stream(DistanceManager.this.getPlayerTicketManagers().spliterator(), false).mapToInt(tracker -> tracker.getLevel(id)).min().orElse(maxPlayerTrackerViewDistance + 2);
         }
 
-        public void updateViewDistance(int watchDistance) {
-            ObjectIterator objectiterator = this.chunks.long2ByteEntrySet().iterator();
-
-            while (objectiterator.hasNext()) {
-                it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry it_unimi_dsi_fastutil_longs_long2bytemap_entry = (it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry) objectiterator.next();
-                byte b0 = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getByteValue();
-                long j = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getLongKey();
-
-                this.onLevelChange(j, b0, this.haveTicketFor(b0), b0 <= watchDistance - 2);
+        private void onSomePlayerTicketTrackerLevelChange(PlayerTicketTracker tracker, long pos, int distance, boolean oldWithinViewDistance, boolean withinViewDistance) {
+            if (!DistanceManager.this.perPlayerLoadViewDistance) {
+                this.onCombinedPlayerTicketTrackerLevelChange(pos, distance, oldWithinViewDistance, withinViewDistance);
+                return;
             }
-
-            this.viewDistance = watchDistance;
+            int minDistance = distance;
+            boolean oldWithinSomeViewDistance = oldWithinViewDistance;
+            boolean withinSomeViewDistance = withinViewDistance;
+            for (PlayerTicketTracker otherTracker : DistanceManager.this.getPlayerTicketManagers()) {
+                if (otherTracker != tracker) {
+                    minDistance = Math.min(distance, otherTracker.getLevel(pos));
+                    oldWithinSomeViewDistance |= otherTracker.haveTicketFor(distance);
+                    withinSomeViewDistance |= otherTracker.haveTicketFor(distance);
+                }
+            }
+            this.onCombinedPlayerTicketTrackerLevelChange(pos, minDistance, oldWithinSomeViewDistance, withinSomeViewDistance);
         }
 
-        private void onLevelChange(long pos, int distance, boolean oldWithinViewDistance, boolean withinViewDistance) {
+        private void onCombinedPlayerTicketTrackerLevelChange(long pos, int distance, boolean oldWithinViewDistance, boolean withinViewDistance) {
             if (oldWithinViewDistance != withinViewDistance) {
                 Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, DistanceManager.PLAYER_TICKET_LEVEL, new ChunkPos(pos));
 
@@ -727,7 +809,55 @@ public abstract class DistanceManager {
                     }, pos, true));
                 }
             }
+        }
+
+    }
+    // Martijn end - per-player load distance
+
+    private class PlayerTicketTracker extends DistanceManager.FixedPlayerDistanceChunkTracker {
+
+        private int viewDistance = 0;
+        private final Long2IntMap queueLevels = Long2IntMaps.synchronize(new Long2IntOpenHashMap());
+        private final LongSet toUpdate = new LongOpenHashSet();
+
+        protected PlayerTicketTracker(int i) {
+            super(i);
+            this.queueLevels.defaultReturnValue(i + 2);
+        }
+
+        @Override
+        protected void onLevelChange(long pos, int oldDistance, int distance) {
+            this.toUpdate.add(pos);
+        }
+
+        // Martijn start - per-player load distance
+        public void updateViewDistanceByPlayerLoadDistance(ServerPlayer player) {
+            this.updateViewDistanceByOriginalWatchDistance(player.getCachedLoadViewDistance() + 1);
+        }
+
+        public void updateViewDistanceByWorldViewDistance(int worldViewDistance) {
+            this.updateViewDistanceByOriginalWatchDistance(worldViewDistance + 1);
+        }
+
+        private void updateViewDistanceByOriginalWatchDistance(int watchDistance) {
+            // Martijn end - per-player load distance
+            ObjectIterator objectiterator = this.chunks.long2ByteEntrySet().iterator();
+
+            while (objectiterator.hasNext()) {
+                it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry it_unimi_dsi_fastutil_longs_long2bytemap_entry = (it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry) objectiterator.next();
+                byte b0 = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getByteValue();
+                long j = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getLongKey();
+
+                this.onLevelChange(j, b0, this.haveTicketFor(b0), b0 <= watchDistance - 2);
+            }
 
+            this.viewDistance = watchDistance;
+        }
+
+        private void onLevelChange(long pos, int distance, boolean oldWithinViewDistance, boolean withinViewDistance) {
+            if (oldWithinViewDistance != withinViewDistance) {
+                DistanceManager.this.combinedPlayerTicketManager.onSomePlayerTicketTrackerLevelChange(this, pos, distance, oldWithinViewDistance, withinViewDistance); // Martijn - per-player load distance
+            }
         }
 
         @Override
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 9a07ccbd12675e501a9aebf89ab85adf6fb658ba..67b32cef8eeb31fa7c05fcb34abce9366426cdb0 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -948,7 +948,7 @@ public class ServerChunkCache extends ChunkSource {
                     continue;
                 }
 
-                int viewDistance = this.chunkMap.getEffectiveViewDistance();
+                int viewDistance = player.getCachedLoadViewDistance() - 1; // Martijn - per-player load view distance
 
                 // copied and modified from isOutisdeRange
                 int chunkRange = level.spigotConfig.mobSpawnRange;
@@ -1177,7 +1177,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public void setViewDistance(int watchDistance) {
-        this.chunkMap.setViewDistance(watchDistance);
+        this.chunkMap.setWorldViewDistance(watchDistance); // Martijn - per-player view distance
     }
 
     public void setSimulationDistance(int simulationDistance) {
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index ecc30a97d5788f3c33ab79d9c3d1fce52614c96a..ff8721306ad6df68e76e53113a72bd3f0ca5f733 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -18,6 +18,7 @@ import java.util.Optional;
 import java.util.OptionalInt;
 import java.util.Random;
 import java.util.UUID;
+import java.util.function.Supplier;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 
@@ -184,11 +185,286 @@ import org.bukkit.event.player.PlayerPortalEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 import org.bukkit.inventory.MainHand;
+import org.jetbrains.annotations.NotNull;
 // CraftBukkit end
 
 public class ServerPlayer extends Player {
 
-    public final int getViewDistance() { return this.getLevel().getChunkSource().chunkMap.viewDistance - 1; } // Paper - placeholder
+    // Martijn start - per-player view distance
+
+    private final int getWorldSeeViewDistance() { return this.getLevel().getChunkSource().chunkMap.worldViewDistance - 1; } // Paper - placeholder
+
+    private final int getWorldTrackViewDistance() {
+        return getWorldSeeViewDistance();
+    }
+
+    private final int getWorldLoadViewDistance() {
+        return getWorldSeeViewDistance() + 1;
+    }
+
+    private @Nullable Integer lastComputedTrackViewDistance = null;
+    private @Nullable Integer lastComputedSeeViewDistance = null;
+    private @Nullable Integer lastComputedLoadViewDistance = null;
+
+    public final int getCachedTrackViewDistance() {
+        if (this.lastComputedTrackViewDistance != null) return this.lastComputedTrackViewDistance;
+        return this.computeAndCacheTrackViewDistance();
+    }
+
+    private final int computeAndCacheTrackViewDistance() {
+        return this.computeAndCacheTrackViewDistance(null, false);
+    }
+
+    private final int computeAndCacheTrackViewDistance(@Nullable Integer precomputedMaxTrackViewDistanceDueToTotalTrackedChunks, boolean dontUpdateOtherPlayersAfterwards) {
+        int maxTrackViewDistanceDueToTotalTrackedChunks = precomputedMaxTrackViewDistanceDueToTotalTrackedChunks != null ? precomputedMaxTrackViewDistanceDueToTotalTrackedChunks : computeMaxTrackViewDistanceDueToMaxTotalTrackedChunks();
+        @Nullable Integer oldTrackViewDistance = this.lastComputedTrackViewDistance;
+        this.lastComputedTrackViewDistance = this.computeTrackViewDistance(maxTrackViewDistanceDueToTotalTrackedChunks);
+        this.processTrackViewDistanceChange(oldTrackViewDistance, this.lastComputedTrackViewDistance, maxTrackViewDistanceDueToTotalTrackedChunks, dontUpdateOtherPlayersAfterwards);
+        return this.lastComputedTrackViewDistance;
+    }
+
+    private final int computeTrackViewDistance(int assumedMaxTrackViewDistanceDueToTotalTrackedChunks) {
+
+        this.level.timings.getTrackViewDistance.startTiming();
+
+        // Limit by world view distance
+        int trackViewDistance = getWorldTrackViewDistance();
+        // Limit by see view distance
+        trackViewDistance = Math.min(trackViewDistance, this.computeAndCacheSeeViewDistance());
+        if (this.getLevel().paperConfig.getPerPlayerTrackViewDistance()) {
+            // Limit by world max track view distance
+            int levelMaxTrackViewDistance = this.getLevel().paperConfig.getMaxTrackViewDistance();
+            if (levelMaxTrackViewDistance != -1) {
+                trackViewDistance = Math.min(trackViewDistance,levelMaxTrackViewDistance);
+            }
+            // Limit by client view distance
+            if (this.getLevel().paperConfig.getLimitTrackViewDistanceByClientViewDistance()) {
+                if (this.clientViewDistance != null && this.clientViewDistance >= 1) {
+                    trackViewDistance = Math.min(trackViewDistance, this.clientViewDistance);
+                }
+            }
+        }
+        // Limit by max total tracked chunks
+        if (assumedMaxTrackViewDistanceDueToTotalTrackedChunks != -1) {
+            trackViewDistance = Math.min(trackViewDistance, assumedMaxTrackViewDistanceDueToTotalTrackedChunks);
+        }
+        // Clamp to possible values
+        trackViewDistance = Mth.clamp(trackViewDistance, 2, 32);
+
+        this.level.timings.getTrackViewDistance.stopTiming();
+
+        return trackViewDistance;
+
+    }
+
+    public final int getCachedSeeViewDistance() {
+        if (this.lastComputedSeeViewDistance != null) return this.lastComputedSeeViewDistance;
+        return this.computeAndCacheSeeViewDistance();
+    }
+
+    private final int computeAndCacheSeeViewDistance() {
+        return this.computeAndCacheSeeViewDistance(null, false);
+    }
+
+    private final int computeAndCacheSeeViewDistance(@Nullable Integer precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks, boolean dontUpdateOtherPlayersAfterwards) {
+        int maxSeeViewDistanceDueToMaxTotalSeenChunks = precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks != null ? precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks : computeMaxSeeViewDistanceDueToMaxTotalSeenChunks();
+        @Nullable Integer oldSeeViewDistance = this.lastComputedSeeViewDistance;
+        this.lastComputedSeeViewDistance = this.computeSeeViewDistance(maxSeeViewDistanceDueToMaxTotalSeenChunks);
+        this.processSeeViewDistanceChange(oldSeeViewDistance, this.lastComputedSeeViewDistance, maxSeeViewDistanceDueToMaxTotalSeenChunks, dontUpdateOtherPlayersAfterwards);
+        return this.lastComputedSeeViewDistance;
+    }
+
+    private final int computeSeeViewDistance(int assumedMaxSeeViewDistanceDueToMaxTotalSeenChunks) {
+
+        this.level.timings.getSeeViewDistance.startTiming();
+
+        // Limit by world view distance
+        int seeViewDistance = this.getWorldSeeViewDistance();
+        if (this.getLevel().paperConfig.getPerPlayerSeeViewDistance()) {
+            // Limit by world max see view distance
+            int levelMaxSeeViewDistance = this.getLevel().paperConfig.getMaxSeeViewDistance();
+            if (levelMaxSeeViewDistance != -1) {
+                seeViewDistance = Math.min(seeViewDistance, levelMaxSeeViewDistance);
+            }
+            // Limit by client view distance
+            if (this.getLevel().paperConfig.getLimitSeeViewDistanceByClientViewDistance()) {
+                if (this.clientViewDistance != null && this.clientViewDistance >= 1) {
+                    seeViewDistance = Math.min(seeViewDistance, this.clientViewDistance);
+                }
+            }
+        }
+        // Limit by max total seen chunks
+        if (assumedMaxSeeViewDistanceDueToMaxTotalSeenChunks != -1) {
+            seeViewDistance = Math.min(seeViewDistance, assumedMaxSeeViewDistanceDueToMaxTotalSeenChunks);
+        }
+        // Clamp to possible values
+        seeViewDistance = Mth.clamp(seeViewDistance, 2, 32);
+
+        this.level.timings.getSeeViewDistance.stopTiming();
+
+        return seeViewDistance;
+
+    }
+
+    public final int getCachedLoadViewDistance() {
+        if (this.lastComputedLoadViewDistance != null) return this.lastComputedLoadViewDistance;
+        return this.computeAndCacheLoadViewDistance();
+    }
+
+    private final int computeAndCacheLoadViewDistance() {
+        Integer oldLoadViewDistance = this.lastComputedLoadViewDistance;
+        this.lastComputedLoadViewDistance = this.computeLoadViewDistance();
+        processLoadViewDistanceChange(oldLoadViewDistance, this.lastComputedLoadViewDistance);
+        return this.lastComputedLoadViewDistance;
+    }
+
+    private final int computeLoadViewDistance() {
+
+        this.level.timings.getLoadViewDistance.startTiming();
+
+        // Limit by world view distance
+        int loadViewDistance = this.getWorldLoadViewDistance();
+        if (this.getLevel().paperConfig.getPerPlayerLoadViewDistance()) {
+            // Limit by world max load view distance
+            int levelMaxLoadViewDistance = this.getLevel().paperConfig.getMaxLoadViewDistance();
+            if (levelMaxLoadViewDistance != -1) {
+                loadViewDistance = Math.min(loadViewDistance, levelMaxLoadViewDistance);
+            }
+            // Limit by see view distance
+            if (this.getLevel().paperConfig.getLimitLoadViewDistanceBySeeViewDistance()) {
+                loadViewDistance = Math.min(loadViewDistance, this.computeAndCacheSeeViewDistance() + 1);
+            }
+            // Limit by client view distance
+            if (this.getLevel().paperConfig.getLimitLoadViewDistanceByClientViewDistance()) {
+                if (this.clientViewDistance != null && this.clientViewDistance >= 1) {
+                    loadViewDistance = Math.min(loadViewDistance, this.clientViewDistance + 1);
+                }
+            }
+        }
+        // Clamp to possible values
+        loadViewDistance = Mth.clamp(loadViewDistance, 3, 33);
+
+        this.level.timings.getLoadViewDistance.stopTiming();
+
+        return loadViewDistance;
+
+    }
+
+    public void trackViewDistanceMayHaveChanged() {
+        this.trackViewDistanceMayHaveChanged(null, false);
+    }
+
+    public void trackViewDistanceMayHaveChanged(@Nullable Integer precomputedMaxTrackViewDistanceDueToMaxTotalTrackedChunks, boolean dontUpdateOtherPlayersAfterwards) {
+        this.computeAndCacheTrackViewDistance(precomputedMaxTrackViewDistanceDueToMaxTotalTrackedChunks, dontUpdateOtherPlayersAfterwards);
+    }
+
+    /**
+     * @param precomputedMaxTrackViewDistanceDueToMaxTotalTrackedChunks If null, indicates it hasn't been computed; if -1, indicates there is no maximum
+     */
+    private void processTrackViewDistanceChange(@Nullable Integer oldTrackViewDistance, int newTrackViewDistance, int precomputedMaxTrackViewDistanceDueToMaxTotalTrackedChunks, boolean dontUpdateOtherPlayersAfterwards) {
+
+        if (oldTrackViewDistance != null && oldTrackViewDistance == newTrackViewDistance) return;
+
+        this.level.timings.trackViewDistanceMayHaveChanged.startTiming();
+
+        // Update chunk tracking
+        this.getLevel().getChunkSource().chunkMap.updateChunkTrackingDueToPlayerTrackViewDistanceChange(this, oldTrackViewDistance != null ? oldTrackViewDistance : newTrackViewDistance, newTrackViewDistance);
+
+        this.level.timings.trackViewDistanceMayHaveChanged.stopTiming();
+
+        // Update track view distance of other players
+        if (!dontUpdateOtherPlayersAfterwards && precomputedMaxTrackViewDistanceDueToMaxTotalTrackedChunks != -1) {
+            Bukkit.getOnlinePlayers().stream()
+                .map(it -> ((CraftPlayer) it).getHandle())
+                .filter(it -> !it.equals(this))
+                .forEach(it -> it.computeAndCacheTrackViewDistance(precomputedMaxTrackViewDistanceDueToMaxTotalTrackedChunks, true));
+        }
+
+    }
+
+    /**
+     * @return If -1, indicates there is no maximum; otherwise in the range [2, 32]
+     */
+    public static int computeMaxTrackViewDistanceDueToMaxTotalTrackedChunks() {
+        int maxTotalTrackedChunks = PaperConfig.getMaxTotalTrackedChunks();
+        if (maxTotalTrackedChunks == -1) return -1;
+        // Finds the lowest distance that is not possible (or 3 if none are possible, or 33 if all are possible), then subtracts 1 to find the highest distance that is possible (or 2 if none are possible, or 32 if all are posisble)
+        return Mth.binarySearch(3, 33, candidate -> {
+            // Must return whether the candidate is not possible
+            return Bukkit.getOnlinePlayers().stream().mapToInt(it -> ((CraftPlayer) it).getHandle().computeTrackViewDistance(candidate)).map(it -> (it*2+1)*(it*2+1)).sum() > maxTotalTrackedChunks;
+        }) - 1;
+    }
+
+    public void seeViewDistanceMayHaveChanged() {
+        this.seeViewDistanceMayHaveChanged(null, false);
+    }
+
+    public void seeViewDistanceMayHaveChanged(@Nullable Integer precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks, boolean dontUpdateOtherPlayersAfterwards) {
+        this.computeAndCacheSeeViewDistance(precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks, dontUpdateOtherPlayersAfterwards);
+    }
+
+    /**
+     * @param precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks If null, indicates it hasn't been computed; if -1, indicates there is no maximum
+     */
+    private void processSeeViewDistanceChange(@Nullable Integer oldSeeViewDistance, int newSeeViewDistance, int precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks, boolean dontUpdateOtherPlayersAfterwards) {
+
+        if (oldSeeViewDistance != null && oldSeeViewDistance == newSeeViewDistance) return;
+
+        this.level.timings.seeViewDistanceMayHaveChanged.startTiming();
+
+        // Update chunk seeing
+        this.getLevel().getChunkSource().chunkMap.updateChunkSeeingDueToPlayerSeeViewDistanceChange(this, oldSeeViewDistance != null ? oldSeeViewDistance : newSeeViewDistance, newSeeViewDistance);
+
+        this.level.timings.seeViewDistanceMayHaveChanged.stopTiming();
+
+        // Update track view distance
+        this.trackViewDistanceMayHaveChanged();
+        // Update load view distance
+        this.loadViewDistanceMayHaveChanged();
+
+        // Update see view distance of other players
+        if (!dontUpdateOtherPlayersAfterwards && precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks != -1) {
+            Bukkit.getOnlinePlayers().stream()
+                .map(it -> ((CraftPlayer) it).getHandle())
+                .filter(it -> !it.equals(this))
+                .forEach(it -> it.computeAndCacheSeeViewDistance(precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks, true));
+        }
+
+    }
+
+    /**
+     * @return If -1, indicates there is no maximum; otherwise in the range [2, 32]
+     */
+    public static int computeMaxSeeViewDistanceDueToMaxTotalSeenChunks() {
+        int maxTotalSeenChunks = PaperConfig.getMaxTotalSeenChunks();
+        if (maxTotalSeenChunks == -1) return -1;
+        // Finds the lowest distance that is not possible (or 3 if none are possible, or 33 if all are possible), then subtracts 1 to find the highest distance that is possible (or 2 if none are possible, or 32 if all are posisble)
+        return Mth.binarySearch(3, 33, candidate -> {
+            // Must return whether the candidate is not possible
+            return Bukkit.getOnlinePlayers().stream().mapToInt(it -> ((CraftPlayer) it).getHandle().computeSeeViewDistance(candidate)).map(it -> (it*2+1)*(it*2+1)).sum() > maxTotalSeenChunks;
+        }) - 1;
+    }
+
+    public void loadViewDistanceMayHaveChanged() {
+        computeAndCacheLoadViewDistance();
+    }
+
+    private void processLoadViewDistanceChange(@Nullable Integer oldLoadViewDistance, int newLoadViewDistance) {
+
+        if (oldLoadViewDistance != null && oldLoadViewDistance == newLoadViewDistance) return;
+
+        this.level.timings.loadViewDistanceMayHaveChanged.startTiming();
+
+        // Update player chunk load tickets
+        if (this.getLevel().paperConfig.getPerPlayerLoadViewDistance()) {
+            this.getLevel().getChunkSource().chunkMap.distanceManager.updatePlayerTicketsByPlayerLoadDistance(this);
+        }
+
+        this.level.timings.loadViewDistanceMayHaveChanged.stopTiming();
+
+    }
+
+    // Martijn end - per-player view distance
 
     private static final Logger LOGGER = LogManager.getLogger();
     public long lastSave = MinecraftServer.currentTick; // Paper
@@ -1992,6 +2268,11 @@ public class ServerPlayer extends Player {
         this.connection.connection.channel.attr(PaperAdventure.LOCALE_ATTRIBUTE).set(this.adventure$locale);
         // Paper end
         this.clientViewDistance = packet.viewDistance;
+        // Martijn start - per-player view distance
+        trackViewDistanceMayHaveChanged();
+        seeViewDistanceMayHaveChanged();
+        loadViewDistanceMayHaveChanged();
+        // Martijn end - per-player view distance
         // CraftBukkit end
         this.chatVisibility = packet.chatVisibility();
         this.canChatColor = packet.chatColors();
@@ -2251,27 +2532,102 @@ public class ServerPlayer extends Player {
 
     }
 
-    public void trackChunk(ChunkPos chunkPos, Packet<?> chunkDataPacket) {
+    // Martijn start - per-player track and see view distance
+
+    public void trackOrSeeChunk(LevelChunk chunk, Packet<?> chunkDataPacket, boolean concernsTracking) {
+
         this.connection.send(chunkDataPacket);
+
         // Paper start
-        if(io.papermc.paper.event.packet.PlayerChunkLoadEvent.getHandlerList().getRegisteredListeners().length > 0){
-            new io.papermc.paper.event.packet.PlayerChunkLoadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+        if (concernsTracking) {
+            if (io.papermc.paper.event.packet.PlayerChunkLoadEvent.getHandlerList().getRegisteredListeners().length > 0) {
+                new io.papermc.paper.event.packet.PlayerChunkLoadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunk.getPos().longKey), this.getBukkitEntity()).callEvent();
+            }
         }
         // Paper end
+
+        if (concernsTracking) {
+
+            // The following used to be the tail of ChunkMap.playerLoadedChunk, after the call to ServerPlayer.trackChunk
+
+            DebugPackets.sendPoiPacketsForChunk(getLevel(), chunk.getPos());
+            List<Entity> list = Lists.newArrayList();
+            List<Entity> list1 = Lists.newArrayList();
+            // Paper start - optimise entity tracker
+            // use the chunk entity list, not the whole trackedEntities map...
+            Entity[] entities = chunk.entities.getRawData();
+            for (int i = 0, size = chunk.entities.size(); i < size; ++i) {
+                Entity entity = entities[i];
+                if (entity == this) {
+                    continue;
+                }
+                ChunkMap.TrackedEntity tracker = this.getLevel().getChunkSource().chunkMap.entityMap.get(entity.getId());
+                if (tracker != null) { // dumb plugins... move on...
+                    tracker.updatePlayer(this);
+                }
+
+                // keep the vanilla logic here - this is REQUIRED or else passengers and their vehicles disappear!
+                // (and god knows what the leash thing is)
+
+                if (entity instanceof Mob && ((Mob) entity).getLeashHolder() != null) {
+                    list.add(entity);
+                }
+
+                if (!entity.getPassengers().isEmpty()) {
+                    list1.add(entity);
+                }
+            }
+            // Paper end - optimise entity tracker
+
+            Iterator iterator;
+            Entity entity1;
+
+            if (!list.isEmpty()) {
+                iterator = list.iterator();
+
+                while (iterator.hasNext()) {
+                    entity1 = (Entity) iterator.next();
+                    connection.send(new ClientboundSetEntityLinkPacket(entity1, ((Mob) entity1).getLeashHolder()));
+                }
+            }
+
+            if (!list1.isEmpty()) {
+                iterator = list1.iterator();
+
+                while (iterator.hasNext()) {
+                    entity1 = (Entity) iterator.next();
+                    connection.send(new ClientboundSetPassengersPacket(entity1));
+                }
+            }
+
+        }
     }
 
-    public void untrackChunk(ChunkPos chunkPos) {
+    public void untrackOrUnseeChunk(ChunkPos chunkPos, boolean concernsTracking) {
+
         if (this.isAlive()) {
-            this.connection.send(new ClientboundForgetLevelChunkPacket(chunkPos.x, chunkPos.z));
-            // Paper start
-            if(io.papermc.paper.event.packet.PlayerChunkUnloadEvent.getHandlerList().getRegisteredListeners().length > 0){
-                new io.papermc.paper.event.packet.PlayerChunkUnloadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+            if (!concernsTracking) {
+                this.connection.send(new ClientboundForgetLevelChunkPacket(chunkPos.x, chunkPos.z));
+            }
+            if (concernsTracking) {
+                // Paper start
+                if (io.papermc.paper.event.packet.PlayerChunkUnloadEvent.getHandlerList().getRegisteredListeners().length > 0) {
+                    new io.papermc.paper.event.packet.PlayerChunkUnloadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+                }
+                // Paper end
             }
-            // Paper end
         }
 
     }
 
+    public ClientboundLevelChunkWithLightPacket getClientboundChunkInitializationPacket(LevelChunk chunk) {
+        boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(this, chunk);
+        ChunkMap chunkMap = this.getLevel().getChunkSource().chunkMap;
+        return new ClientboundLevelChunkWithLightPacket(chunk, chunkMap.lightEngine, (BitSet) null, (BitSet) null, true, shouldModify);
+    }
+
+    // Martijn end - per-player track and see view distance
+
     public SectionPos getLastSectionPos() {
         return this.lastSectionPos;
     }
diff --git a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
index e17a3afa41fd628d2c4a3637ae19418e258a99b8..8c30bfff85ec076b580325347643225d8320b284 100644
--- a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
+++ b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
@@ -1,5 +1,6 @@
 package net.minecraft.world.entity.boss.enderdragon;
 
+import com.destroystokyo.paper.PaperConfig;
 import com.google.common.collect.Lists;
 import java.util.Iterator;
 import java.util.List;
@@ -647,7 +648,7 @@ public class EnderDragon extends Mob implements Enemy {
                 // this.world.b(1028, this.getChunkCoordinates(), 0);
                 //int viewDistance = ((WorldServer) this.world).getServer().getViewDistance() * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
                 for (net.minecraft.server.level.ServerPlayer player : (List<net.minecraft.server.level.ServerPlayer>) ((ServerLevel)level).players()) {
-                    final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
+                    final int viewDistance = PaperConfig.sendEnderDragonSpawnSoundToPlayersWhoAreSeeingButNotTracking ? player.getCachedSeeViewDistance() : player.getCachedTrackViewDistance(); // TODO apply view distance api patch // Martijn - per-player track and see view distance
                     double deltaX = this.getX() - player.getX();
                     double deltaZ = this.getZ() - player.getZ();
                     double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
index ede0ced64d74d71547d1b8bb6853c5aacc1b486a..b36a6a5cf460e6a29df07857d276c664ae94993d 100644
--- a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
+++ b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
@@ -1,5 +1,6 @@
 package net.minecraft.world.entity.boss.wither;
 
+import com.destroystokyo.paper.PaperConfig;
 import com.google.common.collect.ImmutableList;
 import java.util.EnumSet;
 import java.util.List;
@@ -279,7 +280,7 @@ public class WitherBoss extends Monster implements PowerableMob, RangedAttackMob
                     // this.world.globalLevelEvent(1023, new BlockPosition(this), 0);
                     //int viewDistance = ((ServerLevel) this.level).getCraftServer().getViewDistance() * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
                     for (ServerPlayer player : (List<ServerPlayer>)this.level.players()) { // Paper
-                        final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
+                        final int viewDistance = PaperConfig.sendWitherSpawnSoundToPlayersWhoAreSeeingButNotTracking ? player.getCachedSeeViewDistance() : player.getCachedTrackViewDistance(); // TODO apply view distance api patch // Martijn - per-player track and see view distance
                         double deltaX = this.getX() - player.getX();
                         double deltaZ = this.getZ() - player.getZ();
                         double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 5fb475b3ccaa98861e2c817b37cd1740e5bfed8d..66d2e1dd2022b4d819165e4d19bdcd8788d075a4 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -1,5 +1,6 @@
 package org.bukkit.craftbukkit;
 
+import com.destroystokyo.paper.PaperConfig;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
@@ -465,7 +466,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
         playerChunk.getTickingChunkFuture().thenAccept(either -> {
             either.left().ifPresent(chunk -> {
-                List<ServerPlayer> playersInRange = playerChunk.playerProvider.getPlayers(playerChunk.getPos(), false);
+                List<ServerPlayer> playersInRange = playerChunk.playerProvider.getPlayersNearChunkForSending(playerChunk.getPos(), false, !PaperConfig.sendChunkRefreshToPlayersWhoAreSeeingButNotTracking); // Martijn - per-player track and see view distance
                 if (playersInRange.isEmpty()) return;
 
                 ClientboundLevelChunkWithLightPacket refreshPacket = new ClientboundLevelChunkWithLightPacket(chunk, this.world.getLightEngine(), null, null, true);
