From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Sat, 2 Jul 2022 14:34:49 +0200
Subject: [PATCH] Fix custom block breaking speed


diff --git a/src/main/java/net/minecraft/core/MappedRegistry.java b/src/main/java/net/minecraft/core/MappedRegistry.java
index 16c37e5f8af31c366286254b210439082cc418dc..f066d1fb63c89127badef69c59e978b5a8316a39 100644
--- a/src/main/java/net/minecraft/core/MappedRegistry.java
+++ b/src/main/java/net/minecraft/core/MappedRegistry.java
@@ -35,9 +35,11 @@ import net.minecraft.tags.TagKey;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.level.biome.Biome;
 import net.minecraft.world.level.biome.Biomes;
+import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.levelgen.structure.Structure;
 import nl.martijnmuijsers.paper.biome.SuCraftBiomeTags;
 import nl.martijnmuijsers.paper.biome.SuCraftBiomeTagsProvider;
+import nl.martijnmuijsers.paper.block.SuCraftBlockTagsProvider;
 import nl.martijnmuijsers.paper.data.SuCraftTagsProvider;
 import nl.martijnmuijsers.paper.structure.SuCraftBuiltinStructures;
 import nl.martijnmuijsers.paper.structure.SuCraftStructureTagsProvider;
@@ -394,6 +396,8 @@ public class MappedRegistry<T> extends WritableRegistry<T> {
             tagEntries = ((SuCraftTagsProvider<T>) new SuCraftStructureTagsProvider((Registry<Structure>) this)).run(tagEntries);
         } else if (this.key().equals(BIOME_REGISTRY)) {
             tagEntries = ((SuCraftTagsProvider<T>) new SuCraftBiomeTagsProvider((Registry<Biome>) this)).run(tagEntries);
+        } else if (this.key().equals(BLOCK_REGISTRY)) {
+            tagEntries = ((SuCraftTagsProvider<T>) new SuCraftBlockTagsProvider((Registry<Block>) this)).run(tagEntries);
         }
         // Martijn end - custom resource
         tagEntries.forEach((tag, entries) -> {
diff --git a/src/main/java/net/minecraft/network/Connection.java b/src/main/java/net/minecraft/network/Connection.java
index 77cce6fa31a1e7fb252e02051a78bba11b6c4bf2..557628d0677de5b6cf1f4e2008ddea0dcdd72f1b 100644
--- a/src/main/java/net/minecraft/network/Connection.java
+++ b/src/main/java/net/minecraft/network/Connection.java
@@ -41,9 +41,13 @@ import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.game.ClientboundBlockChangedAckPacket;
+import net.minecraft.network.protocol.game.ClientboundBlockDestructionPacket;
+import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundContainerSetContentPacket;
 import net.minecraft.network.protocol.game.ClientboundContainerSetSlotPacket;
 import net.minecraft.network.protocol.game.ClientboundDisconnectPacket;
+import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
 import net.minecraft.network.protocol.login.ClientboundLoginDisconnectPacket;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.RunningOnDifferentThreadException;
@@ -436,6 +440,15 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         this.writePacket(packet, callback, Boolean.TRUE);
     }
     private void writePacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback, Boolean flushConditional) {
+        if (packet instanceof ClientboundBlockChangedAckPacket ackPacket) {
+            LOGGER.info("TEMP DEBUG - send ack " + ackPacket.sequence());
+        } else if (packet instanceof ClientboundBlockDestructionPacket destructionPacket) {
+            LOGGER.info("TEMP DEBUG - send destruction " + destructionPacket.getProgress() + " @ " + destructionPacket.getPos());
+        } else if (packet instanceof ClientboundBlockUpdatePacket blockUpdatePacket) {
+            LOGGER.info("TEMP DEBUG - send update " + blockUpdatePacket.getBlockState() + " @ " + blockUpdatePacket.getPos());
+        } else if (packet instanceof ClientboundSectionBlocksUpdatePacket sectionUpdatePacket) {
+            LOGGER.info("TEMP DEBUG - send section update, with suppress light updates: " + sectionUpdatePacket.shouldSuppressLightUpdates());
+        }
         this.packetWrites.getAndIncrement(); // must be befeore using canFlush
         boolean effectiveFlush = flushConditional == null ? this.canFlush : flushConditional.booleanValue();
         // Martijn start - more packets without delay
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
index 7123b7a821e2b3b75701976ed5382f4f3aaecfda..ffb196dec74ff8c06fcda94227c3f3fe3661b0c6 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
@@ -322,9 +322,11 @@ public class ServerPlayerGameMode {
                     if (!iblockdata.isAir()) {
                         float f1 = iblockdata.getDestroyProgress(this.player, this.player.level, pos) * (float) (l + 1);
 
+                        LOGGER.info("TEMP DEBUG - broken amount is: " + f1 + " , based on progress " + iblockdata.getDestroyProgress(this.player, this.player.level, pos) + " * time taken " + (float) (l + 1));
                         if (f1 >= 0.7F) {
                             this.isDestroyingBlock = false;
                             this.level.destroyBlockProgress(this.player.getId(), pos, -1);
+                            LOGGER.info("TEMP DEBUG - going to destroyAndAck for sequence " + sequence);
                             this.destroyAndAck(pos, sequence, "destroyed");
                             return;
                         }
@@ -362,8 +364,10 @@ public class ServerPlayerGameMode {
 
     public void destroyAndAck(BlockPos pos, int sequence, String reason) {
         if (this.destroyBlock(pos)) {
+            LOGGER.info("TEMP DEBUG - it was a destroy");
             this.debugLogging(pos, true, sequence, reason);
         } else {
+            LOGGER.info("TEMP DEBUG - sending update block");
             this.player.connection.send(new ClientboundBlockUpdatePacket(pos, this.level.getBlockState(pos)));
             this.debugLogging(pos, false, sequence, reason);
         }
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 96c59ed95385a41c9133dfbec170291d65283172..d698d0fa688c5a38a494c186e044b8258a1d6acb 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -1732,6 +1732,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
 
     @Override
     public void handlePlayerAction(ServerboundPlayerActionPacket packet) {
+        LOGGER.info("TEMP DEBUG - receive player action " + packet.getSequence() + " : " + packet.getAction() + " @ " + packet.getPos() + " -> " + packet.getDirection());
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.getLevel());
         if (this.player.isImmobile()) return; // CraftBukkit
         BlockPos blockposition = packet.getPos();
@@ -1806,7 +1807,9 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
                     return;
                 }
                 // Paper end - Don't allow digging in unloaded chunks
+                LOGGER.info("TEMP DEBUG - going to handle block break action");
                 this.player.gameMode.handleBlockBreakAction(blockposition, packetplayinblockdig_enumplayerdigtype, packet.getDirection(), this.player.level.getMaxBuildHeight(), packet.getSequence());
+                LOGGER.info("TEMP DEBUG - going to acc block changes up to " + packet.getSequence() + " after block break action handle");
                 this.player.connection.ackBlockChangesUpTo(packet.getSequence());
                 return;
             default:
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index 16f74e2a118803e64a3156fb6a894c558c6adde7..3ac535cb961e803edcaf737ac3db390d69188f47 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -39,6 +39,7 @@ import net.minecraft.network.syncher.EntityDataAccessor;
 import net.minecraft.network.syncher.EntityDataSerializers;
 import net.minecraft.network.syncher.SynchedEntityData;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.sounds.SoundEvent;
@@ -852,6 +853,15 @@ public abstract class Player extends LivingEntity {
         return !state.requiresCorrectToolForDrops() || this.inventory.getSelected().isCorrectToolForDrops(state);
     }
 
+    // Martijn start - custom blocks and items
+
+    public boolean hasCorrectToolForFasterBreaking(BlockState state) {
+        MinecraftServer.LOGGER.info("TEMP DEBUG - checking if " + getName() + " has correct tool for faster breaking " + state);
+        return hasCorrectToolForDrops(state) || !state.requiresCorrectToolForFasterBreaking(true) || this.inventory.getSelected().isCorrectToolForFasterBreaking(state, true);
+    }
+
+    // Martijn end - custom blocks and items
+
     @Override
     public void readAdditionalSaveData(CompoundTag nbt) {
         super.readAdditionalSaveData(nbt);
diff --git a/src/main/java/net/minecraft/world/item/ItemStack.java b/src/main/java/net/minecraft/world/item/ItemStack.java
index 6b3cfc19c4fd1382ddf534265a1114995a4f6b55..326e8b6b2f9274329d2fd073d4223740bec0cd12 100644
--- a/src/main/java/net/minecraft/world/item/ItemStack.java
+++ b/src/main/java/net/minecraft/world/item/ItemStack.java
@@ -669,6 +669,29 @@ public final class ItemStack {
         return this.getItem().isCorrectToolForDrops(state);
     }
 
+    // Martijn start - custom blocks and items
+
+    public boolean isCorrectToolForFasterBreaking(net.minecraft.world.level.block.state.BlockState state, boolean doPlayerObservableLookups) {
+        MinecraftServer.LOGGER.info("TEMP DEBUG - checking if " + getItem() + " is correct tool for faster breaking " + state);
+        if (this.isCorrectToolForDrops(state)) {
+            return true;
+        }
+        if (doPlayerObservableLookups) {
+            MinecraftServer.LOGGER.info("TEMP DEBUG - alternatives to check are: " + Block.realStateToPlayerObservableStates[Block.BLOCK_STATE_REGISTRY.getId(state)]);
+            for (int playerObservableStateId : Block.realStateToPlayerObservableStates[Block.BLOCK_STATE_REGISTRY.getId(state)]) {
+                net.minecraft.world.level.block.state.BlockState playerObservableState = Block.BLOCK_STATE_REGISTRY.byId(playerObservableStateId);
+                MinecraftServer.LOGGER.info("TEMP DEBUG - checking " + playerObservableState);
+                if (this.isCorrectToolForFasterBreaking(playerObservableState, false)) {
+                    MinecraftServer.LOGGER.info("TEMP DEBUG - now we got it");
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    // Martijn end - custom blocks and items
+
     public InteractionResult interactLivingEntity(net.minecraft.world.entity.player.Player user, LivingEntity entity, InteractionHand hand) {
         return this.getItem().interactLivingEntity(this, user, entity, hand);
     }
diff --git a/src/main/java/net/minecraft/world/item/Items.java b/src/main/java/net/minecraft/world/item/Items.java
index fa7dfe52155bf93e60f28d8af1b33961cb97f2e2..999155078a13a755e88cdfef47539e99d658e40e 100644
--- a/src/main/java/net/minecraft/world/item/Items.java
+++ b/src/main/java/net/minecraft/world/item/Items.java
@@ -15,6 +15,7 @@ import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.material.Fluids;
 import nl.martijnmuijsers.paper.item.SuCraftItems;
+import nl.martijnmuijsers.paper.resourcepack.httpserver.ResourcePackHTTPServer;
 import nl.martijnmuijsers.paper.resourcepack.sucraft.CreateSuCraftResourcePack;
 
 public class Items {
@@ -1227,8 +1228,10 @@ public class Items {
         ECHO_SHARD.asItem();
         // Then bootstrap SuCraftItems
         SuCraftItems.bootstrap();
-        // This is the a reasonable time to create the resource pack
+        // This is a reasonable time to create the resource pack
         CreateSuCraftResourcePack.createAndWrite();
+        // Start the HTTP server that serves the resource pack
+        ResourcePackHTTPServer.getInstance().startIfNotStarted();
     }
 
     // Martijn end - custom blocks and items
diff --git a/src/main/java/net/minecraft/world/level/block/Block.java b/src/main/java/net/minecraft/world/level/block/Block.java
index 6cc6ae1059f2ca410ba5bbe2cd766dac932a65f6..d120c5003e4d2fbe3d87952a8d92e222605022b6 100644
--- a/src/main/java/net/minecraft/world/level/block/Block.java
+++ b/src/main/java/net/minecraft/world/level/block/Block.java
@@ -75,6 +75,20 @@ public class Block extends BlockBehaviour implements ItemLike {
     public static final IdMapper<BlockState> BLOCK_STATE_REGISTRY_VANILLA = new IdMapper<>();
     public static int[] stateIdReplacementArrayWithResourcePack;
     public static int[] stateIdReplacementArrayWithoutResourcePack;
+    public static int[][] realStateToPlayerObservableStates;
+    public static void addRealStateToPlayerObservableStates(int realState, int playerObservableState) {
+        int[] existingPlayerObservableStates = realStateToPlayerObservableStates[realState];
+        for (int i = 0; i < existingPlayerObservableStates.length; i++) {
+            if (existingPlayerObservableStates[i] == playerObservableState) {
+                // Already present in the array
+                return;
+            }
+        }
+        int[] newPlayerObservableStates = new int[existingPlayerObservableStates.length + 1];
+        System.arraycopy(existingPlayerObservableStates, 0, newPlayerObservableStates, 0, existingPlayerObservableStates.length);
+        newPlayerObservableStates[existingPlayerObservableStates.length] = playerObservableState;
+        realStateToPlayerObservableStates[realState] = newPlayerObservableStates;
+    }
     // Martijn end - custom blocks and items
     private static final LoadingCache<VoxelShape, Boolean> SHAPE_FULL_BLOCK_CACHE = CacheBuilder.newBuilder().maximumSize(512L).weakKeys().build(new CacheLoader<VoxelShape, Boolean>() {
         public Boolean load(VoxelShape voxelshape) {
@@ -656,4 +670,14 @@ public class Block extends BlockBehaviour implements ItemLike {
             return i;
         }
     }
+
+    // Martijn start - custom blocks and items
+
+    public void updateDestroyTime(float destroyTime) {
+        this.properties.destroyTime(destroyTime);
+        this.getStateDefinition().getPossibleStates().forEach(state -> state.destroySpeed = destroyTime);
+    }
+
+    // Martijn end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/world/level/block/Blocks.java b/src/main/java/net/minecraft/world/level/block/Blocks.java
index 80c812ed5ae6e7099000457625af916245e5b221..065eca1a740d25c060a963ecdd5a56cc3ca73e45 100644
--- a/src/main/java/net/minecraft/world/level/block/Blocks.java
+++ b/src/main/java/net/minecraft/world/level/block/Blocks.java
@@ -1201,7 +1201,9 @@ public class Blocks {
 
             block.getLootTable();
         }
+
         // Martijn start - custom blocks and items
+
         // Initialize the global state replacement arrays so we can populate them
         Block.stateIdReplacementArrayWithResourcePack = new int[Block.BLOCK_STATE_REGISTRY.size()];
         Block.stateIdReplacementArrayWithoutResourcePack = new int[Block.BLOCK_STATE_REGISTRY.size()];
@@ -1210,12 +1212,18 @@ public class Blocks {
             Block.stateIdReplacementArrayWithResourcePack[id] = id;
             Block.stateIdReplacementArrayWithoutResourcePack[id] = id;
         }
+        // Initialize the global real state to observable states arrays with empty arrays
+        Block.realStateToPlayerObservableStates = new int[Block.BLOCK_STATE_REGISTRY.size()][];
+        for (int id = 0; id < Block.BLOCK_STATE_REGISTRY.size(); id++) {
+            Block.realStateToPlayerObservableStates[id] = new int[0];
+        }
         // Then overwrite them where necessary with all the needed replacements
         for (Block block : Registry.BLOCK) {
             if (block.replacementRule != null) {
                 block.replacementRule.writeToStateIdReplacementArrays();
             }
         }
+
         // Martijn end - custom blocks and items
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
index 2f69f56e4573b60c4c84bda549130841e2d1f562..fb0100178c1d1ae040647eaf6eeb923293bafd5e 100644
--- a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
+++ b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
@@ -18,6 +18,7 @@ import net.minecraft.core.HolderSet;
 import net.minecraft.core.Registry;
 import net.minecraft.network.protocol.game.DebugPackets;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.tags.FluidTags;
 import net.minecraft.tags.TagKey;
@@ -366,11 +367,14 @@ public abstract class BlockBehaviour {
     public float getDestroyProgress(BlockState state, Player player, BlockGetter world, BlockPos pos) {
 
         float f = state.getDestroySpeed(world, pos);
+        MinecraftServer.LOGGER.info("TEMP DEBUG - getting destroy progress of state " + state + " @ " + pos + " in " + world + " by " + player.getName() + " : destroy speed is " + f);
 
         if (f == -1.0F) {
+            MinecraftServer.LOGGER.info("TEMP DEBUG - returning naught");
             return 0.0F;
         } else {
-            int i = player.hasCorrectToolForDrops(state) ? 30 : 100;
+            int i = player.hasCorrectToolForFasterBreaking(state) ? 30 : 100; // Martijn - custom blocks and items
+            MinecraftServer.LOGGER.info("TEMP DEBUG - has correct tool = " + player.hasCorrectToolForFasterBreaking(state) + " so i = " + i + " and result will be " + player.getDestroySpeed(state) / f / (float) i + " which is based on player destroy speed = " + player.getDestroySpeed(state));
 
             return player.getDestroySpeed(state) / f / (float) i;
         }
@@ -693,7 +697,7 @@ public abstract class BlockBehaviour {
         private final boolean isAir;
         private final Material material;
         private final MaterialColor materialColor;
-        public final float destroySpeed;
+        public float destroySpeed; // Martijn - custom blocks and items
         private final boolean requiresCorrectToolForDrops;
         private final boolean canOcclude;
 
@@ -1185,6 +1189,29 @@ public abstract class BlockBehaviour {
             return this.requiresCorrectToolForDrops;
         }
 
+        // Martijn start - custom blocks and items
+
+        public boolean requiresCorrectToolForFasterBreaking(boolean doPlayerObservableLookups) {
+            MinecraftServer.LOGGER.info("TEMP DEBUG - checking if " + this + " requires correct tool for faster breaking");
+            if (!this.requiresCorrectToolForDrops()) {
+                return false;
+            }
+            if (doPlayerObservableLookups) {
+                MinecraftServer.LOGGER.info("TEMP DEBUG - alternatives to check are: " + Block.realStateToPlayerObservableStates[Block.BLOCK_STATE_REGISTRY.getId(this.asState())]);
+                for (int playerObservableStateId : Block.realStateToPlayerObservableStates[Block.BLOCK_STATE_REGISTRY.getId(this.asState())]) {
+                    net.minecraft.world.level.block.state.BlockState playerObservableState = Block.BLOCK_STATE_REGISTRY.byId(playerObservableStateId);
+                    MinecraftServer.LOGGER.info("TEMP DEBUG - checking " + playerObservableState);
+                    if (!playerObservableState.requiresCorrectToolForFasterBreaking(false)) {
+                        MinecraftServer.LOGGER.info("TEMP DEBUG - now we got it");
+                        return false;
+                    }
+                }
+            }
+            return true;
+        }
+
+        // Martijn end - custom blocks and items
+
         public BlockBehaviour.OffsetType getOffsetType() {
             return this.offsetType;
         }
diff --git a/src/main/java/nl/martijnmuijsers/paper/biome/SuCraftBiomeTagsProvider.java b/src/main/java/nl/martijnmuijsers/paper/biome/SuCraftBiomeTagsProvider.java
index 347f0b29fbe89eaab83692e3991aa19752c0e8fd..01c9d12bc884e60a69ade60cfa8be985c7964b72 100644
--- a/src/main/java/nl/martijnmuijsers/paper/biome/SuCraftBiomeTagsProvider.java
+++ b/src/main/java/nl/martijnmuijsers/paper/biome/SuCraftBiomeTagsProvider.java
@@ -2,12 +2,17 @@
 
 package nl.martijnmuijsers.paper.biome;
 
+import net.minecraft.core.Holder;
 import net.minecraft.core.Registry;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.tags.TagKey;
 import net.minecraft.world.level.biome.Biome;
 import nl.martijnmuijsers.paper.data.SuCraftTagsProvider;
 import net.minecraft.world.level.biome.Biomes;
 
+import java.util.List;
+import java.util.Map;
+
 /**
  * Based on {@link net.minecraft.data.tags.BiomeTagsProvider}
  */
@@ -18,7 +23,7 @@ public class SuCraftBiomeTagsProvider extends SuCraftTagsProvider<Biome> {
     }
 
     @Override
-    protected void addTags() {
+    protected void addTags(Map<TagKey<Biome>, List<Holder<Biome>>> existingRegistryTagEntries) {
         MinecraftServer.LOGGER.info("Adding custom biome tags...");
         this.tag(SuCraftBiomeTags.HAS_STRONGHOLD_SURFACE).add(Biomes.PLAINS).add(Biomes.SUNFLOWER_PLAINS).add(Biomes.SNOWY_PLAINS).add(Biomes.ICE_SPIKES).add(Biomes.DESERT).add(Biomes.FOREST).add(Biomes.FLOWER_FOREST).add(Biomes.BIRCH_FOREST).add(Biomes.DARK_FOREST).add(Biomes.OLD_GROWTH_BIRCH_FOREST).add(Biomes.OLD_GROWTH_PINE_TAIGA).add(Biomes.OLD_GROWTH_SPRUCE_TAIGA).add(Biomes.TAIGA).add(Biomes.SNOWY_TAIGA).add(Biomes.SAVANNA).add(Biomes.SAVANNA_PLATEAU).add(Biomes.WINDSWEPT_HILLS).add(Biomes.WINDSWEPT_GRAVELLY_HILLS).add(Biomes.WINDSWEPT_FOREST).add(Biomes.WINDSWEPT_SAVANNA).add(Biomes.JUNGLE).add(Biomes.SPARSE_JUNGLE).add(Biomes.BAMBOO_JUNGLE).add(Biomes.BADLANDS).add(Biomes.ERODED_BADLANDS).add(Biomes.WOODED_BADLANDS).add(Biomes.MEADOW).add(Biomes.GROVE).add(Biomes.SNOWY_SLOPES).add(Biomes.FROZEN_PEAKS).add(Biomes.JAGGED_PEAKS).add(Biomes.STONY_PEAKS).add(Biomes.MUSHROOM_FIELDS); // Martijn - custom strongholds - surface strongholds
     }
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/BlockReplacementRule.java b/src/main/java/nl/martijnmuijsers/paper/block/BlockReplacementRule.java
index ecf2ed96a5a55dcf328b03db19fe94cdb085405a..d4743a096630929c3d3c96cf2a1a4c4857973776 100644
--- a/src/main/java/nl/martijnmuijsers/paper/block/BlockReplacementRule.java
+++ b/src/main/java/nl/martijnmuijsers/paper/block/BlockReplacementRule.java
@@ -24,6 +24,8 @@ import java.util.Collections;
 import java.util.Set;
 import java.util.function.Function;
 import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 
 public interface BlockReplacementRule {
 
@@ -63,6 +65,20 @@ public interface BlockReplacementRule {
 
     @Nullable Item getHostReplacingItemReplacement(@NotNull Item item);
 
+    /**
+     * All blocks that serve as a host or fallback, without duplicates
+     */
+    @NotNull Iterable<@NotNull Block> getHostAndFallbackBlocks();
+
+    /**
+     * All blocks that may potentially be observed as another block
+     * <br>
+     * Represented by an iterable of pairs, where each pair holds first a block type that may be presented as something different when sent, and second the block type that can be observed by the user instead of the first block
+     * <br>
+     * Contains no duplicates, and contains no pairs where the first and second element are equal
+     */
+    @NotNull Iterable<@NotNull Pair<@NotNull Block, @NotNull Block>> getPotentialObservationReplacements();
+
     @Nullable Model getModelForStatePlacedByItem();
 
     void writeToStateIdReplacementArrays();
@@ -70,12 +86,12 @@ public interface BlockReplacementRule {
     void addToResourcePack(@NotNull MutableResourcePack resourcePack);
 
     default void updateMinDestroyTimes() {
-        updateMinDestroyTimeOfReal(); // Some will see it as the host, others as the fallback
-        updateMinDestroyTimeOfHost(); // Some may see it as the host replacement
+        this.updateMinDestroyTimeOfReal(); // Some will see it as the host, others as the fallback
+        this.updateMinDestroyTimeOfHost(); // Some may see it as the host replacement
     }
 
     default void updateMinDestroyTimeOfReal() {
-        getReal().properties.destroyTime(Math.min(
+        this.getReal().updateDestroyTime(Math.min(
             getReal().properties.destroyTime,
             getMinDestroyTimeOfHostAndFallback()
         ));
@@ -375,6 +391,16 @@ public interface BlockReplacementRule {
             return null;
         }
 
+        @Override
+        public @NotNull Iterable<@NotNull Block> getHostAndFallbackBlocks() {
+            return Set.of(this.host.getBlock(), this.fallback.getBlock());
+        }
+
+        @Override
+        public @NotNull Iterable<@NotNull Pair<@NotNull Block, @NotNull Block>> getPotentialObservationReplacements() {
+            return Stream.of(Pair.of(this.real, this.host.getBlock()), Pair.of(this.host.getBlock(), this.hostReplacement.getBlock()), Pair.of(this.real, this.fallback.getBlock())).filter(pair -> !pair.left().equals(pair.right())).collect(Collectors.toSet());
+        }
+
         @Override
         public @Nullable Model getModelForStatePlacedByItem() {
             return this.model;
@@ -382,7 +408,7 @@ public interface BlockReplacementRule {
 
         @Override
         public void updateMinDestroyTimeOfHost() {
-            this.host.getBlock().properties.destroyTime(this.getMinDestroyTimeOfHostAndHostReplacement());
+            this.host.getBlock().updateDestroyTime(this.getMinDestroyTimeOfHostAndHostReplacement());
         }
 
         @Override
@@ -410,6 +436,9 @@ public interface BlockReplacementRule {
             Block.stateIdReplacementArrayWithResourcePack[realId] = hostId;
             Block.stateIdReplacementArrayWithResourcePack[hostId] = hostReplacementId;
             Block.stateIdReplacementArrayWithoutResourcePack[realId] = fallbackId;
+            Block.addRealStateToPlayerObservableStates(realId, hostId);
+            Block.addRealStateToPlayerObservableStates(hostId, hostReplacementId);
+            Block.addRealStateToPlayerObservableStates(realId, fallbackId);
         }
 
         @Override
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlockTagsProvider.java b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlockTagsProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..8c2229684bfb259fdf57ca17339563c7f0a936cc
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlockTagsProvider.java
@@ -0,0 +1,53 @@
+// Martijn - custom resources
+
+package nl.martijnmuijsers.paper.block;
+
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.core.Holder;
+import net.minecraft.core.Registry;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.tags.TagKey;
+import net.minecraft.world.level.block.Block;
+import nl.martijnmuijsers.paper.data.SuCraftTagsProvider;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Based on {@link net.minecraft.data.tags.BlockTagsProvider}
+ */
+public class SuCraftBlockTagsProvider extends SuCraftTagsProvider<Block> {
+
+    public SuCraftBlockTagsProvider(Registry<Block> registry) {
+        super(registry);
+    }
+
+    @Override
+    protected void addTags(Map<TagKey<Block>, List<Holder<Block>>> existingRegistryTagEntries) {
+        MinecraftServer.LOGGER.info("Adding onto existing block tags...");
+        // Martijn start - custom blocks and items
+        MinecraftServer.LOGGER.info("Inheriting mineable with tool tags for custom blocks...");
+        final List<TagKey<Block>> mineableTags = List.of(BlockTags.MINEABLE_WITH_AXE, BlockTags.MINEABLE_WITH_HOE, BlockTags.MINEABLE_WITH_PICKAXE, BlockTags.MINEABLE_WITH_SHOVEL);
+        for (Block block : Registry.BLOCK) {
+            MinecraftServer.LOGGER.info("TEMP DEBUG - block " + block);
+            BlockReplacementRule blockReplacementRule = block.replacementRule;
+            if (blockReplacementRule != null) {
+                for (@NotNull Pair<@NotNull Block, @NotNull Block> observationReplacement : blockReplacementRule.getPotentialObservationReplacements()) {
+                    MinecraftServer.LOGGER.info("TEMP DEBUG - actual block " + observationReplacement.first() + " has player observable block " + observationReplacement.second());
+                    for (TagKey<Block> tag : mineableTags) {
+                        MinecraftServer.LOGGER.info("TEMP DEBUG - going to check " + tag);
+                        if (existingRegistryTagEntries.getOrDefault(tag, Collections.emptyList()).contains(this.registry.getHolderOrThrow(this.registry.getResourceKey(observationReplacement.second()).get()))) {
+                            MinecraftServer.LOGGER.info("TEMP DEBUG - added " + tag.location() + " from " + observationReplacement.second() + " to " + observationReplacement.first());
+                            this.tag(tag).add(this.registry.getResourceKey(observationReplacement.first()).get());
+                        }
+                    }
+                }
+            }
+        }
+        // Martijn end - custom blocks and items
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/data/SuCraftTagsProvider.java b/src/main/java/nl/martijnmuijsers/paper/data/SuCraftTagsProvider.java
index 4b30f9b23f095e6850d34161547c15cb23ac839e..cab6ae5e7350638faf1537cc7f60cdfea7133d4f 100644
--- a/src/main/java/nl/martijnmuijsers/paper/data/SuCraftTagsProvider.java
+++ b/src/main/java/nl/martijnmuijsers/paper/data/SuCraftTagsProvider.java
@@ -32,7 +32,7 @@ public abstract class SuCraftTagsProvider<T> {
         this.registry = registry;
     }
 
-    protected abstract void addTags();
+    protected abstract void addTags(Map<TagKey<T>, List<Holder<T>>> existingRegistryTagEntries);
 
     public Map<TagKey<T>, List<Holder<T>>> run(Map<TagKey<T>, List<Holder<T>>> existingRegistryTagEntries) {
 
@@ -58,7 +58,7 @@ public abstract class SuCraftTagsProvider<T> {
         };
 
         // Create the builders: done by running this method similar to TagsProvider.addTags, which defines the elements for each tag that we wish to add elements to (both elements for custom tags and extra elements for existing tags)
-        this.addTags();
+        this.addTags(existingRegistryTagEntries);
         // For each tag for which entries were added in addTags
         this.builders.forEach((tagId, builder) -> {
             TagKey<T> tagKey = TagKey.create(SuCraftTagsProvider.this.registry.key(), tagId);
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/httpserver/ResourcePackHTTPServer.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/httpserver/ResourcePackHTTPServer.java
new file mode 100644
index 0000000000000000000000000000000000000000..47de9ec1ea8637f53cf29a9f6b7f34d9080803fc
--- /dev/null
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/httpserver/ResourcePackHTTPServer.java
@@ -0,0 +1,76 @@
+// Martijn - custom blocks and items
+
+package nl.martijnmuijsers.paper.resourcepack.httpserver;
+
+import com.sun.net.httpserver.HttpExchange;
+import com.sun.net.httpserver.HttpServer;
+import nl.martijnmuijsers.paper.resourcepack.sucraft.CreateSuCraftResourcePack;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.InetSocketAddress;
+
+/**
+ * A singleton that runs an HTTP server to serve the server resource pack (or multiple variants of it)
+ */
+public final class ResourcePackHTTPServer {
+
+    private static final @NotNull String PROTOCOL = "http";
+    private static final @NotNull String IP = "sucraft.org";
+    private static final int PORT = 25454;
+    private static final @NotNull String PATH = "resourcepack";
+
+    public static final @NotNull String RESOURCE_PACK_URL = PROTOCOL + "://" + IP + ":" + PORT + "/" + PATH;
+
+    private ResourcePackHTTPServer() {}
+
+    private static @Nullable ResourcePackHTTPServer instance;
+    public static @NotNull ResourcePackHTTPServer getInstance() {
+        if (instance == null) {
+            instance = new ResourcePackHTTPServer();
+        }
+        return instance;
+    }
+
+    private boolean isStarted = false;
+    /**
+     * Only null while not initialized yet
+     */
+    private @Nullable HttpServer httpServer = null;
+
+    public void startIfNotStarted() {
+        if (this.isStarted) {
+            return;
+        }
+        try {
+            this.httpServer = HttpServer.create(new InetSocketAddress(25454), 0);
+            httpServer.createContext("/" + PATH, ResourcePackHTTPServer::handle);
+            httpServer.setExecutor(null); // creates a default executor
+            httpServer.start();
+            this.isStarted = true;
+        } catch (Exception e) {
+            throw new RuntimeException("Exception occurred while starting resource pack HTTP server", e);
+        } finally {
+            this.httpServer = null;
+        }
+    }
+
+    /**
+     * The whole resource pack is stored in memory, this seems a much better tradeoff than making retrieving it cost I/O operations
+     */
+    private static byte @Nullable [] resourcePackBytes;
+
+    public static void handle(HttpExchange httpExchange) throws IOException {
+        if (resourcePackBytes == null) {
+            resourcePackBytes = new FileInputStream(CreateSuCraftResourcePack.getOutputFile()).readAllBytes();
+        }
+        httpExchange.sendResponseHeaders(200, resourcePackBytes.length);
+        OutputStream responseBody = httpExchange.getResponseBody();
+        responseBody.write(resourcePackBytes);
+        responseBody.close();
+    }
+
+}
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/memory/MemoryResourcePack.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/memory/MemoryResourcePack.java
index 79884eccff1994db247ee495048635a16d54495a..01093db12b3df09cace350238c8f4d09b702c0a8 100644
--- a/src/main/java/nl/martijnmuijsers/paper/resourcepack/memory/MemoryResourcePack.java
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/memory/MemoryResourcePack.java
@@ -168,12 +168,8 @@ public class MemoryResourcePack implements MutableResourcePack {
         return newAsset;
     }
 
-    public void writeToFolder(String folderPath) throws IOException {
-        @NotNull File folder = new File(folderPath);
-        if (!folder.isDirectory()) {
-            throw new IOException("MemoryResourcePack.writeToFolder received a path that does not point to a folder");
-        }
-        try (@NotNull FileOutputStream fileOutputStream = new FileOutputStream(Path.of(folderPath, this.getSettings().getName() + ".zip").toFile())) {
+    public void writeToFile(@NotNull File file) throws IOException {
+        try (@NotNull FileOutputStream fileOutputStream = new FileOutputStream(file)) {
             try (@NotNull ZipOutputStream zipOutputStream = new ZipOutputStream(fileOutputStream)) {
                 @NotNull Set<@NotNull String> zippedFilePaths = new HashSet<>();
                 // Add the settings
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/sucraft/CreateSuCraftResourcePack.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/sucraft/CreateSuCraftResourcePack.java
index 20aed5bfadc83bc58841e1a55ad1a41ed80ba9c4..2dcff263b8f6733c48ee5f632b39e50c2e5b3c3b 100644
--- a/src/main/java/nl/martijnmuijsers/paper/resourcepack/sucraft/CreateSuCraftResourcePack.java
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/sucraft/CreateSuCraftResourcePack.java
@@ -18,6 +18,10 @@ import nl.martijnmuijsers.paper.resourcepack.readfromarchive.ReadFromArchiveReso
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Path;
+
 /**
  * Utility class to create and write the server resource pack.
  */
@@ -36,6 +40,14 @@ public final class CreateSuCraftResourcePack {
 
     private static final String OUTPUT_FOLDER_PATH = "resourcepack/output";
 
+    public static @NotNull File getOutputFile() throws IOException {
+        @NotNull File folder = new File(OUTPUT_FOLDER_PATH);
+        if (!folder.isDirectory()) {
+            throw new IOException("CreateSuCraftResourcePack.OUTPUT_FOLDER_PATH does not point to a folder");
+        }
+        return Path.of(OUTPUT_FOLDER_PATH, NAME + ".zip").toFile();
+    }
+
     public static void createAndWrite() {
         MinecraftServer.LOGGER.info("Creating server resource pack...");
         try {
@@ -70,7 +82,7 @@ public final class CreateSuCraftResourcePack {
                 }
 
                 // Write the resource pack to the output file
-                resourcePack.writeToFolder(OUTPUT_FOLDER_PATH);
+                resourcePack.writeToFile(getOutputFile());
 
             } finally {
 
diff --git a/src/main/java/nl/martijnmuijsers/paper/structure/SuCraftStructureTagsProvider.java b/src/main/java/nl/martijnmuijsers/paper/structure/SuCraftStructureTagsProvider.java
index d8999bae8bd0fea2265320fc6505eb7e09fc3e12..106e07afaf3164ebe1d63e9e48f543c99da83d4c 100644
--- a/src/main/java/nl/martijnmuijsers/paper/structure/SuCraftStructureTagsProvider.java
+++ b/src/main/java/nl/martijnmuijsers/paper/structure/SuCraftStructureTagsProvider.java
@@ -2,12 +2,17 @@
 
 package nl.martijnmuijsers.paper.structure;
 
+import net.minecraft.core.Holder;
 import net.minecraft.core.Registry;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.tags.StructureTags;
+import net.minecraft.tags.TagKey;
 import net.minecraft.world.level.levelgen.structure.Structure;
 import nl.martijnmuijsers.paper.data.SuCraftTagsProvider;
 
+import java.util.List;
+import java.util.Map;
+
 /**
  * Based on {@link net.minecraft.data.tags.StructureTagsProvider}
  */
@@ -18,7 +23,7 @@ public class SuCraftStructureTagsProvider extends SuCraftTagsProvider<Structure>
     }
 
     @Override
-    protected void addTags() {
+    protected void addTags(Map<TagKey<Structure>, List<Holder<Structure>>> existingRegistryTagEntries) {
         MinecraftServer.LOGGER.info("Adding onto existing structure tags...");
         this.tag(StructureTags.EYE_OF_ENDER_LOCATED).add(SuCraftBuiltinStructures.STRONGHOLD_SURFACE);
     }
