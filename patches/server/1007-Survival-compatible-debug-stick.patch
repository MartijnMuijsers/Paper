From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Tue, 18 Jan 2022 21:44:58 +0100
Subject: [PATCH] Survival-compatible debug stick


diff --git a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
index 7f2a790f8772373ddf329278de3b9b342117c0dc..669389048b965aba2a8d55637cef20d2d1c64472 100644
--- a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
@@ -255,6 +255,21 @@ public class GlobalConfiguration extends ConfigurationPart {
 
     // Martijn end - configurable keepalive
 
+    // Martijn start - survival debug stick
+
+    public SurvivallikeDebugStick survivallikeDebugStick;
+
+    public class SurvivallikeDebugStick extends ConfigurationPart {
+
+        /**
+         * In milliseconds
+         */
+        public int switchPropertyTimeout = 300;
+
+    }
+
+    // Martijn end - survival debug stick
+
     public Messages messages;
 
     public class Messages extends ConfigurationPart {
diff --git a/src/main/java/net/minecraft/core/Direction.java b/src/main/java/net/minecraft/core/Direction.java
index a3bbebcdaea9e0dfddd9825272f84fc76cd13e89..e0d684510df3c32ca10da8a5408dc45efdea38da 100644
--- a/src/main/java/net/minecraft/core/Direction.java
+++ b/src/main/java/net/minecraft/core/Direction.java
@@ -638,7 +638,7 @@ public enum Direction implements StringRepresentable {
         HORIZONTAL(new Direction[]{Direction.NORTH, Direction.EAST, Direction.SOUTH, Direction.WEST}, new Direction.Axis[]{Direction.Axis.X, Direction.Axis.Z}),
         VERTICAL(new Direction[]{Direction.UP, Direction.DOWN}, new Direction.Axis[]{Direction.Axis.Y});
 
-        private final Direction[] faces;
+        public final Direction[] faces; // Martijn - survival debug stick
         private final Direction.Axis[] axis;
 
         private Plane(Direction[] facingArray, Direction.Axis[] axisArray) {
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
index 5a60f5dc202c44b06ca34e9a19d45cb715f74fd3..280d28257ff2c28775f8a236a324d8c63b53093a 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
@@ -10,6 +10,7 @@ import net.minecraft.world.MenuProvider;
 import net.minecraft.world.entity.EquipmentSlot;
 import net.minecraft.world.item.DoubleHighBlockItem;
 import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
 import net.minecraft.world.item.context.UseOnContext;
 import net.minecraft.world.level.GameType;
 import net.minecraft.world.level.Level;
@@ -21,6 +22,7 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.block.state.properties.DoubleBlockHalf;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.craftbukkit.util.permissions.CraftDefaultPermissions;
 import org.slf4j.Logger;
 
 // CraftBukkit start
@@ -210,7 +212,37 @@ public class ServerPlayerGameMode {
                 }
                 // CraftBukkit end
 
+                // Martijn start - survival debug stick, survival barrier blocks, survival light blocks
+                boolean canCreativeDestroy = false;
+                // Check for creative
                 if (this.isCreative()) {
+                    canCreativeDestroy = true;
+                } else {
+                    if (this.isSurvival()) {
+                        // Check for survival debug stick
+                        boolean isUsingSurvivalDebugStick = false;
+                        if (player.getBukkitEntity().hasPermission(CraftDefaultPermissions.survivallikeDebugStick) || player.getBukkitEntity().hasPermission(CraftDefaultPermissions.alwaysDebugStick)) {
+                            if (player.getItemInHand(InteractionHand.MAIN_HAND).is(Items.DEBUG_STICK)) {
+                                isUsingSurvivalDebugStick = true;
+                            }
+                        }
+                        if (isUsingSurvivalDebugStick) {
+                            canCreativeDestroy = true;
+                        } else {
+                            // Check for breaking barrier
+                            if (player.getItemInHand(InteractionHand.MAIN_HAND).is(Items.BARRIER) && this.level.getBlockState(pos).is(Blocks.BARRIER)) {
+                                canCreativeDestroy = true;
+                            } else {
+                                // Check for breaking light
+                                if (player.getItemInHand(InteractionHand.MAIN_HAND).is(Items.LIGHT) && this.level.getBlockState(pos).is(Blocks.LIGHT)) {
+                                    canCreativeDestroy = true;
+                                }
+                            }
+                        }
+                    }
+                }
+                if (canCreativeDestroy) {
+                    // Martijn end - survival debug stick, survival barrier blocks, survival light blocks
                     this.destroyAndAck(pos, sequence, "creative destroy");
                     return;
                 }
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index 9b131f0a827413e9f5d6d0f7491c5481576cb8b1..489c871ba53d15567d18b1a11908e00204975951 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -116,6 +116,9 @@ import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.scores.PlayerTeam;
 import net.minecraft.world.scores.Scoreboard;
 import org.slf4j.Logger;
+// CraftBukkit start
+import org.bukkit.Bukkit;
+import org.bukkit.GameMode;
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.util.CraftVector;
diff --git a/src/main/java/net/minecraft/world/item/DebugStickItem.java b/src/main/java/net/minecraft/world/item/DebugStickItem.java
index 09124f20d00d5631fa52e84cc0e8645caaa80e35..df16551bf1ef987bf773ee49618bbe1a0aa50b9c 100644
--- a/src/main/java/net/minecraft/world/item/DebugStickItem.java
+++ b/src/main/java/net/minecraft/world/item/DebugStickItem.java
@@ -1,10 +1,25 @@
 // mc-dev import
 package net.minecraft.world.item;
 
+import java.util.Arrays;
 import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+import java.util.function.Predicate;
 import javax.annotation.Nullable;
+
+import com.destroystokyo.paper.PaperConfig;
+import io.papermc.paper.configuration.GlobalConfiguration;
+import it.unimi.dsi.fastutil.objects.Object2LongMap;
+import it.unimi.dsi.fastutil.objects.Object2LongOpenHashMap;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
 import net.minecraft.core.Registry;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.chat.Component;
@@ -15,10 +30,63 @@ import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.context.UseOnContext;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelAccessor;
+import net.minecraft.world.level.block.AbstractFurnaceBlock;
+import net.minecraft.world.level.block.AnvilBlock;
+import net.minecraft.world.level.block.AttachedStemBlock;
+import net.minecraft.world.level.block.BambooBlock;
+import net.minecraft.world.level.block.BannerBlock;
+import net.minecraft.world.level.block.BarrelBlock;
+import net.minecraft.world.level.block.BeehiveBlock;
+import net.minecraft.world.level.block.BlastFurnaceBlock;
 import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.CampfireBlock;
+import net.minecraft.world.level.block.CarvedPumpkinBlock;
+import net.minecraft.world.level.block.ChorusPlantBlock;
+import net.minecraft.world.level.block.ComparatorBlock;
+import net.minecraft.world.level.block.DaylightDetectorBlock;
+import net.minecraft.world.level.block.DetectorRailBlock;
+import net.minecraft.world.level.block.DiodeBlock;
+import net.minecraft.world.level.block.DispenserBlock;
+import net.minecraft.world.level.block.DoublePlantBlock;
+import net.minecraft.world.level.block.DropperBlock;
+import net.minecraft.world.level.block.EnderChestBlock;
+import net.minecraft.world.level.block.FenceBlock;
+import net.minecraft.world.level.block.FenceGateBlock;
+import net.minecraft.world.level.block.FurnaceBlock;
+import net.minecraft.world.level.block.GlazedTerracottaBlock;
+import net.minecraft.world.level.block.GrindstoneBlock;
+import net.minecraft.world.level.block.HopperBlock;
+import net.minecraft.world.level.block.HugeMushroomBlock;
+import net.minecraft.world.level.block.IronBarsBlock;
+import net.minecraft.world.level.block.LecternBlock;
+import net.minecraft.world.level.block.LoomBlock;
+import net.minecraft.world.level.block.NetherPortalBlock;
+import net.minecraft.world.level.block.NoteBlock;
+import net.minecraft.world.level.block.ObserverBlock;
+import net.minecraft.world.level.block.PoweredRailBlock;
+import net.minecraft.world.level.block.RailBlock;
+import net.minecraft.world.level.block.RedstoneLampBlock;
+import net.minecraft.world.level.block.RodBlock;
+import net.minecraft.world.level.block.RotatedPillarBlock;
+import net.minecraft.world.level.block.SkullBlock;
+import net.minecraft.world.level.block.SnowyDirtBlock;
+import net.minecraft.world.level.block.StairBlock;
+import net.minecraft.world.level.block.StandingSignBlock;
+import net.minecraft.world.level.block.StonecutterBlock;
+import net.minecraft.world.level.block.TrappedChestBlock;
+import net.minecraft.world.level.block.VineBlock;
+import net.minecraft.world.level.block.WallBlock;
+import net.minecraft.world.level.block.WallSkullBlock;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.block.state.StateDefinition;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.block.state.properties.Property;
+import net.minecraft.world.level.material.Material;
+import org.bukkit.GameMode;
+import org.bukkit.block.DaylightDetector;
+import org.bukkit.block.data.type.Fence;
+import org.bukkit.craftbukkit.util.permissions.CraftDefaultPermissions;
 
 public class DebugStickItem extends Item {
 
@@ -56,36 +124,69 @@ public class DebugStickItem extends Item {
         return InteractionResult.sidedSuccess(world.isClientSide);
     }
 
+    // Martijn start - survival debug stick
+    private final Object2LongMap<UUID> lastSwitchPropertyTimestamp = new Object2LongOpenHashMap<>();
+
     private boolean handleInteraction(Player player, BlockState state, LevelAccessor world, BlockPos pos, boolean update, ItemStack stack) {
-        if (!player.canUseGameMasterBlocks() && !(player.getAbilities().instabuild && player.getBukkitEntity().hasPermission("minecraft.debugstick")) && !player.getBukkitEntity().hasPermission("minecraft.debugstick.always")) { // Spigot
+        boolean canUseDebugStickUnlimited = player.canUseGameMasterBlocks()
+            || (player.getAbilities().instabuild && player.getBukkitEntity().hasPermission(CraftDefaultPermissions.debugStick)) // Spigot
+            || player.getBukkitEntity().hasPermission(CraftDefaultPermissions.alwaysDebugStick); // Spigot
+        boolean canUseDebugStickAtAll = canUseDebugStickUnlimited
+            || player.getBukkitEntity().hasPermission(CraftDefaultPermissions.survivallikeDebugStick);
+        if (!canUseDebugStickAtAll) {
             return false;
         } else {
             Block block = state.getBlock();
             StateDefinition<Block, BlockState> blockstatelist = block.getStateDefinition();
-            Collection<Property<?>> collection = blockstatelist.getProperties();
+            Collection<Property<?>> allProperties = blockstatelist.getProperties();
+            Collection<Property<?>> changeableProperties = canUseDebugStickUnlimited
+                ? allProperties
+                : allProperties.stream().filter(property -> canChangePropertyInSurvivallike(block, property)).toList();
             String s = Registry.BLOCK.getKey(block).toString();
 
-            if (collection.isEmpty()) {
+            if (changeableProperties.isEmpty()) {
                 DebugStickItem.message(player, Component.translatable(this.getDescriptionId() + ".empty", s));
                 return false;
             } else {
                 CompoundTag nbttagcompound = stack.getOrCreateTagElement("DebugProperty");
                 String s1 = nbttagcompound.getString(s);
                 Property<?> iblockstate = blockstatelist.getProperty(s1);
+                if (!changeableProperties.contains(iblockstate)) {
+                    iblockstate = null;
+                }
 
                 if (update) {
                     if (iblockstate == null) {
-                        iblockstate = (Property) collection.iterator().next();
+                        iblockstate = (Property) changeableProperties.iterator().next();
+                    }
+
+                    @Nullable Set<?> possibleValues = canUseDebugStickUnlimited ? null : getChangeablePropertyValuesInSurvivallike(block, iblockstate);
+                    if (possibleValues != null && !possibleValues.contains(state.getValue(iblockstate))) {
+                        DebugStickItem.message(player, Component.translatable(this.getDescriptionId() + ".update", iblockstate.getName(), DebugStickItem.getNameHelper(state, iblockstate)));
+                        return true;
                     }
 
-                    BlockState iblockdata1 = DebugStickItem.cycleState(state, iblockstate, player.isSecondaryUseActive());
+                    BlockState iblockdata1 = DebugStickItem.cycleState(state, iblockstate, possibleValues, player.isSecondaryUseActive());
 
                     world.setBlock(pos, iblockdata1, 18);
                     DebugStickItem.message(player, Component.translatable(this.getDescriptionId() + ".update", iblockstate.getName(), DebugStickItem.getNameHelper(iblockdata1, iblockstate)));
                 } else {
-                    iblockstate = (Property) DebugStickItem.getRelative(collection, iblockstate, player.isSecondaryUseActive());
+                    if (player.getBukkitEntity().getGameMode() == GameMode.SURVIVAL) {
+                        if (System.currentTimeMillis() <= lastSwitchPropertyTimestamp.getOrDefault(player.getUUID(), 0L) + GlobalConfiguration.get().survivallikeDebugStick.switchPropertyTimeout) {
+                            return true;
+                        }
+                        lastSwitchPropertyTimestamp.put(player.getUUID(), System.currentTimeMillis());
+                    }
+                    if (iblockstate == null) {
+                        iblockstate = (Property) changeableProperties.iterator().next();
+                    } else {
+                        iblockstate = (Property) DebugStickItem.getRelative(changeableProperties, iblockstate, player.isSecondaryUseActive());
+                    }
                     String s2 = iblockstate.getName();
 
+                    if (iblockstate == null) {
+                        iblockstate = (Property) changeableProperties.iterator().next();
+                    }
                     nbttagcompound.putString(s, s2);
                     DebugStickItem.message(player, Component.translatable(this.getDescriptionId() + ".select", s2, DebugStickItem.getNameHelper(state, iblockstate)));
                 }
@@ -95,9 +196,13 @@ public class DebugStickItem extends Item {
         }
     }
 
-    private static <T extends Comparable<T>> BlockState cycleState(BlockState state, Property<T> property, boolean inverse) {
-        return (BlockState) state.setValue(property, DebugStickItem.getRelative(property.getPossibleValues(), state.getValue(property), inverse)); // CraftBukkit - decompile error
+    /**
+     * @param possibleValues If null, will assume all existing values are possible
+     */
+    private static <T extends Comparable<T>> BlockState cycleState(BlockState state, Property<T> property, @Nullable Collection<?> possibleValues, boolean inverse) {
+        return (BlockState) state.setValue(property, DebugStickItem.getRelative(possibleValues == null ? property.getPossibleValues() : (Collection<T>) possibleValues, state.getValue(property), inverse)); // CraftBukkit - decompile error
     }
+    // Martijn end - survival debug stick
 
     private static <T> T getRelative(Iterable<T> elements, @Nullable T current, boolean inverse) {
         return inverse ? Util.findPreviousInIterable(elements, current) : Util.findNextInIterable(elements, current);
@@ -110,4 +215,122 @@ public class DebugStickItem extends Item {
     private static <T extends Comparable<T>> String getNameHelper(BlockState state, Property<T> property) {
         return property.getName(state.getValue(property));
     }
+
+    // Martijn start - survival debug stick
+    private static final Map<Block, Map<Property<?>, Set<Object>>> changeablePropertyValues;
+    private static <T extends Comparable<T>> void registerChangeablePropertyValues(Block[] blocks, Property<T> property, Collection<T> values) {
+        if (blocks.length == 0) return;
+        if (values.isEmpty()) return;
+        for (Block block : blocks) {
+            Map<Property<?>, Set<Object>> changeablePropertyValuesForBlock = changeablePropertyValues.computeIfAbsent(block, it -> new HashMap<>(1));
+            Set<Object> existingValues = changeablePropertyValuesForBlock.computeIfAbsent(property, it -> new HashSet<>(1));
+            existingValues.addAll(values);
+        }
+    }
+    private static <T extends Comparable<T>> void registerChangeablePropertyValues(Block[] blocks, Property<T> property, T[] values) {
+        registerChangeablePropertyValues(blocks, property, Arrays.asList(values));
+    }
+    private static <B extends Block, T extends Comparable<T>> void registerChangeablePropertyWithAllValues(Block[] blocks, Property<?> property) {
+        registerChangeablePropertyValues(blocks, (Property<T>) property, ((Property<T>) property).getPossibleValues());
+    }
+    @SafeVarargs
+    private static <T extends Comparable<T>> void registerChangeablePropertiesWithAllValues(Block[] blocks, Property<?>... properties) {
+        Arrays.stream(properties).forEach(property -> registerChangeablePropertyWithAllValues(blocks, property));
+    }
+    private static <T extends Comparable<T>> void registerChangeablePropertyValues(Predicate<Block> blockPredicate, Property<T> property, Collection<T> values) {
+        registerChangeablePropertyValues(Registry.BLOCK.stream().filter(blockPredicate).toArray(Block[]::new), property, values);
+    }
+    private static <T extends Comparable<T>> void registerChangeablePropertyValues(Predicate<Block> blockPredicate, Property<T> property, T[] values) {
+        registerChangeablePropertyValues(blockPredicate, property, Arrays.asList(values));
+    }
+    private static <B extends Block, T extends Comparable<T>> void registerChangeablePropertyWithAllValues(Predicate<Block> blockPredicate, Property<?> property) {
+        registerChangeablePropertyValues(blockPredicate, (Property<T>) property, ((Property<T>) property).getPossibleValues());
+    }
+    @SafeVarargs
+    private static <T extends Comparable<T>> void registerChangeablePropertiesWithAllValues(Predicate<Block> blockPredicate, Property<?>... properties) {
+        Arrays.stream(properties).forEach(property -> registerChangeablePropertyWithAllValues(blockPredicate, property));
+    }
+    private static <B extends Block, T extends Comparable<T>> void registerChangeablePropertyValues(Class<B> blockType, Property<T> property, Collection<T> values) {
+        registerChangeablePropertyValues(blockType::isInstance, property, values);
+    }
+    private static <B extends Block, T extends Comparable<T>> void registerChangeablePropertyValues(Class<B> blockType, Property<T> property, T[] values) {
+        registerChangeablePropertyValues(blockType, property, Arrays.asList(values));
+    }
+    private static <B extends Block, T extends Comparable<T>> void registerChangeablePropertyWithAllValues(Class<B> blockType, Property<?> property) {
+        registerChangeablePropertyValues(blockType, (Property<T>) property, ((Property<T>) property).getPossibleValues());
+    }
+    @SafeVarargs
+    private static <B extends Block, T extends Comparable<T>> void registerChangeablePropertiesWithAllValues(Class<B> blockType, Property<?>... properties) {
+        Arrays.stream(properties).forEach(property -> registerChangeablePropertyWithAllValues(blockType, property));
+    }
+    static {
+        changeablePropertyValues = new HashMap<>(0);
+        registerChangeablePropertiesWithAllValues(GlazedTerracottaBlock.class, GlazedTerracottaBlock.FACING);
+        registerChangeablePropertiesWithAllValues(SnowyDirtBlock.class, SnowyDirtBlock.SNOWY);
+        registerChangeablePropertiesWithAllValues(RotatedPillarBlock.class, RotatedPillarBlock.AXIS);
+        registerChangeablePropertiesWithAllValues(NetherPortalBlock.class, NetherPortalBlock.AXIS);
+        registerChangeablePropertiesWithAllValues(HugeMushroomBlock.class, HugeMushroomBlock.DOWN, HugeMushroomBlock.EAST, HugeMushroomBlock.NORTH, HugeMushroomBlock.SOUTH, HugeMushroomBlock.UP, HugeMushroomBlock.WEST);
+        registerChangeablePropertiesWithAllValues(ChorusPlantBlock.class, ChorusPlantBlock.DOWN, ChorusPlantBlock.EAST, ChorusPlantBlock.NORTH, ChorusPlantBlock.SOUTH, ChorusPlantBlock.UP, ChorusPlantBlock.WEST);
+        registerChangeablePropertiesWithAllValues(FenceBlock.class, FenceBlock.EAST, FenceBlock.NORTH, FenceBlock.SOUTH, FenceBlock.WEST);
+        registerChangeablePropertiesWithAllValues(IronBarsBlock.class, IronBarsBlock.EAST, IronBarsBlock.NORTH, IronBarsBlock.SOUTH, IronBarsBlock.WEST);
+        registerChangeablePropertiesWithAllValues(WallBlock.class, WallBlock.EAST_WALL, WallBlock.NORTH_WALL, WallBlock.SOUTH_WALL, WallBlock.WEST_WALL);
+        registerChangeablePropertiesWithAllValues(VineBlock.class, VineBlock.EAST, VineBlock.NORTH, VineBlock.SOUTH, VineBlock.WEST);
+        registerChangeablePropertiesWithAllValues(GrindstoneBlock.class, GrindstoneBlock.FACE, GrindstoneBlock.FACING);
+        registerChangeablePropertiesWithAllValues(BarrelBlock.class, BarrelBlock.FACING, BarrelBlock.OPEN);
+        registerChangeablePropertiesWithAllValues(DispenserBlock.class, DispenserBlock.FACING);
+        registerChangeablePropertiesWithAllValues(RodBlock.class, RodBlock.FACING);
+        registerChangeablePropertiesWithAllValues(ObserverBlock.class, ObserverBlock.FACING);
+        registerChangeablePropertiesWithAllValues(AnvilBlock.class, AnvilBlock.FACING);
+        registerChangeablePropertiesWithAllValues(FenceGateBlock.class, FenceGateBlock.FACING, FenceGateBlock.IN_WALL);
+        registerChangeablePropertiesWithAllValues(WallSkullBlock.class, WallSkullBlock.FACING);
+        registerChangeablePropertiesWithAllValues(AttachedStemBlock.class, AttachedStemBlock.FACING);
+        registerChangeablePropertiesWithAllValues(BeehiveBlock.class, BeehiveBlock.FACING);
+        registerChangeablePropertiesWithAllValues(AbstractFurnaceBlock.class, AbstractFurnaceBlock.FACING, AbstractFurnaceBlock.LIT);
+        registerChangeablePropertiesWithAllValues(CampfireBlock.class, CampfireBlock.FACING);
+        registerChangeablePropertiesWithAllValues(CarvedPumpkinBlock.class, CarvedPumpkinBlock.FACING);
+        registerChangeablePropertiesWithAllValues(EnderChestBlock.class, EnderChestBlock.FACING);
+        registerChangeablePropertiesWithAllValues(LecternBlock.class, LecternBlock.FACING);
+        registerChangeablePropertiesWithAllValues(LoomBlock.class, LoomBlock.FACING);
+        registerChangeablePropertiesWithAllValues(DiodeBlock.class, DiodeBlock.FACING);
+        registerChangeablePropertiesWithAllValues(StonecutterBlock.class, StonecutterBlock.FACING);
+        registerChangeablePropertiesWithAllValues(TrappedChestBlock.class, TrappedChestBlock.FACING);
+        registerChangeablePropertiesWithAllValues(HopperBlock.class, HopperBlock.FACING);
+        registerChangeablePropertiesWithAllValues(NoteBlock.class, NoteBlock.INSTRUMENT, NoteBlock.NOTE);
+        registerChangeablePropertiesWithAllValues(DaylightDetectorBlock.class, DaylightDetectorBlock.INVERTED);
+        registerChangeablePropertiesWithAllValues(BambooBlock.class, BambooBlock.LEAVES, BambooBlock.AGE);
+        registerChangeablePropertiesWithAllValues(RedstoneLampBlock.class, RedstoneLampBlock.LIT);
+        registerChangeablePropertiesWithAllValues(BannerBlock.class, BannerBlock.ROTATION);
+        registerChangeablePropertiesWithAllValues(SkullBlock.class, SkullBlock.ROTATION);
+        registerChangeablePropertiesWithAllValues(StandingSignBlock.class, StandingSignBlock.ROTATION);
+        registerChangeablePropertiesWithAllValues(StairBlock.class, StairBlock.SHAPE);
+        registerChangeablePropertiesWithAllValues(PoweredRailBlock.class, PoweredRailBlock.SHAPE);
+        registerChangeablePropertiesWithAllValues(DetectorRailBlock.class, DetectorRailBlock.SHAPE);
+        registerChangeablePropertiesWithAllValues(RailBlock.class, RailBlock.SHAPE);
+    }
+
+    public static boolean canChangeBlockInSurvivallike(Block block) {
+        Map<Property<?>, Set<Object>> changeablePropertyValuesForBlock = changeablePropertyValues.get(block);
+        if (changeablePropertyValuesForBlock == null) {
+            return false;
+        }
+        return changeablePropertyValuesForBlock.entrySet().stream().anyMatch(entry -> !entry.getValue().isEmpty());
+    }
+
+    public static @Nullable Set<Object> getChangeablePropertyValuesInSurvivallike(Block block, Property<?> property) {
+        Map<Property<?>, Set<Object>> changeablePropertyValuesForBlock = changeablePropertyValues.get(block);
+        if (changeablePropertyValuesForBlock == null) {
+            return null;
+        }
+        return changeablePropertyValuesForBlock.get(property);
+    }
+
+    public static boolean canChangePropertyInSurvivallike(Block block, Property<?> property) {
+        Set<Object> values = getChangeablePropertyValuesInSurvivallike(block, property);
+        if (values == null) {
+            return false;
+        }
+        return !values.isEmpty();
+    }
+    // Martijn end - survival debug stick
+
 }
diff --git a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
index fbf69c402ba97b99319d0df90b501d43686bce8c..09c95fea219fc777aeb9354387aa694fcc9fe03a 100644
--- a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
+++ b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
@@ -34,6 +34,7 @@ import net.minecraft.world.entity.projectile.Projectile;
 import net.minecraft.world.item.DyeColor;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
 import net.minecraft.world.item.context.BlockPlaceContext;
 import net.minecraft.world.item.context.UseOnContext;
 import net.minecraft.world.level.BlockGetter;
@@ -69,6 +70,7 @@ import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
+import org.bukkit.GameMode;
 
 public abstract class BlockBehaviour {
 
@@ -353,6 +355,7 @@ public abstract class BlockBehaviour {
     /** @deprecated */
     @Deprecated
     public float getDestroyProgress(BlockState state, Player player, BlockGetter world, BlockPos pos) {
+
         float f = state.getDestroySpeed(world, pos);
 
         if (f == -1.0F) {
diff --git a/src/main/java/org/bukkit/craftbukkit/util/permissions/CraftDefaultPermissions.java b/src/main/java/org/bukkit/craftbukkit/util/permissions/CraftDefaultPermissions.java
index 8e06bc11fb28baee3407bbfe9d7b3689d6f85ff2..843e04d58c7aca4bd11ab84cf42120cda6a3f4ee 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/permissions/CraftDefaultPermissions.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/permissions/CraftDefaultPermissions.java
@@ -6,6 +6,12 @@ import org.bukkit.util.permissions.DefaultPermissions;
 public final class CraftDefaultPermissions {
     private static final String ROOT = "minecraft";
 
+    // Martijn start - survival debug stick
+    public static Permission debugStick;
+    public static Permission alwaysDebugStick;
+    public static Permission survivallikeDebugStick;
+    // Martijn end - survival debug stick
+
     private CraftDefaultPermissions() {}
 
     public static void registerCorePermissions() {
@@ -14,8 +20,11 @@ public final class CraftDefaultPermissions {
         // Spigot start
         DefaultPermissions.registerPermission(CraftDefaultPermissions.ROOT + ".nbt.place", "Gives the user the ability to place restricted blocks with NBT in creative", org.bukkit.permissions.PermissionDefault.OP, parent);
         DefaultPermissions.registerPermission(CraftDefaultPermissions.ROOT + ".nbt.copy", "Gives the user the ability to copy NBT in creative", org.bukkit.permissions.PermissionDefault.TRUE, parent);
-        DefaultPermissions.registerPermission(CraftDefaultPermissions.ROOT + ".debugstick", "Gives the user the ability to use the debug stick in creative", org.bukkit.permissions.PermissionDefault.OP, parent);
-        DefaultPermissions.registerPermission(CraftDefaultPermissions.ROOT + ".debugstick.always", "Gives the user the ability to use the debug stick in all game modes", org.bukkit.permissions.PermissionDefault.FALSE/* , parent */); // Paper - should not have this parent, as it's not a "vanilla" utility
+        // Martijn start - survival debug stick
+        debugStick = DefaultPermissions.registerPermission(CraftDefaultPermissions.ROOT + ".debugstick", "Gives the user the ability to use the debug stick in creative", org.bukkit.permissions.PermissionDefault.OP, parent);
+        alwaysDebugStick = DefaultPermissions.registerPermission(CraftDefaultPermissions.ROOT + ".debugstick.always", "Gives the user the ability to use the debug stick in all game modes", org.bukkit.permissions.PermissionDefault.FALSE, parent);
+        survivallikeDebugStick = DefaultPermissions.registerPermission(CraftDefaultPermissions.ROOT + ".debugstick.survivallike", "Gives the user the ability to partially use the debug stick in all game modes, with the only usages allowed being those compatible with survival mode gameplay", org.bukkit.permissions.PermissionDefault.FALSE, parent);
+        // Martijn end - survival debug stick
         DefaultPermissions.registerPermission(CraftDefaultPermissions.ROOT + ".commandblock", "Gives the user the ability to use command blocks.", org.bukkit.permissions.PermissionDefault.OP, parent); // Paper
         // Spigot end
         parent.recalculatePermissibles();
