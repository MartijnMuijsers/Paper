From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Wed, 20 Jul 2022 18:52:30 +0200
Subject: [PATCH] X


diff --git a/src/main/java/net/minecraft/resources/ResourceLocation.java b/src/main/java/net/minecraft/resources/ResourceLocation.java
index a4d569e63b5caf2dd7e04597588a3ee7a48a5534..8a353de5309ca6496332cdd1559a3c14c06d0ee6 100644
--- a/src/main/java/net/minecraft/resources/ResourceLocation.java
+++ b/src/main/java/net/minecraft/resources/ResourceLocation.java
@@ -17,6 +17,7 @@ import javax.annotation.Nullable;
 import net.minecraft.ResourceLocationException;
 import net.minecraft.network.chat.Component;
 import net.minecraft.util.GsonHelper;
+import nl.martijnmuijsers.paper.resourcepack.asset.intention.NamespacedKeyWithIntention;
 import org.apache.commons.lang3.StringUtils;
 import org.bukkit.NamespacedKey;
 import org.jetbrains.annotations.NotNull;
@@ -59,6 +60,14 @@ public class ResourceLocation implements Comparable<ResourceLocation> {
         return new NamespacedKey(this.namespace, this.path);
     }
 
+    public @NotNull ResourceLocation withPathSuffix(@NotNull String suffix) {
+        return new ResourceLocation(namespace, this.path + suffix);
+    }
+
+    public @NotNull ResourceLocation withPathPrefix(@NotNull String prefix) {
+        return new ResourceLocation(namespace, prefix + this.path);
+    }
+
     // Martijn end - custom resources
 
     public static ResourceLocation of(String id, char delimiter) {
diff --git a/src/main/java/net/minecraft/world/level/block/Block.java b/src/main/java/net/minecraft/world/level/block/Block.java
index 80ea871646526098f89ce27bfc9f685c52cbdcf9..4a6e1e7a8915f48edff111c3028fda68ac106cd8 100644
--- a/src/main/java/net/minecraft/world/level/block/Block.java
+++ b/src/main/java/net/minecraft/world/level/block/Block.java
@@ -240,10 +240,18 @@ public class Block extends BlockBehaviour implements ItemLike {
         return this.withTag(() -> BlockTags.SLABS);
     }
 
+    public @NotNull Block stairs() {
+        return this.withTag(() -> BlockTags.STAIRS);
+    }
+
     public @NotNull Block woodenSlab() {
         return this.withTag(() -> BlockTags.WOODEN_SLABS).slab();
     }
 
+    public @NotNull Block woodenStairs() {
+        return this.withTag(() -> BlockTags.WOODEN_STAIRS).stairs();
+    }
+
     public @NotNull Block dirt() {
         return this.withTag(() -> BlockTags.DIRT);
     }
diff --git a/src/main/java/net/minecraft/world/level/block/StairBlock.java b/src/main/java/net/minecraft/world/level/block/StairBlock.java
index 827713a332baa6d280cd61d40faf8f6243b3b08c..d0a0b1f696441c8ebcda8cc96a33fae3764e89cc 100644
--- a/src/main/java/net/minecraft/world/level/block/StairBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/StairBlock.java
@@ -81,7 +81,7 @@ public class StairBlock extends Block implements SimpleWaterloggedBlock {
         return voxelShape;
     }
 
-    protected StairBlock(BlockState baseBlockState, BlockBehaviour.Properties settings) {
+    public StairBlock(BlockState baseBlockState, BlockBehaviour.Properties settings) { // Martijn - custom blocks and items
         super(settings);
         this.registerDefaultState(this.stateDefinition.any().setValue(FACING, Direction.NORTH).setValue(HALF, Half.BOTTOM).setValue(SHAPE, StairsShape.STRAIGHT).setValue(WATERLOGGED, Boolean.valueOf(false)));
         this.base = baseBlockState.getBlock();
diff --git a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
index 34ccaa62a466fc7b1f96191ff59e7485f3eedb47..23b6f79c868484421b8ee80dd2ec0e09b1b18183 100644
--- a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
+++ b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
@@ -638,6 +638,15 @@ public abstract class BlockBehaviour {
             return this;
         }
 
+        // Martijn start - custom blocks and items
+
+        public BlockBehaviour.Properties doesNotRequireCorrectToolForDrops() {
+            this.requiresCorrectToolForDrops = false;
+            return this;
+        }
+
+        // Martijn end - custom blocks and items
+
         public BlockBehaviour.Properties color(MaterialColor color) {
             this.materialColor = (iblockdata) -> {
                 return color;
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlocks.java b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlocks.java
index 05335efe482685e6880cc7034e25f975fbf25027..cdc84463a94ed25312296540f6e7df6b1b1e0d90 100644
--- a/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlocks.java
+++ b/src/main/java/nl/martijnmuijsers/paper/block/SuCraftBlocks.java
@@ -6,16 +6,15 @@ import net.minecraft.core.Registry;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.world.item.DyeColor;
 import net.minecraft.world.item.Items;
-import net.minecraft.world.level.block.BaseFireBlock;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.FireBlock;
 import net.minecraft.world.level.block.InfestedBlock;
 import net.minecraft.world.level.block.LeavesBlock;
 import net.minecraft.world.level.block.RotatedPillarBlock;
 import net.minecraft.world.level.block.SlabBlock;
 import net.minecraft.world.level.block.SoulFireBlock;
 import net.minecraft.world.level.block.SoundType;
+import net.minecraft.world.level.block.StairBlock;
 import net.minecraft.world.level.block.state.BlockBehaviour;
 import net.minecraft.world.level.material.Material;
 import net.minecraft.world.level.material.MaterialColor;
@@ -493,7 +492,7 @@ public class SuCraftBlocks {
     public static final Block OBSIDIAN_SLAB = registerFakeSlab(Blocks.OBSIDIAN, "obsidian", Blocks.BLACKSTONE_SLAB).mineableWithPickaxe();
     public static final Block CRYING_OBSIDIAN_SLAB = registerFakeSlab(Blocks.CRYING_OBSIDIAN, "crying_obsidian", Blocks.BLACKSTONE_SLAB).mineableWithPickaxe();
     public static final Block GILDED_BLACKSTONE_SLAB = registerFakeSlab(Blocks.GILDED_BLACKSTONE, "gilded_blackstone", Blocks.BLACKSTONE_SLAB).mineableWithPickaxe();
-//    public static final Block SNOWY_STONE_BRICK_STAIRS = registerFakeStairs(SNOWY_STONE_BRICKS, "snowy_stone_brick", null, Blocks.STONE_BRICK_STAIRS);
+    public static final Block SNOWY_STONE_BRICK_STAIRS = registerFakeStairs(SNOWY_STONE_BRICKS, "snowy_stone_brick", null, Blocks.STONE_BRICK_STAIRS);
 
     private static @NotNull Block register(@NotNull String id, @NotNull BlockReplacementRuleBuilder<?, ?> replacementRuleBuilder, @NotNull Block block, @Nullable Supplier<@Nullable LootTable> lootTableSupplier) {
         return register(id, replacementRuleBuilder, block, lootTableSupplier == null ? null : ($ -> lootTableSupplier.get()));
@@ -721,7 +720,7 @@ public class SuCraftBlocks {
                 .withAnalogousFallbacks(fallback)
                 .withDefaultModelCreationsForSlabReplacedBySlab(doubleSlabModelCreation, sideTexture, bottomHalfBottomTexture, bottomHalfTopTexture, topHalfBottomTexture, topHalfTopTexture)
                 .withRealItemRuleFromHostBlock(),
-            new SlabBlock(properties == null ? fullBlock.properties : properties).withAddedTagsLike(fullBlock).slab(),
+            new SlabBlock(properties == null ? BlockBehaviour.Properties.copy(fullBlock).doesNotRequireCorrectToolForDrops() : properties).withAddedTagsLike(fullBlock).slab(),
             SuCraftBlockLoot::dropSingleOrDoubleSlabSelf
         ).withCustomSlabStonecutterRecipe(fullBlock);
     }
@@ -869,14 +868,14 @@ public class SuCraftBlocks {
                 .withAnalogousFallbacks(fallback)
                 .withDefaultModelCreationsForSlabReplacedBySlab(textureBlock != null ? NamespacedKeyWithoutIntention.minecraft(textureBlock) : fullBlock.replacementRule.getModel(fullBlock.defaultBlockState()).model().getKey(), ModelContent.Existing.ExistingModelContentOutwardExpansionType.CUBE)
                 .withRealItemRuleFromHostBlock(),
-            new SlabBlock(properties == null ? fullBlock.properties : properties).withAddedTagsLike(fullBlock).slab(),
+            new SlabBlock(properties == null ? BlockBehaviour.Properties.copy(fullBlock).doesNotRequireCorrectToolForDrops() : properties).withAddedTagsLike(fullBlock).slab(),
             SuCraftBlockLoot::dropSingleOrDoubleSlabSelf
         ).withCustomSlabStonecutterRecipe(fullBlock);
     }
 
     /**
      * Based on {@link Blocks#OAK_STAIRS}
-     * @param textureBlock If null, will be the based on the model of the full block, else it will be assumed to be a default Minecraft model as well as texture namespaced key path (for example 'dirt' will mean the the texture used is 'minecraft:block/dirt')
+     * @param textureBlock If null, will be the based on the model of the full block, else it will be assumed to be a default Minecraft model as well as texture namespaced key path (for example 'dirt' will mean the texture used is 'minecraft:block/dirt')
      * @param fallback If null, will be the same as host
      */
     private static @NotNull Block registerFakeStairs(@NotNull Block fullBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @Nullable String textureBlock, @NotNull Block host, @Nullable Block fallback) {
@@ -889,11 +888,11 @@ public class SuCraftBlocks {
                 .rendersAsEntity()
                 .withAnalogousHosts(host)
                 .withAnalogousFallbacks(fallback)
-                .withDefaultModelCreationsForSlabReplacedBySlab(textureBlock != null ? NamespacedKeyWithoutIntention.minecraft(textureBlock) : fullBlock.replacementRule.getModel(fullBlock.defaultBlockState()).model().getKey(), ModelContent.Existing.ExistingModelContentOutwardExpansionType.CUBE)
+                .withDefaultModelCreationsForStairsReplacedByStairs(textureBlock != null ? NamespacedKeyWithoutIntention.minecraft(textureBlock) : fullBlock.replacementRule.getModel(fullBlock.defaultBlockState()).model().getKey())
                 .withRealItemRuleFromHostBlock(),
-            new SlabBlock(properties == null ? fullBlock.properties : properties).withAddedTagsLike(fullBlock).slab(),
-            SuCraftBlockLoot::dropSingleOrDoubleSlabSelf
-        ).withCustomSlabStonecutterRecipe(fullBlock);
+            new StairBlock(fullBlock.defaultBlockState(), properties == null ? BlockBehaviour.Properties.copy(fullBlock).doesNotRequireCorrectToolForDrops() : properties).withAddedTagsLike(fullBlock).stairs(),
+            SuCraftBlockLoot::dropSelf
+        ).withCustomOneToOneStonecutterRecipe(fullBlock);
     }
 
     private static @NotNull Block registerFakeSlab(@NotNull Block fullBlock, @NotNull String type, @Nullable String textureBlock, @NotNull Block host, @Nullable Block fallback) {
diff --git a/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/BlockReplacementRuleBuilder.java b/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/BlockReplacementRuleBuilder.java
index a734f536b0770e38a85564639af4a52775696e4f..7189a0f1eae94ef88b661a0c243af8433aa9237d 100644
--- a/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/BlockReplacementRuleBuilder.java
+++ b/src/main/java/nl/martijnmuijsers/paper/block/replacementrule/BlockReplacementRuleBuilder.java
@@ -10,9 +10,11 @@ import net.minecraft.world.level.block.BaseFireBlock;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.FireBlock;
+import net.minecraft.world.level.block.StairBlock;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.block.state.properties.SlabType;
+import net.minecraft.world.level.block.state.properties.StairsShape;
 import nl.martijnmuijsers.paper.block.UsedHostBlockStates;
 import nl.martijnmuijsers.paper.blockanditemdata.model.Model;
 import nl.martijnmuijsers.paper.blockanditemdata.model.ModelContent;
@@ -340,9 +342,9 @@ public interface BlockReplacementRuleBuilder<R extends BlockReplacementRule, B e
     }
 
     /**
-     * Set a single host overriding model for the host block, that as a single model encapsulates a slab: the mechanism for this is provided by the parent model already)
+     * Set a single host overriding model for the host block, that as a single model encapsulates a slab: the mechanism for this is provided by the parent model alread)
      *
-     * @param sideTexture             A texture of a block that will be used as a the texture of this slab (the mechanism for this is provided by the parent model already)
+     * @param sideTexture             A texture of a block that will be used as the texture of this slab (the mechanism for this is provided by the parent model already)
      * @param bottomHalfBottomTexture Will be {@param sideTexture} if null
      * @param bottomHalfTopTexture    Will be {@param bottomHalfBottomTexture} if null
      * @param topHalfBottomTexture    Will be {@param bottomHalfTopTexture} if null
@@ -365,7 +367,7 @@ public interface BlockReplacementRuleBuilder<R extends BlockReplacementRule, B e
         final @NotNull Texture finalBottomHalfTopTexture = bottomHalfTopTexture;
         final @NotNull Texture finalTopHalfBottomTexture = topHalfBottomTexture;
         final @NotNull Texture finalTopHalfTopTexture = topHalfTopTexture;
-        return this.withModelCreationForRealState(realState -> {
+        return this.withModelCreationForRealState(realState ->
             switch (realState.getValue(BlockStateProperties.SLAB_TYPE)) {
 //                case BOTTOM, DOUBLE, TOP -> {
 //                    return ((ModelCreation) (intention, key) -> {
@@ -377,18 +379,89 @@ public interface BlockReplacementRuleBuilder<R extends BlockReplacementRule, B e
 //                        return toReturn;
 //                    }).withNoParameters();
 //                }
-                case BOTTOM -> {
-                    return Model.creation(ModelContent.BottomSlab.creationCompanion.creation(finalBottomHalfBottomTexture, sideTexture, finalBottomHalfTopTexture)).withNoParameters();
-                }
-                case DOUBLE -> {
-                    return doubleSlabModelCreation.withNoParameters();
-                }
-                case TOP -> {
-                    return ((ModelCreation) (intention, key) -> Model.creation(ModelContent.TopSlab.creationCompanion.creation(finalTopHalfBottomTexture, sideTexture, finalTopHalfTopTexture)).create(intention, new ResourceLocation(key.getNamespace(), key.getPath() + "_top"))).withNoParameters();
-                }
+                case BOTTOM ->
+                    Model.creation(ModelContent.BottomSlab.creationCompanion.creation(finalBottomHalfBottomTexture, sideTexture, finalBottomHalfTopTexture)).withNoParameters();
+                case DOUBLE ->
+                    doubleSlabModelCreation.withNoParameters();
+                case TOP ->
+                    ((ModelCreation) (intention, key) -> Model.creation(ModelContent.TopSlab.creationCompanion.creation(finalTopHalfBottomTexture, sideTexture, finalTopHalfTopTexture)).create(intention, key.withPathSuffix("_top"))).withNoParameters();
                 default ->
                     throw new IllegalStateException("Unknown slab type: " + realState.getValue(BlockStateProperties.SLAB_TYPE));
             }
+        );
+    }
+
+    /**
+     * @param fullBlockTextureKey A key pointing to the full block texture (used as texture basis for the stairs)
+     * @see #withDefaultModelCreationsForStairsReplacedByStairs
+     */
+    default @NotNull B withDefaultModelCreationsForStairsReplacedByStairs(@NotNull NamespacedKeyWithoutIntention fullBlockTextureKey) {
+        return this.withDefaultModelCreationsForStairsReplacedByStairs(new Texture(ResourcePackAssetIntention.BLOCK, fullBlockTextureKey, TextureContent.Existing.getInstance()), null, null);
+    }
+
+    /**
+     * Set a single host overriding model for the host block, that as a single model encapsulates stairs: the mechanism for this is provided by the parent model already
+     *
+     * @param sideTexture             A texture of a block that will be used as the texture of these stairs (the mechanism for this is provided by the parent model already)
+     * @param bottomTexture Will be {@param sideTexture} if null
+     * @param topTexture    Will be {@param bottomTexture} if null
+     */
+    default @NotNull B withDefaultModelCreationsForStairsReplacedByStairs(@NotNull Texture sideTexture, @Nullable Texture bottomTexture, @Nullable Texture topTexture) {
+        if (bottomTexture == null) {
+            bottomTexture = sideTexture;
+        }
+        if (topTexture == null) {
+            topTexture = bottomTexture;
+        }
+        final @NotNull Texture finalBottomTexture = bottomTexture;
+        final @NotNull Texture finalTopTexture = topTexture;
+        return this.withModelCreationForRealState(realState -> {
+
+            var shape = realState.getValue(StairBlock.SHAPE);
+            var half = realState.getValue(StairBlock.HALF);
+            var facing = realState.getValue(StairBlock.FACING);
+
+            // Outer stairs look the same as a different direction of inner stairs, so we create only a model for inner stairs, and replace the outer stairs by the right inner stairs
+            if (shape == StairsShape.INNER_RIGHT || shape == StairsShape.OUTER_RIGHT) {
+                shape = shape == StairsShape.INNER_RIGHT ? StairsShape.INNER_LEFT : StairsShape.OUTER_LEFT;
+            } else if (shape == StairsShape.INNER_LEFT || shape == StairsShape.OUTER_LEFT) {
+                facing = switch (facing) {
+                    case NORTH -> Direction.WEST;
+                    case WEST -> Direction.SOUTH;
+                    case EAST -> Direction.NORTH;
+                    case SOUTH -> Direction.EAST;
+                    case DOWN, UP -> throw new IllegalStateException("Illegal stairs direction: " + facing);
+                };
+            }
+
+            String stateSuffix = "_" + switch (shape) {
+                case STRAIGHT -> "a";
+                case INNER_LEFT -> "i";
+                case OUTER_LEFT -> "o";
+                case INNER_RIGHT, OUTER_RIGHT -> throw new IllegalStateException("Shape without model: " + shape);
+            } + switch (half) {
+                case TOP -> "t";
+                case BOTTOM -> "b";
+            } + switch (facing) {
+                case NORTH -> "n";
+                case WEST -> "w";
+                case EAST -> "e";
+                case SOUTH -> "s";
+                case DOWN, UP -> throw new IllegalStateException("Illegal stairs direction: " + facing);
+            };
+            final var finalFacing = facing;
+            final var creationCompanion = switch (shape) {
+                case STRAIGHT ->
+                    ModelContent.StraightStairs.creationCompanion;
+                case INNER_LEFT ->
+                    ModelContent.InnerLeftStairs.creationCompanion;
+                case OUTER_LEFT ->
+                    ModelContent.OuterLeftStairs.creationCompanion;
+                default ->
+                    throw new IllegalStateException("Unknown or illegal stairs shape: " + realState.getValue(BlockStateProperties.STAIRS_SHAPE));
+            };
+            return ((ModelCreation) (intention, key) -> Model.creation(creationCompanion.creation(finalBottomTexture, sideTexture, finalTopTexture, half, finalFacing)).create(intention, key.withPathSuffix(stateSuffix))).withNoParameters();
+
         });
     }
 
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/Model.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/Model.java
index 47ebb61c2ab6759f2d903d40c78370f91bafecdd..69f91b1cc88165e09b6b760a5374a5e968838da7 100644
--- a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/Model.java
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/Model.java
@@ -2,8 +2,10 @@
 
 package nl.martijnmuijsers.paper.blockanditemdata.model;
 
+import net.minecraft.core.Direction;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.level.block.state.properties.Half;
 import nl.martijnmuijsers.paper.blockanditemdata.texture.Texture;
 import nl.martijnmuijsers.paper.blockanditemdata.texture.TextureContent;
 import nl.martijnmuijsers.paper.blockanditemdata.texture.TextureContentCreation;
@@ -201,4 +203,67 @@ public class Model extends ResourcePackIntentionedAssetDataByContent<ModelConten
 
     }
 
+    /**
+     * @see ModelContent.StraightStairs
+     */
+    public static final class StraightStairs {
+
+        private StraightStairs() {}
+
+        public static @NotNull ModelCreation defaultCreation(@NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.StraightStairs.creationCompanion.defaultCreation(half, facing));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull Texture bottomTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.StraightStairs.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture, half, facing));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation topTexture, @NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.StraightStairs.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture, half, facing));
+        }
+
+    }
+
+    /**
+     * @see ModelContent.InnerLeftStairs
+     */
+    public static final class InnerLeftStairs {
+
+        private InnerLeftStairs() {}
+
+        public static @NotNull ModelCreation defaultCreation(@NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.InnerLeftStairs.creationCompanion.defaultCreation(half, facing));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull Texture bottomTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.InnerLeftStairs.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture, half, facing));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation topTexture, @NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.InnerLeftStairs.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture, half, facing));
+        }
+
+    }
+
+    /**
+     * @see ModelContent.OuterLeftStairs
+     */
+    public static final class OuterLeftStairs {
+
+        private OuterLeftStairs() {}
+
+        public static @NotNull ModelCreation defaultCreation(@NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.OuterLeftStairs.creationCompanion.defaultCreation(half, facing));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull Texture bottomTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.OuterLeftStairs.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture, half, facing));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation topTexture, @NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.OuterLeftStairs.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture, half, facing));
+        }
+
+    }
+
 }
diff --git a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelContent.java b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelContent.java
index 1b0a53d5db5b9c63f6fa83462b47578994c123f5..2fabfd40629766c0eb16325733a5ec63fce7f65a 100644
--- a/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelContent.java
+++ b/src/main/java/nl/martijnmuijsers/paper/blockanditemdata/model/ModelContent.java
@@ -3,9 +3,13 @@
 package nl.martijnmuijsers.paper.blockanditemdata.model;
 
 import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonParser;
+import net.minecraft.core.Direction;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.level.block.state.properties.Half;
 import nl.martijnmuijsers.paper.blockanditemdata.texture.Texture;
 import nl.martijnmuijsers.paper.blockanditemdata.texture.TextureContent;
 import nl.martijnmuijsers.paper.blockanditemdata.texture.TextureContentCreation;
@@ -18,9 +22,12 @@ import nl.martijnmuijsers.paper.resourcepack.asset.intention.ResourcePackAssetIn
 import nl.martijnmuijsers.paper.resourcepack.asset.texture.MutableResourcePackTexture;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
+import org.json.simple.JSONObject;
 
 import java.util.Arrays;
 import java.util.EnumMap;
+import java.util.Locale;
+import java.util.Map;
 import java.util.function.Function;
 import java.util.function.Supplier;
 
@@ -451,6 +458,588 @@ public abstract class ModelContent implements ResourcePackAssetDataContent {
 
     }
 
+    /**
+     * Utility class to help with models that have elements that may need to be transformed within the model (rotated or flipped)
+     */
+    public static class TransformableElement {
+
+        public static class TransformableEndpoint {
+
+            private float x, y, z;
+
+            public TransformableEndpoint(float x, float y, float z) {
+                this.x = x;
+                this.y = y;
+                this.z = z;
+            }
+
+            public @NotNull JsonArray toJson() {
+                @NotNull JsonArray json = new JsonArray(3);
+                json.add(this.x);
+                json.add(this.y);
+                json.add(this.z);
+                return json;
+            }
+
+            public void transformAccordingToState(@NotNull Half half, @NotNull Direction facing) {
+                float newX = switch (facing) {
+                    case EAST -> x;
+                    case NORTH -> z;
+                    case WEST -> 16 - x;
+                    case SOUTH -> 16 - z;
+                    default -> throw new IllegalArgumentException("Illegal stairs direction: " + facing);
+                };
+                float newY = switch (half) {
+                    case TOP -> 16 - y;
+                    case BOTTOM -> y;
+                };
+                float newZ = switch (facing) {
+                    case EAST -> z;
+                    case NORTH -> 16 - x;
+                    case WEST -> 16 - z;
+                    case SOUTH -> x;
+                    default -> throw new IllegalArgumentException("Illegal stairs direction: " + facing);
+                };
+                this.x = newX;
+                this.y = newY;
+                this.z = newZ;
+            }
+
+            private float getCoordinate(int axis) {
+                return switch (axis) {
+                    case 0 -> this.x;
+                    case 1 -> this.y;
+                    case 2 -> this.z;
+                    default -> throw new IllegalArgumentException(("Invalid axis index: " + axis));
+                };
+            }
+
+            private void setCoordinate(int axis, float coordinate) {
+                switch (axis) {
+                    case 0 -> this.x = coordinate;
+                    case 1 -> this.y = coordinate;
+                    case 2 -> this.z = coordinate;
+                    default -> throw new IllegalArgumentException(("Invalid axis index: " + axis));
+                };
+            }
+
+            public void swapCoordinatesAsFirstEndpoint(@NotNull TransformableEndpoint secondEndpoint) {
+                for (int axis = 0; axis < 3; axis++) {
+                    if (this.getCoordinate(axis) > secondEndpoint.getCoordinate(axis)) {
+                        float temp = this.getCoordinate(axis);
+                        this.setCoordinate(axis, secondEndpoint.getCoordinate(axis));
+                        secondEndpoint.setCoordinate(axis, temp);
+                    }
+                }
+            }
+
+        }
+
+        public static class TransformableFace {
+
+            public static class TransformableUV {
+
+                public static class TransformableUVEndpoint {
+
+                    private int x, y;
+
+                    public TransformableUVEndpoint(int x, int y) {
+                        this.x = x;
+                        this.y = y;
+                    }
+
+                    public @NotNull JsonArray toJson() {
+                        @NotNull JsonArray json = new JsonArray();
+                        json.add(this.x);
+                        json.add(this.y);
+                        return json;
+                    }
+
+                    public void rotate90DegreesAroundTangentAxis() {
+                        int newX = y;
+                        int newY = 16 - x;
+                        this.x = newX;
+                        this.y = newY;
+                    }
+
+                    public void flipInY() {
+                        this.y = 16 - y;
+                    }
+
+                    private int getCoordinate(int axis) {
+                        return switch (axis) {
+                            case 0 -> this.x;
+                            case 1 -> this.y;
+                            default -> throw new IllegalArgumentException(("Invalid axis index: " + axis));
+                        };
+                    }
+
+                    private void setCoordinate(int axis, int coordinate) {
+                        switch (axis) {
+                            case 0 -> this.x = coordinate;
+                            case 1 -> this.y = coordinate;
+                            default -> throw new IllegalArgumentException(("Invalid axis index: " + axis));
+                        };
+                    }
+
+                    public void swapCoordinatesAsFirstEndpoint(@NotNull TransformableUVEndpoint secondEndpoint) {
+                        for (int axis = 0; axis < 2; axis++) {
+                            if (this.getCoordinate(axis) > secondEndpoint.getCoordinate(axis)) {
+                                int temp = this.getCoordinate(axis);
+                                this.setCoordinate(axis, secondEndpoint.getCoordinate(axis));
+                                secondEndpoint.setCoordinate(axis, temp);
+                            }
+                        }
+                    }
+
+                }
+
+                private final @NotNull TransformableUVEndpoint from, to;
+
+                public TransformableUV(@NotNull TransformableUVEndpoint from, @NotNull TransformableUVEndpoint to) {
+                    this.from = from;
+                    this.to = to;
+                }
+
+                public TransformableUV(@NotNull JsonArray json) {
+                    this(new TransformableUVEndpoint(json.get(0).getAsInt(), json.get(1).getAsInt()), new TransformableUVEndpoint(json.get(2).getAsInt(), json.get(3).getAsInt()));
+                }
+
+                public @NotNull JsonArray toJson() {
+                    @NotNull JsonArray json = new JsonArray();
+                    json.addAll(this.from.toJson());
+                    json.addAll(this.to.toJson());
+                    return json;
+                }
+
+                public void rotate90DegreesAroundTangentAxis() {
+                    this.from.rotate90DegreesAroundTangentAxis();
+                    this.to.rotate90DegreesAroundTangentAxis();
+                    this.from.swapCoordinatesAsFirstEndpoint(this.to);
+                }
+
+                public void flipInY() {
+                    this.from.flipInY();
+                    this.to.flipInY();
+                    this.from.swapCoordinatesAsFirstEndpoint(this.to);
+                }
+
+            }
+
+            private @NotNull Direction facing;
+            private final @NotNull TransformableUV uv;
+            private final @NotNull String texture;
+            private final boolean cullable;
+
+            public TransformableFace(@NotNull Direction facing, @NotNull TransformableUV uv, @NotNull String texture, boolean cullable) {
+                this.facing = facing;
+                this.uv = uv;
+                this.texture = texture;
+                this.cullable = cullable;
+            }
+
+            public TransformableFace(@NotNull Direction facing, @NotNull JsonObject json) {
+                this(facing, new TransformableUV(json.getAsJsonArray("uv")), json.get("texture").getAsString(), json.has("cullface"));
+            }
+
+            public TransformableFace(@NotNull Map.Entry<@NotNull String, @NotNull JsonElement> jsonEntry) {
+                this(Direction.valueOf(jsonEntry.getKey().toUpperCase(Locale.ROOT)), jsonEntry.getValue().getAsJsonObject());
+            }
+
+            public @NotNull Direction getFacing() {
+                return this.facing;
+            }
+
+            public @NotNull JsonObject toJson() {
+                @NotNull JsonObject json = new JsonObject();
+                json.add("uv", uv.toJson());
+                json.addProperty("texture", this.texture);
+                if (this.cullable) {
+                    json.addProperty("cullface", this.facing.name().toLowerCase(Locale.ROOT));
+                }
+                return json;
+            }
+
+            public void transformAccordingToState(@NotNull Half half, @NotNull Direction facing) {
+//                if (half == Half.TOP && this.facing == Direction.UP) {
+//                    System.out.println("TEMP DEBUG - " + System.identityHashCode(this) + " - I'm originally upwards in top, and my uv is " + this.uv.toJson().toString());
+//                }
+                // For sides, we can just switch which face represents which direction based on facing, and keep the uv coordinates the same
+                int rotations = switch (facing) {
+                    case EAST -> 0;
+                    case SOUTH -> 3;
+                    case WEST -> 2;
+                    case NORTH -> 1;
+                    default -> throw new IllegalArgumentException("Illegal stairs direction: " + facing);
+                };
+                for (int rotation = 0; rotation < rotations; rotation++) {
+                    if (this.facing.getAxis().isHorizontal()) {
+                        this.facing = switch (this.facing) {
+                            case EAST -> Direction.NORTH;
+                            case SOUTH -> Direction.EAST;
+                            case WEST -> Direction.SOUTH;
+                            case NORTH -> Direction.WEST;
+                            default -> throw new IllegalStateException("Illegal stairs direction: " + this.facing);
+                        };
+                    } else {
+                        // Rotate the vertical faces simply by transforming the uv coordinates according to the rotation around the y axis, and then fix the coordinates to make the first endpoint coordinate in each axis smaller than the corresponding second endpoint coordinate
+                        uv.rotate90DegreesAroundTangentAxis();
+                    }
+                }
+//                if (half == Half.TOP && this.facing == Direction.UP) {
+//                    System.out.println("TEMP DEBUG - " + System.identityHashCode(this) + " - After " + rotations + " face rotations my uv is " + this.uv.toJson().toString());
+//                }
+                // Half-based changes are only needed for the top
+                if (half == Half.TOP) {
+                    // For the top and bottom, we switch which face represents which direction based on half
+                    if (this.facing.getAxis().isVertical()) {
+                        this.facing = this.facing == Direction.UP ? Direction.DOWN : Direction.UP;
+                        // Fix the uv for faces that now face downwards
+                        if (this.facing == Direction.DOWN) {
+                            if (facing == Direction.NORTH || facing == Direction.SOUTH) {
+                                this.uv.flipInY();
+                            }
+                        }
+                    } else {
+                        // Flip the horizontal faces simply by flipping the uv y coordinates , and then fix the coordinates to make the first endpoint coordinate in each axis smaller than the corresponding second endpoint coordinate
+                        this.uv.flipInY();
+                    }
+                }
+//                if (half == Half.TOP && this.facing == Direction.DOWN) {
+//                    System.out.println("TEMP DEBUG - " + System.identityHashCode(this) + " - Afterwards I'm downwards and my uv is " + this.uv.toJson().toString());
+//                }
+            }
+
+        }
+
+        private final @NotNull TransformableEndpoint from;
+        private final @NotNull TransformableEndpoint to;
+        private @NotNull TransformableFace @NotNull [] faces;
+
+        public TransformableElement(@NotNull TransformableEndpoint from, @NotNull TransformableEndpoint to, @NotNull TransformableFace @NotNull [] faces) {
+            this.from = from;
+            this.to = to;
+            this.faces = faces;
+        }
+
+        public TransformableElement(@NotNull TransformableEndpoint from, @NotNull TransformableEndpoint to, @NotNull String facesJsonString) {
+            this(from, to, JsonParser.parseString(facesJsonString).getAsJsonObject().entrySet().stream().map(TransformableFace::new).toArray(TransformableFace[]::new));
+        }
+
+        public @NotNull JsonObject toJson() {
+            @NotNull JsonObject json = new JsonObject();
+            json.add("from", this.from.toJson());
+            json.add("to", this.to.toJson());
+            @NotNull JsonObject facesJson = new JsonObject();
+            for (@NotNull TransformableFace face : this.faces) {
+                facesJson.add(face.getFacing().name().toLowerCase(Locale.ROOT), face.toJson());
+            }
+            json.add("faces", facesJson);
+            return json;
+        }
+
+        public void transformAccordingToState(@NotNull Half half, @NotNull Direction facing) {
+            // Transform the endpoints individually
+            this.from.transformAccordingToState(half, facing);
+            this.to.transformAccordingToState(half, facing);
+            // Flip coordinates where the from endpoint coordinate is greater than the to endpoint coordinate (which causes the texture to be rendered on the wrong side of the surface)
+            this.from.swapCoordinatesAsFirstEndpoint(this.to);
+            // Transform the faces
+            for (@NotNull TransformableFace face : this.faces) {
+                face.transformAccordingToState(half, facing);
+            }
+        }
+
+    }
+
+    public static abstract class AbstractStairs extends AbstractBottomTopPillarCube {
+
+        public final @NotNull Half half;
+        public final @NotNull Direction facing;
+
+        public AbstractStairs(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+            super(bottomTexture, sideTexture, topTexture);
+            this.half = half;
+            this.facing = facing;
+        }
+
+        public static abstract class CreationCompanion<M extends AbstractStairs> {
+
+            protected abstract @NotNull M construct(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing);
+
+            public @NotNull M create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key, @NotNull TextureCreation bottomTexture, @NotNull TextureCreation sideTexture, @NotNull TextureCreation topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return this.construct(bottomTexture.create(intention, key), sideTexture.create(intention, key), topTexture.create(intention, key), half, facing);
+            }
+
+            public @NotNull ModelContentCreation creation(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return (intention, key) -> this.construct(bottomTexture, sideTexture, topTexture, half, facing);
+            }
+
+            public @NotNull ModelContentCreation creation(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation sideTexture, @NotNull TextureCreation topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return (intention, key) -> this.create(intention, key, bottomTexture, sideTexture, topTexture, half, facing);
+            }
+
+            public @NotNull ModelContentCreation defaultCreation(@NotNull Half half, @NotNull Direction facing) {
+                return creation(Texture.defaultBottomCreation(), Texture.defaultCreation(), Texture.defaultTopCreation(), half, facing);
+            }
+
+            public @NotNull ModelContentCreation defaultCreationWithAlternativeBottomTop(@NotNull Texture bottomTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return this.defaultCreationWithAlternativeBottomTop((intention, key) -> bottomTexture, (intention, key) -> topTexture, half, facing);
+            }
+
+            public @NotNull ModelContentCreation defaultCreationWithAlternativeBottomTop(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return (intention, key) -> this.create(intention, key, bottomTexture, Texture.defaultCreation(), topTexture, half, facing);
+            }
+
+        }
+
+    }
+
+    /**
+     * A form of {@link ModelContent}: straight (not inner or outer) stairs with one texture for the bottom, one textures for the x- and z-oriented sides (representing the texture along the entire face, of which a stair-shaped cut will be used), and one texture for the top
+     */
+    public static final class StraightStairs extends AbstractStairs {
+
+        private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("stairs"), Existing.getInstance());
+
+        // Based on vanilla Minecraft resource file /assets/minecraft/models/block/stairs.json
+        public static @NotNull JsonArray getStraightStairsOutwardExpandedElements(float outwardDistance, @NotNull Half half, @NotNull Direction facing) {
+            float from = -outwardDistance;
+            float to = 16 + outwardDistance;
+            float afterMiddle = 8 + outwardDistance;
+            float beforeMiddle = 8 - outwardDistance;
+            // Initialize the physical coordinates as they would be before state modifications (so currently only the default coordinates with the outward distance applied)
+            TransformableElement[] elements = {
+                new TransformableElement(
+                    new TransformableElement.TransformableEndpoint(from, from, from),
+                    new TransformableElement.TransformableEndpoint(to, afterMiddle, to),
+                    """
+                        {
+                            "down":  { "uv": [ 0, 0, 16, 16 ], "texture": "#bottom", "cullface": "down" },
+                            "up":    { "uv": [ 0, 0, 16, 16 ], "texture": "#top" },
+                            "north": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "north" },
+                            "south": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "south" },
+                            "west":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "west" },
+                            "east":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "east" }
+                        }"""
+                ),
+                new TransformableElement(
+                    new TransformableElement.TransformableEndpoint(beforeMiddle, afterMiddle, from),
+                    new TransformableElement.TransformableEndpoint(to, to, to),
+                    """
+                        {
+                            "up":    { "uv": [ 8, 0, 16, 16 ], "texture": "#top", "cullface": "up" },
+                            "north": { "uv": [ 0, 0,  8,  8 ], "texture": "#side", "cullface": "north" },
+                            "south": { "uv": [ 8, 0, 16,  8 ], "texture": "#side", "cullface": "south" },
+                            "west":  { "uv": [ 0, 0, 16,  8 ], "texture": "#side" },
+                            "east":  { "uv": [ 0, 0, 16,  8 ], "texture": "#side", "cullface": "east" }
+                        }"""
+                )
+            };
+            // Transform the elements according to the state (half and facing)
+            for (TransformableElement element : elements) {
+                element.transformAccordingToState(half, facing);
+            }
+            // Return the elements
+            JsonArray elementsJson = new JsonArray();
+            for (TransformableElement element : elements) {
+                elementsJson.add(element.toJson());
+            }
+            return elementsJson;
+        }
+
+        public StraightStairs(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+            super(bottomTexture, sideTexture, topTexture, half, facing);
+        }
+
+        @Override
+        protected @NotNull Model getParent() {
+            return parent;
+        }
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(float outwardDistance) {
+            return getStraightStairsOutwardExpandedElements(outwardDistance, this.half, this.facing);
+        }
+
+        public static final @NotNull CreationCompanion<StraightStairs> creationCompanion = new CreationCompanion<>() {
+
+            @Override
+            protected @NotNull StraightStairs construct(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return new StraightStairs(bottomTexture, sideTexture, topTexture, half, facing);
+            }
+
+        };
+
+    }
+
+    /**
+     * A form of {@link ModelContent}: left inner stairs with one texture for the bottom, one textures for the x- and z-oriented sides (representing the texture along the entire face, of which a stair-shaped cut will be used), and one texture for the top
+     */
+    public static final class InnerLeftStairs extends AbstractStairs {
+
+        private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("inner_stairs"), Existing.getInstance());
+
+        // Based on vanilla Minecraft resource file /assets/minecraft/models/block/inner_stairs.json
+        public static @NotNull JsonArray getInnerLeftStairsOutwardExpandedElements(float outwardDistance, @NotNull Half half, @NotNull Direction facing) {
+            float from = -outwardDistance;
+            float to = 16 + outwardDistance;
+            float afterMiddle = 8 + outwardDistance;
+            float beforeMiddle = 8 - outwardDistance;
+            // Initialize the physical coordinates as they would be before state modifications (so currently only the default coordinates with the outward distance applied)
+            TransformableElement[] elements = {
+                new TransformableElement(
+                    new TransformableElement.TransformableEndpoint(from, from, from),
+                    new TransformableElement.TransformableEndpoint(to, afterMiddle, to),
+                    """
+                        {
+                 			"down":  { "uv": [ 0, 0, 16, 16 ], "texture": "#bottom", "cullface": "down" },
+                 			"up":    { "uv": [ 0, 0, 16, 16 ], "texture": "#top" },
+                 			"north": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "north" },
+                 			"south": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "south" },
+                 			"west":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "west" },
+                 			"east":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "east" }
+                 		}"""
+                ),
+                new TransformableElement(
+                    new TransformableElement.TransformableEndpoint(beforeMiddle, afterMiddle, from),
+                    new TransformableElement.TransformableEndpoint(to, to, to),
+                    """
+                        {
+                 			"up":    { "uv": [ 8, 0, 16, 16 ], "texture": "#top", "cullface": "up" },
+                 			"north": { "uv": [ 0, 0,  8,  8 ], "texture": "#side", "cullface": "north" },
+                 			"south": { "uv": [ 8, 0, 16,  8 ], "texture": "#side", "cullface": "south" },
+                 			"west":  { "uv": [ 0, 0, 16,  8 ], "texture": "#side" },
+                 			"east":  { "uv": [ 0, 0, 16,  8 ], "texture": "#side", "cullface": "east" }
+                 		}"""
+                ),
+                new TransformableElement(
+                    new TransformableElement.TransformableEndpoint(from, afterMiddle, beforeMiddle),
+                    new TransformableElement.TransformableEndpoint(beforeMiddle, to, to),
+                    """
+                        {
+                 			"up":    { "uv": [ 0, 8,  8, 16 ], "texture": "#top", "cullface": "up" },
+                 			"north": { "uv": [ 8, 0, 16,  8 ], "texture": "#side" },
+                 			"south": { "uv": [ 0, 0,  8,  8 ], "texture": "#side", "cullface": "south" },
+                 			"west":  { "uv": [ 8, 0, 16,  8 ], "texture": "#side", "cullface": "west" }
+                 		}"""
+                )
+            };
+            // Transform the elements according to the state (half and facing)
+            for (TransformableElement element : elements) {
+                element.transformAccordingToState(half, facing);
+            }
+            // Return the elements
+            JsonArray elementsJson = new JsonArray();
+            for (TransformableElement element : elements) {
+                elementsJson.add(element.toJson());
+            }
+            return elementsJson;
+        }
+
+        public InnerLeftStairs(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+            super(bottomTexture, sideTexture, topTexture, half, facing);
+        }
+
+        @Override
+        protected @NotNull Model getParent() {
+            return parent;
+        }
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(float outwardDistance) {
+            return getInnerLeftStairsOutwardExpandedElements(outwardDistance, this.half, this.facing);
+        }
+
+        public static final @NotNull CreationCompanion<InnerLeftStairs> creationCompanion = new CreationCompanion<>() {
+
+            @Override
+            protected @NotNull InnerLeftStairs construct(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return new InnerLeftStairs(bottomTexture, sideTexture, topTexture, half, facing);
+            }
+
+        };
+
+    }
+
+    /**
+     * A form of {@link ModelContent}: left outer stairs with one texture for the bottom, one textures for the x- and z-oriented sides (representing the texture along the entire face, of which a stair-shaped cut will be used), and one texture for the top
+     */
+    public static final class OuterLeftStairs extends AbstractStairs {
+
+        private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("outer_stairs"), Existing.getInstance());
+
+        // Based on vanilla Minecraft resource file /assets/minecraft/models/block/outer_stairs.json
+        public static @NotNull JsonArray getOuterLeftStairsOutwardExpandedElements(float outwardDistance, @NotNull Half half, @NotNull Direction facing) {
+            float from = -outwardDistance;
+            float to = 16 + outwardDistance;
+            float afterMiddle = 8 + outwardDistance;
+            float beforeMiddle = 8 - outwardDistance;
+            // Initialize the physical coordinates as they would be before state modifications (so currently only the default coordinates with the outward distance applied)
+            TransformableElement[] elements = {
+                new TransformableElement(
+                    new TransformableElement.TransformableEndpoint(from, from, from),
+                    new TransformableElement.TransformableEndpoint(to, afterMiddle, to),
+                    """
+                        {
+                 			"down":  { "uv": [ 0, 0, 16, 16 ], "texture": "#bottom", "cullface": "down" },
+                 			"up":    { "uv": [ 0, 0, 16, 16 ], "texture": "#top" },
+                 			"north": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "north" },
+                 			"south": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "south" },
+                 			"west":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "west" },
+                 			"east":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "east" }
+                 		}"""
+                ),
+                new TransformableElement(
+                    new TransformableElement.TransformableEndpoint(beforeMiddle, afterMiddle, beforeMiddle),
+                    new TransformableElement.TransformableEndpoint(to, to, to),
+                    """
+                        {
+                 			"up":    { "uv": [ 8, 8, 16, 16 ], "texture": "#top", "cullface": "up" },
+                 			"north": { "uv": [ 0, 0,  8,  8 ], "texture": "#side" },
+                 			"south": { "uv": [ 8, 0, 16,  8 ], "texture": "#side", "cullface": "south" },
+                 			"west":  { "uv": [ 8, 0, 16,  8 ], "texture": "#side" },
+                 			"east":  { "uv": [ 0, 0,  8,  8 ], "texture": "#side", "cullface": "east" }
+                 		}"""
+                )
+            };
+            // Transform the elements according to the state (half and facing)
+            for (TransformableElement element : elements) {
+                element.transformAccordingToState(half, facing);
+            }
+            // Return the elements
+            JsonArray elementsJson = new JsonArray();
+            for (TransformableElement element : elements) {
+                elementsJson.add(element.toJson());
+            }
+            return elementsJson;
+        }
+
+        public OuterLeftStairs(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+            super(bottomTexture, sideTexture, topTexture, half, facing);
+        }
+
+        @Override
+        protected @NotNull Model getParent() {
+            return parent;
+        }
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(float outwardDistance) {
+            return getOuterLeftStairsOutwardExpandedElements(outwardDistance, this.half, this.facing);
+        }
+
+        public static final @NotNull CreationCompanion<OuterLeftStairs> creationCompanion = new CreationCompanion<>() {
+
+            @Override
+            protected @NotNull OuterLeftStairs construct(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return new OuterLeftStairs(bottomTexture, sideTexture, topTexture, half, facing);
+            }
+
+        };
+
+    }
+
     /**
      * A basic form of {@link ModelContent}: a fire model (which is one of several models displayed simultaneously in a fire block: see the fire blockstates)
      */
diff --git a/src/main/java/nl/martijnmuijsers/paper/item/SuCraftItems.java b/src/main/java/nl/martijnmuijsers/paper/item/SuCraftItems.java
index 3959a2fcb4dc08183e73f2fee31f3b33d618a18b..736cf46f2b2330b8301179f380d308f3348136c7 100644
--- a/src/main/java/nl/martijnmuijsers/paper/item/SuCraftItems.java
+++ b/src/main/java/nl/martijnmuijsers/paper/item/SuCraftItems.java
@@ -328,6 +328,7 @@ public class SuCraftItems {
     public static final Item OBSIDIAN_SLAB = registerSlab(SuCraftBlocks.OBSIDIAN_SLAB, "Obsidian");
     public static final Item CRYING_OBSIDIAN_SLAB = registerSlab(SuCraftBlocks.CRYING_OBSIDIAN_SLAB, "Crying Obsidian");
     public static final Item GILDED_BLACKSTONE_SLAB = registerSlab(SuCraftBlocks.GILDED_BLACKSTONE_SLAB, "Gilded Blackstone");
+    public static final Item SNOWY_STONE_BRICK_STAIRS = registerStairs(SuCraftBlocks.SNOWY_STONE_BRICK_STAIRS, "Snowy Stone Brick");
 
     private static @NotNull Item registerBlock(@NotNull Block block, @NotNull String displayName, CreativeModeTab group) {
         return registerBlock(block, displayName, group, null);
@@ -431,6 +432,13 @@ public class SuCraftItems {
         return registerBlock(block, typeDisplayName + " Slab", CreativeModeTab.TAB_BUILDING_BLOCKS);
     }
 
+    /**
+     * Based on {@link Items#OAK_STAIRS}
+     */
+    private static @NotNull Item registerStairs(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerBlock(block, typeDisplayName + " Stairs", CreativeModeTab.TAB_BUILDING_BLOCKS);
+    }
+
     private static @NotNull Item registerPlankSlab(@NotNull Block block, @NotNull String typeDisplayName) {
         return registerSlab(block, typeDisplayName + " Plank");
     }
diff --git a/src/main/java/nl/martijnmuijsers/paper/resourcepack/memory/MemoryResourcePack.java b/src/main/java/nl/martijnmuijsers/paper/resourcepack/memory/MemoryResourcePack.java
index b27a82e34369fe878b47b870d3ba1d8211a946c4..e721dc9e5b948e328e643da963ba456f0d310848 100644
--- a/src/main/java/nl/martijnmuijsers/paper/resourcepack/memory/MemoryResourcePack.java
+++ b/src/main/java/nl/martijnmuijsers/paper/resourcepack/memory/MemoryResourcePack.java
@@ -172,6 +172,7 @@ public class MemoryResourcePack implements MutableResourcePack {
     public void writeToFile(@NotNull File file) throws IOException {
         try (@NotNull FileOutputStream fileOutputStream = new FileOutputStream(file)) {
             try (@NotNull ZipOutputStream zipOutputStream = new ZipOutputStream(fileOutputStream)) {
+                zipOutputStream.setLevel(9);
                 @NotNull Set<@NotNull String> zippedFilePaths = new HashSet<>();
                 // Add the settings
                 {
