From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Wed, 12 Jan 2022 15:18:27 +0100
Subject: [PATCH] Fourth version of chunk sending


diff --git a/src/main/java/io/papermc/paper/network/ChunkPacket.java b/src/main/java/io/papermc/paper/network/ChunkPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..71ff490d5c8e8c91011fbba35c4c9f9d88aecb91
--- /dev/null
+++ b/src/main/java/io/papermc/paper/network/ChunkPacket.java
@@ -0,0 +1,15 @@
+package io.papermc.paper.network;
+
+import net.minecraft.world.level.ChunkPos;
+
+public interface ChunkPacket {
+
+    int getRelatedChunkX();
+
+    int getRelatedChunkZ();
+
+    default long getRelatedChunkLongKey() {
+        return new ChunkPos(getRelatedChunkX(), getRelatedChunkZ()).longKey;
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/network/EntityAddPacket.java b/src/main/java/io/papermc/paper/network/EntityAddPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..5e98f5c92715b9fcfa487fd421403734267a5a51
--- /dev/null
+++ b/src/main/java/io/papermc/paper/network/EntityAddPacket.java
@@ -0,0 +1,3 @@
+package io.papermc.paper.network;
+
+public interface EntityAddPacket extends ChunkPacket, EntityIdPacket {}
diff --git a/src/main/java/io/papermc/paper/network/EntityIdPacket.java b/src/main/java/io/papermc/paper/network/EntityIdPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..a347af18098d48f49a147e23b01f1521a1b7d768
--- /dev/null
+++ b/src/main/java/io/papermc/paper/network/EntityIdPacket.java
@@ -0,0 +1,17 @@
+package io.papermc.paper.network;
+
+import it.unimi.dsi.fastutil.ints.IntList;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientGamePacketListener;
+import org.jetbrains.annotations.Nullable;
+
+public interface EntityIdPacket extends EntityIdsPacket {
+
+    int getRelatedEntityId();
+
+    @Override
+    default IntList getRelatedEntityIds() {
+        return IntList.of(getRelatedEntityId());
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/network/EntityIdsPacket.java b/src/main/java/io/papermc/paper/network/EntityIdsPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..08725efb0780838d02a22d58ad88a4763abf15d2
--- /dev/null
+++ b/src/main/java/io/papermc/paper/network/EntityIdsPacket.java
@@ -0,0 +1,9 @@
+package io.papermc.paper.network;
+
+import it.unimi.dsi.fastutil.ints.IntList;
+
+public interface EntityIdsPacket {
+
+    IntList getRelatedEntityIds();
+
+}
diff --git a/src/main/java/io/papermc/paper/network/EntityIdsPacketHolder.java b/src/main/java/io/papermc/paper/network/EntityIdsPacketHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..1dec38cc330128c77566c75185fc238c1b3389a9
--- /dev/null
+++ b/src/main/java/io/papermc/paper/network/EntityIdsPacketHolder.java
@@ -0,0 +1,19 @@
+package io.papermc.paper.network;
+
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
+import it.unimi.dsi.fastutil.ints.IntList;
+import net.minecraft.network.Connection;
+import net.minecraft.network.protocol.Packet;
+import org.jetbrains.annotations.Nullable;
+
+public class EntityIdsPacketHolder extends Connection.PacketHolder {
+
+    public final IntList entityIds;
+
+    public EntityIdsPacketHolder(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback, IntList entityIds) {
+        super(packet, callback);
+        this.entityIds = entityIds;
+    }
+
+}
diff --git a/src/main/java/net/minecraft/network/Connection.java b/src/main/java/net/minecraft/network/Connection.java
index 81dde0efc1a06420c0791520b9e40b24dd1f0318..78beb9c8fec098868d1734572263105965edde05 100644
--- a/src/main/java/net/minecraft/network/Connection.java
+++ b/src/main/java/net/minecraft/network/Connection.java
@@ -19,7 +19,6 @@ import io.netty.channel.epoll.EpollSocketChannel;
 import io.netty.channel.local.LocalChannel;
 import io.netty.channel.local.LocalServerChannel;
 import io.netty.channel.nio.NioEventLoopGroup;
-import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.handler.timeout.ReadTimeoutHandler;
 import io.netty.handler.timeout.TimeoutException;
@@ -28,21 +27,59 @@ import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
 import java.util.Queue;
+import java.util.function.BiConsumer;
+import java.util.function.Consumer;
+import java.util.function.Supplier;
+import java.util.stream.Stream;
 import javax.annotation.Nullable;
-import javax.crypto.Cipher;
+
+import io.papermc.paper.network.ChunkPacket;
+import io.papermc.paper.network.EntityAddPacket;
+import io.papermc.paper.network.EntityIdsPacket;
+import io.papermc.paper.network.EntityIdsPacketHolder;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.ints.IntList;
+import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongArrayList;
+import it.unimi.dsi.fastutil.longs.LongList;
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.TranslatableComponent;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.game.ClientboundAddPlayerPacket;
+import net.minecraft.network.protocol.game.ClientboundBlockDestructionPacket;
+import net.minecraft.network.protocol.game.ClientboundBlockEventPacket;
+import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundDisconnectPacket;
+import net.minecraft.network.protocol.game.ClientboundForgetLevelChunkPacket;
+import net.minecraft.network.protocol.game.ClientboundKeepAlivePacket;
+import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
+import net.minecraft.network.protocol.game.ClientboundMapItemDataPacket;
+import net.minecraft.network.protocol.game.ClientboundPlayerInfoPacket;
+import net.minecraft.network.protocol.game.ClientboundRemoveEntitiesPacket;
 import net.minecraft.network.protocol.login.ClientboundLoginDisconnectPacket;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.RunningOnDifferentThreadException;
+import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.server.network.ServerGamePacketListenerImpl;
 import net.minecraft.server.network.ServerLoginPacketListenerImpl;
 import net.minecraft.util.LazyLoadedValue;
 import net.minecraft.util.Mth;
+import net.minecraft.world.level.ChunkPos;
 import org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -51,8 +88,19 @@ import org.apache.logging.log4j.MarkerManager;
 
 
 import io.netty.util.concurrent.AbstractEventExecutor; // Paper
+import org.bukkit.Bukkit;
+
 public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
 
+    // Martijn start
+    // TODO turn into configuration options
+    public static final int initialMaxNumberOfChunkPacketsInTransit = 1;
+    public static final int minMaxNumberOfChunkPacketsInTransit = 1;
+    public static final int maxMaxNumberOfChunkPacketsInTransit = 7;
+    public static final int sendChunkDistanceMarginFromViewDistance = 3;
+    public static final long millisIntervalToConsiderChunkPacketsPotentiallyOutdated = 3000L;
+    public static final int assumeChunksNearbyAreLoadedUponChunkInitializationPacketMaxDistance = 2;
+    // Martijn end
     private static final float AVERAGE_PACKETS_SMOOTHING = 0.75F;
     private static final Logger LOGGER = LogManager.getLogger();
     public static final Marker ROOT_MARKER = MarkerManager.getMarker("NETWORK");
@@ -68,7 +116,447 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         return new DefaultEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Local Client IO #%d").setDaemon(true).setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(LOGGER)).build()); // Paper
     });
     private final PacketFlow receiving;
-    private final Queue<Connection.PacketHolder> queue = Queues.newConcurrentLinkedQueue();
+    private final Queue<PacketHolder> queue = Queues.newConcurrentLinkedQueue();
+
+    // Martijn start
+
+    public List<PacketHolder> unpackPotentialExtras(Packet<?> packet, GenericFutureListener<? extends Future<? super Void>> callback) {
+        List<Packet> extraPackets = InnerUtil.buildExtraPackets(packet);
+        if (extraPackets == null || extraPackets.isEmpty()) {
+            return Collections.singletonList(new PacketHolder(packet, callback));
+        }
+        List<PacketHolder> packetHolders = new ArrayList<>(extraPackets.size() + 1);
+        packetHolders.add(new PacketHolder(packet, null));
+        for (int i = 0; i < extraPackets.size(); i++) {
+            packetHolders.add(new PacketHolder(extraPackets.get(i), i == extraPackets.size() - 1 ? callback : null));
+        }
+        return packetHolders;
+    }
+
+    public abstract class BlockedPacketList<P, IP, FP> {
+
+        public final List<PacketHolder> packets = new ArrayList<>(0);
+        public PacketHolder initializationPacket = null;
+//        public PacketHolder finalizationPacket = null;
+
+        public abstract boolean isInitializationPacket(Packet<?> packet);
+
+//        public abstract boolean isFinalizationPacket(Packet<?> packet);
+
+        public void addPacket(PacketHolder packet) {
+            if (isInitializationPacket(packet.packet)) {
+                this.initializationPacket = packet;
+//            } else if (isFinalizationPacket(packet.packet)) {
+//                this.initializationPacket = null;
+//                this.packets.clear();
+//                this.finalizationPacket = packet;
+            } else {
+                this.packets.add(packet);
+            }
+        }
+
+        public boolean canBeSent() {
+            return initializationPacket != null;
+//                || finalizationPacket != null;
+        }
+
+        public Stream<PacketHolder> getPacketsToSend() {
+            if (initializationPacket == null) {
+                return packets.stream();
+            }
+            return Stream.concat(Stream.of(initializationPacket), packets.stream());
+        }
+
+    }
+
+    public class TypeCheckingBlockedPacketList<P, IP, FP> extends BlockedPacketList<P, IP, FP> {
+
+        public TypeCheckingBlockedPacketList(Class<IP> initializationPacketType, Class<FP> finalizationPacketType) {
+            this.initializationPacketType = initializationPacketType;
+//            this.finalizationPacketType = finalizationPacketType;
+        }
+
+        public final Class<IP> initializationPacketType;
+//        public final Class<FP> finalizationPacketType;
+
+        @Override
+        public boolean isInitializationPacket(Packet<?> packet) {
+            return initializationPacketType.isInstance(packet);
+        }
+
+//        @Override
+//        public boolean isFinalizationPacket(Packet<?> packet) {
+//            return finalizationPacketType.isInstance(packet);
+//        }
+
+    }
+
+    public class ChunkBlockedPacketList extends BlockedPacketList<ChunkPacket, ClientboundLevelChunkWithLightPacket, ClientboundForgetLevelChunkPacket> {
+
+        @Override
+        public boolean isInitializationPacket(Packet<?> packet) {
+            return packet instanceof ClientboundLevelChunkWithLightPacket;
+        }
+
+//        @Override
+//        public boolean isFinalizationPacket(Packet<?> packet) {
+//            return packet instanceof ClientboundForgetLevelChunkPacket;
+//        }
+
+    }
+
+    public class EntityBlockedPacketList extends BlockedPacketList<EntityIdsPacket, EntityAddPacket, ClientboundRemoveEntitiesPacket> {
+
+        @Override
+        public boolean isInitializationPacket(Packet<?> packet) {
+            return packet instanceof EntityAddPacket;
+        }
+
+//        @Override
+//        public boolean isFinalizationPacket(Packet<?> packet) {
+//            return packet instanceof ClientboundRemoveEntitiesPacket;
+//        }
+
+    }
+
+    public class ChunkQueue {
+
+        // Data
+
+        public final Long2ObjectMap<ChunkBlockedPacketList> queue = new Long2ObjectOpenHashMap<>(0);
+
+        // Ordered by distance to player - updated every time queue is processed
+//        public final LongList orderedQueueKeys = new LongArrayList(0);
+
+        // Keep track of chunk packets in transit
+        public final ArrayDeque<Long> inTransit = new ArrayDeque<>();
+
+        public int maxNumberOfChunkPacketsInTransit = initialMaxNumberOfChunkPacketsInTransit;
+
+        public final LongSet atClient = new LongOpenHashSet(1);
+
+        // Implementation
+
+        public Stream<PacketHolder> getAllQueuedPackets() {
+            return queue.values().stream().flatMap(it -> it.getPacketsToSend());
+        }
+
+        // Input must be a Packet that is also a ChunkPacket
+        public void wantToSendChunkPacketAndPotentialExtras(Packet<?> packet, GenericFutureListener<? extends Future<? super Void>> callback) {
+            long chunkKey = ((ChunkPacket) packet).getRelatedChunkLongKey();
+            for (PacketHolder packetHolder : unpackPotentialExtras(packet, callback)) {
+                wantToSendImplicitChunkRelatedPacket(packetHolder, chunkKey);
+            }
+        }
+
+        // Input must be a PacketHolder containing either a ChunkPacket or some other Packet that was an extra for a ChunkPacket
+        public void wantToSendImplicitChunkRelatedPacket(PacketHolder packet, long chunkKey) {
+
+            // If finalization, delete all queued data for the chunk and write the finalization packet followed by any now no longer blocked entity packets
+            if (packet.packet instanceof ClientboundForgetLevelChunkPacket) {
+                atClient.remove(chunkKey);
+                ChunkBlockedPacketList blockedPacketList = queue.remove(chunkKey);
+                writePacketWithDefaultFlush(packet);
+                if (blockedPacketList != null) {
+                    chunkQueueKeysWereRemovedSinceLastQueueTraversal = true;
+                    for (PacketHolder blockedPacket : blockedPacketList.packets) {
+                        if (blockedPacket.packet instanceof EntityAddPacket) {
+                            entityQueue.entityAddPacketIsNoLongerBlockedByChunk(blockedPacket);
+                        } else if (blockedPacket.packet instanceof EntityIdsPacket) {
+                            entityQueue.wantToSendImplicitNonAddEntityEntityRelatedPacket(blockedPacket, ((EntityIdsPacket) blockedPacket.packet).getRelatedEntityIds());
+                        }
+                    }
+                }
+                return;
+            }
+
+            // If already at client, just write this packet
+            if (atClient.contains(chunkKey)) {
+                writePacketWithDefaultFlush(packet);
+                // If it is an entity add packet, note this so any blocked packets can be sent too
+                if (packet.packet instanceof EntityAddPacket) {
+                    entityQueue.entityAddPacketWasJustWritten(packet);
+                }
+                return;
+            }
+
+            // If exempt from being blocked, just write this packet
+            if (isExemptFromBeingBlocked(packet.packet)) {
+                writePacketWithDefaultFlush(packet);
+                return;
+            }
+
+            // Block
+            ChunkBlockedPacketList blockedPacketList = queue.computeIfAbsent(chunkKey, it -> new ChunkBlockedPacketList());
+            if (blockedPacketList.packets.isEmpty() && blockedPacketList.initializationPacket == null) {
+                chunkQueueKeysWereAddedSinceLastQueueTraversal = true;
+            }
+            blockedPacketList.addPacket(packet);
+            // If it is an entity add packet, note this so we know the  most recent blocked entity add packet for that entity id
+            if (packet.packet instanceof EntityAddPacket) {
+                entityQueue.entityAddPacketWasJustBlockedByChunkQueue(packet);
+            }
+
+        }
+
+        private boolean chunkQueueKeysWereAddedSinceLastQueueTraversal = false;
+        private boolean chunkQueueKeysWereRemovedSinceLastQueueTraversal = false;
+        private ChunkPos playerChunkPosAtLastQueueTraversal = null;
+        private int inTransitSizeAtStartOfLastQueueTraversal = 0;
+        private boolean atLastQueueTraversalSomeChunksWereSent = false;
+
+        public void goOverChunkQueueAndWriteWhateverIsPossible() {
+
+            ServerPlayer player = Connection.this.getPlayer();
+
+            // Don't do anything is nothing changed since the last queue traversal
+            ChunkPos playerChunkPos = (player == null) ? null : player.chunkPosition();
+            synchronized (inTransit) {
+                if (!(
+                    chunkQueueKeysWereAddedSinceLastQueueTraversal
+                        || chunkQueueKeysWereRemovedSinceLastQueueTraversal
+                        || ((playerChunkPosAtLastQueueTraversal == null) != (playerChunkPos == null))
+                        || (playerChunkPosAtLastQueueTraversal != null && playerChunkPos != null && playerChunkPosAtLastQueueTraversal.equals(playerChunkPos))
+                        || (inTransit.size() != inTransitSizeAtStartOfLastQueueTraversal)
+                        || atLastQueueTraversalSomeChunksWereSent
+                )) return;
+            }
+
+            chunkQueueKeysWereAddedSinceLastQueueTraversal = false;
+            chunkQueueKeysWereRemovedSinceLastQueueTraversal = false;
+            playerChunkPosAtLastQueueTraversal = playerChunkPos;
+            synchronized (inTransit) {
+                inTransitSizeAtStartOfLastQueueTraversal = inTransit.size();
+            }
+            atLastQueueTraversalSomeChunksWereSent = false;
+
+            // Sort the chunks in the queue by distance
+
+            Long[] orderedQueueKeys = queue.keySet().toArray(Long[]::new);
+            Arrays.sort(orderedQueueKeys, chunkKeyComparatorByDistanceToPlayer);
+
+            // Prepare shared information
+            //long currentTime = System.currentTimeMillis();
+            int playerViewDistance = Math.max(
+                (player == null) ? 0 : player.getLevel().getWorld().getViewDistance(),
+                Bukkit.getViewDistance()
+            );
+            // If we are on main, we are safe here in that nothing else should be processing queue off main anymore
+            // But if we are not on main due to login/status, the parent is synchronized on packetQueue
+
+            for (long chunkKey : orderedQueueKeys) {
+
+                Integer distance = getPlayerDistanceToChunk(chunkKey);
+
+                // Determine the number of chunk packets in transit that would limit sending this chunk
+
+                // TODO turn into configuration options
+                int maxNumberOfChunkPacketsInTransitByDistance = 10;
+                if (distance >= 12) {
+                    maxNumberOfChunkPacketsInTransitByDistance = 1;
+                } else if (distance >= 8) {
+                    maxNumberOfChunkPacketsInTransitByDistance = 2;
+                } else if (distance >= 5) {
+                    maxNumberOfChunkPacketsInTransitByDistance = 3;
+                } else if (distance >= 3) {
+                    maxNumberOfChunkPacketsInTransitByDistance = 4;
+                } else if (distance >= 2) {
+                    maxNumberOfChunkPacketsInTransitByDistance = 5;
+                } else if (distance >= 1) {
+                    maxNumberOfChunkPacketsInTransitByDistance = 6;
+                }
+
+                int maxNumberOfChunkPacketsInTransitToUse = Math.min(
+                    maxNumberOfChunkPacketsInTransit,
+                    maxNumberOfChunkPacketsInTransitByDistance
+                );
+
+                // Skip the rest if there are already too many chunk updates in transit
+                synchronized (inTransit) {
+                    if (inTransit.size() >= maxNumberOfChunkPacketsInTransitToUse) {
+                        return;
+                    }
+                }
+                // Write this chunk
+                writeChunkInitializationAndBlockedPackets(chunkKey, playerViewDistance);
+
+            }
+
+        }
+
+        public void writeChunkInitializationAndBlockedPackets(long chunkKey, int playerViewDistance) {
+
+            ChunkBlockedPacketList blockedPacketList = queue.get(chunkKey);
+
+            // Actually, skip this chunk if it has no initialization yet
+            if (blockedPacketList.initializationPacket == null) return;
+
+            Integer distance = getPlayerDistanceToChunk(chunkKey);
+            // If this chunk is too far away from the player, ignore it
+            if (distance != null && distance > playerViewDistance + sendChunkDistanceMarginFromViewDistance) return;
+
+            atLastQueueTraversalSomeChunksWereSent = true;
+
+            if (!blockedPacketList.initializationPacket.packet.isReady() || blockedPacketList.packets.stream().anyMatch(it -> !it.packet.isReady())) {
+                // We are probably just waiting for anti-xray for this chunk, so just skip it for now
+                return;
+            }
+
+            // We will write all packets for this chunk
+            atClient.add(chunkKey);
+            queue.remove(chunkKey);
+            writePacketWithDefaultFlush(blockedPacketList.initializationPacket);
+            for (PacketHolder packet : blockedPacketList.packets) {
+                if (packet.packet instanceof EntityAddPacket) {
+                    entityQueue.entityAddPacketIsNoLongerBlockedByChunk(packet);
+                } else if (packet instanceof EntityIdsPacket) {
+                    entityQueue.wantToSendImplicitNonAddEntityEntityRelatedPacket(packet, ((EntityIdsPacket) packet).getRelatedEntityIds());
+                } else {
+                    writePacketWithDefaultFlush(packet);
+                }
+            }
+
+            // Quickly write a keep-alive packet after writing the chunk packets
+            // Generate a keep-alive challenge that is not the same as any real one (the real ones use the current system time itself)
+            long keepAliveChallenge = -System.currentTimeMillis();
+            Packet<?> followingKeepAlivePacket = new ClientboundKeepAlivePacket(keepAliveChallenge);
+            synchronized (inTransit) {
+                inTransit.addLast(keepAliveChallenge);
+            }
+            writePacketWithDefaultFlush(new PacketHolder(followingKeepAlivePacket, null));
+
+        }
+
+    }
+
+    public class EntityQueue {
+
+        // Data
+
+        public final Int2ObjectMap<EntityBlockedPacketList> queue = new Int2ObjectOpenHashMap<>(0);
+
+        public final IntSet atClient = new IntOpenHashSet(0);
+
+        // Implementation
+
+        public Stream<PacketHolder> getAllQueuedPackets() {
+            return queue.values().stream().flatMap(it -> it.getPacketsToSend());
+        }
+
+        public void addPlayerEntityIdToAtClient() {
+            ServerPlayer player = getPlayer();
+            if (player != null) {
+                atClient.add(player.getBukkitEntity().getEntityId());
+            }
+        }
+
+        // Input must be a Packet that is also an EntityIdsPacket but not an EntityAddPacket
+        public void wantToSendNonAddEntityPacketAndPotentialExtras(Packet<?> packet, GenericFutureListener<? extends Future<? super Void>> callback) {
+            IntList entityIds = ((EntityIdsPacket) packet).getRelatedEntityIds();
+            for (PacketHolder packetHolder : unpackPotentialExtras(packet, callback)) {
+                wantToSendImplicitNonAddEntityEntityRelatedPacket(packetHolder, entityIds);
+            }
+        }
+
+        // Input must be a PacketHolder containing a packet that is an EntityIdsPacket or some other Packet that was an extra for an EntityIdsPacket, and that is not an EntityAddPacket
+        public void wantToSendImplicitNonAddEntityEntityRelatedPacket(PacketHolder packet, IntList entityIds) {
+
+            // Make sure the player entity id is regarded as at the client
+            addPlayerEntityIdToAtClient();
+
+            // If finalization, delete all queued data for the entity and write the finalization packet
+            if (packet.packet instanceof ClientboundRemoveEntitiesPacket) {
+                entityIds.forEach(it -> atClient.remove(it));
+                entityIds.forEach(it -> queue.remove(it));
+                writePacketWithDefaultFlush(packet);
+                return;
+            }
+
+            // If already at client, just write this packet
+            if (atClient.containsAll(entityIds)) {
+                writePacketWithDefaultFlush(packet);
+                return;
+            }
+
+            // If exempt from being blocked, just write this packet
+            if (isExemptFromBeingBlocked(packet.packet)) {
+                writePacketWithDefaultFlush(packet);
+                return;
+            }
+
+            // Block
+            for (int entityId : entityIds) {
+                if (atClient.contains(entityId)) continue;
+                EntityBlockedPacketList blockedPacketList = queue.computeIfAbsent(entityId, it -> new EntityBlockedPacketList());
+                blockedPacketList.addPacket(packet);
+            }
+
+        }
+
+        // Input must be a PacketHolder containing an EntityAddPacket
+        public void entityAddPacketWasJustBlockedByChunkQueue(PacketHolder packet) {
+
+            // Make sure the player entity id is regarded as at the client
+            addPlayerEntityIdToAtClient();
+
+            int entityId = ((EntityAddPacket) packet.packet).getRelatedEntityId();
+
+            // Add the initialization packet to the queue value
+            queue.computeIfAbsent(entityId, it -> new EntityBlockedPacketList()).initializationPacket = packet;
+
+        }
+
+        // Input must be a PacketHolder containing an EntityAddPacket
+        public void entityAddPacketWasJustWritten(PacketHolder packet) {
+
+            // Make sure the player entity id is regarded as at the client
+            addPlayerEntityIdToAtClient();
+
+            int entityId = ((EntityAddPacket) packet.packet).getRelatedEntityId();
+
+            // Mark that it is at the client
+            atClient.add(entityId);
+
+            // Also write any blocked packets that are no longer blocked by anything else
+            EntityBlockedPacketList blockedPacketList = queue.remove(entityId);
+            if (blockedPacketList != null) {
+                for (PacketHolder blockedPacket : blockedPacketList.packets) {
+                    if (!(blockedPacket instanceof EntityIdsPacket) || !((EntityIdsPacket) blockedPacket.packet).getRelatedEntityIds().intStream().anyMatch(it -> queue.containsKey(it))) {
+                        writePacketWithDefaultFlush(blockedPacket);
+                    }
+                }
+            }
+
+        }
+
+        // Input must be a PacketHolder containing an EntityAddPacket
+        public void entityAddPacketIsNoLongerBlockedByChunk(PacketHolder packet) {
+
+            int entityId = ((EntityAddPacket) packet.packet).getRelatedEntityId();
+
+            // Get the packets in the queue for this entity
+            EntityBlockedPacketList blockedPacketList = queue.get(entityId);
+
+            // If nothing is found, then this entity was already finalized
+            if (blockedPacketList == null) return;
+
+            // If something is found, but it has a different initialization packet, then a newer initialization packet exists and this one is no longer relevant
+            if (packet != blockedPacketList.initializationPacket) return;
+
+            // Write the add packet itself
+            writePacketWithDefaultFlush(packet);
+            // Write the previously blocked packets, this will remove the blocked packet list from the queue
+            entityAddPacketWasJustWritten(packet);
+
+        }
+
+    }
+
+    public final ChunkQueue chunkQueue = new ChunkQueue();
+    public final EntityQueue entityQueue = new EntityQueue();
+
+    // Martijn end
+
     public Channel channel;
     public SocketAddress address;
     // Spigot Start
@@ -89,7 +577,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     // Paper start - NetworkClient implementation
     public int protocolVersion;
     public java.net.InetSocketAddress virtualHost;
-    private static boolean enableExplicitFlush = Boolean.getBoolean("paper.explicit-flush");
+    private static boolean enableExplicitFlush = true;//Boolean.getBoolean("paper.explicit-flush"); // Martijn
     // Optimize network
     public boolean isPending = true;
     public boolean queueImmunity = false;
@@ -293,6 +781,26 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             return null;
         }
     }
+
+    // Martijn start
+    public @Nullable Integer getPlayerDistanceToChunk(long chunkKey) {
+        ServerPlayer player = getPlayer();
+        if (player == null) {
+            return null;
+        }
+        ChunkPos chunk = new ChunkPos(chunkKey);
+        int playerChunkX = player.getBlockX() >> 4;
+        int playerChunkZ = player.getBlockZ() >> 4;
+        return Math.max(Math.abs(playerChunkX - chunk.x), Math.abs(playerChunkZ - chunk.z));
+    }
+
+    public final Comparator<Long> chunkKeyComparatorByDistanceToPlayer = (chunkKey1, chunkKey2) -> {
+        Integer distance1 = getPlayerDistanceToChunk(chunkKey1);
+        Integer distance2 = getPlayerDistanceToChunk(chunkKey2);
+        return Integer.compare(distance1 == null ? 0 : distance1, distance2 == null ? 0 : distance2);
+    };
+    // Martijn end
+
     private static class InnerUtil { // Attempt to hide these methods from ProtocolLib so it doesn't accidently pick them up.
         private static java.util.List<Packet> buildExtraPackets(Packet packet) {
             java.util.List<Packet> extra = packet.getExtraPackets();
@@ -330,6 +838,17 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     }
     // Paper end
 
+    // Martijn start
+    private static boolean isExemptFromBeingBlocked(Packet<?> packet) {
+        return packet instanceof ClientboundAddPlayerPacket
+            || packet instanceof ClientboundMapItemDataPacket
+            || packet instanceof ClientboundPlayerInfoPacket;
+//            || packet instanceof ClientboundBlockDestructionPacket
+//            || packet instanceof ClientboundBlockUpdatePacket
+//            || packet instanceof ClientboundBlockEventPacket;
+    }
+    // Martijn end
+
     public void send(Packet<?> packet) {
         this.send(packet, (GenericFutureListener) null);
     }
@@ -341,41 +860,82 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             return; // Do nothing
         }
         packet.onPacketDispatch(getPlayer());
+
+        PacketHolder packetHolder = new PacketHolder(packet, callback);
+
+        // Martijn start
+
+        if (packet instanceof ChunkPacket) {
+            chunkQueue.wantToSendChunkPacketAndPotentialExtras(packet, callback);
+            return;
+        } else if (packet instanceof EntityIdsPacket && !(packet instanceof EntityAddPacket)) {
+            entityQueue.wantToSendNonAddEntityPacketAndPotentialExtras(packet, callback);
+            return;
+        }
+
+        // Use Paper's insta-send here if possible
         if (connected && (InnerUtil.canSendImmediate(this, packet) || (
             net.minecraft.server.MCUtil.isMainThread() && packet.isReady() && this.queue.isEmpty() &&
-            (packet.getExtraPackets() == null || packet.getExtraPackets().isEmpty())
+                (packet.getExtraPackets() == null || packet.getExtraPackets().isEmpty())
         ))) {
             this.writePacket(packet, callback, null); // Paper
             return;
         }
+
         // write the packets to the queue, then flush - antixray hooks there already
-        java.util.List<Packet> extraPackets = InnerUtil.buildExtraPackets(packet);
-        boolean hasExtraPackets = extraPackets != null && !extraPackets.isEmpty();
-        if (!hasExtraPackets) {
-            this.queue.add(new Connection.PacketHolder(packet, callback));
-        } else {
-            java.util.List<Connection.PacketHolder> packets = new java.util.ArrayList<>(1 + extraPackets.size());
-            packets.add(new Connection.PacketHolder(packet, null)); // delay the future listener until the end of the extra packets
 
-            for (int i = 0, len = extraPackets.size(); i < len;) {
-                Packet extra = extraPackets.get(i);
-                boolean end = ++i == len;
-                packets.add(new Connection.PacketHolder(extra, end ? callback : null)); // append listener to the end
-            }
-            this.queue.addAll(packets); // atomic
-        }
+        // Add remaining packet with extras to the regular queue
+        queue.addAll(unpackPotentialExtras(packet, callback));
+
+        // Martijn end
+
         this.flushQueue();
         // Paper end
     }
 
+    // Martijn start
+
+    public void writePacketWithDefaultFlush(PacketHolder packet) {
+        writePacketWithDefaultFlush(packet, null);
+    }
+
+    public void writePacketWithDefaultFlush(PacketHolder packet, Boolean flushOverride) {
+        boolean thereAreMorePacketsInSomeQueue =
+            !this.queue.isEmpty() || !chunkQueue.queue.isEmpty() || !entityQueue.queue.isEmpty();
+        Boolean flush = (!thereAreMorePacketsInSomeQueue && Connection.this.canFlush) ? Boolean.TRUE : Boolean.FALSE;
+        if (flush == null) {
+            flush = flushOverride;
+        } else if (flushOverride != null) {
+            flush |= flushOverride;
+        }
+        this.writePacket(
+            packet.packet,
+            packet.listener,
+            flush
+        );
+    }
+
+    // Martijn end
+
     private void sendPacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback) {
         // Paper start - add flush parameter
         this.writePacket(packet, callback, Boolean.TRUE);
     }
+
     private void writePacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback, Boolean flushConditional) {
+
         this.packetWrites.getAndIncrement(); // must be befeore using canFlush
         boolean effectiveFlush = flushConditional == null ? this.canFlush : flushConditional.booleanValue();
-        final boolean flush = effectiveFlush || packet instanceof net.minecraft.network.protocol.game.ClientboundKeepAlivePacket || packet instanceof ClientboundDisconnectPacket; // no delay for certain packets
+        // Martijn start
+        // Flush after more types of packets
+        final boolean flush =
+            effectiveFlush
+                || packet instanceof ClientboundKeepAlivePacket
+                || packet instanceof ClientboundDisconnectPacket
+                || packet instanceof ClientboundLevelChunkWithLightPacket
+                || packet instanceof ClientboundMapItemDataPacket
+                || packet instanceof ClientboundPlayerInfoPacket; // no delay for certain packets
+        // Martijn end
         // Paper end - add flush parameter
         ConnectionProtocol enumprotocol = ConnectionProtocol.getProtocolForPacket(packet);
         ConnectionProtocol enumprotocol1 = this.getCurrentProtocol();
@@ -465,40 +1025,34 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         }
         return false;
     }
+
+    // Martijn start
     private boolean processQueue() {
-        if (this.queue.isEmpty()) return true;
-        // Paper start - make only one flush call per sendPacketQueue() call
-        final boolean needsFlush = this.canFlush;
-        boolean hasWrotePacket = false;
-        // Paper end - make only one flush call per sendPacketQueue() call
+
+        // Process the regular queue
         // If we are on main, we are safe here in that nothing else should be processing queue off main anymore
         // But if we are not on main due to login/status, the parent is synchronized on packetQueue
-        java.util.Iterator<PacketHolder> iterator = this.queue.iterator();
-        while (iterator.hasNext()) {
-            PacketHolder queued = iterator.next(); // poll -> peek
-
-            // Fix NPE (Spigot bug caused by handleDisconnection())
-            if (false && queued == null) { // Paper - diff on change, this logic is redundant: iterator guarantees ret of an element - on change, hook the flush logic here
-                return true;
-            }
+        while (!this.queue.isEmpty()) {
+            PacketHolder queued = this.queue.peek(); // poll -> peek
 
             Packet<?> packet = queued.packet;
             if (!packet.isReady()) {
-                // Paper start - make only one flush call per sendPacketQueue() call
-                if (hasWrotePacket && (needsFlush || this.canFlush)) {
-                    this.flush();
-                }
-                // Paper end - make only one flush call per sendPacketQueue() call
-                return false;
+                Connection.this.flush();
+                break;
             } else {
-                iterator.remove();
-                this.writePacket(packet, queued.listener, (!iterator.hasNext() && (needsFlush || this.canFlush)) ? Boolean.TRUE : Boolean.FALSE); // Paper - make only one flush call per sendPacketQueue() call
-                hasWrotePacket = true; // Paper - make only one flush call per sendPacketQueue() call
+                this.queue.poll();
+                writePacketWithDefaultFlush(queued);
             }
         }
-        return true;
+
+        // Process the chunks
+        chunkQueue.goOverChunkQueueAndWriteWhateverIsPossible();
+
+        return queue.isEmpty() && chunkQueue.queue.isEmpty() && entityQueue.queue.isEmpty();
+
     }
     // Paper end
+    // Martijn end
 
     private static final int MAX_PER_TICK = com.destroystokyo.paper.PaperConfig.maxJoinsPerTick; // Paper
     private static int joinAttemptsThisTick; // Paper
@@ -557,19 +1111,30 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     // Paper start
     public void clearPacketQueue() {
         net.minecraft.server.level.ServerPlayer player = getPlayer();
-        queue.forEach(queuedPacket -> {
+        Stream.concat(queue.stream(), Stream.concat(chunkQueue.getAllQueuedPackets(), entityQueue.getAllQueuedPackets())).forEach(queuedPacket -> { // Martijn
             Packet<?> packet = queuedPacket.packet;
             if (packet.hasFinishListener()) {
                 packet.onPacketDispatchFinish(player, null);
             }
         });
         queue.clear();
+        // Martijn start
+        chunkQueue.queue.clear();
+        entityQueue.queue.clear();
+        // Martijn end
     }
     // Paper end
     public void disconnect(Component disconnectReason) {
         // Spigot Start
         this.preparing = false;
         clearPacketQueue(); // Paper
+        // Martijn start
+        chunkQueue.atClient.clear();
+        entityQueue.atClient.clear();
+        synchronized (chunkQueue.inTransit) {
+            chunkQueue.inTransit.clear();
+        }
+        // Martijn end
         // Spigot End
         if (this.channel.isOpen()) {
             this.channel.close(); // We can't wait as this may be called from an event loop.
@@ -714,6 +1279,11 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
                     this.getPacketListener().onDisconnect(new TranslatableComponent("multiplayer.disconnect.generic"));
                 }
                 clearPacketQueue(); // Paper
+                // Martijn start
+                synchronized (chunkQueue.inTransit) {
+                    chunkQueue.inTransit.clear();
+                }
+                // Martijn end
                 // Paper start - Add PlayerConnectionCloseEvent
                 final PacketListener packetListener = this.getPacketListener();
                 if (packetListener instanceof ServerGamePacketListenerImpl) {
@@ -747,7 +1317,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         return this.averageSentPackets;
     }
 
-    private static class PacketHolder {
+    public static class PacketHolder { // Martijn
 
         final Packet<?> packet;
         @Nullable
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundAddEntityPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundAddEntityPacket.java
index 4abe27f06966fa61370627bc1b37426735dcf971..8ce961fd1e1ac8d81b1bdf864a6cac52751fc962 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundAddEntityPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundAddEntityPacket.java
@@ -1,6 +1,8 @@
 package net.minecraft.network.protocol.game;
 
 import java.util.UUID;
+
+import io.papermc.paper.network.EntityAddPacket;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Registry;
 import net.minecraft.network.FriendlyByteBuf;
@@ -10,7 +12,7 @@ import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.phys.Vec3;
 
-public class ClientboundAddEntityPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundAddEntityPacket implements Packet<ClientGamePacketListener>, EntityAddPacket { // Martijn
     public static final double MAGICAL_QUANTIZATION = 8000.0D;
     private final int id;
     private final UUID uuid;
@@ -68,6 +70,23 @@ public class ClientboundAddEntityPacket implements Packet<ClientGamePacketListen
         this.za = buf.readShort();
     }
 
+    // Martijn start
+    @Override
+    public int getRelatedChunkX() {
+        return ((int) Math.floor(x)) >> 4;
+    }
+
+    @Override
+    public int getRelatedChunkZ() {
+        return ((int) Math.floor(z)) >> 4;
+    }
+
+    @Override
+    public int getRelatedEntityId() {
+        return id;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeVarInt(this.id);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundAddExperienceOrbPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundAddExperienceOrbPacket.java
index c2fee7533528911204fdc03979de9d2d9b46bc6f..9ab6be3250449b8220743234ea79b4169b11e47e 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundAddExperienceOrbPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundAddExperienceOrbPacket.java
@@ -1,10 +1,11 @@
 package net.minecraft.network.protocol.game;
 
+import io.papermc.paper.network.EntityAddPacket;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.entity.ExperienceOrb;
 
-public class ClientboundAddExperienceOrbPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundAddExperienceOrbPacket implements Packet<ClientGamePacketListener>, EntityAddPacket { // Martijn
     private final int id;
     private final double x;
     private final double y;
@@ -27,6 +28,23 @@ public class ClientboundAddExperienceOrbPacket implements Packet<ClientGamePacke
         this.value = buf.readShort();
     }
 
+    // Martijn start
+    @Override
+    public int getRelatedChunkX() {
+        return ((int) Math.floor(x)) >> 4;
+    }
+
+    @Override
+    public int getRelatedChunkZ() {
+        return ((int) Math.floor(z)) >> 4;
+    }
+
+    @Override
+    public int getRelatedEntityId() {
+        return id;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeVarInt(this.id);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundAddMobPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundAddMobPacket.java
index 4fb3977a4ebad03da7367e7d2264489573aa9859..7122bd68096dac1dcf911239462935233550278a 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundAddMobPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundAddMobPacket.java
@@ -1,6 +1,8 @@
 package net.minecraft.network.protocol.game;
 
 import java.util.UUID;
+
+import io.papermc.paper.network.EntityAddPacket;
 import net.minecraft.core.Registry;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
@@ -8,7 +10,7 @@ import net.minecraft.util.Mth;
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.phys.Vec3;
 
-public class ClientboundAddMobPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundAddMobPacket implements Packet<ClientGamePacketListener>, EntityAddPacket { // Martijn
     private final int id;
     private final UUID uuid;
     private final int type;
@@ -57,6 +59,23 @@ public class ClientboundAddMobPacket implements Packet<ClientGamePacketListener>
         this.zd = buf.readShort();
     }
 
+    // Martijn start
+    @Override
+    public int getRelatedChunkX() {
+        return ((int) Math.floor(x)) >> 4;
+    }
+
+    @Override
+    public int getRelatedChunkZ() {
+        return ((int) Math.floor(z)) >> 4;
+    }
+
+    @Override
+    public int getRelatedEntityId() {
+        return id;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeVarInt(this.id);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundAddPaintingPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundAddPaintingPacket.java
index a0a9155c6e70c2d4a44370efbe76f7abb203cff7..5614260e3479b2eefee1c5508501ed5873b797db 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundAddPaintingPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundAddPaintingPacket.java
@@ -1,6 +1,8 @@
 package net.minecraft.network.protocol.game;
 
 import java.util.UUID;
+
+import io.papermc.paper.network.EntityAddPacket;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Registry;
@@ -9,7 +11,7 @@ import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.entity.decoration.Motive;
 import net.minecraft.world.entity.decoration.Painting;
 
-public class ClientboundAddPaintingPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundAddPaintingPacket implements Packet<ClientGamePacketListener>, EntityAddPacket { // Martijn
     private final int id;
     private final UUID uuid;
     private final BlockPos pos;
@@ -32,6 +34,23 @@ public class ClientboundAddPaintingPacket implements Packet<ClientGamePacketList
         this.direction = Direction.from2DDataValue(buf.readUnsignedByte());
     }
 
+    // Martijn start
+    @Override
+    public int getRelatedChunkX() {
+        return pos.getX() >> 4;
+    }
+
+    @Override
+    public int getRelatedChunkZ() {
+        return pos.getZ() >> 4;
+    }
+
+    @Override
+    public int getRelatedEntityId() {
+        return id;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeVarInt(this.id);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundAddPlayerPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundAddPlayerPacket.java
index ab823de3fe0eb4870cd7fec543730d6d17060940..d5bf680137eb25996a923a8cc2e941daa94a7333 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundAddPlayerPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundAddPlayerPacket.java
@@ -1,11 +1,13 @@
 package net.minecraft.network.protocol.game;
 
 import java.util.UUID;
+
+import io.papermc.paper.network.EntityAddPacket;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.entity.player.Player;
 
-public class ClientboundAddPlayerPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundAddPlayerPacket implements Packet<ClientGamePacketListener>, EntityAddPacket { // Martijn
     private final int entityId;
     private final UUID playerId;
     private final double x;
@@ -34,6 +36,23 @@ public class ClientboundAddPlayerPacket implements Packet<ClientGamePacketListen
         this.xRot = buf.readByte();
     }
 
+    // Martijn start
+    @Override
+    public int getRelatedChunkX() {
+        return ((int) Math.floor(x)) >> 4;
+    }
+
+    @Override
+    public int getRelatedChunkZ() {
+        return ((int) Math.floor(z)) >> 4;
+    }
+
+    @Override
+    public int getRelatedEntityId() {
+        return entityId;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeVarInt(this.entityId);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundAddVibrationSignalPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundAddVibrationSignalPacket.java
index c7d1b4ba15c0f9539c914a1ac256be1dd11ded1f..1664d0f9c86218a89e42345bec6b8bfe8704275f 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundAddVibrationSignalPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundAddVibrationSignalPacket.java
@@ -1,10 +1,11 @@
 package net.minecraft.network.protocol.game;
 
+import io.papermc.paper.network.ChunkPacket;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.level.gameevent.vibrations.VibrationPath;
 
-public class ClientboundAddVibrationSignalPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundAddVibrationSignalPacket implements Packet<ClientGamePacketListener>, ChunkPacket {
     private final VibrationPath vibrationPath;
 
     public ClientboundAddVibrationSignalPacket(VibrationPath vibration) {
@@ -15,6 +16,18 @@ public class ClientboundAddVibrationSignalPacket implements Packet<ClientGamePac
         this.vibrationPath = VibrationPath.read(buf);
     }
 
+    // Martijn start
+    @Override
+    public int getRelatedChunkX() {
+        return vibrationPath.getOrigin().getX() >> 4;
+    }
+
+    @Override
+    public int getRelatedChunkZ() {
+        return vibrationPath.getOrigin().getZ() >> 4;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         VibrationPath.write(buf, this.vibrationPath);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundAnimatePacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundAnimatePacket.java
index e94937e58c77a5331d012cb2775ae5f4bc84656e..7d10e168b33d0a4628d4f9c6f0b473b75ad5f0ab 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundAnimatePacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundAnimatePacket.java
@@ -1,10 +1,11 @@
 package net.minecraft.network.protocol.game;
 
+import io.papermc.paper.network.EntityIdPacket;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.entity.Entity;
 
-public class ClientboundAnimatePacket implements Packet<ClientGamePacketListener> {
+public class ClientboundAnimatePacket implements Packet<ClientGamePacketListener>, EntityIdPacket { // Martijn
     public static final int SWING_MAIN_HAND = 0;
     public static final int HURT = 1;
     public static final int WAKE_UP = 2;
@@ -24,6 +25,13 @@ public class ClientboundAnimatePacket implements Packet<ClientGamePacketListener
         this.action = buf.readUnsignedByte();
     }
 
+    // Martijn start
+    @Override
+    public int getRelatedEntityId() {
+        return id;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeVarInt(this.id);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockDestructionPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockDestructionPacket.java
index 5c10d258d83e269f2c9570e438fb88ef1155ecaf..5f949ff99b6f98f6b7977ebdb81004d86836328b 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockDestructionPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockDestructionPacket.java
@@ -1,10 +1,11 @@
 package net.minecraft.network.protocol.game;
 
+import io.papermc.paper.network.ChunkPacket;
 import net.minecraft.core.BlockPos;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 
-public class ClientboundBlockDestructionPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundBlockDestructionPacket implements Packet<ClientGamePacketListener>, ChunkPacket { // Martijn
     private final int id;
     private final BlockPos pos;
     private final int progress;
@@ -21,6 +22,18 @@ public class ClientboundBlockDestructionPacket implements Packet<ClientGamePacke
         this.progress = buf.readUnsignedByte();
     }
 
+    // Martijn start
+    @Override
+    public int getRelatedChunkX() {
+        return pos.getX() >> 4;
+    }
+
+    @Override
+    public int getRelatedChunkZ() {
+        return pos.getZ() >> 4;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeVarInt(this.id);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockEntityDataPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockEntityDataPacket.java
index 43220caaa331eade5b183f68f09d94542b4bc3db..70c75c74523671b9a58fdbea2ba4141a3a95e927 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockEntityDataPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockEntityDataPacket.java
@@ -1,5 +1,6 @@
 package net.minecraft.network.protocol.game;
 
+import io.papermc.paper.network.ChunkPacket;
 import java.util.function.Function;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
@@ -10,7 +11,7 @@ import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.entity.BlockEntityType;
 
-public class ClientboundBlockEntityDataPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundBlockEntityDataPacket implements Packet<ClientGamePacketListener>, ChunkPacket { // Martijn
     private final BlockPos pos;
     private final BlockEntityType<?> type;
     @Nullable
@@ -36,6 +37,18 @@ public class ClientboundBlockEntityDataPacket implements Packet<ClientGamePacket
         this.tag = buf.readNbt();
     }
 
+    // Martijn start
+    @Override
+    public int getRelatedChunkX() {
+        return pos.getX() >> 4;
+    }
+
+    @Override
+    public int getRelatedChunkZ() {
+        return pos.getZ() >> 4;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeBlockPos(this.pos);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockEventPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockEventPacket.java
index 45968379a7d04bf3cdb9cac260883fafde94a5cd..587e64c662fef8a339a1a89e455964ac8100c8bb 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockEventPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockEventPacket.java
@@ -1,12 +1,13 @@
 package net.minecraft.network.protocol.game;
 
+import io.papermc.paper.network.ChunkPacket;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Registry;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.level.block.Block;
 
-public class ClientboundBlockEventPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundBlockEventPacket implements Packet<ClientGamePacketListener>, ChunkPacket { // Martijn
     private final BlockPos pos;
     private final int b0;
     private final int b1;
@@ -26,6 +27,18 @@ public class ClientboundBlockEventPacket implements Packet<ClientGamePacketListe
         this.block = Registry.BLOCK.byId(buf.readVarInt());
     }
 
+    // Martijn start
+    @Override
+    public int getRelatedChunkX() {
+        return pos.getX() >> 4;
+    }
+
+    @Override
+    public int getRelatedChunkZ() {
+        return pos.getZ() >> 4;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeBlockPos(this.pos);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockUpdatePacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockUpdatePacket.java
index 67b8535f0c180135c9187de5696779de9fc5882f..0680f23f36134d2f52c34ef57565ba604c9f6e28 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockUpdatePacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockUpdatePacket.java
@@ -1,5 +1,6 @@
 package net.minecraft.network.protocol.game;
 
+import io.papermc.paper.network.ChunkPacket;
 import net.minecraft.core.BlockPos;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
@@ -7,7 +8,7 @@ import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.state.BlockState;
 
-public class ClientboundBlockUpdatePacket implements Packet<ClientGamePacketListener> {
+public class ClientboundBlockUpdatePacket implements Packet<ClientGamePacketListener>, ChunkPacket { // Martijn
     private final BlockPos pos;
     public final BlockState blockState;
 
@@ -25,6 +26,18 @@ public class ClientboundBlockUpdatePacket implements Packet<ClientGamePacketList
         this.blockState = Block.BLOCK_STATE_REGISTRY.byId(buf.readVarInt());
     }
 
+    // Martijn start
+    @Override
+    public int getRelatedChunkX() {
+        return pos.getX() >> 4;
+    }
+
+    @Override
+    public int getRelatedChunkZ() {
+        return pos.getZ() >> 4;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeBlockPos(this.pos);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundEntityEventPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundEntityEventPacket.java
index 31ed553aa4f6c9f5930b44cc3c6f19ffdaf1696f..fdd00454803c38740101d40531fb0c569382bf79 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundEntityEventPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundEntityEventPacket.java
@@ -1,12 +1,13 @@
 package net.minecraft.network.protocol.game;
 
+import io.papermc.paper.network.EntityIdPacket;
 import javax.annotation.Nullable;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.level.Level;
 
-public class ClientboundEntityEventPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundEntityEventPacket implements Packet<ClientGamePacketListener>, EntityIdPacket { // Martijn
     private final int entityId;
     private final byte eventId;
 
@@ -20,6 +21,13 @@ public class ClientboundEntityEventPacket implements Packet<ClientGamePacketList
         this.eventId = buf.readByte();
     }
 
+    // Martijn start
+    @Override
+    public int getRelatedEntityId() {
+        return entityId;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeInt(this.entityId);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundForgetLevelChunkPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundForgetLevelChunkPacket.java
index 578600a56f9461fbf3a6c1abf1d5aad614a93eb6..cfd5f10bc26caa4ad209af12f1caa8232b589cb0 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundForgetLevelChunkPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundForgetLevelChunkPacket.java
@@ -1,9 +1,10 @@
 package net.minecraft.network.protocol.game;
 
+import io.papermc.paper.network.ChunkPacket;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 
-public class ClientboundForgetLevelChunkPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundForgetLevelChunkPacket implements Packet<ClientGamePacketListener>, ChunkPacket { // Martijn
     private final int x;
     private final int z;
 
@@ -17,6 +18,18 @@ public class ClientboundForgetLevelChunkPacket implements Packet<ClientGamePacke
         this.z = buf.readInt();
     }
 
+    // Martijn start
+    @Override
+    public int getRelatedChunkX() {
+        return x;
+    }
+
+    @Override
+    public int getRelatedChunkZ() {
+        return z;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeInt(this.x);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
index 2072aa8710f6e285f7c8f76c63b7bcf85cc11030..01f83832900ddcd3797391236c0cb4fc4821ed96 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
@@ -2,13 +2,16 @@ package net.minecraft.network.protocol.game;
 
 import java.util.BitSet;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.network.ChunkPacket;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.lighting.LevelLightEngine;
 
-public class ClientboundLevelChunkWithLightPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundLevelChunkWithLightPacket implements Packet<ClientGamePacketListener>, ChunkPacket { // Martijn
+    public final long creationTimestamp = System.currentTimeMillis();
     private final int x;
     private final int z;
     private final ClientboundLevelChunkPacketData chunkData;
@@ -46,6 +49,18 @@ public class ClientboundLevelChunkWithLightPacket implements Packet<ClientGamePa
         this.lightData = new ClientboundLightUpdatePacketData(buf, this.x, this.z);
     }
 
+    // Martijn start
+    @Override
+    public int getRelatedChunkX() {
+        return x;
+    }
+
+    @Override
+    public int getRelatedChunkZ() {
+        return z;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeInt(this.x);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundMoveEntityPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundMoveEntityPacket.java
index ec93f5300cc7d423ec0d292f0f8443f900d72dab..99428cacadbe919dba27009a0331453c2bf2836e 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundMoveEntityPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundMoveEntityPacket.java
@@ -1,6 +1,8 @@
 package net.minecraft.network.protocol.game;
 
 import javax.annotation.Nullable;
+
+import io.papermc.paper.network.EntityIdPacket;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.util.Mth;
@@ -8,7 +10,7 @@ import net.minecraft.world.entity.Entity;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.phys.Vec3;
 
-public abstract class ClientboundMoveEntityPacket implements Packet<ClientGamePacketListener> {
+public abstract class ClientboundMoveEntityPacket implements Packet<ClientGamePacketListener>, EntityIdPacket { // Martijn
     private static final double TRUNCATION_STEPS = 4096.0D;
     protected final int entityId;
     protected final short xa;
@@ -51,6 +53,12 @@ public abstract class ClientboundMoveEntityPacket implements Packet<ClientGamePa
         this.hasPos = positionChanged;
     }
 
+    // Martijn start
+    public int getRelatedEntityId() {
+        return entityId;
+    }
+    // Martijn end
+
     @Override
     public void handle(ClientGamePacketListener listener) {
         listener.handleMoveEntity(this);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundOpenSignEditorPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundOpenSignEditorPacket.java
index 17e58ed1779dcb77b27ad45b9fb8a2f877e9222b..336b55dd985f7b269552c314fc99c0e179685465 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundOpenSignEditorPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundOpenSignEditorPacket.java
@@ -1,10 +1,11 @@
 package net.minecraft.network.protocol.game;
 
+import io.papermc.paper.network.ChunkPacket;
 import net.minecraft.core.BlockPos;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 
-public class ClientboundOpenSignEditorPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundOpenSignEditorPacket implements Packet<ClientGamePacketListener>, ChunkPacket {
     private final BlockPos pos;
 
     public ClientboundOpenSignEditorPacket(BlockPos pos) {
@@ -15,6 +16,18 @@ public class ClientboundOpenSignEditorPacket implements Packet<ClientGamePacketL
         this.pos = buf.readBlockPos();
     }
 
+    // Martijn start
+    @Override
+    public int getRelatedChunkX() {
+        return pos.getX() >> 4;
+    }
+
+    @Override
+    public int getRelatedChunkZ() {
+        return pos.getZ() >> 4;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeBlockPos(this.pos);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundRemoveEntitiesPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundRemoveEntitiesPacket.java
index 1223f195f7b6b8627fad434f3c10f2e9d5a6ad8b..269061edf77fc2203acbf31a9b67ad428dcb52c0 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundRemoveEntitiesPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundRemoveEntitiesPacket.java
@@ -1,11 +1,12 @@
 package net.minecraft.network.protocol.game;
 
+import io.papermc.paper.network.EntityIdsPacket;
 import it.unimi.dsi.fastutil.ints.IntArrayList;
 import it.unimi.dsi.fastutil.ints.IntList;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 
-public class ClientboundRemoveEntitiesPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundRemoveEntitiesPacket implements Packet<ClientGamePacketListener>, EntityIdsPacket { // Martijn
     private final IntList entityIds;
 
     public ClientboundRemoveEntitiesPacket(IntList entityIds) {
@@ -20,6 +21,13 @@ public class ClientboundRemoveEntitiesPacket implements Packet<ClientGamePacketL
         this.entityIds = buf.readIntIdList();
     }
 
+    // Martijn start
+    @Override
+    public IntList getRelatedEntityIds() {
+        return getEntityIds();
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeIntIdList(this.entityIds);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundRemoveMobEffectPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundRemoveMobEffectPacket.java
index d78d94762c138d5ca41a00053f9623d42c628f3b..a539c9fcd43e618192428d78b8b9eecfe85845a3 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundRemoveMobEffectPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundRemoveMobEffectPacket.java
@@ -1,5 +1,6 @@
 package net.minecraft.network.protocol.game;
 
+import io.papermc.paper.network.EntityIdPacket;
 import javax.annotation.Nullable;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
@@ -7,7 +8,7 @@ import net.minecraft.world.effect.MobEffect;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.level.Level;
 
-public class ClientboundRemoveMobEffectPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundRemoveMobEffectPacket implements Packet<ClientGamePacketListener>, EntityIdPacket { // Martijn
     private final int entityId;
     private final MobEffect effect;
 
@@ -21,6 +22,13 @@ public class ClientboundRemoveMobEffectPacket implements Packet<ClientGamePacket
         this.effect = MobEffect.byId(buf.readUnsignedByte());
     }
 
+    // Martijn start
+    @Override
+    public int getRelatedEntityId() {
+        return entityId;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeVarInt(this.entityId);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundRotateHeadPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundRotateHeadPacket.java
index 15ebf22e9ca11870e5f24ff5ab8bcbee8c571ee3..f0ce5a315d9696d912b9c21eaf0f8b31a5d5fb36 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundRotateHeadPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundRotateHeadPacket.java
@@ -1,11 +1,12 @@
 package net.minecraft.network.protocol.game;
 
+import io.papermc.paper.network.EntityIdPacket;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.level.Level;
 
-public class ClientboundRotateHeadPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundRotateHeadPacket implements Packet<ClientGamePacketListener>, EntityIdPacket { // Martijn
     private final int entityId;
     private final byte yHeadRot;
 
@@ -19,6 +20,12 @@ public class ClientboundRotateHeadPacket implements Packet<ClientGamePacketListe
         this.yHeadRot = buf.readByte();
     }
 
+    // Martijn start
+    public int getRelatedEntityId() {
+        return entityId;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeVarInt(this.entityId);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
index 82ea4fabd5732052a286d50bcff8bbcc2c4aa7d7..d3495c2bc56f273e0504737f3ceb8e7fb612f3c5 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
@@ -1,5 +1,6 @@
 package net.minecraft.network.protocol.game;
 
+import io.papermc.paper.network.ChunkPacket;
 import it.unimi.dsi.fastutil.shorts.ShortIterator;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
 import java.util.function.BiConsumer;
@@ -11,7 +12,7 @@ import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.LevelChunkSection;
 
-public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePacketListener> {
+public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePacketListener>, ChunkPacket { // Martijn
 
     private static final int POS_IN_SECTION_BITS = 12;
     private final SectionPos sectionPos;
@@ -54,6 +55,18 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
 
     }
 
+    // Martijn start
+    @Override
+    public int getRelatedChunkX() {
+        return this.sectionPos.chunk().x;
+    }
+
+    @Override
+    public int getRelatedChunkZ() {
+        return this.sectionPos.chunk().z;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeLong(this.sectionPos.asLong());
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityDataPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityDataPacket.java
index 3e17f6131bf590d7c4a16b79c1c145cb4f565bc9..81a7adab530c5000cde29fdbe2e9635d1d2a41d7 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityDataPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityDataPacket.java
@@ -2,11 +2,13 @@ package net.minecraft.network.protocol.game;
 
 import java.util.List;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.network.EntityIdPacket;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.syncher.SynchedEntityData;
 
-public class ClientboundSetEntityDataPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundSetEntityDataPacket implements Packet<ClientGamePacketListener>, EntityIdPacket { // Martijn
     private final int id;
     @Nullable
     private final List<SynchedEntityData.DataItem<?>> packedItems;
@@ -27,6 +29,12 @@ public class ClientboundSetEntityDataPacket implements Packet<ClientGamePacketLi
         this.packedItems = SynchedEntityData.unpack(buf);
     }
 
+    // Martijn start
+    public int getRelatedEntityId() {
+        return id;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeVarInt(this.id);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityLinkPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityLinkPacket.java
index f440ee2ba6776e09523fec54e71c14267a285492..3c4712d30402b1a9a269b8a6913ef8a307a4793f 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityLinkPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityLinkPacket.java
@@ -1,11 +1,14 @@
 package net.minecraft.network.protocol.game;
 
 import javax.annotation.Nullable;
+
+import io.papermc.paper.network.EntityIdsPacket;
+import it.unimi.dsi.fastutil.ints.IntList;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.entity.Entity;
 
-public class ClientboundSetEntityLinkPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundSetEntityLinkPacket implements Packet<ClientGamePacketListener>, EntityIdsPacket { // Martijn
     private final int sourceId;
     private final int destId;
 
@@ -19,6 +22,12 @@ public class ClientboundSetEntityLinkPacket implements Packet<ClientGamePacketLi
         this.destId = buf.readInt();
     }
 
+    // Martijn start
+    public IntList getRelatedEntityIds() {
+        return IntList.of(sourceId, destId);
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeInt(this.sourceId);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityMotionPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityMotionPacket.java
index dcfa31123acacf43b1d35b277ec0c8672f09ab3d..c84bf3e21b7884b4720c27dab1af77f4550a95ca 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityMotionPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityMotionPacket.java
@@ -1,12 +1,13 @@
 package net.minecraft.network.protocol.game;
 
+import io.papermc.paper.network.EntityIdPacket;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.util.Mth;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.phys.Vec3;
 
-public class ClientboundSetEntityMotionPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundSetEntityMotionPacket implements Packet<ClientGamePacketListener>, EntityIdPacket { // Martijn
     private final int id;
     private final int xa;
     private final int ya;
@@ -34,6 +35,12 @@ public class ClientboundSetEntityMotionPacket implements Packet<ClientGamePacket
         this.za = buf.readShort();
     }
 
+    // Martijn start
+    public int getRelatedEntityId() {
+        return id;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeVarInt(this.id);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEquipmentPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEquipmentPacket.java
index 5a8f850b447fc3a4bd0eb0c505bbdfc8be7115e8..2b82507e2e8a0085b11a2a2a8ce9833c4b6778e2 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEquipmentPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEquipmentPacket.java
@@ -3,12 +3,14 @@ package net.minecraft.network.protocol.game;
 import com.google.common.collect.Lists;
 import com.mojang.datafixers.util.Pair;
 import java.util.List;
+
+import io.papermc.paper.network.EntityIdPacket;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.entity.EquipmentSlot;
 import net.minecraft.world.item.ItemStack;
 
-public class ClientboundSetEquipmentPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundSetEquipmentPacket implements Packet<ClientGamePacketListener>, EntityIdPacket { // Martijn
     private static final byte CONTINUE_MASK = -128;
     private final int entity;
     private final List<Pair<EquipmentSlot, ItemStack>> slots;
@@ -33,6 +35,12 @@ public class ClientboundSetEquipmentPacket implements Packet<ClientGamePacketLis
 
     }
 
+    // Martijn start
+    public int getRelatedEntityId() {
+        return entity;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeVarInt(this.entity);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetPassengersPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetPassengersPacket.java
index 89b7e43a2938da79b7487db89980ac5ef2d48033..ea2bd2f57e432f6ef5c50308ef1655de28c2b2b5 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetPassengersPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetPassengersPacket.java
@@ -1,11 +1,14 @@
 package net.minecraft.network.protocol.game;
 
 import java.util.List;
+
+import io.papermc.paper.network.EntityIdsPacket;
+import it.unimi.dsi.fastutil.ints.IntList;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.entity.Entity;
 
-public class ClientboundSetPassengersPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundSetPassengersPacket implements Packet<ClientGamePacketListener>, EntityIdsPacket { // Martijn
     private final int vehicle;
     private final int[] passengers;
 
@@ -25,6 +28,18 @@ public class ClientboundSetPassengersPacket implements Packet<ClientGamePacketLi
         this.passengers = buf.readVarIntArray();
     }
 
+    // Martijn start
+    public IntList getRelatedEntityIds() {
+        if (passengers == null) {
+            return IntList.of(this.vehicle);
+        }
+        int[] entityIds = new int[this.passengers.length + 1];
+        entityIds[0] = this.vehicle;
+        System.arraycopy(this.passengers, 0, entityIds, 1, this.passengers.length);
+        return IntList.of(entityIds);
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeVarInt(this.vehicle);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSoundEntityPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSoundEntityPacket.java
index e687104e74d4478ccbc9d66e83fad9a4a314430d..cf371cd67ff0e5c7d415029d0e56d6f50c637f46 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSoundEntityPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSoundEntityPacket.java
@@ -1,5 +1,6 @@
 package net.minecraft.network.protocol.game;
 
+import io.papermc.paper.network.EntityIdPacket;
 import net.minecraft.core.Registry;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
@@ -8,7 +9,7 @@ import net.minecraft.sounds.SoundSource;
 import net.minecraft.world.entity.Entity;
 import org.apache.commons.lang3.Validate;
 
-public class ClientboundSoundEntityPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundSoundEntityPacket implements Packet<ClientGamePacketListener>, EntityIdPacket { // Martijn
     private final SoundEvent sound;
     private final SoundSource source;
     private final int id;
@@ -32,6 +33,13 @@ public class ClientboundSoundEntityPacket implements Packet<ClientGamePacketList
         this.pitch = buf.readFloat();
     }
 
+    // Martijn start
+    @Override
+    public int getRelatedEntityId() {
+        return id;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeVarInt(Registry.SOUND_EVENT.getId(this.sound));
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundTakeItemEntityPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundTakeItemEntityPacket.java
index 80268f14ecb5a09e85fdb7a83057011c3c8e9edb..534dab017dfad03a70577b5704585dce1e61be25 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundTakeItemEntityPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundTakeItemEntityPacket.java
@@ -1,9 +1,11 @@
 package net.minecraft.network.protocol.game;
 
+import io.papermc.paper.network.EntityIdsPacket;
+import it.unimi.dsi.fastutil.ints.IntList;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 
-public class ClientboundTakeItemEntityPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundTakeItemEntityPacket implements Packet<ClientGamePacketListener>, EntityIdsPacket { // Martijn
     private final int itemId;
     private final int playerId;
     private final int amount;
@@ -20,6 +22,13 @@ public class ClientboundTakeItemEntityPacket implements Packet<ClientGamePacketL
         this.amount = buf.readVarInt();
     }
 
+    // Martijn start
+    @Override
+    public IntList getRelatedEntityIds() {
+        return IntList.of(itemId, playerId);
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeVarInt(this.itemId);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundTeleportEntityPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundTeleportEntityPacket.java
index 56e4036a88e570333633bf5fc4dc4a2de4654ab9..dbd49e9339b7126bfff8f7fed25aa3fd82d8273a 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundTeleportEntityPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundTeleportEntityPacket.java
@@ -1,10 +1,11 @@
 package net.minecraft.network.protocol.game;
 
+import io.papermc.paper.network.EntityIdPacket;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.entity.Entity;
 
-public class ClientboundTeleportEntityPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundTeleportEntityPacket implements Packet<ClientGamePacketListener>, EntityIdPacket { // Martijn
     private final int id;
     private final double x;
     private final double y;
@@ -33,6 +34,13 @@ public class ClientboundTeleportEntityPacket implements Packet<ClientGamePacketL
         this.onGround = buf.readBoolean();
     }
 
+    // Martijn start
+    @Override
+    public int getRelatedEntityId() {
+        return id;
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeVarInt(this.id);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateAttributesPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateAttributesPacket.java
index 1c4cc0db0a27f7f747ce92d6cfbcb957e79c4e95..296d33f13805a0b09339fda6cbf92ffb9677900f 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateAttributesPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateAttributesPacket.java
@@ -3,6 +3,8 @@ package net.minecraft.network.protocol.game;
 import com.google.common.collect.Lists;
 import java.util.Collection;
 import java.util.List;
+
+import io.papermc.paper.network.EntityIdPacket;
 import net.minecraft.core.Registry;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
@@ -11,7 +13,7 @@ import net.minecraft.world.entity.ai.attributes.Attribute;
 import net.minecraft.world.entity.ai.attributes.AttributeInstance;
 import net.minecraft.world.entity.ai.attributes.AttributeModifier;
 
-public class ClientboundUpdateAttributesPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundUpdateAttributesPacket implements Packet<ClientGamePacketListener>, EntityIdPacket { // Martijn
     private final int entityId;
     private final List<ClientboundUpdateAttributesPacket.AttributeSnapshot> attributes;
 
@@ -38,17 +40,27 @@ public class ClientboundUpdateAttributesPacket implements Packet<ClientGamePacke
         });
     }
 
+    // Martijn start
+    @Override
+    public int getRelatedEntityId() {
+        return getEntityId();
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeVarInt(this.entityId);
         buf.writeCollection(this.attributes, (bufx, attribute) -> {
             bufx.writeResourceLocation(Registry.ATTRIBUTE.getKey(attribute.getAttribute()));
             bufx.writeDouble(attribute.getBase());
-            bufx.writeCollection(attribute.getModifiers(), (buf, modifier) -> {
-                buf.writeUUID(modifier.getId());
-                buf.writeDouble(modifier.getAmount());
-                buf.writeByte(modifier.getOperation().toValue());
+            // Martijn start
+            // Fix decompile
+            bufx.writeCollection(attribute.getModifiers(), (bufy, modifier) -> {
+                bufy.writeUUID(modifier.getId());
+                bufy.writeDouble(modifier.getAmount());
+                bufy.writeByte(modifier.getOperation().toValue());
             });
+            // Martijn end
         });
     }
 
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateMobEffectPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateMobEffectPacket.java
index 93e97b8c1b165905cc833d77b693a17c76b473de..bc69df2e89783ed36f9b74be66d137bb3f1b59ef 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateMobEffectPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateMobEffectPacket.java
@@ -1,11 +1,12 @@
 package net.minecraft.network.protocol.game;
 
+import io.papermc.paper.network.EntityIdPacket;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.effect.MobEffect;
 import net.minecraft.world.effect.MobEffectInstance;
 
-public class ClientboundUpdateMobEffectPacket implements Packet<ClientGamePacketListener> {
+public class ClientboundUpdateMobEffectPacket implements Packet<ClientGamePacketListener>, EntityIdPacket { // Martijn
     private static final int FLAG_AMBIENT = 1;
     private static final int FLAG_VISIBLE = 2;
     private static final int FLAG_SHOW_ICON = 4;
@@ -49,6 +50,13 @@ public class ClientboundUpdateMobEffectPacket implements Packet<ClientGamePacket
         this.flags = buf.readByte();
     }
 
+    // Martijn start
+    @Override
+    public int getRelatedEntityId() {
+        return getEntityId();
+    }
+    // Martijn end
+
     @Override
     public void write(FriendlyByteBuf buf) {
         buf.writeVarInt(this.entityId);
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 926d0a80cbb55184955ac6720948d2e86683cc57..b0562297977343be3ca3eddb48a495dad1f0a20a 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -3099,17 +3099,71 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
 
     @Override
     public void handleKeepAlive(ServerboundKeepAlivePacket packet) {
+        // Martijn start
+        // Catch any keep-alive responses that originate from our fake keep-alive packets after chunk packets
+        synchronized (this.connection.chunkQueue.inTransit) {
+            if (this.connection.chunkQueue.inTransit.contains(packet.getId())) {
+                // This is a response to one of our fake keep-alive packets
+                // We will remove all chunk packets in transition up to the received one that was apparently successful
+                while (!this.connection.chunkQueue.inTransit.isEmpty()) {
+                    if (this.connection.chunkQueue.inTransit.peekFirst() == packet.getId()) {
+                        this.connection.chunkQueue.inTransit.removeFirst();
+                        break;
+                    }
+                    this.connection.chunkQueue.inTransit.removeFirst();
+                }
+                return;
+            }
+        }
+        // Martijn end
         //PlayerConnectionUtils.ensureMainThread(packetplayinkeepalive, this, this.player.getWorldServer()); // CraftBukkit // Paper - This shouldn't be on the main thread
         if (this.keepAlivePending && packet.getId() == this.keepAliveChallenge) {
             int i = (int) (Util.getMillis() - this.keepAliveTime);
 
             this.player.latency = (this.player.latency * 3 + i) / 4;
+            // Martijn start
+            // Player ping was updated: if it is too high we update the
+            //if (this.player.latency != 0) {
+                if (this.player.latency > 500) {
+                    // This ping is unnaceptable
+                    this.connection.chunkQueue.maxNumberOfChunkPacketsInTransit = Connection.minMaxNumberOfChunkPacketsInTransit;
+                } else {
+                    // TODO turn into configuration options
+                    int maxNumberOfChunkPacketsInTransitChange = 0;
+                    if (this.player.latency > 400) {
+                        // This ping is very undesired
+                        maxNumberOfChunkPacketsInTransitChange = -2;
+                    } else if (this.player.latency > 300) {
+                        // This ping is quite undesired
+                        maxNumberOfChunkPacketsInTransitChange = -1;
+                    } else if (this.player.latency < 90) {
+                        // This ping is very good
+                        maxNumberOfChunkPacketsInTransitChange = 2;
+                    } else if (this.player.latency < 165) {
+                        // This ping is quite good
+                        maxNumberOfChunkPacketsInTransitChange = 1;
+                    }
+                    if (maxNumberOfChunkPacketsInTransitChange != 0) {
+                        this.connection.chunkQueue.maxNumberOfChunkPacketsInTransit = Math.max(
+                            Connection.minMaxNumberOfChunkPacketsInTransit,
+                            Math.min(
+                                Connection.maxMaxNumberOfChunkPacketsInTransit,
+                                this.connection.chunkQueue.maxNumberOfChunkPacketsInTransit + maxNumberOfChunkPacketsInTransitChange
+                            )
+                        );
+                    }
+                }
+            //}
+            // Martijn end
             this.keepAlivePending = false;
         } else if (!this.isSingleplayerOwner()) {
             // Paper start - This needs to be handled on the main thread for plugins
-            server.submit(() -> {
-            this.disconnect(new TranslatableComponent("disconnect.timeout"), org.bukkit.event.player.PlayerKickEvent.Cause.TIMEOUT); // Paper - kick event cause
-            });
+            // Martijn start
+            // Do not disconnect on late receival of keep-alive, or when keep-alive challenge is wrong
+//            server.submit(() -> {
+//            this.disconnect(new TranslatableComponent("disconnect.timeout"), org.bukkit.event.player.PlayerKickEvent.Cause.TIMEOUT); // Paper - kick event cause
+//            });
+            // Martijn end
             // Paper end
         }
 
