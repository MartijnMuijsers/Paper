From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Thu, 30 Sep 2021 20:42:55 +0200
Subject: [PATCH] Update player chunk sending in queue when next deadline is
 updated


diff --git a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
index 885ab3870d5f2d11ed8641a8ecc0c512a8840fd7..19de41ddc10120c584ce68cb873f3ef7f671a345 100644
--- a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
@@ -448,7 +448,7 @@ public final class PlayerChunkLoader {
         while (!this.chunkSendWaitQueue.isEmpty()) {
             final PlayerLoaderData data = this.chunkSendWaitQueue.first();
 
-            if (data.nextChunkSendTarget > time) {
+            if (data.getNextChunkSendTarget() > time) { // Martijn in Paper - controllable chunk sending
                 break;
             }
 
@@ -495,7 +495,7 @@ public final class PlayerChunkLoader {
             }
 
             final long nextPlayerDeadline = getTargetSendPerPlayerAddend(data.player) + time; // Martijn in Paper - per-player chunk send rate
-            data.nextChunkSendTarget = nextPlayerDeadline;
+            data.updateNextChunkSendTarget(nextPlayerDeadline); // Martijn in Paper - controllable chunk sending
             this.chunkSendWaitQueue.add(data);
 
             synchronized (this.sendingChunkCounts) {
@@ -705,7 +705,21 @@ public final class PlayerChunkLoader {
         protected int loadViewDistance = -1;
         protected int tickViewDistance = -1;
 
-        public long nextChunkSendTarget; // Martijn in Paper - update chunk send deadline based on chunk send rate
+        // Martijn in Paper start - controllable chunk sending
+        private long nextChunkSendTarget;
+
+        public long getNextChunkSendTarget() {
+            return this.nextChunkSendTarget;
+        }
+
+        public void updateNextChunkSendTarget(long target) {
+            boolean removedFromChunkSendWaitQueue = this.loader.chunkSendWaitQueue.remove(this);
+            this.nextChunkSendTarget = target;
+            if (removedFromChunkSendWaitQueue) {
+                this.loader.chunkSendWaitQueue.add(this);
+            }
+        }
+        // Martijn in Paper end - controllable chunk sending
 
         public PlayerLoaderData(final ServerPlayer player, final PlayerChunkLoader loader) {
             this.player = player;
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 4b034573044027316c407e61e269801ca4bfd34d..b08ba786c779bf9def7389affd48ffd8f01a9524 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -598,11 +598,11 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
         io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
         if (data != null) {
-            if (data.nextChunkSendTarget != 0) {
+            if (data.getNextChunkSendTarget() != 0) { // Martijn - controllable chunk sending
                 long scheduleDelay = data.loader.getTargetSendPerPlayerAddend(this.getHandle());
                 if (scheduleDelay != 0) {
                     long newTimeIfCurrentlyScheduled = System.nanoTime() + scheduleDelay;
-                    data.nextChunkSendTarget = Math.min(data.nextChunkSendTarget, newTimeIfCurrentlyScheduled);
+                    data.updateNextChunkSendTarget(Math.min(data.getNextChunkSendTarget(), newTimeIfCurrentlyScheduled)); // Martijn - controllable chunk sending
                 }
             }
         }
