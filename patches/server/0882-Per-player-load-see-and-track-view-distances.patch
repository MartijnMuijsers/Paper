From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Thu, 27 Jan 2022 00:10:19 +0100
Subject: [PATCH] Per-player load, see and track view distances


diff --git a/src/main/java/co/aikar/timings/TimingsExport.java b/src/main/java/co/aikar/timings/TimingsExport.java
index 1cb0aae3e0c619a715766e0fa604dfd9a8caefcc..200f4349cbe24fedbdac9a61f641417f869ef530 100644
--- a/src/main/java/co/aikar/timings/TimingsExport.java
+++ b/src/main/java/co/aikar/timings/TimingsExport.java
@@ -154,8 +154,11 @@ public class TimingsExport extends Thread {
                 })),
                 // Paper start - replace chunk loader system
                 pair("ticking-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance()),
-                pair("no-ticking-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetNoTickViewDistance()),
-                pair("sending-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance())
+                // Martijn start - per-player track and see view distance
+                pair("max-track-distance", world.paperConfig.getMaxTrackViewDistance()),
+                pair("max-see-distance", world.paperConfig.getMaxSeeViewDistance()),
+                pair("max-load-distance", world.paperConfig.getMaxLoadViewDistance())
+                // Martijn end - per-player track and see view distance
                 // Paper end - replace chunk loader system
             ));
         }));
diff --git a/src/main/java/co/aikar/timings/WorldTimingsHandler.java b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
index fe79c0add4f7cb18d487c5bb9415c40c5b551ea2..dc4f52c99466302345f2818c12d0760733f5fe9b 100644
--- a/src/main/java/co/aikar/timings/WorldTimingsHandler.java
+++ b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
@@ -44,6 +44,24 @@ public class WorldTimingsHandler {
     public final Timing broadcastChunkUpdates;
     public final Timing countNaturalMobs;
 
+    // Martijn start - per-player view distance
+//    public final Timing getPlayersNearChunkForSending;
+    public final Timing chunkMapPlayerMove;
+//    public final Timing chunkMapPlayerMoveUpdatePos;
+//    public final Timing chunkMapPlayerMoveUpdateDistanceManager;
+//    public final Timing chunkMapPlayerMoveUpdatePlayerMap;
+//    public final Timing chunkMapUpdatePlayerMaps;
+    public final Timing playerChunkLoaderUpdate;
+//    public final Timing chunkMapPlayerMoveUpdateChunkTrackingOrSeeing;
+//    public final Timing chunkMapPlayerMoveSortChunksForTrackAndSee;
+    public final Timing computeTrackViewDistance;
+    public final Timing computeSeeViewDistance;
+    public final Timing computeLoadViewDistance;
+    public final Timing trackViewDistanceMayHaveChanged;
+    public final Timing seeViewDistanceMayHaveChanged;
+    public final Timing loadViewDistanceMayHaveChanged;
+    // Martijn end - per-player view distance
+
     public final Timing chunkLoad;
     public final Timing chunkLoadPopulate;
     public final Timing syncChunkLoad;
@@ -119,6 +137,23 @@ public class WorldTimingsHandler {
         broadcastChunkUpdates = Timings.ofSafe(name + "Broadcast chunk updates");
         countNaturalMobs = Timings.ofSafe(name + "Count natural mobs");
 
+        // Martijn start - per-player view distance
+//        getPlayersNearChunkForSending = Timings.ofSafe("Get players near chunk for sending");
+        chunkMapPlayerMove = Timings.ofSafe("Chunk map player move");
+//        chunkMapPlayerMoveUpdatePos = Timings.ofSafe("Chunk map player move - update pos");
+//        chunkMapPlayerMoveUpdateDistanceManager = Timings.ofSafe("Chunk map player move - update distance manager");
+//        chunkMapPlayerMoveUpdatePlayerMap = Timings.ofSafe("Chunk map player move - update player map");
+//        chunkMapUpdatePlayerMaps = Timings.ofSafe("Chunk map update player maps");
+        playerChunkLoaderUpdate = Timings.ofSafe("Player chunk loader update");
+//        chunkMapPlayerMoveUpdateChunkTrackingOrSeeing = Timings.ofSafe("Chunk map player move - update chunk tracking or seeing");
+//        chunkMapPlayerMoveSortChunksForTrackAndSee = Timings.ofSafe("Chunk map player move - sort chunks for track and see");
+        computeTrackViewDistance = Timings.ofSafe("Compute track view distance");
+        computeSeeViewDistance = Timings.ofSafe("Compute see view distance");
+        computeLoadViewDistance = Timings.ofSafe("Compute load view distance");
+        trackViewDistanceMayHaveChanged = Timings.ofSafe("Track view distance may have changed");
+        seeViewDistanceMayHaveChanged = Timings.ofSafe("See view distance may have changed");
+        loadViewDistanceMayHaveChanged = Timings.ofSafe("Load view distance may have changed");
+        // Martijn end - per-player view distance
 
         miscMobSpawning = Timings.ofSafe(name + "Mob spawning - Misc");
 
diff --git a/src/main/java/com/destroystokyo/paper/PaperConfig.java b/src/main/java/com/destroystokyo/paper/PaperConfig.java
index 5e3f23d5898b391609a1115f40c94d293c4dfbd2..62cbb56af530fbc8133afac7697c5e018b2d467b 100644
--- a/src/main/java/com/destroystokyo/paper/PaperConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperConfig.java
@@ -19,6 +19,7 @@ import java.util.regex.Pattern;
 
 import com.google.common.collect.Lists;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
 import org.bukkit.Bukkit;
 import org.bukkit.ChatColor;
 import org.bukkit.command.Command;
@@ -27,6 +28,7 @@ import org.bukkit.configuration.InvalidConfigurationException;
 import org.bukkit.configuration.file.YamlConfiguration;
 import co.aikar.timings.Timings;
 import co.aikar.timings.TimingsManager;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.spigotmc.SpigotConfig;
 import org.spigotmc.WatchdogThread;
 
@@ -91,6 +93,66 @@ public class PaperConfig {
         }
     }
 
+    // Martijn start - per-player track and see view distance
+
+    public static boolean sendChunkRefreshToPlayersWhoAreSeeingButNotTracking = true;
+    private static void sendChunkRefreshToPlayersWhoAreSeeingButNotTracking() {
+        sendChunkRefreshToPlayersWhoAreSeeingButNotTracking = getBoolean("settings.view-distances.track-and-see-view-distance.if-can-see-but-not-tracking.send-chunk-refresh", sendChunkRefreshToPlayersWhoAreSeeingButNotTracking);
+    }
+
+    public static boolean sendWitherSpawnSoundToPlayersWhoAreSeeingButNotTracking = true;
+    private static void sendWitherSpawnSoundToPlayersWhoAreSeeingButNotTracking() {
+        sendWitherSpawnSoundToPlayersWhoAreSeeingButNotTracking = getBoolean("settings.view-distances.track-and-see-view-distance.if-can-see-but-not-tracking.send-wither-spawn-sound", sendWitherSpawnSoundToPlayersWhoAreSeeingButNotTracking);
+    }
+
+    public static boolean sendEnderDragonSpawnSoundToPlayersWhoAreSeeingButNotTracking = true;
+    private static void sendEnderDragonSpawnSoundToPlayersWhoAreSeeingButNotTracking() {
+        sendEnderDragonSpawnSoundToPlayersWhoAreSeeingButNotTracking = getBoolean("settings.view-distances.track-and-see-view-distance.if-can-see-but-not-tracking.send-ender-dragon-spawn-sound", sendEnderDragonSpawnSoundToPlayersWhoAreSeeingButNotTracking);
+    }
+
+    public static boolean sendEndPortalFillSoundToPlayersWhoAreSeeingButNotTracking = true;
+    private static void sendEndPortalFillSoundToPlayersWhoAreSeeingButNotTracking() {
+        sendEndPortalFillSoundToPlayersWhoAreSeeingButNotTracking = getBoolean("settings.view-distances.track-and-see-view-distance.if-can-see-but-not-tracking.send-ender-portal-fill-sound", sendEndPortalFillSoundToPlayersWhoAreSeeingButNotTracking);
+    }
+
+    /**
+     * -1 indicates no limit
+     */
+    public static int maxTotalTrackedChunks = -1;
+    private static void maxTotalTrackChunks() {
+        maxTotalTrackedChunks = getInt("settings.view-distances.track-view-distance.max-total", maxTotalTrackedChunks);
+    }
+    public static int getMaxTotalTrackedChunks() {
+        return maxTotalTrackedChunks;
+    }
+    public static void setMaxTotalTrackedChunks(int maxTotalTrackedChunks) {
+        if (PaperConfig.maxTotalTrackedChunks != maxTotalTrackedChunks) {
+            PaperConfig.maxTotalTrackedChunks = maxTotalTrackedChunks;
+            int precomputedMaxTrackViewDistanceDueToMaxTotalTrackedChunks = ServerPlayer.computeMaxTrackViewDistanceDueToMaxTotalTrackedChunks();
+            Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().trackViewDistanceMayHaveChanged(precomputedMaxTrackViewDistanceDueToMaxTotalTrackedChunks, true));
+        }
+    }
+
+    /**
+     * -1 indicates no limit
+     */
+    public static int maxTotalSeenChunks = -1;
+    private static void maxTotalSeeChunks() {
+        maxTotalSeenChunks = getInt("settings.view-distances.see-view-distance.max-total", maxTotalSeenChunks);
+    }
+    public static int getMaxTotalSeenChunks() {
+        return maxTotalSeenChunks;
+    }
+    public static void setMaxTotalSeenChunks(int maxTotalSeenChunks) {
+        if (PaperConfig.maxTotalSeenChunks != maxTotalSeenChunks) {
+            PaperConfig.maxTotalSeenChunks = maxTotalSeenChunks;
+            int precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks = ServerPlayer.computeMaxSeeViewDistanceDueToMaxTotalSeenChunks();
+            Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().seeViewDistanceMayHaveChanged(precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks, true));
+        }
+    }
+
+    // Martijn end - per-player track and see view distance
+
     // Martijn start - configurable keepalive
 
     /**
diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index d7dcf36c8c972e30320c56e447822cf26f6d5fb3..a24f9b94d92c742444a7465b6aa44b75123dd8a3 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -14,6 +14,7 @@ import java.util.Map;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.ConfigurationSection;
 import org.bukkit.configuration.file.YamlConfiguration;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.spigotmc.SpigotWorldConfig;
 
 import static com.destroystokyo.paper.PaperConfig.log;
@@ -67,6 +68,176 @@ public class PaperWorldConfig {
         }
     }
 
+    // Martijn start - per-player track view distance
+
+    private boolean perPlayerTrackViewDistance = false;
+    private void perPlayerTrackViewDistance() {
+        this.perPlayerTrackViewDistance = getBoolean("view-distances.track-view-distance.per-player", this.perPlayerTrackViewDistance);
+    }
+    public boolean getPerPlayerTrackViewDistance() {
+        return this.perPlayerTrackViewDistance;
+    }
+
+    /**
+     * This is only used if perPlayerTrackViewDistance is true
+     * -1 indicates no limit (it is still limited by the Bukkit world view distance)
+     * Valid values are -1 or an integer in the range [2, 32]
+     */
+    private int maxTrackViewDistance = -1;
+    private void maxTrackViewDistance() {
+        this.maxTrackViewDistance = getInt("view-distances.track-view-distance.max", this.maxTrackViewDistance);
+    }
+    public int getMaxTrackViewDistance() {
+        return this.maxTrackViewDistance;
+    }
+    public void setMaxTrackViewDistance(int maxTrackViewDistance) {
+        this.maxTrackViewDistance = maxTrackViewDistance;
+        Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().trackViewDistanceMayHaveChanged());
+    }
+
+    private boolean limitTrackViewDistanceByClientViewDistance = false;
+    private void limitTrackViewDistanceByClientViewDistance() {
+        setLimitTrackViewDistanceByClientViewDistance(getBoolean("view-distances.track-view-distance.limit-by-client-view-distance", this.limitTrackViewDistanceByClientViewDistance));
+    }
+    public boolean getLimitTrackViewDistanceByClientViewDistance() {
+        return this.limitTrackViewDistanceByClientViewDistance;
+    }
+    public void setLimitTrackViewDistanceByClientViewDistance(boolean limitTrackViewDistanceByClientViewDistance) {
+        this.limitTrackViewDistanceByClientViewDistance = limitTrackViewDistanceByClientViewDistance;
+        Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().trackViewDistanceMayHaveChanged());
+    }
+
+    // Martijn end - per-player track view distance
+
+    // Martijn start - per-player see view distance
+
+    private boolean perPlayerSeeViewDistance = false;
+    private void perPlayerSeeViewDistance() {
+        this.perPlayerSeeViewDistance = getBoolean("view-distances.see-view-distance.per-player", this.perPlayerSeeViewDistance);
+    }
+    public boolean getPerPlayerSeeViewDistance() {
+        return this.perPlayerSeeViewDistance;
+    }
+
+    /**
+     * This is only used if perPlayerSeeViewDistance is true
+     * -1 indicates no limit (it is still limited by the Bukkit world view distance)
+     * Valid values are -1 or an integer in the range [2, 32]
+     */
+    private int maxSeeViewDistance = -1;
+    private void maxSeeViewDistance() {
+        this.maxSeeViewDistance = getInt("view-distances.see-view-distance.max", this.maxSeeViewDistance);
+    }
+    public int getMaxSeeViewDistance() {
+        return this.maxSeeViewDistance;
+    }
+    public void setMaxSeeViewDistance(int maxSeeViewDistance) {
+        this.maxSeeViewDistance = maxSeeViewDistance;
+        Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().seeViewDistanceMayHaveChanged());
+    }
+
+    private boolean limitSeeViewDistanceByClientViewDistance = false;
+    private void limitSeeViewDistanceByClientViewDistance() {
+        setLimitSeeViewDistanceByClientViewDistance(getBoolean("view-distances.see-view-distance.limit-by-client-view-distance", this.limitSeeViewDistanceByClientViewDistance));
+    }
+    public boolean getLimitSeeViewDistanceByClientViewDistance() {
+        return this.limitSeeViewDistanceByClientViewDistance;
+    }
+    public void setLimitSeeViewDistanceByClientViewDistance(boolean limitSeeViewDistanceByClientViewDistance) {
+        this.limitSeeViewDistanceByClientViewDistance = limitSeeViewDistanceByClientViewDistance;
+        Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().seeViewDistanceMayHaveChanged());
+    }
+
+    // Martijn end - per-player see view distance
+
+    // Martijn start - per-player load view distance
+
+    private boolean perPlayerLoadViewDistance = false;
+    private void perPlayerLoadViewDistance() {
+        this.perPlayerLoadViewDistance = getBoolean("view-distances.load-view-distance.per-player", this.perPlayerLoadViewDistance);
+    }
+    public boolean getPerPlayerLoadViewDistance() {
+        return this.perPlayerLoadViewDistance;
+    }
+
+    /**
+     * This is only used if perPlayerLoadViewDistance is true
+     * -1 indicates no limit (it is still limited by the Bukkit world view distance)
+     * Valid values are -1 or an integer in the range [3, 33]
+     */
+    private int maxLoadViewDistance = -1;
+    private void maxLoadViewDistance() {
+        this.maxLoadViewDistance = getInt("view-distances.load-view-distance.max", this.maxLoadViewDistance);
+    }
+    public int getMaxLoadViewDistance() {
+        return this.maxLoadViewDistance;
+    }
+    public void setMaxLoadViewDistance(int maxLoadViewDistance) {
+        this.maxLoadViewDistance = maxLoadViewDistance;
+        Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().loadViewDistanceMayHaveChanged());
+    }
+
+    private boolean limitLoadViewDistanceBySeeViewDistance = false;
+    private void limitLoadViewDistanceBySeeViewDistance() {
+        setLimitLoadViewDistanceBySeeViewDistance(getBoolean("view-distances.load-view-distance.limit-by-see-distance", this.limitLoadViewDistanceBySeeViewDistance));
+    }
+    public boolean getLimitLoadViewDistanceBySeeViewDistance() {
+        return this.limitLoadViewDistanceBySeeViewDistance;
+    }
+    public void setLimitLoadViewDistanceBySeeViewDistance(boolean limitLoadViewDistanceBySeeViewDistance) {
+        this.limitLoadViewDistanceBySeeViewDistance = limitLoadViewDistanceBySeeViewDistance;
+        Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().loadViewDistanceMayHaveChanged());
+    }
+
+    private boolean limitLoadViewDistanceByClientViewDistance = false;
+    private void limitLoadViewDistanceByClientViewDistance() {
+        setLimitLoadViewDistanceByClientViewDistance(getBoolean("view-distances.load-view-distance.limit-by-client-view-distance", this.limitLoadViewDistanceByClientViewDistance));
+    }
+    public boolean getLimitLoadViewDistanceByClientViewDistance() {
+        return this.limitLoadViewDistanceByClientViewDistance;
+    }
+    public void setLimitLoadViewDistanceByClientViewDistance(boolean limitLoadViewDistanceByClientViewDistance) {
+        this.limitLoadViewDistanceByClientViewDistance = limitLoadViewDistanceByClientViewDistance;
+        Bukkit.getOnlinePlayers().forEach(player -> ((CraftPlayer) player).getHandle().loadViewDistanceMayHaveChanged());
+    }
+
+    /**
+     * In ticks
+     * A nonpositive integer disables this feature
+     */
+    public int printLoadedChunksInterval = -1;
+    private void printLoadedChunksInterval() {
+        printLoadedChunksInterval = getInt("view-distances.load-view-distance.print-loaded-chunks-interval", this.printLoadedChunksInterval);
+    }
+
+    // Martijn end - per-player load view distance
+
+    // Martijn start - sort chunks by distance
+
+    // Replaced because of the similar sorting of send queues as determined by PlayerChunkLoader.createSendQueue()
+//    public boolean trackAndSeeChunksInSpiralOrderWhenChangingWorld = false;
+//    private void trackAndSeeChunksInSpiralOrderWhenChangingWorld() {
+//        this.trackAndSeeChunksInSpiralOrderWhenChangingWorld = getBoolean("view-distances.track-and-see-view-distance.track-and-see-chunks-in-spiral-order-when-changing-world", this.trackAndSeeChunksInSpiralOrderWhenChangingWorld);
+//    }
+//
+//    public boolean trackAndSeeChunksInOrderOfDistanceWhenChangingViewDistance = false;
+//    private void trackAndSeeChunksInOrderOfDistanceWhenChangingViewDistance() {
+//        this.trackAndSeeChunksInOrderOfDistanceWhenChangingViewDistance = getBoolean("view-distances.track-and-see-view-distance.track-and-see-chunks-in-order-of-distance-when-changing-view-distance", this.trackAndSeeChunksInOrderOfDistanceWhenChangingViewDistance);
+//    }
+//
+//    public boolean trackAndSeeChunksInOrderOfDistanceWhenMoving = false;
+//    private void trackAndSeeChunksInOrderOfDistanceWhenMoving() {
+//        this.trackAndSeeChunksInOrderOfDistanceWhenMoving = getBoolean("view-distances.track-and-see-view-distance.track-and-see-chunks-in-order-of-distance-when-moving", this.trackAndSeeChunksInOrderOfDistanceWhenMoving);
+//    }
+
+    // Not necessary anymore, because the chunks will end up in a send queue, which will be sorted similarly as determined by PlayerChunkLoader.createSendQueue()
+//    public boolean processChunksInOrderOfDistanceAfterLoad = false;
+//    private void processChunksInOrderOfDistanceAfterLoad() {
+//        this.processChunksInOrderOfDistanceAfterLoad = getBoolean("view-distances.load-view-distance.process-chunks-in-order-of-distance-after-load", this.processChunksInOrderOfDistanceAfterLoad);
+//    }
+
+    // Martijn end - sort chunks by distance
+
     public boolean zombiesTargetTurtleEggs = true;
     private void zombiesTargetTurtleEggs() {
         zombiesTargetTurtleEggs = getBoolean("zombies-target-turtle-eggs", zombiesTargetTurtleEggs);
diff --git a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
index 6d4f5ab1bcc166b926c67dc9613f326c3fc7e544..c1e945c475f5a5db1cd80879cff453624f109204 100644
--- a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
@@ -20,6 +20,7 @@ import net.minecraft.util.Mth;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.chunk.LevelChunk;
 import org.apache.commons.lang3.mutable.MutableObject;
+import org.bukkit.Chunk;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.entity.Player;
 import java.util.ArrayDeque;
@@ -49,31 +50,33 @@ public final class PlayerChunkLoader {
         return data.getTargetTickViewDistance();
     }
 
-    public static int getLoadViewDistance(final Player player) {
-        return getLoadViewDistance(((CraftPlayer)player).getHandle());
-    }
-
-    public static int getLoadViewDistance(final ServerPlayer player) {
-        final ServerLevel level = (ServerLevel)player.level;
-        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
-        if (data == null) {
-            return level.chunkSource.chunkMap.playerChunkManager.getLoadDistance();
-        }
-        return data.getLoadDistance();
-    }
-
-    public static int getSendViewDistance(final Player player) {
-        return getSendViewDistance(((CraftPlayer)player).getHandle());
-    }
-
-    public static int getSendViewDistance(final ServerPlayer player) {
-        final ServerLevel level = (ServerLevel)player.level;
-        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
-        if (data == null) {
-            return level.chunkSource.chunkMap.playerChunkManager.getTargetSendDistance();
-        }
-        return data.getTargetSendViewDistance();
-    }
+    // Martijn start - per-player view distance
+//    public static int getLoadViewDistance(final Player player) {
+//        return getLoadViewDistance(((CraftPlayer)player).getHandle());
+//    }
+//
+//    public static int getLoadViewDistance(final ServerPlayer player) {
+//        final ServerLevel level = (ServerLevel)player.level;
+//        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
+//        if (data == null) {
+//            return level.chunkSource.chunkMap.playerChunkManager.getLoadDistance();
+//        }
+//        return data.getLoadDistance();
+//    }
+
+//    public static int getSendViewDistance(final Player player) {
+//        return getSendViewDistance(((CraftPlayer)player).getHandle());
+//    }
+//
+//    public static int getSendViewDistance(final ServerPlayer player) {
+//        final ServerLevel level = (ServerLevel)player.level;
+//        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
+//        if (data == null) {
+//            return level.chunkSource.chunkMap.playerChunkManager.getTargetSendDistance();
+//        }
+//        return data.getTargetSendViewDistance();
+//    }
+    // Martijn end - per-player view distance
 
     protected final ChunkMap chunkMap;
     protected final Reference2ObjectLinkedOpenHashMap<ServerPlayer, PlayerLoaderData> playerMap = new Reference2ObjectLinkedOpenHashMap<>(512, 0.7f);
@@ -129,7 +132,15 @@ public final class PlayerChunkLoader {
     /**
      * The chunks to be sent to players, provided they're send-ready. Send-ready means the chunk and its 1 radius neighbours are loaded.
      */
-    public final PlayerAreaMap broadcastMap;
+    // Martijn start - per-player track and see view distance
+    public final PlayerAreaMap broadcastMapForTracking;
+    public final PlayerAreaMap broadcastMapForSeeing;
+
+    public PlayerAreaMap getBroadcastMap(final boolean concernsTracking) {
+        return concernsTracking ? this.broadcastMapForTracking : this.broadcastMapForSeeing;
+    }
+
+    // Martijn end - per-player track and see view distance
 
     /**
      * The chunks to be brought up to send-ready status. Send-ready means the chunk and its 1 radius neighbours are loaded.
@@ -147,15 +158,17 @@ public final class PlayerChunkLoader {
      */
     public final PlayerAreaMap tickMap;
 
-    /**
-     * -1 if defaulting to [load distance], else always in [2, load distance]
-     */
-    protected int rawSendDistance = -1;
-
-    /**
-     * -1 if defaulting to [tick view distance + 1], else always in [tick view distance + 1, 32 + 1]
-     */
-    protected int rawLoadDistance = -1;
+    // Martijn start - per-player view distance
+//    /**
+//     * -1 if defaulting to [load distance], else always in [2, load distance]
+//     */
+//    protected int rawSendDistance = -1;
+//
+//    /**
+//     * -1 if defaulting to [tick view distance + 1], else always in [tick view distance + 1, 32 + 1]
+//     */
+//    protected int rawLoadDistance = -1;
+    // Martijn end - per-player view distance
 
     /**
      * Never -1, always in [2, 32]
@@ -172,47 +185,49 @@ public final class PlayerChunkLoader {
         this.setTickDistance(distance);
     }
 
-    public int getTargetNoTickViewDistance() {
-        return this.getLoadDistance() - 1;
-    }
-
-    public void setTargetNoTickViewDistance(final int distance) {
-        this.setLoadDistance(distance == -1 ? -1 : distance + 1);
-    }
-
-    public int getTargetSendDistance() {
-        return this.rawSendDistance == -1 ? this.getLoadDistance() : this.rawSendDistance;
-    }
-
-    public void setTargetSendDistance(final int distance) {
-        this.setSendDistance(distance);
-    }
-
-    // internal methods
-
-    public int getSendDistance() {
-        final int loadDistance = this.getLoadDistance();
-        return this.rawSendDistance == -1 ? loadDistance : Math.min(this.rawSendDistance, loadDistance);
-    }
-
-    public void setSendDistance(final int distance) {
-        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
-            throw new IllegalArgumentException(Integer.toString(distance));
-        }
-        this.rawSendDistance = distance;
-    }
-
-    public int getLoadDistance() {
-        final int tickDistance = this.getTickDistance();
-        return this.rawLoadDistance == -1 ? tickDistance + 1 : Math.max(tickDistance + 1, this.rawLoadDistance);
-    }
-
-    public void setLoadDistance(final int distance) {
-        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
-            throw new IllegalArgumentException(Integer.toString(distance));
-        }
-        this.rawLoadDistance = distance;
-    }
+    // Martijn start - per-player view distance
+//    public int getTargetNoTickViewDistance() {
+//        return this.getLoadDistance() - 1;
+//    }
+//
+//    public void setTargetNoTickViewDistance(final int distance) {
+//        this.setLoadDistance(distance == -1 ? -1 : distance + 1);
+//    }
+//
+//    public int getTargetSendDistance() {
+//        return this.rawSendDistance == -1 ? this.getLoadDistance() : this.rawSendDistance;
+//    }
+//
+//    public void setTargetSendDistance(final int distance) {
+//        this.setSendDistance(distance);
+//    }
+//
+//    // internal methods
+//
+//    public int getSendDistance() {
+//        final int loadDistance = this.getLoadDistance();
+//        return this.rawSendDistance == -1 ? loadDistance : Math.min(this.rawSendDistance, loadDistance);
+//    }
+//
+//    public void setSendDistance(final int distance) {
+//        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
+//            throw new IllegalArgumentException(Integer.toString(distance));
+//        }
+//        this.rawSendDistance = distance;
+//    }
+//
+//    public int getLoadDistance() {
+//        final int tickDistance = this.getTickDistance();
+//        return this.rawLoadDistance == -1 ? tickDistance + 1 : Math.max(tickDistance + 1, this.rawLoadDistance);
+//    }
+//
+//    public void setLoadDistance(final int distance) {
+//        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
+//            throw new IllegalArgumentException(Integer.toString(distance));
+//        }
+//        this.rawLoadDistance = distance;
+//    }
+    // Martijn end - per-player view distance
 
     public int getTickDistance() {
         return this.rawTickDistance;
@@ -250,12 +265,20 @@ public final class PlayerChunkLoader {
 
     public PlayerChunkLoader(final ChunkMap chunkMap, final PooledLinkedHashSets<ServerPlayer> pooledHashSets) {
         this.chunkMap = chunkMap;
-        this.broadcastMap = new PlayerAreaMap(pooledHashSets,
+        // Martijn start - player track and see view distance
+        this.broadcastMapForTracking = new PlayerAreaMap(pooledHashSets,
                 null,
                 (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
                  com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
-                    PlayerChunkLoader.this.onChunkLeave(player, rangeX, rangeZ);
+                    PlayerChunkLoader.this.onChunkLeave(player, rangeX, rangeZ, true);
                 });
+        this.broadcastMapForSeeing = new PlayerAreaMap(pooledHashSets,
+                null,
+                (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                    PlayerChunkLoader.this.onChunkLeave(player, rangeX, rangeZ, false);
+                });
+        // Martijn end - player track and see view distance
         this.loadMap = new PlayerAreaMap(pooledHashSets,
                 null,
                 (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
@@ -305,12 +328,16 @@ public final class PlayerChunkLoader {
     protected final LongOpenHashSet isTargetedForPlayerLoad = new LongOpenHashSet();
     protected final LongOpenHashSet chunkTicketTracker = new LongOpenHashSet();
 
-    public boolean isChunkNearPlayers(final int chunkX, final int chunkZ) {
-        final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.broadcastMap.getObjectsInRange(chunkX, chunkZ);
+    // Martijn start - per-player track and see view distance
+
+    public boolean isChunkNearPlayers(final int chunkX, final int chunkZ, boolean concernsTracking) {
+        final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.getBroadcastMap(concernsTracking).getObjectsInRange(chunkX, chunkZ);
 
         return playersInSendRange != null;
     }
 
+    // Martijn end - per-player track and see view distance
+
     public void onChunkPostProcessing(final int chunkX, final int chunkZ) {
         this.onChunkSendReady(chunkX, chunkZ);
     }
@@ -342,34 +369,38 @@ public final class PlayerChunkLoader {
         return levelChunk != null && levelChunk.isPostProcessingDone && this.isTargetedForPlayerLoad.contains(key);
     }
 
-    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean borderOnly) {
-        return borderOnly ? this.isChunkSentBorderOnly(player, chunkX, chunkZ) : this.isChunkSent(player, chunkX, chunkZ);
+    // Martijn start - per-player track and see view distance
+
+    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean borderOnly, final boolean concernsTracking) {
+        return borderOnly ? this.isChunkSentBorderOnly(player, chunkX, chunkZ, concernsTracking) : this.isChunkSent(player, chunkX, chunkZ, concernsTracking);
     }
 
-    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) {
         final PlayerLoaderData data = this.playerMap.get(player);
         if (data == null) {
             return false;
         }
 
-        return data.hasSentChunk(chunkX, chunkZ);
+        return data.hasSentChunk(chunkX, chunkZ, concernsTracking);
     }
 
-    public boolean isChunkSentBorderOnly(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public boolean isChunkSentBorderOnly(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) {
         final PlayerLoaderData data = this.playerMap.get(player);
         if (data == null) {
             return false;
         }
 
-        final boolean center = data.hasSentChunk(chunkX, chunkZ);
+        final boolean center = data.hasSentChunk(chunkX, chunkZ, concernsTracking);
         if (!center) {
             return false;
         }
 
-        return !(data.hasSentChunk(chunkX - 1, chunkZ) && data.hasSentChunk(chunkX + 1, chunkZ) &&
-            data.hasSentChunk(chunkX, chunkZ - 1) && data.hasSentChunk(chunkX, chunkZ + 1));
+        return !(data.hasSentChunk(chunkX - 1, chunkZ, concernsTracking) && data.hasSentChunk(chunkX + 1, chunkZ, concernsTracking) &&
+            data.hasSentChunk(chunkX, chunkZ - 1, concernsTracking) && data.hasSentChunk(chunkX, chunkZ + 1, concernsTracking));
     }
 
+    // Martijn end - per-player track and see view distance
+
     protected int getMaxConcurrentChunkSends() {
         return PaperConfig.playerMaxConcurrentChunkSends;
     }
@@ -394,47 +425,55 @@ public final class PlayerChunkLoader {
     }
 
     public void onChunkSendReady(final int chunkX, final int chunkZ) {
-        final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.broadcastMap.getObjectsInRange(chunkX, chunkZ);
 
-        if (playersInSendRange == null) {
-            return;
-        }
+        // Martijn start - per-player track and see view distance
 
-        final Object[] rawData = playersInSendRange.getBackingSet();
-        for (int i = 0, len = rawData.length; i < len; ++i) {
-            final Object raw = rawData[i];
+        for (boolean concernsTracking : new boolean[] {false, true}) {
+            final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.getBroadcastMap(concernsTracking).getObjectsInRange(chunkX, chunkZ);
 
-            if (!(raw instanceof ServerPlayer)) {
-                continue;
+            if (playersInSendRange == null) {
+                return;
+            }
+
+            final Object[] rawData = playersInSendRange.getBackingSet();
+            for (int i = 0, len = rawData.length; i < len; ++i) {
+                final Object raw = rawData[i];
+
+                if (!(raw instanceof ServerPlayer)) {
+                    continue;
+                }
+                this.onChunkSendReady((ServerPlayer) raw, chunkX, chunkZ, concernsTracking);
             }
-            this.onChunkSendReady((ServerPlayer)raw, chunkX, chunkZ);
         }
+
+        // Martijn end - per-player track and see view distance
+
     }
 
-    public void onChunkSendReady(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public void onChunkSendReady(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) { // Martijn - per-player track and see view distance
         final PlayerLoaderData data = this.playerMap.get(player);
 
         if (data == null) {
             return;
         }
 
-        if (data.hasSentChunk(chunkX, chunkZ) || !this.isChunkPlayerLoaded(chunkX, chunkZ)) {
+        if (data.hasSentChunk(chunkX, chunkZ, concernsTracking) || !this.isChunkPlayerLoaded(chunkX, chunkZ)) { // Martijn - per-player track and see view distance
             // if we don't have player tickets, then the load logic will pick this up and queue to send
             return;
         }
 
-        if (!data.chunksToBeSent.remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
+        if (!data.getChunksToBeSent(concernsTracking).remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) { // Martijn - per-player track and see view distance
             // don't queue to send, we don't want the chunk
             return;
         }
 
-        final long playerPos = this.broadcastMap.getLastCoordinate(player);
+        final long playerPos = this.broadcastMapForSeeing.getLastCoordinate(player); // Martijn - per-player track and see view distance
         final int playerChunkX = CoordinateUtils.getChunkX(playerPos);
         final int playerChunkZ = CoordinateUtils.getChunkZ(playerPos);
         final int manhattanDistance = Math.abs(playerChunkX - chunkX) + Math.abs(playerChunkZ - chunkZ);
 
         final ChunkPriorityHolder holder = new ChunkPriorityHolder(chunkX, chunkZ, manhattanDistance, 0.0);
-        data.sendQueue.add(holder);
+        data.getSendQueue(concernsTracking).add(holder); // Martijn - per-player track and see view distance
     }
 
     public void onChunkLoad(final int chunkX, final int chunkZ) {
@@ -443,14 +482,14 @@ public final class PlayerChunkLoader {
         }
     }
 
-    public void onChunkLeave(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public void onChunkLeave(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) { // Martijn - per-player track and see view distance
         final PlayerLoaderData data = this.playerMap.get(player);
 
         if (data == null) {
             return;
         }
 
-        data.unloadChunk(chunkX, chunkZ);
+        data.unloadChunk(chunkX, chunkZ, concernsTracking); // Martijn - per-player track and see view distance
     }
 
     public void addPlayer(final ServerPlayer player) {
@@ -553,7 +592,14 @@ public final class PlayerChunkLoader {
 
             final PlayerLoaderData data = this.chunkSendQueue.removeFirst();
 
-            final ChunkPriorityHolder queuedSend = data.sendQueue.pollFirst();
+            // Martijn start - per-player track and see view distance
+            ChunkPriorityHolder queuedSend = data.getSendQueue(true).pollFirst();
+            boolean concernsTracking = true;
+            if (queuedSend == null) {
+                queuedSend = data.getSendQueue(false).pollFirst();
+                concernsTracking = false;
+            }
+            // Martijn end - per-player track and see view distance
             if (queuedSend == null) {
                 concurrentChunkSends.getAndDecrement(); // we never sent, so decrease
                 // stop iterating over players who have nothing to send
@@ -590,7 +636,7 @@ public final class PlayerChunkLoader {
                 }
 
                 concurrentChunkSends.getAndDecrement();
-            });
+            }, concernsTracking);
 
             nextChunkSend = this.getMaxSendAddend() + time;
             if (time < nextChunkSend) {
@@ -763,7 +809,10 @@ public final class PlayerChunkLoader {
         // this is corrected so that 0 is along the positive x-axis
         protected float lastYaw = Float.NEGATIVE_INFINITY;
 
-        protected int lastSendDistance = Integer.MIN_VALUE;
+        // Martijn start - per-player track and see view distance
+        protected int lastTrackDistance = Integer.MIN_VALUE;
+        protected int lastSeeDistance = Integer.MIN_VALUE;
+        // Martijn end - per-player track and see view distance
         protected int lastLoadDistance = Integer.MIN_VALUE;
         protected int lastTickDistance = Integer.MIN_VALUE;
         protected boolean usingLookingPriority;
@@ -774,61 +823,86 @@ public final class PlayerChunkLoader {
         // warning: modifications of this field must be aware that the loadQueue inside PlayerChunkLoader uses this field
         // in a comparator!
         protected final ArrayDeque<ChunkPriorityHolder> loadQueue = new ArrayDeque<>();
-        protected final LongOpenHashSet sentChunks = new LongOpenHashSet();
-        protected final LongOpenHashSet chunksToBeSent = new LongOpenHashSet();
 
-        protected final TreeSet<ChunkPriorityHolder> sendQueue = new TreeSet<>((final ChunkPriorityHolder p1, final ChunkPriorityHolder p2) -> {
-            final int distanceCompare = Integer.compare(p1.manhattanDistanceToPlayer, p2.manhattanDistanceToPlayer);
-            if (distanceCompare != 0) {
-                return distanceCompare;
-            }
+        // Martijn start - per-player view distance
 
-            final int coordinateXCompare = Integer.compare(p1.chunkX, p2.chunkX);
-            if (coordinateXCompare != 0) {
-                return coordinateXCompare;
-            }
+        protected final LongOpenHashSet sentChunksForTracking = new LongOpenHashSet();
+        protected final LongOpenHashSet chunksToBeSentForTracking = new LongOpenHashSet();
 
-            return Integer.compare(p1.chunkZ, p2.chunkZ);
-        });
+        protected final LongOpenHashSet sentChunksForSeeing = new LongOpenHashSet();
+        protected final LongOpenHashSet chunksToBeSentForSeeing = new LongOpenHashSet();
 
-        protected int sendViewDistance = -1;
-        protected int loadViewDistance = -1;
-        protected int tickViewDistance = -1;
+        private TreeSet<ChunkPriorityHolder> createSendQueue() {
+            return new TreeSet<>((final ChunkPriorityHolder p1, final ChunkPriorityHolder p2) -> {
+                final int distanceCompare = Integer.compare(p1.manhattanDistanceToPlayer, p2.manhattanDistanceToPlayer);
+                if (distanceCompare != 0) {
+                    return distanceCompare;
+                }
 
-        protected long nextChunkSendTarget;
+                final int coordinateXCompare = Integer.compare(p1.chunkX, p2.chunkX);
+                if (coordinateXCompare != 0) {
+                    return coordinateXCompare;
+                }
 
-        public PlayerLoaderData(final ServerPlayer player, final PlayerChunkLoader loader) {
-            this.player = player;
-            this.loader = loader;
+                return Integer.compare(p1.chunkZ, p2.chunkZ);
+            });
         }
+        protected final TreeSet<ChunkPriorityHolder> sendQueueForTracking = createSendQueue();
+        protected final TreeSet<ChunkPriorityHolder> sendQueueForSeeing = createSendQueue();
 
-        // these view distance methods are for api
-        public int getTargetSendViewDistance() {
-            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
-            final int loadViewDistance = Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
-            final int clientViewDistance = this.getClientViewDistance();
-            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!PaperConfig.playerAutoConfigureSendViewDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
-            return sendViewDistance;
+        protected LongOpenHashSet getSentChunks(final boolean concernsTracking) {
+            return concernsTracking ? this.sentChunksForTracking : this.sentChunksForSeeing;
         }
 
-        public void setTargetSendViewDistance(final int distance) {
-            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
-                throw new IllegalArgumentException(Integer.toString(distance));
-            }
-            this.sendViewDistance = distance;
+        protected LongOpenHashSet getChunksToBeSent(final boolean concernsTracking) {
+            return concernsTracking ? this.chunksToBeSentForTracking : this.chunksToBeSentForSeeing;
         }
 
-        public int getTargetNoTickViewDistance() {
-            return (this.loadViewDistance == -1 ? this.getLoadDistance() : this.loadViewDistance) - 1;
+        protected TreeSet<ChunkPriorityHolder> getSendQueue(final boolean concernsTracking) {
+            return concernsTracking ? this.sendQueueForTracking : this.sendQueueForSeeing;
         }
 
-        public void setTargetNoTickViewDistance(final int distance) {
-            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE)) {
-                throw new IllegalArgumentException(Integer.toString(distance));
-            }
-            this.loadViewDistance = distance == -1 ? -1 : distance + 1;
+
+//        protected int sendViewDistance = -1;
+//        protected int loadViewDistance = -1;
+        protected int tickViewDistance = -1;
+
+        // Martijn end - per-player view distance
+
+        protected long nextChunkSendTarget;
+
+        public PlayerLoaderData(final ServerPlayer player, final PlayerChunkLoader loader) {
+            this.player = player;
+            this.loader = loader;
         }
 
+//        // these view distance methods are for api
+//        public int getTargetSendViewDistance() {
+//            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+//            final int loadViewDistance = Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
+//            final int clientViewDistance = this.getClientViewDistance();
+//            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!PaperConfig.playerAutoConfigureSendViewDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
+//            return sendViewDistance;
+//        }
+//
+//        public void setTargetSendViewDistance(final int distance) {
+//            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
+//                throw new IllegalArgumentException(Integer.toString(distance));
+//            }
+//            this.sendViewDistance = distance;
+//        }
+
+//        public int getTargetNoTickViewDistance() {
+//            return (this.loadViewDistance == -1 ? this.getLoadDistance() : this.loadViewDistance) - 1;
+//        }
+//
+//        public void setTargetNoTickViewDistance(final int distance) {
+//            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE)) {
+//                throw new IllegalArgumentException(Integer.toString(distance));
+//            }
+//            this.loadViewDistance = distance == -1 ? -1 : distance + 1;
+//        }
+
         public int getTargetTickViewDistance() {
             return this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
         }
@@ -840,33 +914,37 @@ public final class PlayerChunkLoader {
             this.tickViewDistance = distance;
         }
 
-        protected int getLoadDistance() {
-            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+//        protected int getLoadDistance() {
+//            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+//
+//            return Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
+//        }
 
-            return Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
-        }
+        // Martijn start - per-player view distance
 
-        public boolean hasSentChunk(final int chunkX, final int chunkZ) {
-            return this.sentChunks.contains(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+        public boolean hasSentChunk(final int chunkX, final int chunkZ, final boolean concernsTracking) {
+            return this.getSentChunks(concernsTracking).contains(CoordinateUtils.getChunkKey(chunkX, chunkZ));
         }
 
-        public void sendChunk(final int chunkX, final int chunkZ, final Runnable onChunkSend) {
-            if (this.sentChunks.add(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
+        public void sendChunk(final int chunkX, final int chunkZ, final Runnable onChunkSend, final boolean concernsTracking) {
+            if (this.getSentChunks(concernsTracking).add(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
                 this.player.getLevel().getChunkSource().chunkMap.updateChunkTracking(this.player,
-                        new ChunkPos(chunkX, chunkZ), new MutableObject<>(), false, true); // unloaded, loaded
+                        new ChunkPos(chunkX, chunkZ), new MutableObject<>(), false, true, concernsTracking); // unloaded, loaded
                 this.player.connection.connection.execute(onChunkSend);
             } else {
                 throw new IllegalStateException();
             }
         }
 
-        public void unloadChunk(final int chunkX, final int chunkZ) {
-            if (this.sentChunks.remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
+        public void unloadChunk(final int chunkX, final int chunkZ, final boolean concernsTracking) {
+            if (this.getSentChunks(concernsTracking).remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
                 this.player.getLevel().getChunkSource().chunkMap.updateChunkTracking(this.player,
-                        new ChunkPos(chunkX, chunkZ), null, true, false); // unloaded, loaded
+                        new ChunkPos(chunkX, chunkZ), null, true, false, concernsTracking); // unloaded, loaded
             }
         }
 
+        // Martijn end - per-player view distance
+
         protected static boolean wantChunkLoaded(final int centerX, final int centerZ, final int chunkX, final int chunkZ,
                                                  final int sendRadius) {
             // expect sendRadius to be = 1 + target viewable radius
@@ -908,7 +986,10 @@ public final class PlayerChunkLoader {
         }
 
         public void remove() {
-            this.loader.broadcastMap.remove(this.player);
+            // Martijn start - per-player track and see view distance
+            this.loader.getBroadcastMap(false).remove(this.player);
+            this.loader.getBroadcastMap(true).remove(this.player);
+            // Martijn end - per-player track and see view distance
             this.loader.loadMap.remove(this.player);
             this.loader.loadTicketCleanup.remove(this.player);
             this.loader.tickMap.remove(this.player);
@@ -919,12 +1000,20 @@ public final class PlayerChunkLoader {
         }
 
         public void update() {
-            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+            // Martijn start - per-player view distance
+            this.player.level.timings.playerChunkLoaderUpdate.startTiming();
+            this.player.trackViewDistanceMayHaveChanged();
+            this.player.seeViewDistanceMayHaveChanged();
+            this.player.loadViewDistanceMayHaveChanged();
+            final int loadViewDistance = this.player.getCachedLoadViewDistance();
             // load view cannot be less-than tick view + 1
-            final int loadViewDistance = Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
+            final int tickViewDistance = Math.min(this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance, loadViewDistance - 1);
             // send view cannot be greater-than load view
             final int clientViewDistance = this.getClientViewDistance();
-            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!PaperConfig.playerAutoConfigureSendViewDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
+//            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!PaperConfig.playerAutoConfigureSendViewDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
+            final int trackViewDistance = this.player.getCachedTrackViewDistance();
+            final int seeViewDistance = this.player.getCachedSeeViewDistance();
+            // Martijn end - per-player view distance
 
             final double posX = this.player.getX();
             final double posZ = this.player.getZ();
@@ -939,7 +1028,7 @@ public final class PlayerChunkLoader {
 
             if (
                 // has view distance stayed the same?
-                    sendViewDistance == this.lastSendDistance
+                    trackViewDistance == this.lastTrackDistance && seeViewDistance == this.lastSeeDistance // Martijn - per-player track and see view distance
                             && loadViewDistance == this.lastLoadDistance
                             && tickViewDistance == this.lastTickDistance
 
@@ -960,6 +1049,7 @@ public final class PlayerChunkLoader {
                             && (!this.usingLookingPriority || Math.abs(yaw - this.lastYaw) <= LOOK_PRIORITY_YAW_DELTA_RECALC_THRESHOLD)
             ) {
                 // nothing we care about changed, so we're not re-calculating
+                this.player.level.timings.playerChunkLoaderUpdate.stopTiming(); // Martijn - per-player view distance
                 return;
             }
 
@@ -967,16 +1057,20 @@ public final class PlayerChunkLoader {
             final int centerChunkZ = Mth.floor(posZ) >> 4;
 
             final boolean needsChunkCenterUpdate = (centerChunkX != this.lastChunkX) || (centerChunkZ != this.lastChunkZ);
-            this.loader.broadcastMap.addOrUpdate(this.player, centerChunkX, centerChunkZ, sendViewDistance);
+
+            // Martijn start - per-player track and see view distance
+            this.loader.getBroadcastMap(false).addOrUpdate(this.player, centerChunkX, centerChunkZ, seeViewDistance);
+            this.loader.getBroadcastMap(true).addOrUpdate(this.player, centerChunkX, centerChunkZ, trackViewDistance);
+            // Martijn end - per-player track and see view distance
             this.loader.loadMap.addOrUpdate(this.player, centerChunkX, centerChunkZ, loadViewDistance);
             this.loader.loadTicketCleanup.addOrUpdate(this.player, centerChunkX, centerChunkZ, loadViewDistance + 1);
             this.loader.tickMap.addOrUpdate(this.player, centerChunkX, centerChunkZ, tickViewDistance);
 
-            if (sendViewDistance != this.lastSendDistance) {
+            if (seeViewDistance != this.lastSeeDistance) { // Martijn - per-player track and see view distance
                 // update the view radius for client
                 // note that this should be after the map calls because the client wont expect unload calls not in its VD
                 // and it's possible we decreased VD here
-                this.player.connection.send(new ClientboundSetChunkCacheRadiusPacket(sendViewDistance));
+                this.player.connection.send(new ClientboundSetChunkCacheRadiusPacket(seeViewDistance)); // Martijn - per-player track and see view distance
             }
             if (tickViewDistance != this.lastTickDistance) {
                 this.player.connection.send(new ClientboundSetSimulationDistancePacket(tickViewDistance));
@@ -985,7 +1079,10 @@ public final class PlayerChunkLoader {
             this.lastLocX = posX;
             this.lastLocZ = posZ;
             this.lastYaw = yaw;
-            this.lastSendDistance = sendViewDistance;
+            // Martijn start - per-player track and see view distance
+            this.lastTrackDistance = trackViewDistance;
+            this.lastSeeDistance = seeViewDistance;
+            // Martijn start - per-player track and see view distance
             this.lastLoadDistance = loadViewDistance;
             this.lastTickDistance = tickViewDistance;
             this.usingLookingPriority = useLookPriority;
@@ -1015,76 +1112,87 @@ public final class PlayerChunkLoader {
 
             final List<ChunkPriorityHolder> loadQueue = new ArrayList<>();
 
+            // Martijn start - per-player track and see view distance
+
             // clear send queue, we are re-sorting
-            this.sendQueue.clear();
+            this.getSendQueue(false).clear();
+            this.getSendQueue(true).clear();
             // clear chunk want set, vd/position might have changed
-            this.chunksToBeSent.clear();
-
-            final int searchViewDistance = Math.max(loadViewDistance, sendViewDistance);
-
-            for (int dx = -searchViewDistance; dx <= searchViewDistance; ++dx) {
-                for (int dz = -searchViewDistance; dz <= searchViewDistance; ++dz) {
-                    final int chunkX = dx + centerChunkX;
-                    final int chunkZ = dz + centerChunkZ;
-                    final int squareDistance = Math.max(Math.abs(dx), Math.abs(dz));
-                    final boolean sendChunk = squareDistance <= sendViewDistance && wantChunkLoaded(centerChunkX, centerChunkZ, chunkX, chunkZ, sendViewDistance);
-
-                    if (this.hasSentChunk(chunkX, chunkZ)) {
-                        // already sent (which means it is also loaded)
-                        if (!sendChunk) {
-                            // have sent the chunk, but don't want it anymore
-                            // unload it now
-                            this.unloadChunk(chunkX, chunkZ);
+            this.getChunksToBeSent(false).clear();
+            this.getChunksToBeSent(true).clear();
+
+            for (boolean concernsTracking : new boolean[] {false, true}) {
+
+                final int sendViewDistance = concernsTracking ? trackViewDistance : seeViewDistance;
+
+                final int searchViewDistance = Math.max(loadViewDistance, sendViewDistance);
+
+                for (int dx = -searchViewDistance; dx <= searchViewDistance; ++dx) {
+                    for (int dz = -searchViewDistance; dz <= searchViewDistance; ++dz) {
+                        final int chunkX = dx + centerChunkX;
+                        final int chunkZ = dz + centerChunkZ;
+                        final int squareDistance = Math.max(Math.abs(dx), Math.abs(dz));
+                        final boolean sendChunk = squareDistance <= sendViewDistance && wantChunkLoaded(centerChunkX, centerChunkZ, chunkX, chunkZ, sendViewDistance);
+
+                        if (this.hasSentChunk(chunkX, chunkZ, concernsTracking)) {
+                            // already sent (which means it is also loaded)
+                            if (!sendChunk) {
+                                // have sent the chunk, but don't want it anymore
+                                // unload it now
+                                this.unloadChunk(chunkX, chunkZ, concernsTracking);
+                            }
+                            continue;
                         }
-                        continue;
-                    }
 
-                    final boolean loadChunk = squareDistance <= loadViewDistance;
+                        final boolean loadChunk = squareDistance <= loadViewDistance;
 
-                    final boolean prioritised = useLookPriority && triangleIntersects(
+                        final boolean prioritised = useLookPriority && triangleIntersects(
                             // prioritisation triangle
                             p1x, p1z, p2x, p2z, p3x, p3z,
 
                             // center of chunk
-                            (double)((chunkX << 4) | 8), (double)((chunkZ << 4) | 8)
-                    );
+                            (double) ((chunkX << 4) | 8), (double) ((chunkZ << 4) | 8)
+                        );
 
-                    final int manhattanDistance = Math.abs(dx) + Math.abs(dz);
+                        final int manhattanDistance = Math.abs(dx) + Math.abs(dz);
 
-                    final double priority;
+                        final double priority;
 
-                    if (squareDistance <= PaperConfig.playerMinChunkLoadRadius) {
-                        // priority should be negative, and we also want to order it from center outwards
-                        // so we want (0,0) to be the smallest, and (minLoadedRadius,minLoadedRadius) to be the greatest
-                        priority = -((2 * PaperConfig.playerMinChunkLoadRadius + 1) - manhattanDistance);
-                    } else {
-                        if (prioritised) {
-                            // we don't prioritise these chunks above others because we also want to make sure some chunks
-                            // will be loaded if the player changes direction
-                            priority = (double)manhattanDistance / 6.0;
+                        if (squareDistance <= PaperConfig.playerMinChunkLoadRadius) {
+                            // priority should be negative, and we also want to order it from center outwards
+                            // so we want (0,0) to be the smallest, and (minLoadedRadius,minLoadedRadius) to be the greatest
+                            priority = -((2 * PaperConfig.playerMinChunkLoadRadius + 1) - manhattanDistance);
                         } else {
-                            priority = (double)manhattanDistance;
+                            if (prioritised) {
+                                // we don't prioritise these chunks above others because we also want to make sure some chunks
+                                // will be loaded if the player changes direction
+                                priority = (double) manhattanDistance / 6.0;
+                            } else {
+                                priority = (double) manhattanDistance;
+                            }
                         }
-                    }
 
-                    final ChunkPriorityHolder holder = new ChunkPriorityHolder(chunkX, chunkZ, manhattanDistance, priority);
+                        final ChunkPriorityHolder holder = new ChunkPriorityHolder(chunkX, chunkZ, manhattanDistance, priority);
 
-                    if (!this.loader.isChunkPlayerLoaded(chunkX, chunkZ)) {
-                        if (loadChunk) {
-                            loadQueue.add(holder);
+                        if (!this.loader.isChunkPlayerLoaded(chunkX, chunkZ)) {
+                            if (loadChunk) {
+                                loadQueue.add(holder);
+                                if (sendChunk) {
+                                    this.getChunksToBeSent(concernsTracking).add(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+                                }
+                            }
+                        } else {
+                            // loaded but not sent: so queue it!
                             if (sendChunk) {
-                                this.chunksToBeSent.add(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+                                this.getSendQueue(concernsTracking).add(holder);
                             }
                         }
-                    } else {
-                        // loaded but not sent: so queue it!
-                        if (sendChunk) {
-                            this.sendQueue.add(holder);
-                        }
                     }
                 }
             }
 
+            // Martijn end - per-player track and see view distance
+
             loadQueue.sort((final ChunkPriorityHolder p1, final ChunkPriorityHolder p2) -> {
                 return Double.compare(p1.priority, p2.priority);
             });
@@ -1103,6 +1211,9 @@ public final class PlayerChunkLoader {
             if (needsChunkCenterUpdate) {
                 this.player.connection.send(new ClientboundSetChunkCacheCenterPacket(centerChunkX, centerChunkZ));
             }
+
+            this.player.level.timings.playerChunkLoaderUpdate.stopTiming(); // Martijn - per-player view distance
+
         }
     }
 }
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index 7bddc7517356cc74104dcc5c7c55522a53f2596f..71c17fee68f5cef55a3f3b1ad52633df3226dbeb 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -647,7 +647,12 @@ public final class MCUtil {
             });
 
             worldData.addProperty("name", world.getWorld().getName());
-            worldData.addProperty("view-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetNoTickViewDistance()); // Paper - replace chunk loader system
+            // Martijn start - per-player view distance
+            worldData.addProperty("view-distance", world.getChunkSource().chunkMap.getVanillaWorldViewDistance()); // Paper - replace chunk loader system
+            worldData.addProperty("max-track-view-distance", world.paperConfig.getMaxTrackViewDistance());
+            worldData.addProperty("max-see-view-distance", world.paperConfig.getMaxSeeViewDistance());
+            worldData.addProperty("max-load-view-distance", world.paperConfig.getMaxLoadViewDistance());
+            // Martijn end - per-player view distance
             worldData.addProperty("tick-view-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance()); // Paper - replace chunk loader system
             worldData.addProperty("keep-spawn-loaded", world.keepSpawnInMemory);
             worldData.addProperty("keep-spawn-loaded-range", world.paperConfig.keepLoadedRange);
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index 73bd3e1530222f82c00bf2e30c7a7516e0625dc0..b1e384f614a78c6036dcb7da41033158dd9baf15 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -389,7 +389,7 @@ public class ChunkHolder {
         // Paper start - per player view distance
         // there can be potential desync with player's last mapped section and the view distance map, so use the
         // view distance map here.
-        com.destroystokyo.paper.util.misc.PlayerAreaMap viewDistanceMap = this.chunkMap.playerChunkManager.broadcastMap; // Paper - replace old player chunk manager
+        com.destroystokyo.paper.util.misc.PlayerAreaMap viewDistanceMap = this.chunkMap.playerChunkManager.broadcastMapForTracking; // Paper - replace old player chunk manager // Martijn - per-player track and see view distance
         com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> players = viewDistanceMap.getObjectsInRange(this.pos);
         if (players == null) {
             return;
@@ -402,7 +402,7 @@ public class ChunkHolder {
                 continue;
             }
             ServerPlayer player = (ServerPlayer)temp;
-            if (!this.chunkMap.playerChunkManager.isChunkSent(player, this.pos.x, this.pos.z, onlyOnWatchDistanceEdge)) {
+            if (!this.chunkMap.playerChunkManager.isChunkSent(player, this.pos.x, this.pos.z, onlyOnWatchDistanceEdge, true)) { // Martijn - per-player track and see view distance
                 continue;
             }
             player.connection.send(packet);
@@ -818,7 +818,8 @@ public class ChunkHolder {
 
     public interface PlayerProvider {
 
-        List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge);
+        List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge, boolean concernsTracking); // Martijn - per-player track and see view distance
+
     }
 
     private static final class ChunkSaveDebug {
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 8388545552a2b8593099e5c52c6a268450adbccf..e2d50f45703807c83a680c797d0dab85011bf2f3 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -162,7 +162,10 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap;
     private final Long2ByteMap chunkTypeCache;
     private final Queue<Runnable> unloadQueue;
-    int viewDistance;
+    // Martijn start- per-player view distance
+    // This value is the intended world send view distance + 1
+    private int vanillaWorldViewDistancePlusOne;
+    // Martijn end - per-player view distance
     public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerMobDistanceMap; // Paper
     public final ReferenceOpenHashSet<ChunkHolder> needsChangeBroadcasting = new ReferenceOpenHashSet<>();
 
@@ -247,7 +250,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
             int trackRange = this.entityTrackerTrackRanges[i];
 
-            trackMap.add(player, chunkX, chunkZ, Math.min(trackRange, io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player))); // Paper - per player view distances
+            trackMap.add(player, chunkX, chunkZ, Math.min(trackRange, player.getCachedTrackViewDistance())); // Paper - per player view distances // Martijn - per-player track view distance
         }
         // Paper end - use distance map to optimise entity tracker
         // Note: players need to be explicitly added to distance maps before they can be updated
@@ -289,7 +292,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
             int trackRange = this.entityTrackerTrackRanges[i];
 
-            trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player))); // Paper - per player view distances
+            trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, player.getCachedTrackViewDistance())); // Paper - per player view distances // Martijn - per-player track view distance
         }
         // Paper end - use distance map to optimise entity tracker
         this.playerChunkTickRangeMap.update(player, chunkX, chunkZ, DistanceManager.MOB_SPAWN_RANGE); // Paper - optimise ChunkMap#anyPlayerCloseEnoughForSpawning
@@ -466,7 +469,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // Martijn end - sort chunks by distance
 
     boolean unloadingPlayerChunk = false; // Paper - do not allow ticket level changes while unloading chunks
-    public ChunkMap(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureManager structureManager, Executor executor, BlockableEventLoop<Runnable> mainThreadExecutor, LightChunkGetter chunkProvider, ChunkGenerator chunkGenerator, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory, int viewDistance, boolean dsync) {
+    public ChunkMap(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureManager structureManager, Executor executor, BlockableEventLoop<Runnable> mainThreadExecutor, LightChunkGetter chunkProvider, ChunkGenerator chunkGenerator, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory, int vanillaWorldViewDistance, boolean dsync) { // Martijn - per-player view distance
         super(session.getDimensionPath(world.dimension()).resolve("region"), dataFixer, dsync);
         // Paper - don't copy
         this.pendingUnloads = new Long2ObjectLinkedOpenHashMap();
@@ -510,7 +513,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         this.distanceManager = new ChunkMap.ChunkDistanceManager(executor, mainThreadExecutor);
         this.overworldDataStorage = persistentStateManagerFactory;
         this.poiManager = new PoiManager(path.resolve("poi"), dataFixer, dsync, world);
-        this.setViewDistance(viewDistance);
+        this.setVanillaWorldViewDistance(vanillaWorldViewDistance); // Martijn - per-player view distance
         // Paper start
         this.dataRegionManager = new io.papermc.paper.chunk.SingleThreadChunkRegionManager(this.level, 2, (1.0 / 3.0), 1, 6, "Data", DataRegionData::new, DataRegionSectionData::new);
         this.regionManagers.add(this.dataRegionManager);
@@ -756,13 +759,15 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
     }
 
+    // Martijn start - per-player view distance
     // Paper start
-    public final int getEffectiveViewDistance() {
+    public final int getVanillaWorldViewDistance() {
         // TODO this needs to be checked on update
         // Mojang currently sets it to +1 of the configured view distance. So subtract one to get the one we really want.
-        return this.viewDistance - 1;
+        return this.vanillaWorldViewDistancePlusOne - 1;
     }
     // Paper end
+    // Martijn end - per-player view distance
 
     private CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> getChunkRangeFuture(ChunkPos centerChunk, int margin, IntFunction<ChunkStatus> distanceToStatus) {
         List<CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> list = new ArrayList();
@@ -1613,17 +1618,20 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
     }
 
-    public void setViewDistance(int watchDistance) {
-        int j = Mth.clamp(watchDistance + 1, (int) 3, (int) 33);
+    // Martijn start - per-player view distance
+    public void setVanillaWorldViewDistance(int vanillaWorldViewDistance) {
+        int newVanillaWorldViewDistancePlusOne = Mth.clamp(vanillaWorldViewDistance + 1, (int) 3, (int) 33);
 
-        if (j != this.viewDistance) {
-            int k = this.viewDistance;
+        if (newVanillaWorldViewDistancePlusOne != this.vanillaWorldViewDistancePlusOne) {
+            int k = this.vanillaWorldViewDistancePlusOne;
 
-            this.viewDistance = j;
-            this.playerChunkManager.setLoadDistance(Mth.clamp(this.viewDistance, 2, 32)); // Paper - replace player loader system
+            this.vanillaWorldViewDistancePlusOne = newVanillaWorldViewDistancePlusOne;
+            // No longer needed since PlayerChunkLoader.update() will pull the most current load view distance when it executes
+//            this.playerChunkManager.setLoadDistance(Mth.clamp(this.vanillaWorldViewDistancePlusOne, 2, 32)); // Paper - replace player loader system
         }
 
     }
+    // Martijn end - per-player view distance
 
     // Paper start - replace player loader system
     public void setTickViewDistance(int distance) {
@@ -1631,7 +1639,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
     // Paper end - replace player loader system
 
-    public void updateChunkTracking(ServerPlayer player, ChunkPos pos, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> mutableobject, boolean oldWithinViewDistance, boolean newWithinViewDistance) { // Paper - Anti-Xray - Bypass // Paper - public
+    public void updateChunkTracking(ServerPlayer player, ChunkPos pos, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> mutableobject, boolean oldWithinViewDistance, boolean newWithinViewDistance, boolean concernsTracking) { // Paper - Anti-Xray - Bypass // Paper - public // Martijn - per-player track and see view distance
         if (player.level == this.level) {
             if (newWithinViewDistance && !oldWithinViewDistance) {
                 ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos.toLong());
@@ -1640,7 +1648,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                     LevelChunk chunk = playerchunk.getSendingChunk(); // Paper - replace chunk loader system
 
                     if (chunk != null) {
-                        this.playerLoadedChunk(player, mutableobject, chunk);
+                        this.playerLoadedChunk(player, mutableobject, chunk, concernsTracking); // Martijn - per-player track and see view distance
                     }
 
                     DebugPackets.sendPoiPacketsForChunk(this.level, pos);
@@ -1648,7 +1656,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
 
             if (!newWithinViewDistance && oldWithinViewDistance) {
-                player.untrackChunk(pos);
+                player.untrackChunk(pos, concernsTracking); // Martijn - per-player track and see view distance
             }
 
         }
@@ -1916,6 +1924,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public void move(ServerPlayer player) {
         // Paper - delay this logic for the entity tracker tick, no need to duplicate it
 
+        this.level.timings.chunkMapPlayerMove.startTiming(); // Martijn - per-player view distance
+
         int i = SectionPos.blockToSectionCoord(player.getBlockX());
         int j = SectionPos.blockToSectionCoord(player.getBlockZ());
         SectionPos sectionposition = player.getLastSectionPos();
@@ -1928,6 +1938,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
         if (flag2 || flag != flag1) {
             this.updatePlayerPos(player);
+
             if (!flag) {
                 this.distanceManager.removePlayer(sectionposition, player);
             }
@@ -1959,16 +1970,18 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         this.updateMaps(player); // Paper - distance maps
         this.playerChunkManager.updatePlayer(player); // Paper - respond to movement immediately
 
+        this.level.timings.chunkMapPlayerMove.stopTiming(); // Martijn - per-player view distance
+
     }
 
     @Override
-    public List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge) {
+    public List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge, boolean concernsTracking) { // Martijn - per-player track and see view distance
         // Paper start - per player view distance
         // there can be potential desync with player's last mapped section and the view distance map, so use the
         // view distance map here.
         List<ServerPlayer> ret = new java.util.ArrayList<>(4);
 
-        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> players = this.playerChunkManager.broadcastMap.getObjectsInRange(chunkPos);
+        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> players = this.playerChunkManager.getBroadcastMap(concernsTracking).getObjectsInRange(chunkPos); // Martijn - per-player track and see view distance
         if (players == null) {
             return ret;
         }
@@ -2085,6 +2098,13 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // Paper end - optimised tracker
 
     protected void tick() {
+
+        // Martijn start - temporary debug message containing the number of loaded chunks
+        if (this.level.paperConfig.printLoadedChunksInterval > 0 && Math.random() < 1.0 / this.level.paperConfig.printLoadedChunksInterval) {
+            org.bukkit.Bukkit.getLogger().info("Number of loaded chunks in " + this.level.getWorld().getName() + ": " + this.level.getWorld().getLoadedChunks().length);
+        }
+        // Martijn end - temporary debug message containing the number of loaded chunks
+
         // Paper start - optimized tracker
         if (true) {
             this.processTrackQueue();
@@ -2153,7 +2173,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     // Paper start - Anti-Xray - Bypass
-    private void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk) {
+    private void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk, boolean concernsTracking) { // Martijn - per-player track and see view distance
         if (cachedDataPackets.getValue() == null) {
             cachedDataPackets.setValue(new java.util.HashMap<>());
         }
@@ -2161,58 +2181,66 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
         player.trackChunk(chunk.getPos(), cachedDataPackets.getValue().computeIfAbsent(shouldModify, (s) -> {
             return new ClientboundLevelChunkWithLightPacket(chunk, this.lightEngine, (BitSet) null, (BitSet) null, true, (Boolean) s);
-        }));
+        }), concernsTracking);
         // Paper end
         DebugPackets.sendPoiPacketsForChunk(this.level, chunk.getPos());
-        List<Entity> list = Lists.newArrayList();
-        List<Entity> list1 = Lists.newArrayList();
-        // Paper start - optimise entity tracker
-        // use the chunk entity list, not the whole trackedEntities map...
-        Entity[] entities = chunk.entities.getRawData();
-        for (int i = 0, size = chunk.entities.size(); i < size; ++i) {
-            Entity entity = entities[i];
-            if (entity == player) {
-                continue;
-            }
-            ChunkMap.TrackedEntity tracker = this.entityMap.get(entity.getId());
-            if (tracker != null) { // dumb plugins... move on...
-                tracker.updatePlayer(player);
-            }
 
-            // keep the vanilla logic here - this is REQUIRED or else passengers and their vehicles disappear!
-            // (and god knows what the leash thing is)
+        // Martijn start - per-player track and see view distance
+        if (concernsTracking) {
+
+            List<Entity> list = Lists.newArrayList();
+            List<Entity> list1 = Lists.newArrayList();
+            // Paper start - optimise entity tracker
+            // use the chunk entity list, not the whole trackedEntities map...
+            Entity[] entities = chunk.entities.getRawData();
+            for (int i = 0, size = chunk.entities.size(); i < size; ++i) {
+                Entity entity = entities[i];
+                if (entity == player) {
+                    continue;
+                }
+                ChunkMap.TrackedEntity tracker = this.entityMap.get(entity.getId());
+                if (tracker != null) { // dumb plugins... move on...
+                    tracker.updatePlayer(player);
+                }
+
+                // keep the vanilla logic here - this is REQUIRED or else passengers and their vehicles disappear!
+                // (and god knows what the leash thing is)
 
-            if (entity instanceof Mob && ((Mob)entity).getLeashHolder() != null) {
-                list.add(entity);
-            }
+                if (entity instanceof Mob && ((Mob) entity).getLeashHolder() != null) {
+                    list.add(entity);
+                }
 
-            if (!entity.getPassengers().isEmpty()) {
-                list1.add(entity);
+                if (!entity.getPassengers().isEmpty()) {
+                    list1.add(entity);
+                }
             }
-        }
-        // Paper end - optimise entity tracker
+            // Paper end - optimise entity tracker
 
-        Iterator iterator;
-        Entity entity1;
+            Iterator iterator;
+            Entity entity1;
 
-        if (!list.isEmpty()) {
-            iterator = list.iterator();
+            if (!list.isEmpty()) {
+                iterator = list.iterator();
 
-            while (iterator.hasNext()) {
-                entity1 = (Entity) iterator.next();
-                player.connection.send(new ClientboundSetEntityLinkPacket(entity1, ((Mob) entity1).getLeashHolder()));
+                while (iterator.hasNext()) {
+                    entity1 = (Entity) iterator.next();
+                    player.connection.send(new ClientboundSetEntityLinkPacket(entity1, ((Mob) entity1).getLeashHolder()));
+                }
             }
-        }
 
-        if (!list1.isEmpty()) {
-            iterator = list1.iterator();
+            if (!list1.isEmpty()) {
+                iterator = list1.iterator();
 
-            while (iterator.hasNext()) {
-                entity1 = (Entity) iterator.next();
-                player.connection.send(new ClientboundSetPassengersPacket(entity1));
+                while (iterator.hasNext()) {
+                    entity1 = (Entity) iterator.next();
+                    player.connection.send(new ClientboundSetPassengersPacket(entity1));
+                }
             }
+
         }
 
+        // Martijn end - per-player track and see view distance
+
     }
 
     public PoiManager getPoiManager() {
@@ -2356,7 +2384,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 double vec3d_dx = player.getX() - this.entity.getX();
                 double vec3d_dz = player.getZ() - this.entity.getZ();
                 // Paper end - remove allocation of Vec3D here
-                double d0 = (double) Math.min(this.getEffectiveRange(), io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player) * 16); // Paper - per player view distance
+                double d0 = (double) Math.min(this.getEffectiveRange(), player.getCachedTrackViewDistance() * 16); // Paper - per player view distance // Martijn - per-player track view distance
                 double d1 = vec3d_dx * vec3d_dx + vec3d_dz * vec3d_dz; // Paper
                 double d2 = d0 * d0;
                 boolean flag = d1 <= d2 && this.entity.broadcastToPlayer(player);
diff --git a/src/main/java/net/minecraft/server/level/DistanceManager.java b/src/main/java/net/minecraft/server/level/DistanceManager.java
index d278e5b8b3386044e0fbc13add369794fd6f9cd7..c1a2838128b377bc51a0d852ceb08b51ca33b155 100644
--- a/src/main/java/net/minecraft/server/level/DistanceManager.java
+++ b/src/main/java/net/minecraft/server/level/DistanceManager.java
@@ -545,9 +545,12 @@ public abstract class DistanceManager {
         return arraysetsorted != null && !arraysetsorted.isEmpty() ? ((Ticket) arraysetsorted.first()).toString() : "no_ticket";
     }
 
-    protected void updatePlayerTickets(int viewDistance) {
-        this.chunkMap.playerChunkManager.setTargetNoTickViewDistance(viewDistance); // Paper - route to player chunk manager
-    }
+    // Martijn start - per-player load view distance
+    // No longer needed since PlayerChunkLoader.update() will pull the most current load view distance when it executes
+//    protected void updatePlayerTickets(int viewDistance) {
+//        this.chunkMap.playerChunkManager.setTargetNoTickViewDistance(viewDistance); // Paper - route to player chunk manager
+//    }
+    // Martijn end - per-player load view distance
 
     public void updateSimulationDistance(int simulationDistance) {
         this.chunkMap.playerChunkManager.setTargetTickViewDistance(simulationDistance); // Paper - route to player chunk manager
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index b0ced77da807d715a39c04708859a12729883939..c5416b0744e77dd100d124a115b24640336d2a4b 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -943,7 +943,7 @@ public class ServerChunkCache extends ChunkSource {
                     continue;
                 }
 
-                int viewDistance = this.chunkMap.getEffectiveViewDistance();
+                int viewDistance = this.chunkMap.getVanillaWorldViewDistance(); // Martijn - per-player view distance
 
                 // copied and modified from isOutisdeRange
                 int chunkRange = level.spigotConfig.mobSpawnRange;
@@ -1182,9 +1182,11 @@ public class ServerChunkCache extends ChunkSource {
         this.chunkMap.broadcast(entity, packet);
     }
 
-    public void setViewDistance(int watchDistance) {
-        this.chunkMap.setViewDistance(watchDistance);
+    // Martijn start - per-player view distance
+    public void setVanillaWorldViewDistance(int vanillaWorldViewDistance) {
+        this.chunkMap.setVanillaWorldViewDistance(vanillaWorldViewDistance);
     }
+    // Martijn end - per-player view distance
 
     public void setSimulationDistance(int simulationDistance) {
         this.distanceManager.updateSimulationDistance(simulationDistance);
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 8043ec6108f5da104bcbf79d739667562eca866d..8dfdc19386491ea53d40f6d299249de2d8a7b04b 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -7,8 +7,6 @@ import com.mojang.authlib.GameProfile;
 import com.mojang.datafixers.util.Either;
 import com.mojang.serialization.DataResult;
 
-import java.util.ArrayDeque;
-import java.util.BitSet;
 import java.util.Collection;
 import java.util.Comparator;
 import java.util.Iterator;
@@ -23,10 +21,6 @@ import javax.annotation.Nullable;
 
 import it.unimi.dsi.fastutil.Pair;
 import it.unimi.dsi.fastutil.ints.IntIntPair;
-import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import it.unimi.dsi.fastutil.longs.LongSet;
-import it.unimi.dsi.fastutil.objects.Object2ObjectMap;
-import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectObjectImmutablePair;
 import net.minecraft.BlockUtil;
 import net.minecraft.ChatFormatting;
@@ -64,8 +58,6 @@ import net.minecraft.network.protocol.game.ClientboundEntityEventPacket;
 import net.minecraft.network.protocol.game.ClientboundForgetLevelChunkPacket;
 import net.minecraft.network.protocol.game.ClientboundGameEventPacket;
 import net.minecraft.network.protocol.game.ClientboundHorseScreenOpenPacket;
-import net.minecraft.network.protocol.game.ClientboundKeepAlivePacket;
-import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
 import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
 import net.minecraft.network.protocol.game.ClientboundMerchantOffersPacket;
 import net.minecraft.network.protocol.game.ClientboundOpenBookPacket;
@@ -80,13 +72,10 @@ import net.minecraft.network.protocol.game.ClientboundRemoveMobEffectPacket;
 import net.minecraft.network.protocol.game.ClientboundResourcePackPacket;
 import net.minecraft.network.protocol.game.ClientboundRespawnPacket;
 import net.minecraft.network.protocol.game.ClientboundSetCameraPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket;
 import net.minecraft.network.protocol.game.ClientboundSetExperiencePacket;
 import net.minecraft.network.protocol.game.ClientboundSetHealthPacket;
-import net.minecraft.network.protocol.game.ClientboundSetPassengersPacket;
 import net.minecraft.network.protocol.game.ClientboundSoundPacket;
 import net.minecraft.network.protocol.game.ClientboundUpdateMobEffectPacket;
-import net.minecraft.network.protocol.game.DebugPackets;
 import net.minecraft.network.protocol.game.ServerboundClientInformationPacket;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
@@ -150,7 +139,6 @@ import net.minecraft.world.level.block.entity.CommandBlockEntity;
 import net.minecraft.world.level.block.entity.SignBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.border.WorldBorder;
-import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.dimension.LevelStem;
 import net.minecraft.world.level.portal.PortalInfo;
 import net.minecraft.world.phys.AABB;
@@ -188,7 +176,292 @@ import org.bukkit.inventory.MainHand;
 
 public class ServerPlayer extends Player {
 
-    public final int getViewDistance() { throw new UnsupportedOperationException("Use PlayerChunkLoader"); } // Paper - placeholder
+    // Martijn start - per-player view distance
+
+    private final int getWorldSeeViewDistance() { return this.getLevel().getChunkSource().chunkMap.getVanillaWorldViewDistance() - 1; } // Paper - placeholder
+
+    private final int getWorldTrackViewDistance() {
+        return getWorldSeeViewDistance();
+    }
+
+    private final int getWorldLoadViewDistance() {
+        return getWorldSeeViewDistance() + 1;
+    }
+
+    private @Nullable Integer lastComputedTrackViewDistance = null;
+    private @Nullable Integer lastComputedSeeViewDistance = null;
+    private @Nullable Integer lastComputedLoadViewDistance = null;
+
+    public final int getCachedTrackViewDistance() {
+        if (this.lastComputedTrackViewDistance != null) return this.lastComputedTrackViewDistance;
+        return this.computeAndCacheTrackViewDistance();
+    }
+
+    private final int computeAndCacheTrackViewDistance() {
+        return this.computeAndCacheTrackViewDistance(null, false);
+    }
+
+    private final int computeAndCacheTrackViewDistance(@Nullable Integer precomputedMaxTrackViewDistanceDueToTotalTrackedChunks, boolean dontUpdateOtherPlayersAfterwards) {
+        int maxTrackViewDistanceDueToTotalTrackedChunks = precomputedMaxTrackViewDistanceDueToTotalTrackedChunks != null ? precomputedMaxTrackViewDistanceDueToTotalTrackedChunks : computeMaxTrackViewDistanceDueToMaxTotalTrackedChunks();
+        @Nullable Integer oldTrackViewDistance = this.lastComputedTrackViewDistance;
+        this.lastComputedTrackViewDistance = this.computeTrackViewDistance(maxTrackViewDistanceDueToTotalTrackedChunks);
+        this.processTrackViewDistanceChange(oldTrackViewDistance, maxTrackViewDistanceDueToTotalTrackedChunks, dontUpdateOtherPlayersAfterwards);
+        return this.lastComputedTrackViewDistance;
+    }
+
+    private final int computeTrackViewDistance(int assumedMaxTrackViewDistanceDueToTotalTrackedChunks) {
+
+        this.level.timings.computeTrackViewDistance.startTiming();
+
+        // Limit by world view distance
+        int trackViewDistance = getWorldTrackViewDistance();
+        // Limit by see view distance
+        trackViewDistance = Math.min(trackViewDistance, this.computeAndCacheSeeViewDistance());
+        if (this.getLevel().paperConfig.getPerPlayerTrackViewDistance()) {
+            // Limit by world max track view distance
+            int levelMaxTrackViewDistance = this.getLevel().paperConfig.getMaxTrackViewDistance();
+            if (levelMaxTrackViewDistance != -1) {
+                trackViewDistance = Math.min(trackViewDistance,levelMaxTrackViewDistance);
+            }
+            // Limit by client view distance
+            if (this.getLevel().paperConfig.getLimitTrackViewDistanceByClientViewDistance()) {
+                if (this.clientViewDistance != null && this.clientViewDistance >= 1) {
+                    trackViewDistance = Math.min(trackViewDistance, this.clientViewDistance + 1);
+                }
+            }
+        }
+        // Limit by max total tracked chunks
+        if (assumedMaxTrackViewDistanceDueToTotalTrackedChunks != -1) {
+            trackViewDistance = Math.min(trackViewDistance, assumedMaxTrackViewDistanceDueToTotalTrackedChunks);
+        }
+        // Clamp to possible values
+        trackViewDistance = Mth.clamp(trackViewDistance, 2, 32);
+
+        this.level.timings.computeTrackViewDistance.stopTiming();
+
+        return trackViewDistance;
+
+    }
+
+    public final int getCachedSeeViewDistance() {
+        if (this.lastComputedSeeViewDistance != null) return this.lastComputedSeeViewDistance;
+        return this.computeAndCacheSeeViewDistance();
+    }
+
+    private final int computeAndCacheSeeViewDistance() {
+        return this.computeAndCacheSeeViewDistance(null, false);
+    }
+
+    private final int computeAndCacheSeeViewDistance(@Nullable Integer precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks, boolean dontUpdateOtherPlayersAfterwards) {
+        int maxSeeViewDistanceDueToMaxTotalSeenChunks = precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks != null ? precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks : computeMaxSeeViewDistanceDueToMaxTotalSeenChunks();
+        @Nullable Integer oldSeeViewDistance = this.lastComputedSeeViewDistance;
+        this.lastComputedSeeViewDistance = this.computeSeeViewDistance(maxSeeViewDistanceDueToMaxTotalSeenChunks);
+        this.processSeeViewDistanceChange(oldSeeViewDistance, maxSeeViewDistanceDueToMaxTotalSeenChunks, dontUpdateOtherPlayersAfterwards);
+        return this.lastComputedSeeViewDistance;
+    }
+
+    private final int computeSeeViewDistance(int assumedMaxSeeViewDistanceDueToMaxTotalSeenChunks) {
+
+        this.level.timings.computeSeeViewDistance.startTiming();
+
+        // Limit by world view distance
+        int seeViewDistance = this.getWorldSeeViewDistance();
+        if (this.getLevel().paperConfig.getPerPlayerSeeViewDistance()) {
+            // Limit by world max see view distance
+            int levelMaxSeeViewDistance = this.getLevel().paperConfig.getMaxSeeViewDistance();
+            if (levelMaxSeeViewDistance != -1) {
+                seeViewDistance = Math.min(seeViewDistance, levelMaxSeeViewDistance);
+            }
+            // Limit by client view distance
+            if (this.getLevel().paperConfig.getLimitSeeViewDistanceByClientViewDistance()) {
+                if (this.clientViewDistance != null && this.clientViewDistance >= 1) {
+                    seeViewDistance = Math.min(seeViewDistance, this.clientViewDistance + 1);
+                }
+            }
+        }
+        // Limit by max total seen chunks
+        if (assumedMaxSeeViewDistanceDueToMaxTotalSeenChunks != -1) {
+            seeViewDistance = Math.min(seeViewDistance, assumedMaxSeeViewDistanceDueToMaxTotalSeenChunks);
+        }
+        // Clamp to possible values
+        seeViewDistance = Mth.clamp(seeViewDistance, 2, 32);
+
+        this.level.timings.computeSeeViewDistance.stopTiming();
+
+        return seeViewDistance;
+
+    }
+
+    public final int getCachedLoadViewDistance() {
+        if (this.lastComputedLoadViewDistance != null) return this.lastComputedLoadViewDistance;
+        return this.computeAndCacheLoadViewDistance();
+    }
+
+    private final int computeAndCacheLoadViewDistance() {
+        Integer oldLoadViewDistance = this.lastComputedLoadViewDistance;
+        this.lastComputedLoadViewDistance = this.computeLoadViewDistance();
+        processLoadViewDistanceChange(oldLoadViewDistance);
+        return this.lastComputedLoadViewDistance;
+    }
+
+    private final int computeLoadViewDistance() {
+
+        this.level.timings.computeLoadViewDistance.startTiming();
+
+        // Limit by world view distance
+        int loadViewDistance = this.getWorldLoadViewDistance();
+        if (this.getLevel().paperConfig.getPerPlayerLoadViewDistance()) {
+            // Limit by world max load view distance
+            int levelMaxLoadViewDistance = this.getLevel().paperConfig.getMaxLoadViewDistance();
+            if (levelMaxLoadViewDistance != -1) {
+                loadViewDistance = Math.min(loadViewDistance, levelMaxLoadViewDistance);
+            }
+            // Limit by see view distance
+            if (this.getLevel().paperConfig.getLimitLoadViewDistanceBySeeViewDistance()) {
+                loadViewDistance = Math.min(loadViewDistance, this.computeAndCacheSeeViewDistance() + 1);
+            }
+            // Limit by client view distance
+            if (this.getLevel().paperConfig.getLimitLoadViewDistanceByClientViewDistance()) {
+                if (this.clientViewDistance != null && this.clientViewDistance >= 1) {
+                    loadViewDistance = Math.min(loadViewDistance, this.clientViewDistance + 2);
+                }
+            }
+        }
+        // Clamp to possible values
+        loadViewDistance = Mth.clamp(loadViewDistance, 3, 33);
+
+        this.level.timings.computeLoadViewDistance.stopTiming();
+
+        return loadViewDistance;
+
+    }
+
+    public void trackViewDistanceMayHaveChanged() {
+        this.trackViewDistanceMayHaveChanged(null, false);
+    }
+
+    public void trackViewDistanceMayHaveChanged(@Nullable Integer precomputedMaxTrackViewDistanceDueToMaxTotalTrackedChunks, boolean dontUpdateOtherPlayersAfterwards) {
+        this.computeAndCacheTrackViewDistance(precomputedMaxTrackViewDistanceDueToMaxTotalTrackedChunks, dontUpdateOtherPlayersAfterwards);
+    }
+
+    /**
+     * @param precomputedMaxTrackViewDistanceDueToMaxTotalTrackedChunks If null, indicates it hasn't been computed; if -1, indicates there is no maximum
+     */
+    private void processTrackViewDistanceChange(@Nullable Integer oldTrackViewDistance, int precomputedMaxTrackViewDistanceDueToMaxTotalTrackedChunks, boolean dontUpdateOtherPlayersAfterwards) {
+
+        int newTrackViewDistance = this.lastComputedTrackViewDistance;
+
+        if (oldTrackViewDistance != null && oldTrackViewDistance == newTrackViewDistance) return;
+
+        this.level.timings.trackViewDistanceMayHaveChanged.startTiming();
+
+        // Update chunk tracking
+        // No longer needed since PlayerChunkLoader.update() will pull the most current load view distance when it executes
+//        this.getLevel().getChunkSource().chunkMap.updateChunkTrackingDueToPlayerTrackViewDistanceChange(this, oldTrackViewDistance != null ? oldTrackViewDistance : newTrackViewDistance, newTrackViewDistance);
+
+        this.level.timings.trackViewDistanceMayHaveChanged.stopTiming();
+
+        // Update track view distance of other players
+        if (!dontUpdateOtherPlayersAfterwards && precomputedMaxTrackViewDistanceDueToMaxTotalTrackedChunks != -1) {
+            Bukkit.getOnlinePlayers().stream()
+                .map(it -> ((CraftPlayer) it).getHandle())
+                .filter(it -> !it.equals(this))
+                .forEach(it -> it.computeAndCacheTrackViewDistance(precomputedMaxTrackViewDistanceDueToMaxTotalTrackedChunks, true));
+        }
+
+    }
+
+    /**
+     * @return If -1, indicates there is no maximum; otherwise in the range [2, 32]
+     */
+    public static int computeMaxTrackViewDistanceDueToMaxTotalTrackedChunks() {
+        int maxTotalTrackedChunks = PaperConfig.getMaxTotalTrackedChunks();
+        if (maxTotalTrackedChunks == -1) return -1;
+        // Finds the lowest distance that is not possible (or 3 if none are possible, or 33 if all are possible), then subtracts 1 to find the highest distance that is possible (or 2 if none are possible, or 32 if all are posisble)
+        return Mth.binarySearch(3, 33, candidate -> {
+            // Must return whether the candidate is not possible
+            return Bukkit.getOnlinePlayers().stream().mapToInt(it -> ((CraftPlayer) it).getHandle().computeTrackViewDistance(candidate)).map(it -> (it*2+1)*(it*2+1)).sum() > maxTotalTrackedChunks;
+        }) - 1;
+    }
+
+    public void seeViewDistanceMayHaveChanged() {
+        this.seeViewDistanceMayHaveChanged(null, false);
+    }
+
+    public void seeViewDistanceMayHaveChanged(@Nullable Integer precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks, boolean dontUpdateOtherPlayersAfterwards) {
+        this.computeAndCacheSeeViewDistance(precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks, dontUpdateOtherPlayersAfterwards);
+    }
+
+    /**
+     * @param precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks If null, indicates it hasn't been computed; if -1, indicates there is no maximum
+     */
+    private void processSeeViewDistanceChange(@Nullable Integer oldSeeViewDistance, int precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks, boolean dontUpdateOtherPlayersAfterwards) {
+
+        int newSeeViewDistance = this.lastComputedSeeViewDistance;
+
+        if (oldSeeViewDistance != null && oldSeeViewDistance == newSeeViewDistance) return;
+
+        this.level.timings.seeViewDistanceMayHaveChanged.startTiming();
+
+        // Update chunk seeing
+        // No longer needed since PlayerChunkLoader.update() will pull the most current load view distance when it executes
+//        this.getLevel().getChunkSource().chunkMap.updateChunkSeeingDueToPlayerSeeViewDistanceChange(this, oldSeeViewDistance != null ? oldSeeViewDistance : newSeeViewDistance, newSeeViewDistance);
+
+        this.level.timings.seeViewDistanceMayHaveChanged.stopTiming();
+
+        // Update track view distance
+        this.trackViewDistanceMayHaveChanged();
+        // Update load view distance
+        this.loadViewDistanceMayHaveChanged();
+
+        // Update see view distance of other players
+        if (!dontUpdateOtherPlayersAfterwards && precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks != -1) {
+            Bukkit.getOnlinePlayers().stream()
+                .map(it -> ((CraftPlayer) it).getHandle())
+                .filter(it -> !it.equals(this))
+                .forEach(it -> it.computeAndCacheSeeViewDistance(precomputedMaxSeeViewDistanceDueToMaxTotalSeenChunks, true));
+        }
+
+    }
+
+    /**
+     * @return If -1, indicates there is no maximum; otherwise in the range [2, 32]
+     */
+    public static int computeMaxSeeViewDistanceDueToMaxTotalSeenChunks() {
+        int maxTotalSeenChunks = PaperConfig.getMaxTotalSeenChunks();
+        if (maxTotalSeenChunks == -1) return -1;
+        // Finds the lowest distance that is not possible (or 3 if none are possible, or 33 if all are possible), then subtracts 1 to find the highest distance that is possible (or 2 if none are possible, or 32 if all are posisble)
+        return Mth.binarySearch(3, 33, candidate -> {
+            // Must return whether the candidate is not possible
+            return Bukkit.getOnlinePlayers().stream().mapToInt(it -> ((CraftPlayer) it).getHandle().computeSeeViewDistance(candidate)).map(it -> (it*2+1)*(it*2+1)).sum() > maxTotalSeenChunks;
+        }) - 1;
+    }
+
+    public void loadViewDistanceMayHaveChanged() {
+        computeAndCacheLoadViewDistance();
+    }
+
+    private void processLoadViewDistanceChange(@Nullable Integer oldLoadViewDistance) {
+
+        int newLoadViewDistance = this.lastComputedLoadViewDistance;
+
+        if (oldLoadViewDistance != null && oldLoadViewDistance == newLoadViewDistance) return;
+
+        this.level.timings.loadViewDistanceMayHaveChanged.startTiming();
+
+        // Update player chunk load tickets
+        // No longer needed since PlayerChunkLoader.update() will pull the most current load view distance when it executes
+//        if (oldLoadViewDistance != null) { // This prevents calling updatePlayerTicketsByPlayerLoadDistance when already inside a call of updatePlayerTicketsByPlayerLoadDistance by getOrCreatePlayerTicketManager (which would lead to a ConcurrentModificationException)
+//            if (this.getLevel().paperConfig.getPerPlayerLoadViewDistance()) {
+//                this.getLevel().getChunkSource().chunkMap.distanceManager.updatePlayerTickets(this);
+//            }
+//        }
+
+        this.level.timings.loadViewDistanceMayHaveChanged.stopTiming();
+
+    }
+
+    // Martijn end - per-player view distance
 
     private static final Logger LOGGER = LogManager.getLogger();
     public long lastSave = MinecraftServer.currentTick; // Paper
@@ -2251,27 +2524,37 @@ public class ServerPlayer extends Player {
 
     }
 
-    public void trackChunk(ChunkPos chunkPos, Packet<?> chunkDataPacket) {
+    // Martijn start - per-player track and see view distance
+
+    public void trackChunk(ChunkPos chunkPos, Packet<?> chunkDataPacket, boolean concernsTracking) {
         this.connection.send(chunkDataPacket);
-        // Paper start
-        if(io.papermc.paper.event.packet.PlayerChunkLoadEvent.getHandlerList().getRegisteredListeners().length > 0){
-            new io.papermc.paper.event.packet.PlayerChunkLoadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+        if (concernsTracking) {
+            // Paper start
+            if (io.papermc.paper.event.packet.PlayerChunkLoadEvent.getHandlerList().getRegisteredListeners().length > 0) {
+                new io.papermc.paper.event.packet.PlayerChunkLoadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+            }
+            // Paper end
         }
-        // Paper end
     }
 
-    public void untrackChunk(ChunkPos chunkPos) {
+    public void untrackChunk(ChunkPos chunkPos, boolean concernsTracking) {
         if (this.isAlive()) {
-            this.connection.send(new ClientboundForgetLevelChunkPacket(chunkPos.x, chunkPos.z));
-            // Paper start
-            if(io.papermc.paper.event.packet.PlayerChunkUnloadEvent.getHandlerList().getRegisteredListeners().length > 0){
-                new io.papermc.paper.event.packet.PlayerChunkUnloadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+            if (!concernsTracking) {
+                this.connection.send(new ClientboundForgetLevelChunkPacket(chunkPos.x, chunkPos.z));
+            }
+            if (concernsTracking) {
+                // Paper start
+                if (io.papermc.paper.event.packet.PlayerChunkUnloadEvent.getHandlerList().getRegisteredListeners().length > 0) {
+                    new io.papermc.paper.event.packet.PlayerChunkUnloadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+                }
+                // Paper end
             }
-            // Paper end
         }
 
     }
 
+    // Martijn end - per-player track and see view distance
+
     public SectionPos getLastSectionPos() {
         return this.lastSectionPos;
     }
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 7a0c1ba40156df69bbbf36d96bed0950130d2351..e890bcd9ae26e525a086666fb91ff911abf0f8d5 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -271,7 +271,7 @@ public abstract class PlayerList {
         boolean flag1 = gamerules.getBoolean(GameRules.RULE_REDUCEDDEBUGINFO);
 
         // Spigot - view distance
-        playerconnection.send(new ClientboundLoginPacket(player.getId(), worlddata.isHardcore(), player.gameMode.getGameModeForPlayer(), player.gameMode.getPreviousGameModeForPlayer(), this.server.levelKeys(), this.registryHolder, worldserver1.dimensionType(), worldserver1.dimension(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), this.getMaxPlayers(), worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance(), worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance(), flag1, !flag, worldserver1.isDebug(), worldserver1.isFlat())); // Paper - replace old player chunk management
+        playerconnection.send(new ClientboundLoginPacket(player.getId(), worlddata.isHardcore(), player.gameMode.getGameModeForPlayer(), player.gameMode.getPreviousGameModeForPlayer(), this.server.levelKeys(), this.registryHolder, worldserver1.dimensionType(), worldserver1.dimension(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), this.getMaxPlayers(), player.getCachedSeeViewDistance(), worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance(), flag1, !flag, worldserver1.isDebug(), worldserver1.isFlat())); // Paper - replace old player chunk management // Martijn - per-player view distance
         player.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         playerconnection.send(new ClientboundCustomPayloadPacket(ClientboundCustomPayloadPacket.BRAND, (new FriendlyByteBuf(Unpooled.buffer())).writeUtf(this.getServer().getServerModName())));
         playerconnection.send(new ClientboundChangeDifficultyPacket(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
@@ -942,7 +942,7 @@ public abstract class PlayerList {
         // CraftBukkit start
         LevelData worlddata = worldserver1.getLevelData();
         entityplayer1.connection.send(new ClientboundRespawnPacket(worldserver1.dimensionType(), worldserver1.dimension(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), entityplayer1.gameMode.getGameModeForPlayer(), entityplayer1.gameMode.getPreviousGameModeForPlayer(), worldserver1.isDebug(), worldserver1.isFlat(), flag));
-        entityplayer1.connection.send(new ClientboundSetChunkCacheRadiusPacket(worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance())); // Spigot // Paper - replace old player chunk management
+        entityplayer1.connection.send(new ClientboundSetChunkCacheRadiusPacket(entityplayer1.getCachedSeeViewDistance())); // Spigot // Paper - replace old player chunk management // Martijn - per-player see view distance
         entityplayer1.connection.send(new ClientboundSetSimulationDistancePacket(worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance())); // Spigot // Paper - replace old player chunk management
         entityplayer1.spawnIn(worldserver1);
         entityplayer1.unsetRemoved();
@@ -1460,7 +1460,7 @@ public abstract class PlayerList {
             ServerLevel worldserver = (ServerLevel) iterator.next();
 
             if (worldserver != null) {
-                worldserver.getChunkSource().setViewDistance(viewDistance);
+                worldserver.getChunkSource().setVanillaWorldViewDistance(viewDistance); // Martijn - per-player view distance
             }
         }
 
diff --git a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
index b74cdaecb361851b0662002c8ec8f196ab1275bd..3d7c6c6ea81aff31e42a661e6803ae6d646afd2a 100644
--- a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
+++ b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
@@ -647,7 +647,7 @@ public class EnderDragon extends Mob implements Enemy {
                 // this.world.b(1028, this.getChunkCoordinates(), 0);
                 //int viewDistance = ((WorldServer) this.world).getServer().getViewDistance() * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
                 for (net.minecraft.server.level.ServerPlayer player : (List<net.minecraft.server.level.ServerPlayer>) ((ServerLevel)level).players()) {
-                    final int viewDistance = io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player); // Paper - route to player chunk loader
+                    final int viewDistance = com.destroystokyo.paper.PaperConfig.sendEnderDragonSpawnSoundToPlayersWhoAreSeeingButNotTracking ? player.getCachedSeeViewDistance() : player.getCachedTrackViewDistance(); // Paper - route to player chunk loader // Martijn - per-player track and see view distance
                     double deltaX = this.getX() - player.getX();
                     double deltaZ = this.getZ() - player.getZ();
                     double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
index c0ee9915c971482e765d91b4f85d65c3a1f526eb..6945bc7f1abd2d36938e05776bc48501acf60f0b 100644
--- a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
+++ b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
@@ -279,7 +279,7 @@ public class WitherBoss extends Monster implements PowerableMob, RangedAttackMob
                     // this.world.globalLevelEvent(1023, new BlockPosition(this), 0);
                     //int viewDistance = ((ServerLevel) this.level).getCraftServer().getViewDistance() * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
                     for (ServerPlayer player : (List<ServerPlayer>)this.level.players()) { // Paper
-                        final int viewDistance = io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player); // Paper - route to player chunk loader
+                        final int viewDistance = com.destroystokyo.paper.PaperConfig.sendWitherSpawnSoundToPlayersWhoAreSeeingButNotTracking ? player.getCachedSeeViewDistance() : player.getCachedTrackViewDistance(); // Paper - route to player chunk loader // Martijn - per-player track and see view distance
                         double deltaX = this.getX() - player.getX();
                         double deltaZ = this.getZ() - player.getZ();
                         double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/net/minecraft/world/item/EnderEyeItem.java b/src/main/java/net/minecraft/world/item/EnderEyeItem.java
index 2429bdc5fc5150dcadbedf6c33810889c2444f54..89a6e44a64a8ab3256e69ddd86aeddcd0000e7ea 100644
--- a/src/main/java/net/minecraft/world/item/EnderEyeItem.java
+++ b/src/main/java/net/minecraft/world/item/EnderEyeItem.java
@@ -63,7 +63,7 @@ public class EnderEyeItem extends Item {
                     //int viewDistance = world.getCraftServer().getViewDistance() * 16; // Paper - apply view distance patch
                     BlockPos soundPos = blockposition1.offset(1, 0, 1);
                     for (ServerPlayer player : world.getServer().getPlayerList().players) {
-                        final int viewDistance = io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player); // Paper - apply view distance patch
+                        final int viewDistance = com.destroystokyo.paper.PaperConfig.sendEndPortalFillSoundToPlayersWhoAreSeeingButNotTracking ? player.getCachedSeeViewDistance() : player.getCachedTrackViewDistance(); // Paper - apply view distance patch // Martijn - per-player track and see view distance
                         double deltaX = soundPos.getX() - player.getX();
                         double deltaZ = soundPos.getZ() - player.getZ();
                         double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 89bc9f452556bafdcd8b76668639ee33c383596e..5302918501ad2ae6181c22382f68a972ec1d9c67 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -658,7 +658,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
                 this.sendBlockUpdated(blockposition, iblockdata1, iblockdata, i);
                 // Paper start - per player view distance - allow block updates for non-ticking chunks in player view distance
                 // if copied from above
-            } else if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || ((ServerLevel)this).getChunkSource().chunkMap.playerChunkManager.broadcastMap.getObjectsInRange(MCUtil.getCoordinateKey(blockposition)) != null)) { // Paper - replace old player chunk management
+            } else if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || ((ServerLevel)this).getChunkSource().chunkMap.playerChunkManager.getBroadcastMap(true).getObjectsInRange(MCUtil.getCoordinateKey(blockposition)) != null)) { // Paper - replace old player chunk management // Martijn - per-player track and see view distance
                 ((ServerLevel)this).getChunkSource().blockChanged(blockposition);
                 // Paper end - per player view distance
             }
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index b47c4c9e9b82030cd82d72fe90d7c8bf558d6b28..c56a35100dce24aa19ce2c76bb368be2f32451f9 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -211,7 +211,7 @@ public class LevelChunk extends ChunkAccess {
         // this code handles the chunk sending
         if (!areNeighboursLoaded(bitsetBefore, 1) && areNeighboursLoaded(bitsetAfter, 1)) {
             // Paper start - replace old player chunk loading system
-            if (chunkMap.playerChunkManager.isChunkNearPlayers(this.chunkPos.x, this.chunkPos.z)) {
+            if (chunkMap.playerChunkManager.isChunkNearPlayers(this.chunkPos.x, this.chunkPos.z, false)) { // Martijn - per-player track and see view distance
                 // the post processing is expensive, so we don't want to run it unless we're actually near
                 // a player.
                 chunkProviderServer.mainThreadProcessor.execute(() -> {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index c0e1d53f41bf8ed0de8cca901ea75483bbada3bc..c2b5e7f4f9d364ac7ac2d44fef1fc0535a5cfbf1 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -465,7 +465,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
         playerChunk.getTickingChunkFuture().thenAccept(either -> {
             either.left().ifPresent(chunk -> {
-                List<ServerPlayer> playersInRange = playerChunk.playerProvider.getPlayers(playerChunk.getPos(), false);
+                List<ServerPlayer> playersInRange = playerChunk.playerProvider.getPlayers(playerChunk.getPos(), false, !com.destroystokyo.paper.PaperConfig.sendChunkRefreshToPlayersWhoAreSeeingButNotTracking); // Martijn - per-player track and see view distance
                 if (playersInRange.isEmpty()) return;
 
                 ClientboundLevelChunkWithLightPacket refreshPacket = new ClientboundLevelChunkWithLightPacket(chunk, this.world.getLightEngine(), null, null, true);
@@ -2119,7 +2119,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     // Spigot start
     @Override
     public int getViewDistance() {
-        return getHandle().getChunkSource().chunkMap.playerChunkManager.getTargetNoTickViewDistance(); // Paper - replace old player chunk management
+        return getHandle().getChunkSource().chunkMap.getVanillaWorldViewDistance(); // Paper - replace old player chunk management // Martijn - per-player view distance
     }
 
     @Override
@@ -2134,29 +2134,32 @@ public class CraftWorld extends CraftRegionAccessor implements World {
             throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
         }
         net.minecraft.server.level.ChunkMap chunkMap = getHandle().getChunkSource().chunkMap;
-        chunkMap.setViewDistance(viewDistance);
+        chunkMap.setVanillaWorldViewDistance(viewDistance); // Martijn - per-player view distance
         // Paper end - replace old player chunk management
     }
 
-    @Override
-    public int getNoTickViewDistance() {
-        return this.getViewDistance(); // Paper - replace old player chunk management
-    }
-
-    @Override
-    public void setNoTickViewDistance(int viewDistance) {
-        this.setViewDistance(viewDistance); // Paper - replace old player chunk management
-    }
+    // Martijn start - per-player view distance
+//    @Override
+//    public int getNoTickViewDistance() {
+//        return this.getViewDistance(); // Paper - replace old player chunk management
+//    }
+//
+//    @Override
+//    public void setNoTickViewDistance(int viewDistance) {
+//        this.setViewDistance(viewDistance); // Paper - replace old player chunk management
+//    }
+//
+//    @Override
+//    public int getSendViewDistance() {
+//        return getHandle().getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance(); // Paper - replace old player chunk management
+//    }
+//
+//    @Override
+//    public void setSendViewDistance(int viewDistance) {
+//        getHandle().getChunkSource().chunkMap.playerChunkManager.setSendDistance(viewDistance); // Paper - replace old player chunk management
+//    }
+    // Martijn end - per-player view distance
 
-    @Override
-    public int getSendViewDistance() {
-        return getHandle().getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance(); // Paper - replace old player chunk management
-    }
-
-    @Override
-    public void setSendViewDistance(int viewDistance) {
-        getHandle().getChunkSource().chunkMap.playerChunkManager.setSendDistance(viewDistance); // Paper - replace old player chunk management
-    }
     // Spigot end
 
     // Spigot start
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index e204ddd09c8fa8d1e6f7cfcc064e6561ed19bdb3..09113fb5d09455c608ba159f6b60b4c63256a416 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -524,59 +524,61 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         }
     }
 
-    // Paper start - implement view distances
-    @Override
-    public int getSendViewDistance() {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            return chunkMap.playerChunkManager.getTargetSendDistance();
-        }
-        return data.getTargetSendViewDistance();
-    }
-
-    @Override
-    public void setSendViewDistance(int viewDistance) {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            throw new IllegalStateException("Player is not attached to world");
-        }
-
-        data.setTargetSendViewDistance(viewDistance);
-    }
-
-    @Override
-    public int getNoTickViewDistance() {
-        return this.getViewDistance();
-    }
-
-    @Override
-    public void setNoTickViewDistance(int viewDistance) {
-        this.setViewDistance(viewDistance);
-    }
-
-    @Override
-    public int getViewDistance() {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            return chunkMap.playerChunkManager.getTargetNoTickViewDistance();
-        }
-        return data.getTargetNoTickViewDistance();
-    }
-
-    @Override
-    public void setViewDistance(int viewDistance) {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            throw new IllegalStateException("Player is not attached to world");
-        }
-
-        data.setTargetNoTickViewDistance(viewDistance);
-    }
-    // Paper end - implement view distances
+    // Martijn start - per-player view distance
+//    // Paper start - implement view distances
+//    @Override
+//    public int getSendViewDistance() {
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            return chunkMap.playerChunkManager.getTargetSendDistance();
+//        }
+//        return data.getTargetSendViewDistance();
+//    }
+//
+//    @Override
+//    public void setSendViewDistance(int viewDistance) {
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            throw new IllegalStateException("Player is not attached to world");
+//        }
+//
+//        data.setTargetSendViewDistance(viewDistance);
+//    }
+//
+//    @Override
+//    public int getNoTickViewDistance() {
+//        return this.getViewDistance();
+//    }
+//
+//    @Override
+//    public void setNoTickViewDistance(int viewDistance) {
+//        this.setViewDistance(viewDistance);
+//    }
+
+//    @Override
+//    public int getViewDistance() {
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            return chunkMap.playerChunkManager.getTargetNoTickViewDistance();
+//        }
+//        return data.getTargetNoTickViewDistance();
+//    }
+//
+//    @Override
+//    public void setViewDistance(int viewDistance) {
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            throw new IllegalStateException("Player is not attached to world");
+//        }
+//
+//        data.setTargetNoTickViewDistance(viewDistance);
+//    }
+//    // Paper end - implement view distances
+    // Martijn end - per-player view distance
 
     @Override
     public <T> T getClientOption(com.destroystokyo.paper.ClientOption<T> type) {
